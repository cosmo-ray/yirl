/* s7, a Scheme interpreter
 *
 *    derived from:
 *
 * --------------------------------------------------------------------------------
 * T I N Y S C H E M E    1 . 3 9
 *   Dimitrios Souflis (dsouflis@acm.org)
 *   Based on MiniScheme (original credits follow)
 * (MINISCM)               coded by Atsushi Moriwaki (11/5/1989)
 * (MINISCM)           E-MAIL :  moriwaki@kurims.kurims.kyoto-u.ac.jp
 * (MINISCM) This version has been modified by R.C. Secrist.
 * (MINISCM)
 * (MINISCM) Mini-Scheme is now maintained by Akira KIDA.
 * (MINISCM)
 * (MINISCM) This is a revised and modified version by Akira KIDA.
 * (MINISCM)	current version is 0.85k4 (15 May 1994)
 * --------------------------------------------------------------------------------
 *
 * apparently tinyScheme is under the BSD license, so I guess s7 is too.
 * Here is Snd's verbiage which can apply here:
 *
 *     The authors hereby grant permission to use, copy, modify, distribute,
 *     and license this software and its documentation for any purpose.  No
 *     written agreement, license, or royalty fee is required.  Modifications
 *     to this software may be copyrighted by their authors and need not
 *     follow the licensing terms described here.
 *
 * followed by the usual all-caps shouting about liability.
 *
 * --------------------------------------------------------------------------------
 *
 * s7, Bill Schottstaedt, Aug-08, bil@ccrma.stanford.edu
 *
 * Mike Scholz provided the FreeBSD support (complex trig funcs, etc)
 * Rick Taube, Andrew Burnson, Donny Ward, and Greg Santucci provided the MS Visual C++ support
 *
 * Documentation is in s7.h and s7.html.
 * s7test.scm is a regression test.
 * glistener.c is a gtk-based listener.
 * repl.scm is a vt100-based listener.
 * cload.scm and lib*.scm tie in various C libraries.
 * lint.scm checks Scheme code for infelicities.
 * r7rs.scm implements some of r7rs (small).
 * write.scm currrently has pretty-print.
 * mockery.scm has the mock-data definitions.
 * reactive.scm has reactive-set and friends.
 * stuff.scm has some stuff.
 * timing tests are in the snd tools directory
 *
 * s7.c is organized as follows:
 *    structs and type flags
 *    constants
 *    GC
 *    stacks
 *    symbols and keywords
 *    environments
 *    continuations
 *    numbers
 *    characters
 *    strings
 *    ports
 *    format
 *    lists
 *    vectors
 *    hash-tables
 *    c-objects
 *    functions
 *    equal?
 *    generic length, copy, reverse, fill!, append
 *    error handlers
 *    sundry leftovers
 *    the optimizers
 *    multiple-values, quasiquote
 *    eval
 *    multiprecision arithmetic
 *    *s7* environment
 *    initialization
 *    repl
 *
 * naming conventions: s7_* usually are C accessible (s7.h), g_* are scheme accessible (FFI),
 *   H_* are documentation strings, Q_* are procedure signatures,
 *   *_1 are ancillary functions, big_* refer to gmp,
 *   scheme "?" corresponds to C "is_", scheme "->" to C "_to_".
 *
 * ---------------- compile time switches ----------------
 */

#include "mus-config.h"

/*
 * Your config file goes here, or just replace that #include line with the defines you need.
 * The compile-time switches involve booleans, complex numbers, and multiprecision arithmetic.
 * Currently we assume we have setjmp.h (used by the error handlers).
 *
 * Complex number support which is problematic in C++, Solaris, and netBSD
 *   is on the HAVE_COMPLEX_NUMBERS switch. In OSX or Linux, if you're not using C++,
 *
 *   #define HAVE_COMPLEX_NUMBERS 1
 *   #define HAVE_COMPLEX_TRIG 1
 *
 *   In C++ I use:
 *
 *   #define HAVE_COMPLEX_NUMBERS 1
 *   #define HAVE_COMPLEX_TRIG 0
 *
 *   In windows, both are 0.
 *
 *   Some systems (FreeBSD) have complex.h, but some random subset of the trig funcs, so
 *   HAVE_COMPLEX_NUMBERS means we can find
 *      cimag creal cabs csqrt carg conj
 *   and HAVE_COMPLEX_TRIG means we have
 *      cacos cacosh casin casinh catan catanh ccos ccosh cexp clog cpow csin csinh ctan ctanh
 *
 * When HAVE_COMPLEX_NUMBERS is 0, the complex functions are stubs that simply return their
 *   argument -- this will be very confusing for the s7 user because, for example, (sqrt -2)
 *   will return something bogus (it will not signal an error).
 *
 * so the incoming (non-s7-specific) compile-time switches are
 *     HAVE_COMPLEX_NUMBERS, HAVE_COMPLEX_TRIG, SIZEOF_VOID_P
 * if SIZEOF_VOID_P is not defined, we look for __SIZEOF_POINTER__ instead
 *   the default is to assume that we're running on a 64-bit machine.
 *
 * To get multiprecision arithmetic, set WITH_GMP to 1.
 *   You'll also need libgmp, libmpfr, and libmpc (version 0.8.0 or later)
 *   In highly numerical contexts, the gmp version of s7 is about 50(!) times slower than the non-gmp version.
 *
 * and we use these predefined macros: __cplusplus, _MSC_VER, __GNUC__, __clang__, __ANDROID__
 *
 * if WITH_SYSTEM_EXTRAS is 1 (default is 1 unless _MSC_VER), various OS and file related functions are included.
 * in openBSD I think you need to include -ftrampolines in CFLAGS.
 * if you want this file to compile into a stand-alone interpreter, define WITH_MAIN
 *
 * -O3 produces segfaults, and is often slower than -O2 (at least according to callgrind)
 * -march=native seems to improve tree-vectorization which is important in Snd
 * -ffast-math makes a mess of NaNs, and does not appear to be faster
 * for timing tests, I use: -O2 -march=native -fomit-frame-pointer -funroll-loops
 * according to callgrind, clang is normally about 10% slower than gcc, and vectorization either doesn't work or is much worse than gcc's
 *   also g++ appears to be slightly slower than gcc
 */

#if (defined(__GNUC__) || defined(__clang__)) /* s7 uses PRId64 so (for example) g++ 4.4 is too old */
  #define WITH_GCC 1
#else
  #define WITH_GCC 0
#endif


/* ---------------- initial sizes ---------------- */

#ifndef INITIAL_HEAP_SIZE
  #define INITIAL_HEAP_SIZE 128000
#endif
/* the heap grows as needed, this is its initial size.
 * If the initial heap is small, s7 can run in about 2.5 Mbytes of memory. There are (many) cases where a bigger heap is faster.
 * The heap size must be a multiple of 32.  Each object takes 48 bytes.
 *
 * repl runs in    4Mb (18v) (64bit) if heap is 8192
 *                11Mb (25v)         if 128k heap
 *  snd (no gui)  15Mb (151v)
 *  snd (no gui)  17Mb (33v)         (no gsl, fftw, audio)
 *                21Mb (155v)        same but with ALSA!?
 *  snd (motif)   12Mb (285v)
 *  snd (gtk)     32Mb (515v!)
 */

#ifndef SYMBOL_TABLE_SIZE
  #define SYMBOL_TABLE_SIZE 32749
#endif
/* names are hashed into the symbol table (a vector) and collisions are chained as lists. */

#ifndef INITIAL_STACK_SIZE
  #define INITIAL_STACK_SIZE 512
#endif
/* the stack grows as needed, each frame takes 4 entries, this is its initial size.
 *   this needs to be big enough to handle the eval_c_string's at startup (ca 100)
 *   In s7test.scm, the maximum stack size is ca 440.  In snd-test.scm, it's ca 200.
 *   This number matters only because call/cc copies the stack, which requires filling
 *   the unused portion of the new stack, which requires memcpy of #<unspecified>'s.
 */

#ifndef INITIAL_PROTECTED_OBJECTS_SIZE
  #define INITIAL_PROTECTED_OBJECTS_SIZE 16
#endif
/* a vector of objects that are (semi-permanently) protected from the GC, grows as needed */

#ifndef GC_TEMPS_SIZE
  #define GC_TEMPS_SIZE 256
#endif
/* the number of recent objects that are temporarily gc-protected; 8 works for s7test and snd-test.
 *    For the FFI, this sets the lag between a call on s7_cons and the first moment when its result
 *    might be vulnerable to the GC.
 */


/* ---------------- scheme choices ---------------- */

#ifndef WITH_GMP
  #define WITH_GMP 0
  /* this includes multiprecision arithmetic for all numeric types and functions, using gmp, mpfr, and mpc
   * WITH_GMP adds the following functions: bignum and bignum?, and (*s7* 'bignum-precision)
   * using gmp with precision=128 is about 50 times slower than using C doubles and int64_ts.
   */
#endif

#define DEFAULT_BIGNUM_PRECISION 128

#ifndef WITH_PURE_S7
  #define WITH_PURE_S7 0
#endif
#if WITH_PURE_S7
  #define WITH_EXTRA_EXPONENT_MARKERS 0
  #define WITH_IMMUTABLE_UNQUOTE 1
  /* also omitted: *-ci* functions, char-ready?, cond-expand, multiple-values-bind|set!, call-with-values
   *   and a lot more (inexact/exact, integer-length,  etc) -- see s7.html.
   */
#endif

#ifndef WITH_EXTRA_EXPONENT_MARKERS
  #define WITH_EXTRA_EXPONENT_MARKERS 0
#endif
/* if 1, s7 recognizes "d", "f", "l", and "s" as exponent markers, in addition to "e" (also "D", "F", "L", "S") */

#ifndef WITH_SYSTEM_EXTRAS
  #define WITH_SYSTEM_EXTRAS (!_MSC_VER)
  /* this adds several functions that access file info, directories, times, etc
   *    this may be replaced by the cload business below
   */
#endif

#ifndef WITH_IMMUTABLE_UNQUOTE
  #define WITH_IMMUTABLE_UNQUOTE 0
  /* this removes the name "unquote" */
#endif

#ifndef WITH_C_LOADER
  #if WITH_GCC
    #define WITH_C_LOADER 1
  /* (load file.so [e]) looks for (e 'init_func) and if found, calls it
   *   as the shared object init function.  If WITH_SYSTEM_EXTRAS is 0, the caller
   *   needs to supply system and delete-file so that cload.scm works.
   */
  #else
    #define WITH_C_LOADER 0
  #endif
#endif

#ifndef WITH_HISTORY
  #define WITH_HISTORY 0
  /* this includes a circular buffer of previous evaluations for debugging, ((owlet) 'error-history) and (*s7* 'history-size) */
#endif

#ifndef DEFAULT_HISTORY_SIZE
  #define DEFAULT_HISTORY_SIZE 8
  /* this is the default length of the eval history buffer */
#endif
#if WITH_HISTORY
  #define MAX_HISTORY_SIZE 1048576
#endif

#define DEFAULT_PRINT_LENGTH 32 /* (*s7* 'print-length) */

#ifndef WITH_PROFILE
  #define WITH_PROFILE 0
  /* this includes profiling data collection accessible from scheme via the hash-table (*s7* 'profile-info) */
#endif

/* in case mus-config.h forgets these */
#ifdef _MSC_VER
  #ifndef HAVE_COMPLEX_NUMBERS
    #define HAVE_COMPLEX_NUMBERS 0
  #endif
  #ifndef HAVE_COMPLEX_TRIG
    #define HAVE_COMPLEX_TRIG 0
  #endif
#else
  #ifndef HAVE_COMPLEX_NUMBERS
    #define HAVE_COMPLEX_NUMBERS 1
  #endif
  #if __cplusplus
    #ifndef HAVE_COMPLEX_TRIG
      #define HAVE_COMPLEX_TRIG 0
    #endif
  #else
    #ifndef HAVE_COMPLEX_TRIG
      #define HAVE_COMPLEX_TRIG 1
    #endif
  #endif
#endif

/* -------------------------------------------------------------------------------- */

#ifndef WITH_MULTITHREAD_CHECKS
  #define WITH_MULTITHREAD_CHECKS 0
  /* debugging aid if using s7 in a multithreaded program -- this code courtesy of Kjetil Matheussen */
#endif

#ifndef S7_DEBUGGING
  #define S7_DEBUGGING 0
#endif

#ifndef CYCLE_DEBUGGING
  #define CYCLE_DEBUGGING 0
#endif

#undef DEBUGGING
#define DEBUGGING typo!

#ifndef OP_NAMES
  #define OP_NAMES 0
#endif

#ifndef _GNU_SOURCE
#define _GNU_SOURCE
/* for qsort_r, grumble... */
#endif

#ifndef _MSC_VER
  #include <unistd.h>
  #include <sys/param.h>
  #include <strings.h>
  #include <errno.h>
  #include <locale.h>
#else
  /* in Snd these are in mus-config.h */
  #ifndef MUS_CONFIG_H_LOADED
    #define snprintf _snprintf
    #if _MSC_VER > 1200
      #define _CRT_SECURE_NO_DEPRECATE 1
      #define _CRT_NONSTDC_NO_DEPRECATE 1
      #define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
    #endif
  #endif
  #include <io.h>
  #pragma warning(disable: 4244) /* conversion might cause loss of data warning */
#endif

#ifndef WITH_VECTORIZE
#if (defined(__GNUC__) && __GNUC__ >= 5)
  #define WITH_VECTORIZE 1
#else
  #define WITH_VECTORIZE 0
#endif
#endif

#include <stdio.h>
#include <limits.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <time.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdint.h>
#include <inttypes.h>
#include <setjmp.h>

#ifdef _MSC_VER
  #define MS_WINDOWS 1
#else
  #define MS_WINDOWS 0
#endif

#if (!MS_WINDOWS)
#include <pthread.h>
#endif

#if __cplusplus
  #include <cmath>
  #define s7_inline /* g++ 8.1.1 stupidity */
#else
  #include <math.h>
  #define s7_inline inline
#endif

#if HAVE_COMPLEX_NUMBERS
  #if __cplusplus
    #include <complex>
  #else
    #include <complex.h>
    #ifndef __SUNPRO_C
      #if defined(__sun) && defined(__SVR4)
        #undef _Complex_I
        #define _Complex_I 1.0fi
      #endif
    #endif
  #endif

#ifndef CMPLX
  #if (!(defined(__cplusplus))) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)) && !defined(__INTEL_COMPILER)
    #define CMPLX(x, y) __builtin_complex ((double) (x), (double) (y))
  #else
    #define CMPLX(r, i) ((r) + ((i) * _Complex_I))
  #endif
#endif
#endif

#include "s7.h"

#ifndef M_PI
  #define M_PI 3.1415926535897932384626433832795029L
#endif

#ifndef INFINITY
  #define INFINITY (-log(0.0))
  /* 1.0 / 0.0 is also used, there is sometimes a function, infinity(), MSC apparently uses HUGE_VALF, gcc has __builtin_huge_val() */
#endif

#ifndef NAN
  #define NAN (INFINITY / INFINITY) /* gcc has __builtin_nan(str) */
#endif

#define BOLD_TEXT "\033[1m"
#define UNBOLD_TEXT "\033[22m"

#if ((!__NetBSD__) && ((_MSC_VER) || (!defined(__STC__)) || (defined(__STDC_VERSION__) && (__STDC_VERSION__ < 199901L))))
  #define __func__ __FUNCTION__
#endif

#define DISPLAY(Obj) string_value(s7_object_to_string(sc, Obj, false))
#define DISPLAY_80(Obj) string_value(object_to_truncated_string(sc, Obj, 80))

typedef intptr_t opcode_t;

#define PRINT_NAME_PADDING 16
#if (((defined(SIZEOF_VOID_P)) && (SIZEOF_VOID_P == 4)) || ((defined(__SIZEOF_POINTER__)) && (__SIZEOF_POINTER__ == 4)))
  #define PRINT_NAME_SIZE (20 - PRINT_NAME_PADDING - 2) /* pointless */
  #define POINTER_32 true
#else
  #define PRINT_NAME_SIZE (40 - PRINT_NAME_PADDING - 2)
  #define POINTER_32 false
#endif

#define WRITE_REAL_PRECISION 16
typedef long double long_double;

#define print_s7_int PRId64
/* #define print_int32  PRId32 */
#define print_pointer PRIdPTR

#define MAX_FLOAT_FORMAT_PRECISION 128

/* types */
enum {T_FREE = 0,
      T_PAIR, T_NIL, T_UNUSED, T_UNDEFINED, T_UNSPECIFIED, T_EOF_OBJECT,
      T_BOOLEAN, T_CHARACTER, T_SYNTAX, T_SYMBOL,
      T_INTEGER, T_RATIO, T_REAL, T_COMPLEX,
      T_BIG_INTEGER, T_BIG_RATIO, T_BIG_REAL, T_BIG_COMPLEX,         /* these four used only if WITH_GMP -- order matters */
      T_STRING, T_C_OBJECT, T_VECTOR, T_INT_VECTOR, T_FLOAT_VECTOR, T_BYTE_VECTOR,
      T_CATCH, T_DYNAMIC_WIND, T_HASH_TABLE, T_LET, T_ITERATOR,
      T_STACK, T_COUNTER, T_SLOT, T_C_POINTER, T_OUTPUT_PORT, T_INPUT_PORT, T_RANDOM_STATE,
      T_CONTINUATION, T_GOTO, T_BAFFLE,
      T_CLOSURE, T_CLOSURE_STAR, T_C_MACRO, T_MACRO, T_MACRO_STAR, T_BACRO, T_BACRO_STAR,
      T_C_FUNCTION_STAR, T_C_FUNCTION, T_C_ANY_ARGS_FUNCTION, T_C_OPT_ARGS_FUNCTION, T_C_RST_ARGS_FUNCTION,
      NUM_TYPES};
/* T_UNUSED, T_STACK, T_SLOT, T_BAFFLE, T_DYNAMIC_WIND, T_CATCH, T_GOTO, and T_COUNTER are internal */

#if S7_DEBUGGING
static const char *s7_type_names[] = 
  {"free", "pair", "nil", "unused", "undefined", "unspecified", "eof_object", "boolean", "character", 
     "syntax", "symbol", "integer", "ratio", "real", "complex", "big_integer", "big_ratio", "big_real", "big_complex", 
     "string", "c_object", "vector", "int_vector", "float_vector", "byte_vector", "catch", "dynamic_wind", "hash_table", "let", 
     "iterator", "stack", "counter", "slot", "c_pointer", "output_port", "input_port", "random_state", "continuation", "goto", "baffle", 
     "closure", "closure*", "c_macro", "macro", "macro*", "bacro", "bacro*", "c_function*", "c_function", 
     "c_any_args_function", "c_opt_args_function", "c_rst_args_function"
   };
#endif

typedef struct block_t {
  union {
    void *data;
    s7_pointer d_ptr;
    s7_int *i_ptr;
  } dx;
  int32_t index;
  union {
    bool filler;
    uint32_t tag;
  } ln;
  s7_int size;
  union {
    struct block_t *next;
    char *documentation;
    s7_pointer ksym;
    s7_int nx_int;
    s7_int *ix_ptr;
    struct {
      uint32_t i1, i2;
    } ix;
  } nx;
  union {
    s7_pointer ex_ptr;
    void *ex_info;
    struct {
      uint32_t i3;
      int32_t i4;
    } jx;
  } ex;
} block_t;

#define NUM_BLOCK_LISTS 18
#define TOP_BLOCK_LIST 17
#define BLOCK_LIST 0

#define block_data(p)                    p->dx.data
#define block_index(p)                   p->index
#define block_set_index(p, Index)        p->index = Index
#define block_size(p)                    p->size
#define block_set_size(p, Size)          p->size = Size
#define block_next(p)                    p->nx.next
#define block_info(p)                    p->ex.ex_info

typedef block_t hash_entry_t;
#define hash_entry_key(p)                p->dx.d_ptr
#define hash_entry_value(p)              p->ex.ex_ptr
#define hash_entry_set_value(p, Val)     p->ex.ex_ptr = Val
#define hash_entry_next(p)               block_next(p)
#define hash_entry_raw_hash(p)           block_size(p)
#define hash_entry_set_raw_hash(p, Hash) block_set_size(p, Hash)

typedef block_t optfix_t;
#define optfix_expr(p)                   p->dx.d_ptr
#define optfix_op(p)                     block_size(p)
#define optfix_next(p)                   block_next(p)

typedef block_t vdims_t;
#define vdims_rank(p)                    p->size
#define vector_elements_should_be_freed(p) p->ln.filler
#define vdims_dims(p)                    p->dx.i_ptr
#define vdims_offsets(p)                 p->nx.ix_ptr
#define vdims_original(p)                p->ex.ex_ptr


typedef enum {TOKEN_EOF, TOKEN_LEFT_PAREN, TOKEN_RIGHT_PAREN, TOKEN_DOT, TOKEN_ATOM, TOKEN_QUOTE, TOKEN_DOUBLE_QUOTE, TOKEN_BACK_QUOTE,
	      TOKEN_COMMA, TOKEN_AT_MARK, TOKEN_SHARP_CONST, TOKEN_VECTOR, TOKEN_BYTE_VECTOR, TOKEN_INT_VECTOR, TOKEN_FLOAT_VECTOR} token_t;

/* IO ports */
typedef enum {FILE_PORT, STRING_PORT, FUNCTION_PORT} port_type_t;

typedef struct {
  bool needs_free, needs_unprotect, is_closed;
  port_type_t ptype;
  FILE *file;
  char *filename;
  block_t *filename_block;
  uint32_t line_number, file_number;
  s7_int gc_loc, filename_length;
  block_t *block;
  s7_pointer (*input_function)(s7_scheme *sc, s7_read_t read_choice, s7_pointer port);
  void (*output_function)(s7_scheme *sc, uint8_t c, s7_pointer port);
  /* a version of string ports using a pointer to the current location and a pointer to the end
   *   (rather than an integer for both, indexing from the base string) was not faster.
   */
  s7_pointer orig_str;                                                   /* GC protection for string port string */
  int32_t (*read_character)(s7_scheme *sc, s7_pointer port);             /* function to read a character, int32_t for EOF */
  void (*write_character)(s7_scheme *sc, uint8_t c, s7_pointer port);    /* function to write a character */
  void (*write_string)(s7_scheme *sc, const char *str, s7_int len, s7_pointer port); /* function to write a string of known length */
  token_t (*read_semicolon)(s7_scheme *sc, s7_pointer port);             /* internal skip-to-semicolon reader */
  int32_t (*read_white_space)(s7_scheme *sc, s7_pointer port);           /* internal skip white space reader */
  s7_pointer (*read_name)(s7_scheme *sc, s7_pointer pt);                 /* internal get-next-name reader */
  s7_pointer (*read_sharp)(s7_scheme *sc, s7_pointer pt);                /* internal get-next-sharp-constant reader */
  s7_pointer (*read_line)(s7_scheme *sc, s7_pointer pt, bool eol_case, bool copied);  /* function to read a string up to \n */
  void (*display)(s7_scheme *sc, const char *s, s7_pointer pt);
} port_t;

typedef struct opt_funcs {
  int32_t typ;
  void *func;
  struct opt_funcs *next;
} opt_funcs;

typedef struct {
  const char *name;
  int32_t name_length;
  uint32_t id;
  char *doc;
  block_t *block;
  opt_funcs *opt_data; /* vunion-functions (see below) */
  s7_pointer generic_ff, setter, signature, pars;
  s7_pointer (*chooser)(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops);
  /* arg_defaults|names call_args only T_C_FUNCTION_STAR -- call args for GC protection */
  union {
    s7_pointer *arg_defaults;
    s7_pointer bool_setter;
  } dam;
  union {
    s7_pointer *arg_names;
    s7_pointer c_sym;
  } sam;
  union {
    s7_pointer call_args;
    void (*marker)(s7_pointer p, s7_int len);
  } cam;
} c_proc_t;


typedef struct {
  s7_int type, outer_type;
  s7_pointer scheme_name, getter, setter;
  void (*free)(void *value);
  void (*mark)(void *val);
  bool (*equal)(void *val1, void *val2);       /* can this be wrapped? */
#if (!DISABLE_DEPRECATED)
  char *(*print)(s7_scheme *sc, void *value);
#endif
  s7_pointer (*ref)      (s7_scheme *sc, s7_pointer args);
  s7_pointer (*set)      (s7_scheme *sc, s7_pointer args);
  s7_pointer (*length)   (s7_scheme *sc, s7_pointer args);
  s7_pointer (*reverse)  (s7_scheme *sc, s7_pointer args);
  s7_pointer (*copy)     (s7_scheme *sc, s7_pointer args);
  s7_pointer (*fill)     (s7_scheme *sc, s7_pointer args);
  s7_pointer (*to_list)  (s7_scheme *sc, s7_pointer args);
  s7_pointer (*to_string)(s7_scheme *sc, s7_pointer args);
} c_object_t;


typedef s7_int (*hash_map_t)(s7_scheme *sc, s7_pointer table, s7_pointer key);          /* hash-table object->location mapper */
typedef hash_entry_t *(*hash_check_t)(s7_scheme *sc, s7_pointer table, s7_pointer key); /* hash-table object equality function */
static hash_map_t default_hash_map[NUM_TYPES];


/* -------------------------------- */
typedef s7_int (*s7_i_7pi_t)(s7_scheme *sc, s7_pointer p, s7_int i1);
typedef s7_int (*s7_i_7pii_t)(s7_scheme *sc, s7_pointer p, s7_int i1, s7_int i2);
typedef s7_int (*s7_i_7piii_t)(s7_scheme *sc, s7_pointer p, s7_int i1, s7_int i2, s7_int i3);
typedef s7_int (*s7_i_iii_t)(s7_int i1, s7_int i2, s7_int i3);
typedef s7_int (*s7_i_7i_t)(s7_scheme *sc, s7_int i1);
typedef s7_int (*s7_i_7ii_t)(s7_scheme *sc, s7_int i1, s7_int i2);
typedef bool (*s7_b_pp_t)(s7_pointer p1, s7_pointer p2);
typedef bool (*s7_b_7pp_t)(s7_scheme *sc, s7_pointer p1, s7_pointer p2);
typedef bool (*s7_b_7p_t)(s7_scheme *sc, s7_pointer p1);
typedef bool (*s7_b_pi_t)(s7_scheme *sc, s7_pointer p1, s7_int i2);
typedef bool (*s7_b_d_t)(s7_double p1);
typedef bool (*s7_b_i_t)(s7_int p1);
typedef bool (*s7_b_ii_t)(s7_int p1, s7_int p2);
typedef bool (*s7_b_dd_t)(s7_double p1, s7_double p2);
typedef s7_pointer (*s7_p_p_t)(s7_scheme *sc, s7_pointer p);
typedef s7_pointer (*s7_p_t)(s7_scheme *sc);
typedef s7_pointer (*s7_p_pp_t)(s7_scheme *sc, s7_pointer p1, s7_pointer p2);
typedef s7_pointer (*s7_p_ppi_t)(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_int i1);
typedef s7_pointer (*s7_p_ppp_t)(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_pointer p3);
typedef s7_pointer (*s7_p_pi_t)(s7_scheme *sc, s7_pointer p1, s7_int i1);
typedef s7_pointer (*s7_p_pii_t)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2);
typedef s7_pointer (*s7_p_pip_t)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2);
typedef s7_pointer (*s7_p_piip_t)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2, s7_pointer p3);
typedef s7_pointer (*s7_p_i_t)(s7_scheme *sc, s7_int i);
typedef s7_pointer (*s7_p_ii_t)(s7_scheme *sc, s7_int i1, s7_int i2);
typedef s7_pointer (*s7_p_dd_t)(s7_scheme *sc, s7_double x1, s7_double x2);
typedef s7_double (*s7_d_7d_t)(s7_scheme *sc, s7_double p1);
typedef s7_double (*s7_d_7dd_t)(s7_scheme *sc, s7_double p1, s7_double p2);
typedef s7_double (*s7_d_7pii_t)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2);
typedef s7_double (*s7_d_7piid_t)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2, s7_double x1);

#ifndef OPT_INFO_DEBUGGING
  #define OPT_INFO_DEBUGGING 0 /* not useful unless S7_DEBUGGING */
#endif

#if OPT_INFO_DEBUGGING
typedef struct {
#else
typedef union {
#endif
  s7_int i;
  s7_double x;
  s7_pointer p;
  void *obj;
  s7_function cf;
  s7_double (*d_f)(void);
  s7_double (*d_d_f)(s7_double x);
  s7_double (*d_7d_f)(s7_scheme *sc, s7_double x);
  s7_double (*d_dd_f)(s7_double x1, s7_double x2);
  s7_double (*d_7dd_f)(s7_scheme *sc, s7_double x1, s7_double x2);
  s7_double (*d_ddd_f)(s7_double x1, s7_double x2, s7_double x3);
  s7_double (*d_dddd_f)(s7_double x1, s7_double x2, s7_double x3, s7_double x4);
  s7_double (*d_v_f)(void *obj);
  s7_double (*d_vd_f)(void *obj, s7_double fm);
  s7_double (*d_vdd_f)(void *obj, s7_double x1, s7_double x2);
  s7_double (*d_vid_f)(void *obj, s7_int i, s7_double fm);
  s7_double (*d_id_f)(s7_int i, s7_double fm);
  s7_double (*d_7pi_f)(s7_scheme *sc, s7_pointer obj, s7_int i1);
  s7_double (*d_7pii_f)(s7_scheme *sc, s7_pointer obj, s7_int i1, s7_int i2);
  s7_double (*d_7piid_f)(s7_scheme *sc, s7_pointer obj, s7_int i1, s7_int i2, s7_double x);
  s7_double (*d_ip_f)(s7_int i1, s7_pointer p);
  s7_double (*d_pd_f)(s7_pointer obj, s7_double x);
  s7_double (*d_7pid_f)(s7_scheme *sc, s7_pointer obj, s7_int i1, s7_double x);
  s7_double (*d_p_f)(s7_pointer p);
  s7_int (*i_7d_f)(s7_scheme *sc, s7_double i1);
  s7_int (*i_7p_f)(s7_scheme *sc, s7_pointer i1);
  s7_int (*i_i_f)(s7_int i1);
  s7_int (*i_7i_f)(s7_scheme *sc, s7_int i1);
  s7_int (*i_ii_f)(s7_int i1, s7_int i2);
  s7_int (*i_7ii_f)(s7_scheme *sc, s7_int i1, s7_int i2);
  s7_int (*i_iii_f)(s7_int i1, s7_int i2, s7_int i3);
  s7_int (*i_7pi_f)(s7_scheme *sc, s7_pointer p, s7_int i1);
  s7_int (*i_7pii_f)(s7_scheme *sc, s7_pointer p, s7_int i1, s7_int i2);
  s7_int (*i_7piii_f)(s7_scheme *sc, s7_pointer p, s7_int i1, s7_int i2, s7_int i3);
  bool (*b_i_f)(s7_int p);
  bool (*b_d_f)(s7_double p);
  bool (*b_p_f)(s7_pointer p);
  bool (*b_pp_f)(s7_pointer p1, s7_pointer p2);
  bool (*b_7pp_f)(s7_scheme *sc, s7_pointer p1, s7_pointer p2);
  bool (*b_7p_f)(s7_scheme *sc, s7_pointer p1);
  bool (*b_pi_f)(s7_scheme *sc, s7_pointer p1, s7_int i2);
  bool (*b_ii_f)(s7_int i1, s7_int i2);
  bool (*b_dd_f)(s7_double x1, s7_double x2);
  s7_pointer (*p_f)(s7_scheme *sc);
  s7_pointer (*p_p_f)(s7_scheme *sc, s7_pointer p);
  s7_pointer (*p_pp_f)(s7_scheme *sc, s7_pointer p1, s7_pointer p2);
  s7_pointer (*p_ppp_f)(s7_scheme *sc, s7_pointer p, s7_pointer p2, s7_pointer p3);
  s7_pointer (*p_pi_f)(s7_scheme *sc, s7_pointer p1, s7_int i1);
  s7_pointer (*p_pii_f)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2);
  s7_pointer (*p_ppi_f)(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_int i1);
  s7_pointer (*p_pip_f)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2);
  s7_pointer (*p_piip_f)(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2, s7_pointer p3);
  s7_pointer (*p_i_f)(s7_scheme *sc, s7_int i);
  s7_pointer (*p_ii_f)(s7_scheme *sc, s7_int x1, s7_int x2);
  s7_pointer (*p_d_f)(s7_scheme *sc, s7_double x);
  s7_pointer (*p_dd_f)(s7_scheme *sc, s7_double x1, s7_double x2);
  s7_double (*fd)(void *o);
  s7_int (*fi)(void *o);
  bool (*fb)(void *o);
  s7_pointer (*fp)(void *o);
} vunion;

#define NUM_VUNIONS 12
typedef struct {
  vunion v[NUM_VUNIONS];
  int32_t size, slots;
  s7_scheme *sc;
  uint8_t types[NUM_VUNIONS];
#if S7_DEBUGGING
  uint8_t addrs[NUM_VUNIONS];
  s7_pointer vexpr;
  const char *func;
  int32_t line;
#endif
} opt_info;


/* -------------------------------- cell structure -------------------------------- */

typedef struct s7_cell {
  union {
    uint64_t flag;                /* type info */
    uint8_t type_field;
    uint16_t sflag;
    struct {
      uint32_t unused_low_flag;
      uint16_t opt_choice;
      uint16_t high_flag;
    } opts;
  } tf;
  union {

    union {                       /* integers, floats */
      s7_int integer_value;
      s7_double real_value;

      struct {
	uint8_t unused_padding[PRINT_NAME_PADDING];
	uint8_t name[PRINT_NAME_SIZE + 2];
      } pval;

      struct {                    /* ratios */
	s7_int numerator;
	s7_int denominator;
      } fraction_value;

      struct {                    /* complex numbers */
	s7_double rl;
	s7_double im;
      } complex_value;

#if WITH_GMP
      mpz_t big_integer;          /* bignums */
      mpq_t big_ratio;
      mpfr_t big_real;
      mpc_t big_complex;
      /* using free_lists here was not faster, and avoiding the extra init/clear too tricky.  These make up
       *   no more than ca. 5% of the gmp computation -- it is totally dominated by stuff like __gmpz_mul,
       *   so I can't see much point in optimizing the background noise.  In a very numerical context,
       *   gmp slows us down by a factor of 50.
       */
#endif
    } number;

    struct {                       /* ports */
      port_t *port;
      uint8_t *data;
      s7_int size, point;
      block_t *block;
    } prt;

    struct{                        /* characters */
      uint8_t c, up_c;
      int32_t length;
      bool alpha_c, digit_c, space_c, upper_c, lower_c;
      char c_name[12];
    } chr;

    struct {                       /* c-pointers */
      void *c_pointer;
      s7_pointer c_type, info, weak1, weak2;
    } cptr;

    s7_int baffle_key;             /* baffles */

    struct {                       /* vectors */
      s7_int length;
      union {
	s7_pointer *objects;
	s7_int *ints;
	s7_double *floats;
	uint8_t *bytes;
      } elements;
      block_t *block;
      s7_pointer (*vget)(s7_scheme *sc, s7_pointer vec, s7_int loc);
      union {
	s7_pointer (*vset)(s7_scheme *sc, s7_pointer vec, s7_int loc, s7_pointer val);
	s7_pointer fset;
      }setv;
    } vector;

    struct {                        /* stacks (internal) struct must match vector above for length/objects */
      s7_int length;
      s7_pointer *objects;
      block_t *block;
      int64_t top;
    } stk;

    struct {                        /* hash-tables */
      s7_int mask;
      hash_entry_t **elements;
      hash_check_t hash_func;
      hash_map_t *loc;
      block_t *block;
    } hasher;

    struct {                        /* iterators */
      s7_pointer obj, cur;
      union {
	s7_int loc;
	s7_pointer lcur;
      } lc;
      union {
	s7_int len;
	s7_pointer slow;
	hash_entry_t *hcur;
      } lw;
      s7_pointer (*next)(s7_scheme *sc, s7_pointer iterator);
    } iter;

    struct {
      c_proc_t *c_proc;              /* C functions, macros */
      s7_function ff;
      s7_int required_args, optional_args, all_args;
    } fnc;

    struct {                         /* pairs */
      s7_pointer car, cdr, opt1, opt2, opt3;
    } cons;

    struct {                         /* pairs */
      s7_pointer car, cdr, opt1, opt2;
      union {
	uint8_t opt_type;
	int32_t ctr;
      } ce;
    } cons_ext;

    struct {                         /* special purpose pairs (symbol-table etc) */
      s7_pointer unused_car, unused_cdr;
      uint64_t hash;
      const char *fstr;
      uint32_t file, line;          /* line|file=pair_line|file, line also used in symbol_table (raw_len) */
    } sym_cons;

    struct {                        /* scheme functions */
      s7_pointer args, body, env, setter; /* args can be a symbol, as well as a list, setter can be a list as well as a procedure/closure */
      int32_t arity;
    } func;

    struct {                        /* strings */
      s7_int length;
      char *svalue;
      uint64_t hash;                /* string hash-index */
      block_t *block;
      block_t *gensym_block;
    } string;

    struct {                       /* symbols */
      s7_pointer name, global_slot, local_slot;
      int64_t id;                  /* which let last bound the symbol -- for faster symbol lookup */
      uint32_t ctr;                /* how many times has symbol been set */
      uint32_t tag;                /* symbol as member of a set (tree-set-memq etc), high 32 bits are in symbol_info (the string block) */
    } sym;

    struct {                       /* syntax */
      s7_pointer symbol;
      opcode_t op;
      int32_t min_args, max_args;
      const char *documentation;
    } syn;

    struct {                       /* slots (bindings) */
      s7_pointer sym, val, nxt, pending_value, expr;
    } slt;

    struct {                       /* environments (frames, lets) */
      s7_pointer slots, nxt;
      int64_t id;                  /* id of rootlet is -1 */
      union {
	struct {
	  s7_pointer function;     /* __func__ (code) if this is a funclet */
	  uint32_t line, file;     /* __func__ location if it is known */
	} efnc;
	struct {
	  s7_pointer dox1, dox2;   /* do loop variables */
	} dox;
	struct {                   /* (catch #t ...) opts */
	  uint64_t op_stack_loc, goto_loc;
	} ctall;
      } edat;
    } envr;

    struct {                        /* special stuff like #<unspecified> */
      s7_pointer car, cdr;          /* unique_car|cdr, for sc->nil these are sc->unspecified for faster assoc etc */
      int64_t unused_let_id;        /* let_id(sc->nil) is -1, so this needs to align with envr.id above */
      /* these two fields are for some special case objects like #<unspecified> */
      union {
	const char *name;
	char *unknown_name;
      } nm;
      s7_int len;
    } unq;

    struct {                        /* counter (internal) */
      s7_pointer result, list, env, slots; /* env = counter_let (curlet after map/for-each frame created) */
      uint64_t cap;                 /* sc->capture_let_counter for frame reuse */
    } ctr;

    struct {                        /* random-state */
#if WITH_GMP
      gmp_randstate_t state;
#else
      uint64_t seed, carry;
#endif
    } rng;

    struct {                        /* additional object types (C) */
      s7_int type;
      void *value;                  /*  the value the caller associates with the c_object */
      s7_pointer e;                 /*   the method list, if any (openlet) */
      void (*mark)(void *val);
    } c_obj;

    struct {                        /* continuations */
      block_t *block;
      s7_pointer stack;
      s7_pointer *stack_start, *stack_end, *op_stack;
    } cwcc;

    struct {                        /* call-with-exit */
      uint64_t goto_loc, op_stack_loc;
      bool active;
    } rexit;

    struct {                        /* catch */
      uint64_t goto_loc, op_stack_loc;
      s7_pointer tag;
      s7_pointer handler;
    } rcatch; /* C++ reserves "catch" I guess */

    struct {                        /* dynamic-wind */
      s7_pointer in, out, body;
      uint32_t state;
    } winder;
  } object;

#if WITH_PROFILE
  int32_t file_and_line;
#endif
#if S7_DEBUGGING
  int32_t current_alloc_line, previous_alloc_line, uses, explicit_free_line, opt1_line, opt2_line, opt3_line;
  int64_t current_alloc_type, previous_alloc_type, debugger_bits;
  const char *current_alloc_func, *previous_alloc_func, *opt1_func, *opt2_func, *opt3_func;
#endif

} s7_cell;


typedef struct s7_big_cell {
  s7_cell cell;
  int64_t big_hloc;
} s7_big_cell;
typedef struct s7_big_cell *s7_big_pointer;

typedef struct heap_block_t {
  intptr_t start, end;
  int64_t offset;
  struct heap_block_t *next;
} heap_block_t;

typedef struct {
  s7_pointer *objs;
  int32_t size, top, ref, size2;
  bool has_hits;
  int32_t *refs;
  s7_pointer cycle_port, init_port;
  s7_int cycle_loc, init_loc;
  bool *defined;
} shared_info;

typedef struct {
  s7_int loc, curly_len, ctr;
  char *curly_str;
  s7_pointer args, orig_str, curly_arg;
  s7_pointer port, strport;
} format_data;

typedef struct gc_obj {
  s7_pointer p;
  struct gc_obj *nxt;
} gc_obj;

typedef struct {
  s7_pointer *list;
  s7_int size, loc;
} gc_list;


struct s7_scheme {
  s7_pointer code;
  s7_pointer envir;                   /* curlet, layout of first 4 entries should match stack frame layout */
  s7_pointer args;                    /* arguments of current function */
  opcode_t cur_op;
  s7_pointer value;
  s7_pointer cur_code;
  token_t tok;

  s7_pointer stack;                   /* stack is a vector */
  uint32_t stack_size;
  s7_pointer *stack_start, *stack_end, *stack_resize_trigger;

  s7_pointer *op_stack, *op_stack_now, *op_stack_end;
  uint32_t op_stack_size, max_stack_size;

  s7_cell **heap, **free_heap, **free_heap_top, **free_heap_trigger, **previous_free_heap_top;
  int64_t heap_size, gc_freed, max_heap_size;

#if WITH_HISTORY
  s7_pointer eval_history1, eval_history2, error_history, history_sink, history_pairs;
  bool using_history1;
#endif

#if WITH_MULTITHREAD_CHECKS
  int32_t lock_count;
  pthread_mutex_t lock;
#endif

  gc_obj *permanent_objects, *permanent_lets;
  s7_pointer protected_objects, protected_setters, protected_setter_symbols;  /* vectors of gc-protected objects */
  s7_int *gpofl;
  s7_int protected_objects_size, protected_setters_size, protected_setters_loc;
  s7_int gpofl_loc;

  s7_pointer nil;                     /* empty list */
  s7_pointer T;                       /* #t */
  s7_pointer F;                       /* #f */
  s7_pointer undefined;               /* #<undefined> */
  s7_pointer unspecified;             /* #<unspecified> */
  s7_pointer no_value;                /* the (values) value */
  s7_pointer unused;                  /* a marker for an unoccupied slot in sc->protected_objects (and other similar stuff) */

  s7_pointer symbol_table;            /* symbol table */
  s7_pointer rootlet, shadow_rootlet; /* rootlet */
  s7_int rootlet_entries;
  s7_pointer unlet;                   /* original bindings of predefined functions */

  s7_pointer input_port;              /* current-input-port */
  s7_pointer input_port_stack;        /*   input port stack (load and read internally) */
  s7_pointer output_port;             /* current-output-port */
  s7_pointer error_port;              /* current-error-port */
  s7_pointer owlet;                   /* owlet */
  s7_pointer error_type, error_data, error_code, error_line, error_file; /* owlet slots */
  s7_pointer standard_input, standard_output, standard_error;

  s7_pointer sharp_readers;           /* the binding pair for the global *#readers* list */
  s7_pointer load_hook;               /* *load-hook* hook object */
  s7_pointer unbound_variable_hook;   /* *unbound-variable-hook* hook object */
  s7_pointer missing_close_paren_hook, rootlet_redefinition_hook;
  s7_pointer error_hook, read_error_hook; /* *error-hook* hook object, and *read-error-hook* */
  bool gc_off;                        /* gc_off: if true, the GC won't run */
  uint32_t gc_stats, gensym_counter, f_class, add_class, multiply_class, subtract_class, equal_class;
  int32_t format_column;
  uint64_t capture_let_counter;
  bool short_print, is_autoloading, in_with_let, object_out_locked, has_openlets;
  int64_t let_number;
  s7_double default_rationalize_error, equivalent_float_epsilon, hash_table_float_epsilon;
  s7_int default_hash_table_length, initial_string_port_length, print_length, objstr_max_len, history_size, true_history_size;
  s7_int max_vector_length, max_string_length, max_list_length, max_vector_dimensions, max_format_length;
  s7_pointer stacktrace_defaults;
  int32_t float_format_precision;
  vdims_t *wrap_only;

  char *typnam;
  int32_t typnam_len, print_width;
  s7_pointer *singletons;
  block_t *unentry;                   /* hash-table lookup failure indicator */

  #define INITIAL_FILE_NAMES_SIZE 8
  s7_pointer *file_names;
  int32_t file_names_size, file_names_top;

  #define INITIAL_STRBUF_SIZE 1024
  s7_int strbuf_size;
  char *strbuf;

  char *read_line_buf;
  s7_int read_line_buf_size;

  s7_pointer u, v, w, x, y, z;         /* evaluator local vars */
  s7_pointer temp1, temp2, temp3, temp4, temp5, temp6, temp7, temp8, temp9, temp10;
  s7_pointer temp_cell, temp_cell_1, temp_cell_2, u1_1;
  s7_pointer t1_1, t2_1, t2_2, t3_1, t3_2, t3_3, z2_1, z2_2;
  s7_pointer a1_1, a2_1, a2_2, a3_1, a3_2, a3_3, a4_1, a4_2, a4_3, a4_4;
  #define T_TEMPS_SIZE 32
  s7_pointer t_temps[T_TEMPS_SIZE];    /* more eval temps */
  int32_t t_temp_ctr;

  jmp_buf goto_start;
  bool longjmp_ok;
  int32_t setjmp_loc;

  void (*begin_hook)(s7_scheme *sc, bool *val);
  opcode_t begin_op;

  s7_int current_line, s7_call_line, safety;
  const char *current_file, *s7_call_file, *s7_call_name;

  shared_info *circle_info;
  format_data **fdats;
  int32_t num_fdats, last_error_line;
  s7_pointer elist_1, elist_2, elist_3, elist_4, elist_5, plist_1, plist_2, plist_2_2, plist_3, qlist_2, qlist_3, clist_1;
  gc_list *strings, *vectors, *input_ports, *output_ports, *continuations, *c_objects, *hash_tables;
  gc_list *gensyms, *unknowns, *lambdas, *multivectors, *weak_refs, *weak_hash_iterators;
  s7_pointer *setters;
  s7_int setters_size, setters_loc;
  s7_pointer *tree_pointers;
  int32_t tree_pointers_size, tree_pointers_top, permanent_cells, string_wrapper_pos, num_to_str_size;
  s7_pointer format_ports;
  uint32_t alloc_pointer_k, alloc_function_k, alloc_symbol_k;
  s7_cell *alloc_pointer_cells;
  c_proc_t *alloc_function_cells;
  uint32_t alloc_big_pointer_k;
  s7_big_cell *alloc_big_pointer_cells;
  s7_pointer *string_wrappers;
  uint8_t *alloc_symbol_cells;
  char *num_to_str;

  block_t *block_lists[NUM_BLOCK_LISTS];
  size_t alloc_string_k;
  char *alloc_string_cells;

  c_object_t **c_object_types;
  int32_t c_object_types_size, num_c_object_types;
  s7_pointer type_to_typers[NUM_TYPES];

  uint32_t syms_tag, syms_tag2;
  int32_t bignum_precision;
  s7_int baffle_ctr;
  s7_pointer default_rng;

  s7_pointer sort_body, sort_begin, sort_v1, sort_v2;
  opcode_t sort_op;
  s7_int sort_body_len;
  s7_b_7pp_t sort_f;

  #define INT_TO_STR_SIZE 32
  char int_to_str1[INT_TO_STR_SIZE], int_to_str2[INT_TO_STR_SIZE], int_to_str3[INT_TO_STR_SIZE], int_to_str4[INT_TO_STR_SIZE], int_to_str5[INT_TO_STR_SIZE];

  s7_pointer abs_symbol, acos_symbol, acosh_symbol, add_symbol, angle_symbol, append_symbol, apply_symbol, apply_values_symbol, arity_symbol,
             ash_symbol, asin_symbol, asinh_symbol, assoc_symbol, assq_symbol, assv_symbol, atan_symbol, atanh_symbol, autoload_symbol, autoloader_symbol,
             byte_vector_symbol, byte_vector_ref_symbol, byte_vector_set_symbol, byte_vector_to_string_symbol,
             c_pointer_symbol, c_pointer_info_symbol, c_pointer_to_list_symbol, c_pointer_type_symbol, c_pointer_weak1_symbol, c_pointer_weak2_symbol,
             caaaar_symbol, caaadr_symbol, caaar_symbol, caadar_symbol, caaddr_symbol, caadr_symbol,
             caar_symbol, cadaar_symbol, cadadr_symbol, cadar_symbol, caddar_symbol, cadddr_symbol, caddr_symbol, cadr_symbol,
             call_cc_symbol, call_with_current_continuation_symbol, call_with_exit_symbol, call_with_input_file_symbol,
             call_with_input_string_symbol, call_with_output_file_symbol, call_with_output_string_symbol, car_symbol,
             catch_symbol, cdaaar_symbol, cdaadr_symbol, cdaar_symbol, cdadar_symbol, cdaddr_symbol, cdadr_symbol, cdar_symbol,
             cddaar_symbol, cddadr_symbol, cddar_symbol, cdddar_symbol, cddddr_symbol, cdddr_symbol, cddr_symbol, cdr_symbol,
             ceiling_symbol, char_downcase_symbol, char_eq_symbol, char_geq_symbol, char_gt_symbol, char_leq_symbol, char_lt_symbol,
             char_position_symbol, char_to_integer_symbol, char_upcase_symbol, cload_directory_symbol, close_input_port_symbol,
             close_output_port_symbol, complex_symbol, cons_symbol, copy_symbol, cos_symbol, cosh_symbol, coverlet_symbol,
             curlet_symbol, current_error_port_symbol, current_input_port_symbol, current_output_port_symbol, cutlet_symbol, cyclic_sequences_symbol,
             denominator_symbol, dilambda_symbol, display_symbol, divide_symbol, documentation_symbol, dynamic_wind_symbol,
             eq_symbol, error_symbol, eval_string_symbol, eval_symbol, exact_to_inexact_symbol, exit_symbol, exp_symbol, expt_symbol,
             features_symbol, fill_symbol, float_vector_ref_symbol, float_vector_set_symbol, float_vector_symbol, floor_symbol,
             flush_output_port_symbol, for_each_symbol, format_symbol, funclet_symbol,
             gc_symbol, gcd_symbol, gensym_symbol, geq_symbol, get_output_string_symbol, gt_symbol,
             hash_table_entries_symbol, hash_table_ref_symbol, hash_table_set_symbol, hash_table_symbol, help_symbol,
             imag_part_symbol, immutable_symbol, inexact_to_exact_symbol, inlet_symbol, int_vector_ref_symbol, int_vector_set_symbol, int_vector_symbol,
             integer_decode_float_symbol, integer_to_char_symbol, is_aritable_symbol, is_boolean_symbol, is_byte_symbol, is_byte_vector_symbol,
             is_c_object_symbol, c_object_type_symbol, is_c_pointer_symbol, is_char_alphabetic_symbol, is_char_lower_case_symbol, is_char_numeric_symbol,
             is_char_symbol, is_char_upper_case_symbol, is_char_whitespace_symbol, is_complex_symbol, is_constant_symbol,
             is_continuation_symbol, is_defined_symbol, is_dilambda_symbol, is_eof_object_symbol, is_eq_symbol, is_equal_symbol,
             is_eqv_symbol, is_even_symbol, is_exact_symbol, is_float_vector_symbol, is_gensym_symbol, is_hash_table_symbol, is_immutable_symbol,
             is_inexact_symbol, is_infinite_symbol, is_input_port_symbol, is_int_vector_symbol, is_integer_symbol, is_iterator_symbol,
             is_keyword_symbol, is_let_symbol, is_list_symbol, is_macro_symbol, is_equivalent_symbol, is_nan_symbol, is_negative_symbol,
             is_null_symbol, is_number_symbol, is_odd_symbol, is_openlet_symbol, is_output_port_symbol, is_pair_symbol,
             is_port_closed_symbol, is_positive_symbol, is_procedure_symbol, is_proper_list_symbol, is_provided_symbol,
             is_random_state_symbol, is_rational_symbol, is_real_symbol, is_sequence_symbol, is_string_symbol, is_subvector_symbol,
             is_symbol_symbol, is_syntax_symbol, is_vector_symbol, is_weak_hash_table_symbol, is_zero_symbol,
             iterate_symbol, iterator_is_at_end_symbol, iterator_sequence_symbol,
             is_float_symbol, is_integer_or_real_at_end_symbol, is_integer_or_any_at_end_symbol, is_unspecified_symbol, is_undefined_symbol,
             keyword_to_symbol_symbol,
             lcm_symbol, length_symbol, leq_symbol, let_ref_fallback_symbol, let_ref_symbol, let_set_fallback_symbol,
             let_set_symbol, let_temporarily_symbol, libraries_symbol, list_ref_symbol, list_set_symbol, list_symbol, list_tail_symbol, list_values_symbol,
             load_path_symbol, load_symbol, log_symbol, logand_symbol, logbit_symbol, logior_symbol, lognot_symbol, logxor_symbol, lt_symbol,
             magnitude_symbol, make_byte_vector_symbol, make_float_vector_symbol, make_hash_table_symbol, make_weak_hash_table_symbol,
             make_int_vector_symbol, make_iterator_symbol, string_to_keyword_symbol, make_list_symbol, make_string_symbol,
             make_vector_symbol, map_symbol, max_symbol, member_symbol, memq_symbol, memv_symbol, min_symbol, modulo_symbol, multiply_symbol,
             newline_symbol, not_symbol, number_to_string_symbol, numerator_symbol,
             object_to_string_symbol, object_to_let_symbol, open_input_file_symbol, open_input_string_symbol, open_output_file_symbol,
             open_output_string_symbol, openlet_symbol, outlet_symbol, owlet_symbol,
             pair_filename_symbol, pair_line_number_symbol, peek_char_symbol, pi_symbol, port_filename_symbol, port_line_number_symbol,
             port_file_symbol, port_position_symbol, procedure_source_symbol, provide_symbol,
             quotient_symbol,
             random_state_symbol, random_state_to_list_symbol, random_symbol, rationalize_symbol, read_byte_symbol,
             read_char_symbol, read_line_symbol, read_string_symbol, read_symbol, real_part_symbol, remainder_symbol,
             require_symbol, reverse_symbol, reverseb_symbol, rootlet_symbol, round_symbol,
             setter_symbol, set_car_symbol, set_cdr_symbol,
             set_current_error_port_symbol, set_current_input_port_symbol, set_current_output_port_symbol,
             signature_symbol, sin_symbol, sinh_symbol, sort_symbol, sqrt_symbol,
             stacktrace_symbol, string_append_symbol, string_downcase_symbol, string_eq_symbol, string_fill_symbol,
             string_geq_symbol, string_gt_symbol, string_leq_symbol, string_lt_symbol, string_position_symbol, string_ref_symbol,
             string_set_symbol, string_symbol, string_to_number_symbol, string_to_symbol_symbol, string_upcase_symbol,
             sublet_symbol, substring_symbol, subtract_symbol, subvector_symbol, subvector_position_symbol, subvector_vector_symbol,
             symbol_symbol, symbol_to_dynamic_value_symbol,
             symbol_to_keyword_symbol, symbol_to_string_symbol, symbol_to_value_symbol, s7_version_symbol,
             tan_symbol, tanh_symbol, throw_symbol, string_to_byte_vector_symbol,
             tree_count_symbol, tree_leaves_symbol, tree_memq_symbol, tree_set_memq_symbol, tree_is_cyclic_symbol, truncate_symbol, type_of_symbol,
             unlet_symbol,
             values_symbol, varlet_symbol, vector_append_symbol, vector_dimensions_symbol, vector_fill_symbol, vector_ref_symbol,
             vector_set_symbol, vector_symbol,
             weak_hash_table_symbol, with_input_from_file_symbol, with_input_from_string_symbol, with_output_to_file_symbol, with_output_to_string_symbol,
             write_byte_symbol, write_char_symbol, write_string_symbol, write_symbol,
             local_documentation_symbol, local_signature_symbol, local_setter_symbol, local_iterator_symbol;
#if (!WITH_PURE_S7)
  s7_pointer is_char_ready_symbol, char_ci_leq_symbol, char_ci_lt_symbol, char_ci_eq_symbol, char_ci_geq_symbol, char_ci_gt_symbol,
             let_to_list_symbol, integer_length_symbol, string_ci_leq_symbol, string_ci_lt_symbol, string_ci_eq_symbol,
             string_ci_geq_symbol, string_ci_gt_symbol, string_to_list_symbol, vector_to_list_symbol, string_length_symbol,
             string_copy_symbol, list_to_string_symbol, list_to_vector_symbol, vector_length_symbol, make_polar_symbol,
             make_rectangular_symbol;
#endif

  /* *s7* fields */
  s7_pointer stack_top_symbol, heap_size_symbol, gc_freed_symbol, gc_protected_objects_symbol,
             free_heap_size_symbol, file_names_symbol, symbol_table_symbol, cpu_time_symbol, float_format_precision_symbol, max_heap_size_symbol,
             stack_size_symbol, rootlet_size_symbol, c_types_symbol, safety_symbol, max_stack_size_symbol, gc_stats_symbol, autoloading_symbol,
             catches_symbol, stack_symbol, default_rationalize_error_symbol, max_string_length_symbol, default_random_state_symbol, history_enabled_symbol,
             max_list_length_symbol, max_vector_length_symbol, max_vector_dimensions_symbol, default_hash_table_length_symbol, profile_info_symbol,
             hash_table_float_epsilon_symbol, equivalent_float_epsilon_symbol, initial_string_port_length_symbol, memory_usage_symbol, max_format_length_symbol,
             undefined_identifier_warnings_symbol, undefined_constant_warnings_symbol, print_length_symbol, bignum_precision_symbol,
             stacktrace_defaults_symbol, history_symbol, history_size_symbol;

  /* syntax symbols et al */
  s7_pointer else_symbol, lambda_symbol, lambda_star_symbol, let_symbol, quote_symbol, unquote_symbol, macroexpand_symbol,
             define_expansion_symbol, baffle_symbol, with_let_symbol, if_symbol, autoload_error_symbol,
             when_symbol, unless_symbol, begin_symbol, cond_symbol, case_symbol, and_symbol, or_symbol, do_symbol,
             define_symbol, define_star_symbol, define_constant_symbol, with_baffle_symbol, define_macro_symbol,
             define_macro_star_symbol, define_bacro_symbol, define_bacro_star_symbol, letrec_symbol, letrec_star_symbol, let_star_symbol,
             key_rest_symbol, key_allow_other_keys_symbol, key_readable_symbol, key_display_symbol, key_write_symbol, value_symbol, type_symbol,
             baffled_symbol, __func___symbol, set_symbol, body_symbol, class_name_symbol, feed_to_symbol, format_error_symbol,
             wrong_number_of_args_symbol, read_error_symbol, string_read_error_symbol, syntax_error_symbol, division_by_zero_symbol,
             no_catch_symbol, io_error_symbol, invalid_escape_function_symbol, wrong_type_arg_symbol, out_of_range_symbol,
             missing_method_symbol, unbound_variable_symbol, key_if_symbol;
  s7_pointer dox_slot_symbol;

  /* signatures of sequences used as applicable objects: ("hi" 1) */
  s7_pointer string_signature, vector_signature, float_vector_signature, int_vector_signature, byte_vector_signature,
             c_object_signature, let_signature, hash_table_signature, pair_signature;
  /* common signatures */
  s7_pointer pcl_bc, pcl_bs, pcl_bt, pcl_c, pcl_e, pcl_f, pcl_i, pcl_n, pcl_r, pcl_s, pcl_v, pl_bc, pl_bn, pl_bt, pl_p, pl_sf, pl_tl;

  /* optimizer s7_functions */
  s7_pointer add_2, add_1s, add_s1, add_cs1, add_si, add_sf, add_fs, add_f_sf, subtract_1, subtract_2, subtract_s1,
           subtract_cs1, subtract_csn, subtract_sf, subtract_2f, subtract_fs,  simple_char_eq, char_equal_s_ic,
           char_equal_2, char_greater_2, char_less_2, char_position_csi, string_equal_2, substring_to_temp, display_2,
           string_greater_2, string_less_2, symbol_to_string_uncopied, vector_ref_ic, vector_ref_ic_0, vector_ref_ic_1,
           vector_ref_ic_2, vector_ref_ic_3, vector_ref_2, vector_ref_2_direct, vector_ref_3, vector_set_3, vector_set_4,
           fv_ref_2, fv_ref_3, fv_set_3, fv_set_unchecked, iv_ref_2, iv_ref_2i, iv_ref_3, iv_set_3, bv_ref_2, bv_ref_3, bv_set_3,
           list_set_ic, hash_table_ref_2, hash_table_ref_ss, hash_table_2,
           hash_table_ref_car, format_allg, format_allg_no_column, format_just_control_string, format_as_objstr,
           not_is_pair_s, not_is_null_s, not_is_symbol_s, not_is_number_s, not_is_eq_ss, not_is_eq_sq, not_is_pair_car_s,
           not_c_c, is_pair_car_s, is_pair_cdr_s, is_pair_cddr_s, is_pair_cadr_s, is_null_cdr, is_null_cddr_s,
           is_null_cadr_s, is_symbol_cadr_s, is_eq_car, is_eq_car_q, is_eq_caar_q, member_ss, member_sq, memq_2,
           memq_3, memq_4, memq_any, memq_car, memq_car_2, tree_set_memq_syms, read_line_uncopied, simple_inlet,
           lint_let_ref, lint_let_set, or_n, or_2, or_3, and_n, and_2, and_3, if_a_a, if_a_aa, if_not_a_a,
           if_not_a_aa, if_x_qq, if_x_qa, or_s_direct, and_s_direct, geq_2, or_s_direct_2, and_s_direct_2, or_s_type_2;

#if (!WITH_GMP)
  s7_pointer multiply_2, multiply_is, multiply_si, multiply_fs, multiply_sf, sqr_ss, invert_1, divide_1r, mod_si, equal_s_ic,
           equal_length_ic, equal_2, equal_2i, less_s_ic, less_s0, less_2, less_length_ic, greater_s_ic, greater_s_fc, greater_2,
           leq_s_ic, leq_2, geq_s_ic, geq_s_fc, random_ic, random_rc, random_1,
           mul_2_ff, mul_2_ii, mul_2_if, mul_2_fi, mul_2_xi, mul_2_ix, mul_2_fx, mul_2_xf,
           add_2_ff, add_2_ii, add_2_if, add_2_fi, add_2_xi, add_2_ix, add_2_fx, add_2_xf;
#endif
#if WITH_GMP
  s7_pointer bignum_symbol, is_bignum_symbol;
  gc_list *big_integers, *big_ratios, *big_reals, *big_complexes, *big_random_states;
#endif
  /* object->let symbols */
#if (!WITH_GMP)
  s7_pointer seed_symbol, carry_symbol;
#endif
  s7_pointer active_symbol, goto_symbol, data_symbol, weak_symbol, dimensions_symbol, info_symbol, c_type_symbol, source_symbol, c_object_ref_symbol,
             at_end_symbol, sequence_symbol, position_symbol, entries_symbol, locked_symbol, function_symbol, open_symbol, alias_symbol, port_type_symbol,
             file_symbol, line_symbol, c_object_let_symbol, class_symbol, c_object_length_symbol, c_object_set_symbol, current_value_symbol,
             c_object_copy_symbol, c_object_fill_symbol, c_object_reverse_symbol, c_object_to_list_symbol, c_object_to_string_symbol, closed_symbol;

#if WITH_SYSTEM_EXTRAS
  s7_pointer is_directory_symbol, file_exists_symbol, delete_file_symbol, getenv_symbol, system_symbol, directory_to_list_symbol, file_mtime_symbol;
#endif

  s7_pointer vector_set_function, string_set_function, list_set_function, hash_table_set_function, let_set_function, c_object_set_function, last_function;

  s7_pointer wrong_type_arg_info, out_of_range_info, simple_wrong_type_arg_info, simple_out_of_range_info;
  s7_pointer integer_wrapper1, integer_wrapper2, integer_wrapper3;
  s7_pointer real_wrapper1, real_wrapper2, real_wrapper3, real_wrapper4;

  #define NUM_SAFE_PRELISTS 8
  #define NUM_SAFE_LISTS 64               /* 36 is the biggest normally (lint.scm), 49 in s7test, 57 in snd-test */
  s7_pointer safe_lists[NUM_SAFE_LISTS];
  int32_t current_safe_list;

  s7_pointer autoload_table, profile_info, s7_let;
  const char ***autoload_names;
  s7_int *autoload_names_sizes;
  bool **autoloaded_already;
  s7_int autoload_names_loc, autoload_names_top;
  int32_t format_depth;
  bool undefined_identifier_warnings, undefined_constant_warnings;
  optfix_t *optimizer_fixups;
  jmp_buf opt_exit;
  int32_t pc;
  #define OPTS_SIZE 256          /* 128 overflows twice in s7test, 64 overflows 4 times in s7test, once in tall, pqw-vox needs 173 */
  opt_info *opts[OPTS_SIZE + 1]; /* this form is a lot faster than opt_info**! */
  heap_block_t *heap_blocks;
};

static s7_scheme *cur_sc = NULL; /* intended for gdb (see gdbinit) */


/* -------------------------------- mallocate -------------------------------- */

static const int32_t bits[256] =
  {0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};

static void memclr(void *s, size_t n)
{
  uint8_t *s2;
#if S7_ALIGNED
  s2 = (uint8_t *)s;
#else
#if (defined(__x86_64__) || defined(__i386__))
  if (n >= 8)
    {
      int64_t *s1 = (int64_t *)s;
      size_t n8 = n >> 3;
      do {*s1++ = 0;} while (--n8 > 0);
      n &= 7;
      s2 = (uint8_t *)s1;
    }
  else s2 = (uint8_t *)s;
#else
  s2 = (uint8_t *)s;
#endif
#endif
  while (n > 0)
    {
      *s2++ = 0;
      n--;
    }
}

#define LOOP_4(Code) do {Code; Code; Code; Code;} while (0)
#define LOOP_8(Code) do {Code; Code; Code; Code; Code; Code; Code; Code;} while (0)
#define STEP_8(Var) (((Var) & 0x7) == 0)

#if POINTER_32
#define memclr64 memclr
#else
#if WITH_VECTORIZE
static void memclr64(void *p, size_t bytes) __attribute__((optimize("tree-vectorize")));
#endif

static void memclr64(void *p, size_t bytes)
{
  size_t i, n;
  int64_t *vals;
  vals = (int64_t *)p;
  n = bytes >> 3;
  for (i = 0; i < n; )
    LOOP_8(vals[i++] = 0);
}
#endif

static void init_block_lists(s7_scheme *sc)
{
  int32_t i;
  for (i = 0; i < NUM_BLOCK_LISTS; i++)
    sc->block_lists[i] = NULL;
}

/* clear_block_lists (in (gc)?) can free the data blocks and put all blocks on block_list[BLOCK_LIST],
 *  but the blocks themselves can't be freed (they're allocated by malloc in arbitrary batches, and
 *  the malloc pointer block is not currently recognizable).
 */

#if S7_DEBUGGING
static s7_int permanent_string_len = 0;
#endif

static inline void liberate(s7_scheme *sc, block_t *p)
{
  if (block_index(p) != TOP_BLOCK_LIST)
    {
      block_next(p) = (struct block_t *)sc->block_lists[block_index(p)];
      sc->block_lists[block_index(p)] = p;
    }
  else
    {
      if (block_data(p))
	{
#if S7_DEBUGGING
	  permanent_string_len -= block_size(p);
#endif
	  free(block_data(p));
	  block_data(p) = NULL;
	}
      block_set_index(p, BLOCK_LIST);
      block_next(p) = (struct block_t *)sc->block_lists[block_index(p)];
      sc->block_lists[block_index(p)] = p;
    }
}

static inline void liberate_block(s7_scheme *sc, block_t *p)
{
  block_next(p) = (struct block_t *)sc->block_lists[BLOCK_LIST];
  sc->block_lists[BLOCK_LIST] = p;
}

static void fill_block_list(s7_scheme *sc)
{
  int32_t i;
  block_t *b;
  #define BLOCK_MALLOC_SIZE 256
  b = (block_t *)malloc(BLOCK_MALLOC_SIZE * sizeof(block_t)); /* batch alloc means blocks in this batch can't be freed, only returned to the list */
  sc->block_lists[BLOCK_LIST] = b;
  for (i = 0; i < BLOCK_MALLOC_SIZE - 1; i++)
    {
      block_next(b) = (block_t *)(b + 1);
      block_set_index(b, BLOCK_LIST);
      b++;
    }
  block_next(b) = NULL;
  block_set_index(b, BLOCK_LIST);
}

static inline block_t *mallocate_block(s7_scheme *sc)
{
  block_t *p;
  if (!sc->block_lists[BLOCK_LIST])
    fill_block_list(sc);                /* this is much faster than allocating blocks as needed */
  p = sc->block_lists[BLOCK_LIST];
  sc->block_lists[BLOCK_LIST] = (block_t *)(block_next(p));
  block_next(p) = NULL;
  block_index(p) = BLOCK_LIST;
  return(p);
}

static inline char *alloc_permanent_string(s7_scheme *sc, size_t len)
{
  #define ALLOC_STRING_SIZE 32768
  #define ALLOC_MAX_STRING 256
  char *result;
  size_t next_k;

  len = (len + 7) & (~7);            /* 8-byte aligned -- more than half the time, len is already 8-byte aligned */
  next_k = sc->alloc_string_k + len;
  if (next_k >= ALLOC_STRING_SIZE)
    {
      if (len >= ALLOC_MAX_STRING)
	{
#if S7_DEBUGGING
	  permanent_string_len += len;
#endif
	  return((char *)malloc(len));
	}
#if S7_DEBUGGING
      permanent_string_len += ALLOC_STRING_SIZE;
#endif
      sc->alloc_string_cells = (char *)malloc(ALLOC_STRING_SIZE);
      sc->alloc_string_k = 0;
      next_k = len;
    }
  result = &(sc->alloc_string_cells[sc->alloc_string_k]);
  sc->alloc_string_k = next_k;
  return(result);
}

static inline block_t *mallocate(s7_scheme *sc, size_t bytes)
{
  block_t *p;
  if (bytes > 0)
    {
      int32_t index;
      if (bytes <= 8)
	index = 3;
      else
	{
	  if (bytes <= 256)
	    index = bits[bytes - 1];
	  else
	    {
	      if (bytes <= 65536)
		index = 8 + bits[(bytes - 1) >> 8];
	      else index = TOP_BLOCK_LIST; /* expansion to (1 << 17) made no difference */
	    }
	}
      p = sc->block_lists[index];
      if (p)
	{
	  sc->block_lists[index] = (block_t *)block_next(p);
	  block_next(p) = NULL;
	}
      else
	{
	  p = mallocate_block(sc);
	  block_data(p) = (void *)alloc_permanent_string(sc, (index < TOP_BLOCK_LIST) ? (size_t)(1 << index) : bytes);
	  block_set_index(p, index);
	}
    }
  else p = mallocate_block(sc);
  block_set_size(p, bytes);
  return(p);
}

static block_t *callocate(s7_scheme *sc, size_t bytes)
{
  block_t *p;
  p = mallocate(sc, bytes);
  if ((block_data(p)) && (block_index(p) != BLOCK_LIST))
    {
      if (block_index(p) >= 6)
	memclr64((void *)block_data(p), bytes);
      else memclr((void *)(block_data(p)), bytes);
    }
  return(p);
}

static block_t *reallocate(s7_scheme *sc, block_t *op, size_t bytes)
{
  block_t *np;
  np = mallocate(sc, bytes);
  if (block_data(op))  /* presumably block_data(np) is not null */
    memcpy((uint8_t *)(block_data(np)), (uint8_t *)(block_data(op)), block_size(op));
  liberate(sc, op);
  return(np);
}


/* -------------------------------------------------------------------------------- */

enum {NO_SAFETY = 0, IMMUTABLE_VECTOR_SAFETY, MORE_SAFETY_WARNINGS};  /* (*s7* 'safety) settings */

typedef enum {P_DISPLAY, P_WRITE, P_READABLE, P_KEY} use_write_t;

static s7_pointer prepackaged_type_names[NUM_TYPES];

static s7_pointer too_many_arguments_string, not_enough_arguments_string, missing_method_string,
  a_boolean_string, a_byte_vector_string, a_format_port_string, a_let_string, a_list_string, a_non_constant_symbol_string,
  a_non_negative_integer_string, a_normal_procedure_string, a_normal_real_string, a_number_string, a_procedure_string,
  a_proper_list_string, a_random_state_object_string, a_rational_string, a_sequence_string, a_symbol_string, a_thunk_string,
  a_valid_radix_string, an_association_list_string, an_eq_func_string, an_input_file_port_string, an_input_port_string,
  an_input_string_port_string, an_open_port_string, an_output_file_port_string, an_output_port_string, an_output_string_port_string,
  an_unsigned_byte_string, caaar_a_list_string, caadr_a_list_string, caar_a_list_string, cadar_a_list_string, caddr_a_list_string,
  cadr_a_list_string, car_a_list_string, cdaar_a_list_string, cdadr_a_list_string, cdar_a_list_string, cddar_a_list_string,
  cdddr_a_list_string, cddr_a_list_string, cdr_a_list_string, immutable_error_string, its_infinite_string, its_nan_string,
  its_negative_string, its_too_large_string, its_too_small_string, parameter_set_twice_string, result_is_too_large_string,
  something_applicable_string, too_many_indices_string, value_is_missing_string,
  format_string_1, format_string_2, format_string_3, format_string_4;

static bool t_number_p[NUM_TYPES], t_real_p[NUM_TYPES], t_rational_p[NUM_TYPES], t_big_number_p[NUM_TYPES];
static bool t_simple_p[NUM_TYPES], t_structure_p[NUM_TYPES];
static bool t_any_macro_p[NUM_TYPES], t_any_closure_p[NUM_TYPES], t_has_closure_let[NUM_TYPES];
static bool t_mappable_p[NUM_TYPES], t_sequence_p[NUM_TYPES], t_vector_p[NUM_TYPES];
static bool t_procedure_p[NUM_TYPES], t_applicable_p[NUM_TYPES];
#if S7_DEBUGGING
static bool t_freeze_p[NUM_TYPES];
#endif

static void init_types(void)
{
  int32_t i;
  for (i = 0; i < NUM_TYPES; i++)
    {
      t_number_p[i] = false;
      t_real_p[i] = false;
      t_rational_p[i] = false;
      t_simple_p[i] = false;
      t_structure_p[i] = false;
      t_any_macro_p[i] = false;
      t_any_closure_p[i] = false;
      t_has_closure_let[i] = false;
      t_sequence_p[i] = false;
      t_mappable_p[i] = false;
      t_vector_p[i] = false;
      t_applicable_p[i] = false;
      t_procedure_p[i] = false;
#if S7_DEBUGGING
      t_freeze_p[i] = false;
#endif
    }
  t_number_p[T_INTEGER] = true;
  t_number_p[T_RATIO] = true;
  t_number_p[T_REAL] = true;
  t_number_p[T_COMPLEX] = true;

  t_rational_p[T_INTEGER] = true;
  t_rational_p[T_RATIO] = true;

  t_real_p[T_INTEGER] = true;
  t_real_p[T_RATIO] = true;
  t_real_p[T_REAL] = true;

  t_big_number_p[T_BIG_INTEGER] = true;
  t_big_number_p[T_BIG_RATIO] = true;
  t_big_number_p[T_BIG_REAL] = true;
  t_big_number_p[T_BIG_COMPLEX] = true;

  t_structure_p[T_PAIR] = true;
  t_structure_p[T_VECTOR] = true;
  t_structure_p[T_HASH_TABLE] = true;
  t_structure_p[T_SLOT] = true;
  t_structure_p[T_LET] = true;
  t_structure_p[T_ITERATOR] = true;
  t_structure_p[T_C_POINTER] = true;
  t_structure_p[T_C_OBJECT] = true;

  t_sequence_p[T_NIL] = true;
  t_sequence_p[T_PAIR] = true;
  t_sequence_p[T_STRING] = true;
  t_sequence_p[T_VECTOR] = true;
  t_sequence_p[T_INT_VECTOR] = true;
  t_sequence_p[T_FLOAT_VECTOR] = true;
  t_sequence_p[T_BYTE_VECTOR] = true;
  t_sequence_p[T_HASH_TABLE] = true;
  t_sequence_p[T_LET] = true;
  t_sequence_p[T_C_OBJECT] = true;

  t_mappable_p[T_PAIR] = true;
  t_mappable_p[T_STRING] = true;
  t_mappable_p[T_VECTOR] = true;
  t_mappable_p[T_INT_VECTOR] = true;
  t_mappable_p[T_FLOAT_VECTOR] = true;
  t_mappable_p[T_BYTE_VECTOR] = true;
  t_mappable_p[T_HASH_TABLE] = true;
  t_mappable_p[T_LET] = true;
  t_mappable_p[T_C_OBJECT] = true;
  t_mappable_p[T_ITERATOR] = true;
  t_mappable_p[T_C_MACRO] = true;
  t_mappable_p[T_MACRO] = true;
  t_mappable_p[T_BACRO] = true;
  t_mappable_p[T_MACRO_STAR] = true;
  t_mappable_p[T_BACRO_STAR] = true;
  t_mappable_p[T_CLOSURE] = true;
  t_mappable_p[T_CLOSURE_STAR] = true;

  t_vector_p[T_VECTOR] = true;
  t_vector_p[T_INT_VECTOR] = true;
  t_vector_p[T_FLOAT_VECTOR] = true;
  t_vector_p[T_BYTE_VECTOR] = true;

  t_applicable_p[T_PAIR] = true;
  t_applicable_p[T_STRING] = true;
  t_applicable_p[T_VECTOR] = true;
  t_applicable_p[T_INT_VECTOR] = true;
  t_applicable_p[T_FLOAT_VECTOR] = true;
  t_applicable_p[T_BYTE_VECTOR] = true;
  t_applicable_p[T_HASH_TABLE] = true;
  t_applicable_p[T_ITERATOR] = true;
  t_applicable_p[T_LET] = true;
  t_applicable_p[T_C_OBJECT] = true;
  t_applicable_p[T_C_MACRO] = true;
  t_applicable_p[T_MACRO] = true;
  t_applicable_p[T_BACRO] = true;
  t_applicable_p[T_MACRO_STAR] = true;
  t_applicable_p[T_BACRO_STAR] = true;
  t_applicable_p[T_SYNTAX] = true;
  t_applicable_p[T_C_FUNCTION] = true;
  t_applicable_p[T_C_FUNCTION_STAR] = true;
  t_applicable_p[T_C_ANY_ARGS_FUNCTION] = true;
  t_applicable_p[T_C_OPT_ARGS_FUNCTION] = true;
  t_applicable_p[T_C_RST_ARGS_FUNCTION] = true;
  t_applicable_p[T_CLOSURE] = true;
  t_applicable_p[T_CLOSURE_STAR] = true;
  t_applicable_p[T_GOTO] = true;
  t_applicable_p[T_CONTINUATION] = true;

  /* t_procedure_p[T_C_OBJECT] = true; */
  t_procedure_p[T_C_FUNCTION] = true;
  t_procedure_p[T_C_FUNCTION_STAR] = true;
  t_procedure_p[T_C_ANY_ARGS_FUNCTION] = true;
  t_procedure_p[T_C_OPT_ARGS_FUNCTION] = true;
  t_procedure_p[T_C_RST_ARGS_FUNCTION] = true;
  t_procedure_p[T_CLOSURE] = true;
  t_procedure_p[T_CLOSURE_STAR] = true;
  t_procedure_p[T_GOTO] = true;
  t_procedure_p[T_CONTINUATION] = true;

  t_any_macro_p[T_C_MACRO] = true;
  t_any_macro_p[T_MACRO] = true;
  t_any_macro_p[T_BACRO] = true;
  t_any_macro_p[T_MACRO_STAR] = true;
  t_any_macro_p[T_BACRO_STAR] = true;

  t_any_closure_p[T_CLOSURE] = true;
  t_any_closure_p[T_CLOSURE_STAR] = true;

  t_has_closure_let[T_MACRO] = true;
  t_has_closure_let[T_BACRO] = true;
  t_has_closure_let[T_MACRO_STAR] = true;
  t_has_closure_let[T_BACRO_STAR] = true;
  t_has_closure_let[T_CLOSURE] = true;
  t_has_closure_let[T_CLOSURE_STAR] = true;

  t_simple_p[T_NIL] = true;
  t_simple_p[T_UNDEFINED] = true;
  t_simple_p[T_EOF_OBJECT] = true;
  t_simple_p[T_BOOLEAN] = true;
  t_simple_p[T_CHARACTER] = true;
  t_simple_p[T_SYMBOL] = true;
  t_simple_p[T_SYNTAX] = true;
  t_simple_p[T_C_MACRO] = true;
  t_simple_p[T_C_FUNCTION] = true;
  t_simple_p[T_C_FUNCTION_STAR] = true;
  t_simple_p[T_C_ANY_ARGS_FUNCTION] = true;
  t_simple_p[T_C_OPT_ARGS_FUNCTION] = true;
  t_simple_p[T_C_RST_ARGS_FUNCTION] = true;
  /* not completely sure about the next ones */
  t_simple_p[T_LET] = true;
  t_simple_p[T_INPUT_PORT] = true;
  t_simple_p[T_OUTPUT_PORT] = true;

#if S7_DEBUGGING
  t_freeze_p[T_STRING] = true;
  t_freeze_p[T_BYTE_VECTOR] = true;
  t_freeze_p[T_VECTOR] = true;
  t_freeze_p[T_FLOAT_VECTOR] = true;
  t_freeze_p[T_INT_VECTOR] = true;
  t_freeze_p[T_UNDEFINED] = true;
  t_freeze_p[T_C_OBJECT] = true;
  t_freeze_p[T_HASH_TABLE] = true;
  t_freeze_p[T_C_FUNCTION] = true;
  t_freeze_p[T_CONTINUATION] = true;
  t_freeze_p[T_INPUT_PORT] = true;
  t_freeze_p[T_OUTPUT_PORT] = true;
#endif
}

#if WITH_HISTORY
#define current_code(Sc)           car(Sc->cur_code)
#define set_current_code(Sc, Code) do {Sc->cur_code = cdr(Sc->cur_code); set_car(Sc->cur_code, Code);} while (0)
#define mark_current_code(Sc)      do {int32_t i; s7_pointer p; for (p = Sc->cur_code, i = 0; i < sc->history_size; i++, p = cdr(p)) gc_mark(car(p));} while (0)
#else
#define current_code(Sc)           Sc->cur_code
#define set_current_code(Sc, Code) Sc->cur_code = Code
#define mark_current_code(Sc)      gc_mark(Sc->cur_code)
#endif

#define typeflag(p)  ((p)->tf.flag)
#define typesflag(p) ((p)->tf.sflag)
#define TYPE_MASK    0xff

#if S7_DEBUGGING
  static const char *check_name(int32_t typ);
  static s7_pointer check_ref(s7_pointer p, uint8_t expected_type, const char *func, int32_t line, const char *func1, const char *func2);
  static s7_pointer check_ref2(s7_pointer p, uint8_t expected_type, int32_t other_type, const char *func, int32_t line, const char *func1, const char *func2);
  static s7_pointer check_ref3(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref4(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref5(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref6(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref7(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref8(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref9(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref10(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref11(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref12(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref13(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_ref14(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_nref(s7_pointer p, const char *func, int32_t line);
  static s7_pointer check_let_ref(s7_pointer p, uint64_t role, const char *func, int32_t line);
  static s7_pointer check_let_set(s7_pointer p, uint64_t role, const char *func, int32_t line);
  static s7_pointer check_cell(s7_pointer p, const char *func, int32_t line);
  static void print_gc_info(s7_pointer obj, int32_t line);

  static s7_pointer opt1_1(s7_pointer p, uint32_t role, const char *func, int32_t line);
  static s7_pointer set_opt1_1(s7_pointer p, s7_pointer x, uint32_t role, const char *func, int32_t line);
  static s7_pointer opt2_1(s7_scheme *sc, s7_pointer p, uint32_t role, const char *func, int32_t line);
  static void set_opt2_1(s7_scheme *sc, s7_pointer p, s7_pointer x, uint32_t role, const char *func, int32_t line);
  static s7_pointer opt3_1(s7_pointer p, uint32_t role, const char *func, int32_t line);
  static void set_opt3_1(s7_pointer p, s7_pointer x, uint32_t role, const char *func, int32_t line);

  static uint64_t s_hash_1(s7_pointer p, const char *func, int32_t line);
  static void set_s_hash_1(s7_pointer p, uint64_t x, const char *func, int32_t line);
  static const char *s_name_1(s7_pointer p, const char *func, int32_t line);
  static void set_s_name_1(s7_pointer p, const char *str, const char *func, int32_t line);
  static uint32_t s_line_1(s7_pointer p, const char *func, int32_t line);
  static void set_s_line_1(s7_pointer p, uint32_t x, const char *func, int32_t line);
  static void set_s_file_1(s7_scheme *sc, s7_pointer p, uint32_t x, const char *func, int32_t line);
  static uint32_t s_len_1(s7_pointer p, const char *func, int32_t line);
  static void set_s_len_1(s7_pointer p, uint32_t x, const char *func, int32_t line);
  #define unchecked_type(p)           ((p)->tf.type_field)
#if WITH_GCC
  #define type(p) ({uint8_t _t_; _t_ = (p)->tf.type_field; if (((_t_ == T_FREE)) || (_t_ >= NUM_TYPES)) print_gc_info(p, __LINE__); _t_;})
#else
  #define type(p) (p)->tf.type_field
#endif

  #define set_type(p, f)						\
    do {								\
      p->previous_alloc_line = p->current_alloc_line;			\
      p->previous_alloc_func = p->current_alloc_func;			\
      p->previous_alloc_type = p->current_alloc_type;			\
      p->current_alloc_line = __LINE__;					\
      p->current_alloc_func = __func__;					\
      p->current_alloc_type = f;					\
      p->explicit_free_line = 0;					\
      p->uses++; 					                \
      if ((((f) & TYPE_MASK) == T_FREE) || (((f) & TYPE_MASK) >= NUM_TYPES))	\
        fprintf(stderr, "%d: set free %p type to %" PRIx64 "\n", __LINE__, p, (int64_t)(f)); \
      else								\
	{								\
	  if (((typeflag(p) & T_IMMUTABLE) != 0) && ((typeflag(p) != (uint64_t)(f))))						\
	    {fprintf(stderr, "%s[%d]: set immutable %p type %d to %" print_s7_int "\n", __func__, __LINE__, p, unchecked_type(p), (int64_t)(f)); abort();} \
          if (((typeflag(p) & T_UNHEAP) != 0) && (((f) & T_UNHEAP) == 0)) \
	    fprintf(stderr, "%s[%d]: clearing unheap in set type!\n", __func__, __LINE__);		\
	}								\
      typeflag(p) = f;							\
    } while (0)

  /* these check most s7cell field references (and many type bits) for consistency */
  #define T_Int(P) check_ref(P, T_INTEGER,           __func__, __LINE__, NULL, NULL)
  #define T_Rel(P) check_ref(P, T_REAL,              __func__, __LINE__, NULL, NULL)
  #define T_Frc(P) check_ref2(P, T_RATIO, T_INTEGER, __func__, __LINE__, NULL, NULL)
  #define T_Cmp(P) check_ref(P, T_COMPLEX,           __func__, __LINE__, NULL, NULL)
  #define T_Bgi(P) check_ref(P, T_BIG_INTEGER,       __func__, __LINE__, "sweep", NULL)
  #define T_Bgr(P) check_ref(P, T_BIG_REAL,          __func__, __LINE__, "sweep", NULL)
  #define T_Bgf(P) check_ref(P, T_BIG_RATIO,         __func__, __LINE__, "sweep", NULL)
  #define T_Bgz(P) check_ref(P, T_BIG_COMPLEX,       __func__, __LINE__, "sweep", NULL)
  #define T_Chr(P) check_ref(P, T_CHARACTER,         __func__, __LINE__, NULL, NULL)
  #define T_Ctr(P) check_ref(P, T_COUNTER,           __func__, __LINE__, NULL, NULL)
  #define T_Ptr(P) check_ref(P, T_C_POINTER,         __func__, __LINE__, NULL, NULL)
  #define T_Bfl(P) check_ref(P, T_BAFFLE,            __func__, __LINE__, NULL, NULL)
  #define T_Got(P) check_ref(P, T_GOTO,              __func__, __LINE__, NULL, NULL)
  #define T_Stk(P) check_ref(P, T_STACK,             __func__, __LINE__, NULL, NULL)
  #define T_Pair(P) check_ref(P, T_PAIR,             __func__, __LINE__, NULL, NULL)
  #define T_Cat(P) check_ref(P, T_CATCH,             __func__, __LINE__, NULL, NULL)
  #define T_Dyn(P) check_ref(P, T_DYNAMIC_WIND,      __func__, __LINE__, NULL, NULL)
  #define T_Slt(P) check_ref(P, T_SLOT,              __func__, __LINE__, NULL, NULL)
  #define T_Sld(P) check_ref2(P, T_SLOT, T_UNDEFINED,__func__, __LINE__, NULL, NULL)
  #define T_Syn(P) check_ref(P, T_SYNTAX,            __func__, __LINE__, NULL, NULL)
  #define T_Mac(P) check_ref(P, T_C_MACRO,           __func__, __LINE__, NULL, NULL)
  #define T_Let(P) check_ref(P, T_LET,               __func__, __LINE__, NULL, NULL)
  #define T_Lid(P) check_ref2(P, T_LET, T_NIL,       __func__, __LINE__, NULL, NULL)
  #define T_Ran(P) check_ref(P, T_RANDOM_STATE,      __func__, __LINE__, NULL, NULL)
  #define T_Lst(P) check_ref2(P, T_PAIR, T_NIL,      __func__, __LINE__, "gc", NULL)
  #define T_Str(P) check_ref(P, T_STRING,            __func__, __LINE__, "sweep", NULL)
  #define T_BVc(P) check_ref(P, T_BYTE_VECTOR,       __func__, __LINE__, "sweep", NULL)
  #define T_Obj(P) check_ref(P, T_C_OBJECT,          __func__, __LINE__, "sweep", NULL)
  #define T_Hsh(P) check_ref(P, T_HASH_TABLE,        __func__, __LINE__, "sweep", "free_hash_table")
  #define T_Itr(P) check_ref(P, T_ITERATOR,          __func__, __LINE__, "sweep", "process_iterator")
  #define T_Con(P) check_ref(P, T_CONTINUATION,      __func__, __LINE__, "sweep", "process_continuation")
  #define T_Fvc(P) check_ref(P, T_FLOAT_VECTOR,      __func__, __LINE__, "sweep", NULL)
  #define T_Ivc(P) check_ref(P, T_INT_VECTOR,        __func__, __LINE__, "sweep", NULL)
  #define T_Nvc(P) check_ref(P, T_VECTOR,            __func__, __LINE__, "sweep", NULL)
  #define T_Sym(P) check_ref(P, T_SYMBOL,            __func__, __LINE__, "sweep", "remove_gensym_from_symbol_table")
  #define T_Fst(P) check_ref(P, T_C_FUNCTION_STAR,   __func__, __LINE__, "sweep", NULL)
  #define T_Exp(P) check_ref2(P, T_MACRO, T_SYMBOL,  __func__, __LINE__, NULL, NULL)
  #define T_Prt(P) check_ref3(P,                     __func__, __LINE__) /* input|output_port */
  #define T_Vec(P) check_ref4(P,                     __func__, __LINE__) /* any vector */
  #define T_SVec(P) check_ref13(P,                   __func__, __LINE__) /* subvector */
  #define T_Clo(P) check_ref5(P,                     __func__, __LINE__) /* has closure let */
  #define T_Fnc(P) check_ref6(P,                     __func__, __LINE__) /* any c_function|c_macro */
  #define T_Prc(P) check_ref14(P,                    __func__, __LINE__) /* and procedure or #f */
  #define T_Num(P) check_ref7(P,                     __func__, __LINE__) /* any number (not bignums I think) */
  #define T_Seq(P) check_ref8(P,                     __func__, __LINE__) /* any sequence or structure */
  #define T_Met(P) check_ref9(P,                     __func__, __LINE__) /* anything that might contain a method */
  #define T_Arg(P) check_ref10(P,                    __func__, __LINE__) /* closure arg (list, symbol) */
  #define T_App(P) check_ref11(P,                    __func__, __LINE__) /* applicable or #f */
  #define T_Sln(P) check_ref12(P,                    __func__, __LINE__) /* slot or nil */
  #define T_Pos(P) check_nref(P,                     __func__, __LINE__) /* not free */
  #define T_Any(P) check_cell(P,                     __func__, __LINE__) /* any cell */

#else
  #define unchecked_type(p)            ((p)->tf.type_field)
  #define type(p)                      ((p)->tf.type_field)
  #define set_type(p, f)               typeflag(p) = f
  #define T_Int(P)                     P
  #define T_Rel(P)                     P
  #define T_Frc(P)                     P
  #define T_Cmp(P)                     P
  #define T_Bgi(P)                     P
  #define T_Bgr(P)                     P
  #define T_Bgf(P)                     P
  #define T_Bgz(P)                     P
  #define T_Str(P)                     P
  #define T_BVc(P)                     P
  #define T_Syn(P)                     P
  #define T_Chr(P)                     P
  #define T_Obj(P)                     P
  #define T_Ctr(P)                     P
  #define T_Hsh(P)                     P
  #define T_Itr(P)                     P
  #define T_Ptr(P)                     P
  #define T_Bfl(P)                     P
  #define T_Got(P)                     P
  #define T_Con(P)                     P
  #define T_Stk(P)                     P
  #define T_Prt(P)                     P
  #define T_Ivc(P)                     P
  #define T_Fvc(P)                     P
  #define T_Nvc(P)                     P
  #define T_Vec(P)                     P
  #define T_SVec(P)                    P
  #define T_Pair(P)                    P
  #define T_Ran(P)                     P
  #define T_Dyn(P)                     P
  #define T_Cat(P)                     P
  #define T_Clo(P)                     P
  #define T_Fnc(P)                     P
  #define T_Prc(P)                     P
  #define T_Fst(P)                     P
  #define T_Slt(P)                     P
  #define T_Sln(P)                     P
  #define T_Sld(P)                     P
  #define T_Sym(P)                     P
  #define T_Let(P)                     P
  #define T_Lid(P)                     P
  #define T_Lst(P)                     P
  #define T_Num(P)                     P
  #define T_Seq(P)                     P
  #define T_Met(P)                     P
  #define T_Mac(P)                     P
  #define T_Arg(P)                     P
  #define T_App(P)                     P
  #define T_Exp(P)                     P
  #define T_Pos(P)                     P
  #define T_Any(P)                     P
#endif

#define is_number(P)                   t_number_p[type(P)]
/* #define is_integer(P)               (type(P) == T_INTEGER) */ /* ambiguous -- use is_t_integer */
#define is_real(P)                     t_real_p[type(P)]
#define is_rational(P)                 t_rational_p[type(P)]
#define is_big_number(p)               t_big_number_p[type(p)]
#define is_t_integer(p)                (type(p) == T_INTEGER)
#define is_t_ratio(p)                  (type(p) == T_RATIO)
#define is_t_real(p)                   (type(p) == T_REAL)
#define is_t_complex(p)                (type(p) == T_COMPLEX)
#define is_t_big_integer(p)            (type(p) == T_BIG_INTEGER)
#define is_t_big_ratio(p)              (type(p) == T_BIG_RATIO)
#define is_t_big_real(p)               (type(p) == T_BIG_REAL)
#define is_t_big_complex(p)            (type(p) == T_BIG_COMPLEX)
#define is_float(p)                    is_t_real(p) /* ((is_real(p)) && (!is_rational(p))) */

#define is_free(p)                     (type(p) == T_FREE)
#define is_free_and_clear(p)           (typeflag(p) == T_FREE)
#define is_simple(P)                   t_simple_p[type(P)]
#define has_structure(P)               ((t_structure_p[type(P)]) && ((!is_normal_vector(P)) || (!has_simple_elements(P))))

#define is_any_macro(P)                t_any_macro_p[type(P)]
#define is_any_closure(P)              t_any_closure_p[type(P)]
#define is_procedure_or_macro(P)       ((t_procedure_p[type(P)]) || (t_any_macro_p[type(P)]))
#define is_any_procedure(P)            (type(P) >= T_CLOSURE)
#define has_closure_let(P)             t_has_closure_let[type(P)]

#define is_simple_sequence(P)          (t_sequence_p[type(P)])
#define is_sequence(P)                 ((t_sequence_p[type(P)]) || (has_methods(P)))
#define is_mutable_sequence(P)         (((t_sequence_p[type(P)]) || (has_methods(P))) && (!is_immutable(P)))
#define is_mappable(P)                 (t_mappable_p[type(P)])
#define is_applicable(P)               (t_applicable_p[type(P)])
/* this misses #() which actually is not applicable to anything, probably "" also, and inapplicable c-objects like random-state */
#define is_procedure(p)                ((t_procedure_p[type(p)]) || ((is_c_object(p)) && (is_safe_procedure(p))))
#define is_t_procedure(p)              (t_procedure_p[type(p)])

/* the layout of these bits does matter in several cases -- don't shadow SYNTACTIC_PAIR and OPTIMIZED_PAIR */
#define TYPE_BITS                      8

#define set_type_bit(p, b)             typeflag(p) |= (b)
#define clear_type_bit(p, b)           typeflag(p) &= (~(b))
#define has_type_bit(p, b)             ((typeflag(p) & (b)) != 0)

#define set_type0_bit(p, b)            typesflag(p) |= (b)
#define clear_type0_bit(p, b)          typesflag(p) &= (~(b))
#define has_type0_bit(p, b)            ((typesflag(p) & (b)) != 0)

#define set_type1_bit(p, b)            (p)->tf.opts.high_flag |= (b)
#define clear_type1_bit(p, b)          (p)->tf.opts.high_flag &= (~(b))
#define has_type1_bit(p, b)            (((p)->tf.opts.high_flag & (b)) != 0)

#define T_SYNTACTIC                    (1 << (TYPE_BITS + 1))
#define is_syntactic(p)                has_type0_bit(T_Pos(p), T_SYNTACTIC)
#define is_syntactic_symbol(p)         (typesflag(T_Pos(p)) == (uint16_t)(T_SYMBOL | T_SYNTACTIC))
#define is_syntactic_pair(p)           (typesflag(T_Pos(p)) == (uint16_t)(T_PAIR | T_SYNTACTIC))
/* this marks symbols that represent syntax objects, it should be in the second byte */

#define T_SIMPLE_ARG_DEFAULTS          (1 << (TYPE_BITS + 2))
#define lambda_has_simple_defaults(p)  has_type_bit(T_Pair(p), T_SIMPLE_ARG_DEFAULTS)
#define lambda_set_simple_defaults(p)  set_type_bit(T_Pair(p), T_SIMPLE_ARG_DEFAULTS)
/* are all lambda* default values simple? This is set on closure_body, so it doesn't mess up closure_is_ok_1 */

#define T_LIST_IN_USE                  T_SIMPLE_ARG_DEFAULTS
#define list_is_in_use(p)              has_type0_bit(T_Pair(p), T_LIST_IN_USE)
#define set_list_in_use(p)             set_type_bit(T_Pair(p), T_LIST_IN_USE)
#define clear_list_in_use(p)           clear_type_bit(T_Pair(p), T_LIST_IN_USE)
/* if (!is_immutable(p)) free_vlist(cur_sc, p) seems plausible here, but it got no hits in s7test and other cases */

#define T_ONE_FORM                     T_SIMPLE_ARG_DEFAULTS
#define set_closure_has_one_form(p)    set_type_bit(T_Clo(p), T_ONE_FORM)
#define T_MULTIFORM                    (1 << (TYPE_BITS + 0))
#define set_closure_has_multiform(p)   set_type_bit(T_Clo(p), T_MULTIFORM)
#define set_closure_has_fx(p)          set_type_bit(T_Clo(p), T_ONE_FORM | T_MULTIFORM)
#define closure_clear_multiform(p)     clear_type_bit(T_Clo(p), T_MULTIFORM)
/* temporary extra bit (simplify development...) */

#define T_OPTIMIZED                    (1 << (TYPE_BITS + 3))
#define set_optimized(p)               set_type0_bit(T_Pair(p), T_OPTIMIZED)
#define clear_optimized(p)             clear_type0_bit(T_Pair(p), T_OPTIMIZED | T_SYNTACTIC | T_HAS_FX)
#define OPTIMIZED_PAIR                 (uint16_t)(T_PAIR | T_OPTIMIZED)
#define is_optimized(p)                (typesflag(T_Pos(p)) == OPTIMIZED_PAIR)
/* optimizer flag for an expression that has optimization info, it should be in the second byte */

#define T_SCOPE_SAFE                   T_OPTIMIZED
#define is_scope_safe(p)               has_type_bit(T_Fnc(p), T_SCOPE_SAFE)
#define set_scope_safe(p)              set_type_bit(T_Fnc(p), T_SCOPE_SAFE)

#define T_SAFE_CLOSURE                 (1 << (TYPE_BITS + 4))
#define is_safe_closure(p)             has_type0_bit(T_Clo(p), T_SAFE_CLOSURE)
#define set_safe_closure(p)            set_type0_bit(T_Clo(p), T_SAFE_CLOSURE)
#define is_safe_closure_body(p)        has_type0_bit(T_Pair(p), T_SAFE_CLOSURE)
#define set_safe_closure_body(p)       set_type0_bit(T_Pair(p), T_SAFE_CLOSURE)
#define clear_safe_closure_body(p)     clear_type0_bit(T_Pair(p), T_SAFE_CLOSURE)

/* optimizer flag for a closure body that is completely simple (every expression is safe)
 *   set_safe_closure happens only in optimize_lambda (and define_funchcecked?), clear only in procedure_source, bits only here
 *   this has to be separate from T_SAFE_PROCEDURE, and should be in the second byte (closure_is_ok_1 checks typesflag).
 * define -> optimize_lambda sets safe -> define_funchecked -> make_funclet for the frame
 *   similarly, named let -> optimize_lambda, then let creates the frame if safe
 *   thereafter, optimizer uses OP_SAFE_CLOSURE* which calls old_frame*
 */

#define T_DONT_EVAL_ARGS               (1 << (TYPE_BITS + 5))
#define dont_eval_args(p)              has_type0_bit(T_Pos(p), T_DONT_EVAL_ARGS)
/* this marks things that don't evaluate their arguments */

#define T_EXPANSION                    (1 << (TYPE_BITS + 6))
#define is_expansion(p)                has_type0_bit(T_Exp(p), T_EXPANSION) /* T_Exp: macro or symbol */
#define clear_expansion(p)             clear_type0_bit(T_Sym(p), T_EXPANSION)
/* this marks the symbol and its run-time macro value, distinguishing it from an ordinary macro */

#define T_MULTIPLE_VALUE               (1 << (TYPE_BITS + 7))
#define is_multiple_value(p)           has_type0_bit(T_Pos(p), T_MULTIPLE_VALUE)
#define set_multiple_value(p)          set_type0_bit(T_Pair(p), T_MULTIPLE_VALUE)
#define clear_multiple_value(p)        clear_type0_bit(T_Pair(p), T_MULTIPLE_VALUE)
#define multiple_value(p)              p
/* this bit marks a list (from "values") that is waiting for a chance to be spliced into its caller's argument list.  
 *   It is normally on only for a very short time.
 */

#define T_MATCHED                      T_MULTIPLE_VALUE
#define is_matched_pair(p)             has_type0_bit(T_Pair(p), T_MATCHED)
#define set_match_pair(p)              set_type0_bit(T_Pair(p), T_MATCHED)
#define clear_match_pair(p)            clear_type0_bit(T_Pair(p), T_MATCHED)
#define is_matched_symbol(p)           has_type0_bit(T_Sym(p), T_MATCHED)
#define set_match_symbol(p)            set_type0_bit(T_Sym(p), T_MATCHED)
#define clear_match_symbol(p)          clear_type0_bit(T_Sym(p), T_MATCHED)

#define T_GLOBAL                       (1 << (TYPE_BITS + 8))
#define T_LOCAL                        (1 << (TYPE_BITS + 12))
#define is_global(p)                   has_type_bit(T_Sym(p), T_GLOBAL)
#define set_global(p)                  do {if ((typeflag(T_Sym(p)) & T_LOCAL) == 0) typeflag(p) |= T_GLOBAL;} while (0)
/* T_LOCAL marks a symbol that has been used locally */
/* T_GLOBAL marks something defined (bound) at the top-level, and never defined locally */

#if 0
  /* to find who is stomping on our symbols: */
  static void set_local_1(s7_scheme *sc, s7_pointer symbol, const char *func, int32_t line)
  {
    if (is_global(symbol))
      fprintf(stderr, "%s[%d]: %s%s%s in %s\n",
	      func, line,
	      BOLD_TEXT, s7_object_to_c_string(sc, symbol), UNBOLD_TEXT,
	      s7_object_to_c_string(sc, sc->cur_code));
    typeflag(symbol) = (typeflag(symbol) & ~(T_DONT_EVAL_ARGS | T_GLOBAL | T_SYNTACTIC));

  }
  #define set_local(Symbol) set_local_1(sc, Symbol, __func__, __LINE__)
#else
#define set_local(p)                   typeflag(T_Sym(p)) = ((typeflag(p) | T_LOCAL) & ~(T_DONT_EVAL_ARGS | T_GLOBAL | T_SYNTACTIC))
#endif

#define T_UNSAFE_DO                    T_GLOBAL
#define is_unsafe_do(p)                has_type_bit(T_Pair(p), T_UNSAFE_DO)
#define set_unsafe_do(p)               set_type_bit(T_Pair(p), T_UNSAFE_DO)
/* marks do-loops that resist optimization */

#define T_COLLECTED                    (1 << (TYPE_BITS + 9))
#define is_collected(p)                has_type_bit(T_Seq(p), T_COLLECTED)
#define is_collected_unchecked(p)      has_type_bit(p, T_COLLECTED)
#define set_collected(p)               set_type_bit(T_Seq(p), T_COLLECTED)
/* #define clear_collected(p)          clear_type_bit(T_Seq(p), T_COLLECTED) */
/* this is a transient flag used by the printer to catch cycles.  It affects only objects that have structure.
 *   We can't use a low bit (bit 7 for example), because collect_shared_info inspects the object's type.
 */

#define T_LINE_NUMBER                  (1 << (TYPE_BITS + 10))
#define has_line_number(p)             has_type_bit(T_Pair(p), T_LINE_NUMBER)
#define set_has_line_number(p)         set_type_bit(T_Pair(p), T_LINE_NUMBER)
/* pair in question has line/file info added during read, or the environment has function placement info
 *   this bit should not be in the first byte -- SYNTACTIC_PAIR ignores it.
 */

#define T_LOADER_PORT                  T_LINE_NUMBER
#define is_loader_port(p)              has_type_bit(T_Prt(p), T_LOADER_PORT)
#define set_loader_port(p)             set_type_bit(T_Prt(p), T_LOADER_PORT)
#define clear_loader_port(p)           clear_type_bit(T_Prt(p), T_LOADER_PORT)
/* to block random load-time reads from screwing up the load process, this bit marks a port used by the loader */

#define T_HAS_SETTER                   T_LINE_NUMBER
#define symbol_has_setter(p)           has_type_bit(T_Sym(p), T_HAS_SETTER)
#define symbol_set_has_setter(p)       set_type_bit(T_Sym(p), T_HAS_SETTER)
#define slot_has_setter(p)             has_type_bit(T_Slt(p), T_HAS_SETTER)
#define slot_set_has_setter(p)         set_type_bit(T_Slt(p), T_HAS_SETTER)
/* marks a slot that has a setter or symbol that might have a setter */

#define T_WITH_LET_LET                 T_LINE_NUMBER
#define is_with_let_let(p)             has_type_bit(T_Let(p), T_WITH_LET_LET)
#define set_with_let_let(p)            set_type_bit(T_Let(p), T_WITH_LET_LET)
/* marks a let that is the argument to with-let */

#define T_SIMPLE_DEFAULTS              T_LINE_NUMBER
#define c_func_has_simple_defaults(p)  has_type_bit(T_Fnc(p), T_SIMPLE_DEFAULTS)
#define c_func_set_simple_defaults(p)  set_type_bit(T_Fnc(p), T_SIMPLE_DEFAULTS)
#define c_func_clear_simple_defaults(p) clear_type_bit(T_Fnc(p), T_SIMPLE_DEFAULTS)
/* flag c_func_star arg defaults that need GC protection */

#define T_NO_SETTER                    T_LINE_NUMBER
#define closure_no_setter(p)           has_type_bit(T_Clo(p), T_NO_SETTER)
#define closure_set_no_setter(p)       set_type_bit(T_Clo(p), T_NO_SETTER)

#define T_SHARED                       (1 << (TYPE_BITS + 11))
#define is_shared(p)                   has_type_bit(T_Seq(p), T_SHARED)
#define set_shared(p)                  set_type_bit(T_Seq(p), T_SHARED)
#define is_collected_or_shared(p)      has_type_bit(p, T_COLLECTED | T_SHARED)
#define clear_collected_and_shared(p)  clear_type_bit(p, T_COLLECTED | T_SHARED) /* this can clear free cells = calloc */

#define T_SAFE_PROCEDURE               (1 << (TYPE_BITS + 13))
#define is_safe_procedure(p)           has_type_bit(T_Pos(p), T_SAFE_PROCEDURE)
#define is_safe_or_scope_safe_procedure(p) ((typeflag(T_Fnc(p)) & (T_SCOPE_SAFE | T_SAFE_PROCEDURE)) != 0)
/* applicable objects that do not return or modify their arg list directly (no :rest arg in particular),
 *    and that can't call apply themselves either directly or via s7_call, and that don't mess with the stack.
 */

#define T_CHECKED                      (1 << (TYPE_BITS + 14))
#define set_checked(p)                 set_type_bit(T_Pair(p), T_CHECKED)
#define is_checked(p)                  has_type_bit(T_Pair(p), T_CHECKED)
#define clear_checked(p)               clear_type_bit(T_Pair(p), T_CHECKED)
#define set_checked_slot(p)            set_type_bit(T_Slt(p), T_CHECKED)
#define is_checked_slot(p)             has_type_bit(T_Slt(p), T_CHECKED)
#define clear_checked_slot(p)          clear_type_bit(T_Slt(p), T_CHECKED)

#define T_UNSAFE                       (1 << (TYPE_BITS + 15))
#define set_unsafe(p)                  set_type_bit(T_Pair(p), T_UNSAFE)
#define set_unsafely_optimized(p)      typeflag(T_Pair(p)) = (typeflag(p) | T_UNSAFE | T_OPTIMIZED)
#define is_unsafe(p)                   has_type_bit(T_Pair(p), T_UNSAFE)
#define clear_unsafe(p)                clear_type_bit(T_Pair(p), T_UNSAFE)
#define is_safely_optimized(p)         ((typeflag(T_Pos(p)) & (T_OPTIMIZED | T_UNSAFE)) == T_OPTIMIZED)
/* optimizer flag saying "this expression is not completely self-contained.  It might involve the stack, etc" */

#define T_CLEAN_SYMBOL                 T_UNSAFE
#define is_clean_symbol(p)             has_type_bit(T_Sym(p), T_CLEAN_SYMBOL)
#define set_clean_symbol(p)            set_type_bit(T_Sym(p), T_CLEAN_SYMBOL)
/* set if we know the symbol name can be printed without quotes (slashification) */

#define T_HAS_STEPPER                  T_UNSAFE
#define has_stepper(p)                 has_type_bit(T_Slt(p), T_HAS_STEPPER)
#define set_has_stepper(p)             set_type_bit(T_Slt(p), T_HAS_STEPPER)

#define T_IMMUTABLE                    (1 << (TYPE_BITS + 16))
#define is_immutable(p)                has_type_bit(T_Pos(p), T_IMMUTABLE)
#define set_immutable(p)               set_type_bit(T_Pos(p), T_IMMUTABLE)
#define is_immutable_port(p)           has_type_bit(T_Prt(p), T_IMMUTABLE)
#define is_immutable_symbol(p)         has_type_bit(T_Sym(p), T_IMMUTABLE)
#define is_immutable_slot(p)           has_type_bit(T_Slt(p), T_IMMUTABLE)
#define is_immutable_pair(p)           has_type_bit(T_Pair(p), T_IMMUTABLE)
#define is_immutable_vector(p)         has_type_bit(T_Vec(p), T_IMMUTABLE)
#define is_immutable_string(p)         has_type_bit(T_Str(p), T_IMMUTABLE)
/* T_IMMUTABLE is compatible with T_MUTABLE -- the latter is an internal bit for locally mutable numbers */

#define T_SETTER                       (1 << (TYPE_BITS + 17))
#define set_setter(p)                  set_type_bit(T_Sym(p), T_SETTER)
#define is_setter(p)                   has_type_bit(T_Sym(p), T_SETTER)
/* optimizer flag for a procedure that sets some variable (set-car! for example). */

#define T_ALLOW_OTHER_KEYS             T_SETTER
#define set_allow_other_keys(p)        set_type_bit(T_Pair(p), T_ALLOW_OTHER_KEYS)
#define allows_other_keys(p)           has_type_bit(T_Pair(p), T_ALLOW_OTHER_KEYS)
/* marks arglist that allows keyword args other than those in the parameter list; can't allow
 *   (define* (f :allow-other-keys)...) because there's only one nil, and besides, it does say "other".
 */

#define T_HASH_REMOVED                 T_SETTER
#define hash_table_set_removed(p)      set_type_bit(T_Hsh(p), T_HASH_REMOVED)
#define hash_table_removed(p)          has_type_bit(T_Hsh(p), T_HASH_REMOVED)

#define T_LET_REMOVED                  T_SETTER
#define let_set_removed(p)             set_type_bit(T_Let(p), T_LET_REMOVED)
#define let_removed(p)                 has_type_bit(T_Let(p), T_LET_REMOVED)
/* these mark objects that have been removed from the heap or checked for that possibility */

#define T_HAS_EXPRESSION               T_SETTER
#define slot_set_has_expression(p)     set_type_bit(T_Slt(p), T_HAS_EXPRESSION)
#define slot_has_expression(p)         has_type_bit(T_Slt(p), T_HAS_EXPRESSION)

#define T_MUTABLE                      (1 << (TYPE_BITS + 18))
#define is_mutable(p)                  has_type_bit(T_Num(p), T_MUTABLE)
#define clear_mutable(p)               clear_type_bit(T_Num(p), T_MUTABLE)
/* used for mutable numbers, can occur with T_IMMUTABLE (outside view vs inside) */

#define T_HAS_KEYWORD                  T_MUTABLE
#define has_keyword(p)                 has_type_bit(T_Sym(p), T_HAS_KEYWORD)
#define set_has_keyword(p)             set_type_bit(T_Sym(p), T_HAS_KEYWORD)

#define T_MARK_SEQ                     T_MUTABLE
#define is_mark_seq(p)                 has_type_bit(T_Itr(p), T_MARK_SEQ)
#define set_mark_seq(p)                set_type_bit(T_Itr(p), T_MARK_SEQ)
/* used in iterators for GC mark of sequence */

#define T_STEP_END                     T_MUTABLE
#define is_step_end(p)                 has_type_bit(T_Slt(p), T_STEP_END)
#define set_step_end(p)                set_type_bit(T_Slt(p), T_STEP_END)
/* marks a slot that holds a do-loop's step-or-end variable, numerator=current, denominator=end */

#define T_PAIR_NO_OPT                  T_MUTABLE
#define set_pair_no_opt(p)             set_type_bit(T_Pair(p), T_PAIR_NO_OPT)
#define pair_no_opt(p)                 has_type_bit(T_Pair(p), T_PAIR_NO_OPT)

#define T_NO_INT_OPT                   T_SETTER
#define set_no_int_opt(p)              set_type_bit(T_Pair(p), T_NO_INT_OPT)
#define no_int_opt(p)                  has_type_bit(T_Pair(p), T_NO_INT_OPT)

#define T_NO_FLOAT_OPT                 T_UNSAFE
#define set_no_float_opt(p)            set_type_bit(T_Pair(p), T_NO_FLOAT_OPT)
#define no_float_opt(p)                has_type_bit(T_Pair(p), T_NO_FLOAT_OPT)

#define T_NO_BOOL_OPT                  T_SAFE_STEPPER
#define set_no_bool_opt(p)             set_type_bit(T_Pair(p), T_NO_BOOL_OPT)
#define no_bool_opt(p)                 has_type_bit(T_Pair(p), T_NO_BOOL_OPT)

#define T_DIRECT_X_OPT                 T_SAFE_STEPPER
#define set_direct_x_opt(p)            set_type_bit(T_Pair(p), T_DIRECT_X_OPT)
#define has_direct_x_opt(p)            has_type_bit(T_Pair(p), T_DIRECT_X_OPT)

#define T_SAFE_STEPPER                 (1 << (TYPE_BITS + 19))
#define is_safe_stepper(p)             has_type_bit(T_Slt(p), T_SAFE_STEPPER)
#define set_safe_stepper(p)            set_type_bit(T_Slt(p), T_SAFE_STEPPER)
#define clear_safe_stepper(p)          clear_type_bit(T_Slt(p), T_SAFE_STEPPER)
#define is_safe_stepper_expr(p)        has_type_bit(T_Pair(p), T_SAFE_STEPPER)
#define set_safe_stepper_expr(p)       set_type_bit(T_Pair(p), T_SAFE_STEPPER)

#define T_PRINT_NAME                   T_SAFE_STEPPER
#define has_print_name(p)              has_type_bit(T_Num(p), T_PRINT_NAME)
#define set_has_print_name(p)          set_type_bit(T_Num(p), T_PRINT_NAME)
/* marks numbers that have a saved version of their string representation */

#define T_MAYBE_SAFE                   T_SAFE_STEPPER
#define is_maybe_safe(p)               has_type_bit(T_Fnc(p), T_MAYBE_SAFE)
#define set_maybe_safe(p)              set_type_bit(T_Fnc(p), T_MAYBE_SAFE)

#define T_HAS_LET_SET_FALLBACK         T_SAFE_STEPPER
#define T_HAS_LET_REF_FALLBACK         T_MUTABLE
#define has_let_ref_fallback(p)        ((typeflag(T_Lid(p)) & (T_HAS_LET_REF_FALLBACK | T_HAS_METHODS)) == (T_HAS_LET_REF_FALLBACK | T_HAS_METHODS))
#define has_let_set_fallback(p)        ((typeflag(T_Lid(p)) & (T_HAS_LET_SET_FALLBACK | T_HAS_METHODS)) == (T_HAS_LET_SET_FALLBACK | T_HAS_METHODS))
#define set_has_let_ref_fallback(p)    set_type_bit(T_Let(p), T_HAS_LET_REF_FALLBACK)
#define set_has_let_set_fallback(p)    set_type_bit(T_Let(p), T_HAS_LET_SET_FALLBACK)
#define has_let_fallback(p)            has_type_bit(T_Lid(p), (T_HAS_LET_REF_FALLBACK | T_HAS_LET_SET_FALLBACK))
#define set_all_methods(p, e)          typeflag(T_Let(p)) |= (typeflag(e) & (T_HAS_METHODS | T_HAS_LET_REF_FALLBACK | T_HAS_LET_SET_FALLBACK))

#define T_WEAK_HASH                    T_SAFE_STEPPER
#define set_weak_hash_table(p)         set_type_bit(T_Hsh(p), T_WEAK_HASH)
#define is_weak_hash_table(p)          has_type_bit(T_Hsh(p), T_WEAK_HASH)

#define T_COPY_ARGS                    (1 << (TYPE_BITS + 20))
#define needs_copied_args(p)           has_type_bit(T_Pos(p), T_COPY_ARGS)
/* this marks something that might mess with its argument list, it should not be in the second byte */

#define T_GENSYM                       (1 << (TYPE_BITS + 21))
#define is_gensym(p)                   has_type_bit(T_Sym(p), T_GENSYM)
/* symbol is from gensym (GC-able etc) */

#define T_FUNCLET                      T_GENSYM
#define is_funclet(p)                  has_type_bit(T_Let(p), T_FUNCLET)
#define set_funclet(p)                 set_type_bit(T_Let(p), T_FUNCLET)
/* this marks a funclet */

#define T_HASH_CHOSEN                  T_GENSYM
#define hash_chosen(p)                 has_type_bit(T_Hsh(p), T_HASH_CHOSEN)
#define hash_set_chosen(p)             set_type_bit(T_Hsh(p), T_HASH_CHOSEN)
#define hash_clear_chosen(p)           clear_type_bit(T_Hsh(p), T_HASH_CHOSEN)

#define T_DOCUMENTED                   T_GENSYM
#define is_documented(p)               has_type_bit(T_Str(p), T_DOCUMENTED)
#define set_documented(p)              set_type_bit(T_Str(p), T_DOCUMENTED)
/* this marks a symbol that has documentation (bit is set on name cell) */

#define T_DOTTED_PAIR                  T_GENSYM
#define is_dotted_pair(p)              has_type_bit(T_Lst(p), T_DOTTED_PAIR)
#define pair_set_dotted(p)             set_type_bit(T_Pair(p), T_DOTTED_PAIR)
/* reader indication that a list it just read was dotted */

#define T_SUBVECTOR                    T_GENSYM
#define is_subvector(p)                has_type_bit(T_Vec(p), T_SUBVECTOR)

#define T_HAS_PENDING_VALUE            T_GENSYM
#define slot_set_has_pending_value(p)  set_type_bit(T_Slt(p), T_HAS_PENDING_VALUE)
#define slot_has_pending_value(p)      has_type_bit(T_Slt(p), T_HAS_PENDING_VALUE)

#define T_HAS_METHODS                  (1 << (TYPE_BITS + 22))
#define has_methods(p)                 has_type_bit(T_Pos(p), T_HAS_METHODS)
#define has_active_methods(sc, p)      ((has_type_bit(T_Pos(p), T_HAS_METHODS)) && (sc->has_openlets))
#define set_has_methods(p)             set_type_bit(T_Met(p), T_HAS_METHODS)
#define clear_has_methods(p)           clear_type_bit(T_Met(p), T_HAS_METHODS)
/* this marks an environment or closure that is "open" for generic functions etc, don't reuse this bit */

#define T_ITER_OK                      (1LL << (TYPE_BITS + 23))
#define iter_ok(p)                     has_type_bit(T_Pos(p), T_ITER_OK) /* not TItr(p) here because this bit is globally unique */
#define clear_iter_ok(p)               clear_type_bit(T_Itr(p), T_ITER_OK)

/* its faster here to use the high_flag bits rather than typeflag bits */
#define BIT_ROOM                       16
#define T_FULL_SYMCONS                 (1LL << (TYPE_BITS + BIT_ROOM + 24))
#define T_SYMCONS                      (1 << 0)
#define is_possibly_constant(p)        has_type1_bit(T_Sym(p), T_SYMCONS)
#define set_possibly_constant(p)       set_type1_bit(T_Sym(p), T_SYMCONS)
#define is_probably_constant(p)        has_type_bit(T_Sym(p), (T_FULL_SYMCONS | T_IMMUTABLE))

#define T_HAS_LET_ARG                  T_SYMCONS
#define has_let_arg(p)                 has_type1_bit(T_Prc(p), T_HAS_LET_ARG)
#define set_has_let_arg(p)             set_type1_bit(T_Prc(p), T_HAS_LET_ARG)
/* p is a setter procedure, "let arg" refers to the setter's optional third (let) argument */

#define T_FULL_S7_LET_FIELD            (1LL << (TYPE_BITS + BIT_ROOM + 25))
#define T_S7_LET_FIELD                 (1 << 1)
#define is_s7_let_field(p)             has_type1_bit(T_Sym(p), T_S7_LET_FIELD)
#define set_s7_let_field(p)            set_type1_bit(T_Sym(p), T_S7_LET_FIELD)

#define T_HAS_LET_FILE                 T_S7_LET_FIELD
#define has_let_file(p)                has_type1_bit(T_Let(p), T_HAS_LET_FILE)
#define set_has_let_file(p)            set_type1_bit(T_Let(p), T_HAS_LET_FILE)
#define clear_has_let_file(p)          clear_type1_bit(T_Let(p), T_HAS_LET_FILE)

#define T_TYPED_VECTOR                 T_S7_LET_FIELD
#define is_typed_vector(p)             has_type1_bit(T_Vec(p), T_TYPED_VECTOR)
#define set_typed_vector(p)            set_type1_bit(T_Vec(p), T_TYPED_VECTOR)

#define T_TYPED_HASH_TABLE             T_S7_LET_FIELD
#define is_typed_hash_table(p)         has_type1_bit(T_Hsh(p), T_TYPED_HASH_TABLE)
#define set_typed_hash_table(p)        set_type1_bit(T_Hsh(p), T_TYPED_HASH_TABLE)

#define T_BOOL_SETTER                  T_S7_LET_FIELD
#define c_function_has_bool_setter(p)  has_type1_bit(T_Fnc(p), T_BOOL_SETTER)
#define c_function_set_has_bool_setter(p) set_type1_bit(T_Fnc(p), T_BOOL_SETTER)

#define T_REST_SLOT                    T_S7_LET_FIELD
#define is_rest_slot(p)                has_type1_bit(T_Slt(p), T_REST_SLOT)
#define set_is_rest_slot(p)            set_type1_bit(T_Slt(p), T_REST_SLOT)

#define T_FULL_DEFINER                 (1LL << (TYPE_BITS + BIT_ROOM + 26))
#define T_DEFINER                      (1 << 2)
#define is_definer(p)                  has_type1_bit(T_Sym(p), T_DEFINER)
#define set_is_definer(p)              set_type1_bit(T_Sym(p), T_DEFINER)
/* this marks "definers" like define and define-macro */

#define T_HAS_FX                       T_DEFINER
#define set_has_fx(p)                  set_type1_bit(T_Pair(p), T_HAS_FX)
#define has_fx(p)                      has_type1_bit(T_Pair(p), T_HAS_FX)
#define clear_has_fx(p)                clear_type1_bit(T_Pair(p), T_HAS_FX)

#define T_SLOT_DEFAULTS                T_DEFINER
#define slot_defaults(p)               has_type1_bit(T_Slt(p), T_SLOT_DEFAULTS)
#define set_slot_defaults(p)           set_type1_bit(T_Slt(p), T_SLOT_DEFAULTS)

#define T_WEAK_HASH_ITERATOR           T_DEFINER
#define is_weak_hash_iterator(p)       has_type1_bit(T_Itr(p), T_WEAK_HASH_ITERATOR)
#define set_weak_hash_iterator(p)      set_type1_bit(T_Itr(p), T_WEAK_HASH_ITERATOR)
#define clear_weak_hash_iterator(p)    clear_type1_bit(T_Itr(p), T_WEAK_HASH_ITERATOR)

#define T_FULL_BINDER                  (1LL << (TYPE_BITS + BIT_ROOM + 27))
#define T_BINDER                       (1 << 3)
#define is_definer_or_binder(p)        has_type1_bit(T_Sym(p), T_DEFINER | T_BINDER)
#define set_is_binder(p)               set_type1_bit(T_Sym(p), T_BINDER)
/* this marks "binders" like let */

/* #define T_TREE_COLLECTED            T_FULL_BINDER */
#define T_SHORT_TREE_COLLECTED         T_BINDER
#define tree_is_collected(p)           has_type1_bit(T_Pair(p), T_SHORT_TREE_COLLECTED)
#define tree_set_collected(p)          set_type1_bit(T_Pair(p), T_SHORT_TREE_COLLECTED)
#define tree_clear_collected(p)        clear_type1_bit(T_Pair(p), T_SHORT_TREE_COLLECTED)

#define T_SIMPLE_VALUES                T_BINDER
#define has_simple_values(p)           has_type1_bit(T_Hsh(p), T_SIMPLE_VALUES)
#define set_has_simple_values(p)       set_type1_bit(T_Hsh(p), T_SIMPLE_VALUES)

#define T_VERY_SAFE_CLOSURE            (1LL << (TYPE_BITS + BIT_ROOM + 28))
#define T_SHORT_VERY_SAFE_CLOSURE      (1 << 4)
#define is_very_safe_closure(p)        has_type1_bit(T_Clo(p), T_SHORT_VERY_SAFE_CLOSURE)
#define set_very_safe_closure(p)       set_type1_bit(T_Clo(p), T_SHORT_VERY_SAFE_CLOSURE)
#define closure_bits(p)                (typeflag(T_Pair(p)) & (T_SAFE_CLOSURE | T_VERY_SAFE_CLOSURE))
#define is_very_safe_closure_body(p)   has_type1_bit(T_Pair(p), T_SHORT_VERY_SAFE_CLOSURE)
#define set_very_safe_closure_body(p)  set_type1_bit(T_Pair(p), T_SHORT_VERY_SAFE_CLOSURE)

#define T_CYCLIC                       (1LL << (TYPE_BITS + BIT_ROOM + 29))
#define T_SHORT_CYCLIC                 (1 << 5)
#define is_cyclic(p)                   has_type1_bit(T_Seq(p), T_SHORT_CYCLIC)
#define set_cyclic(p)                  set_type1_bit(T_Seq(p), T_SHORT_CYCLIC)

#define T_CYCLIC_SET                   (1LL << (TYPE_BITS + BIT_ROOM + 30))
#define T_SHORT_CYCLIC_SET             (1 << 6)
#define is_cyclic_set(p)               has_type1_bit(T_Pos(p), T_SHORT_CYCLIC_SET)
#define set_cyclic_set(p)              set_type1_bit(T_Seq(p), T_SHORT_CYCLIC_SET)
#define clear_cyclic_bits(p)           clear_type_bit(p, T_COLLECTED | T_SHARED | T_CYCLIC | T_CYCLIC_SET)

#define T_KEYWORD                      (1LL << (TYPE_BITS + BIT_ROOM + 31))
#define T_SHORT_KEYWORD                (1 << 7)
#define is_keyword(p)                  has_type1_bit(T_Pos(p), T_SHORT_KEYWORD)
/* this bit distinguishes a symbol from a symbol that is also a keyword */

#define T_FULL_SIMPLE_ELEMENTS         (1LL << (TYPE_BITS + BIT_ROOM + 32))
#define T_SIMPLE_ELEMENTS              (1 << 8)
#define has_simple_elements(p)         has_type1_bit(T_Nvc(p), T_SIMPLE_ELEMENTS)
#define set_has_simple_elements(p)     set_type1_bit(T_Nvc(p), T_SIMPLE_ELEMENTS)
#define c_function_has_simple_elements(p)     has_type1_bit(T_Fnc(p), T_SIMPLE_ELEMENTS)
#define c_function_set_has_simple_elements(p) set_type1_bit(T_Fnc(p), T_SIMPLE_ELEMENTS)

#define T_SIMPLE_KEYS                  T_SIMPLE_ELEMENTS
#define has_simple_keys(p)             has_type1_bit(T_Hsh(p), T_SIMPLE_KEYS)
#define set_has_simple_keys(p)         set_type1_bit(T_Hsh(p), T_SIMPLE_KEYS)

#define T_CTR3_SET                     T_SIMPLE_ELEMENTS
#define ctr3_is_set(p)                 has_type1_bit(T_Pair(p), T_CTR3_SET)
#define set_ctr3_is_set(p)             do {set_type1_bit(T_Pair(p), T_CTR3_SET); clear_type_bit(p, T_LINE_NUMBER);} while (0)

#define T_FULL_CASE_KEY                (1LL << (TYPE_BITS + BIT_ROOM + 33))
#define T_CASE_KEY                     (1 << 9)
#define is_case_key(p)                 has_type1_bit(T_Pos(p), T_CASE_KEY)
#define set_case_key(p)                set_type1_bit(T_Sym(p), T_CASE_KEY)

#define UNUSED_BITS                    0x3c00000000000000

#define T_GC_MARK                      0x8000000000000000
#define is_marked(p)                   has_type_bit(p, T_GC_MARK)
#define set_mark(p)                    set_type_bit(T_Pos(p), T_GC_MARK)
#define clear_mark(p)                  clear_type_bit(p, T_GC_MARK)
/* using the sign bit, bit 23 (or 55) == 31 (or 63) for this makes a big difference in the GC */

#define T_UNHEAP                       0x4000000000000000
#define T_SHORT_UNHEAP                 (1 << 14)
#define not_in_heap(p)                 has_type1_bit(T_Pos(p), T_SHORT_UNHEAP)
#define in_heap(p)                     (((T_Pos(p))->tf.opts.high_flag & T_SHORT_UNHEAP) == 0)
#define unheap(sc, p)                  set_type1_bit(T_Pos(p), T_SHORT_UNHEAP)

#define is_eof(p)                      ((T_Pos(p)) == eof_object)
#define is_undefined(p)                (type(p) == T_UNDEFINED)
#define is_true(Sc, p)                 ((T_Pos(p)) != Sc->F)
#define is_false(Sc, p)                ((T_Pos(p)) == Sc->F)

#ifdef _MSC_VER
  static s7_pointer make_boolean(s7_scheme *sc, bool val) {if (val) return(sc->T); return(sc->F);}
#else
  #define make_boolean(sc, Val)        ((Val) ? sc->T : sc->F)
#endif

#define is_pair(p)                     (type(p) == T_PAIR)
#define is_mutable_pair(p)             ((typeflag(T_Pos(p)) & (TYPE_MASK | T_IMMUTABLE)) == T_PAIR)
#define is_null(p)                     ((T_Pos(p)) == sc->nil)
#define is_not_null(p)                 ((T_Pos(p)) != sc->nil)
#define is_list(p)                     ((is_pair(p)) || (type(p) == T_NIL))
#define is_quoted_pair(p)              ((is_pair(p)) && (car(p) == sc->quote_symbol))
#define is_unquoted_pair(p)            ((is_pair(p)) && (car(p) != sc->quote_symbol))

#define raw_opt1(p)                    ((p)->object.cons.opt1)

#if (!S7_DEBUGGING)
#define opt1(p, r)                     ((p)->object.cons.opt1)
#define set_opt1(p, x, r)              (p)->object.cons.opt1 = x
#define opt2(p, r)                     ((p)->object.cons.opt2)
#define set_opt2(p, x, r)              (p)->object.cons.opt2 = (s7_pointer)(x)
#define opt3(p, r)                     ((p)->object.cons.opt3)
#define set_opt3(p, x, r)              do {(p)->object.cons.opt3 = x; clear_type_bit(p, T_LINE_NUMBER);} while (0)
/* 29-Oct-18 this used to clear T_OPTIMIZED -- optimize_op was sharing opt3 with line info */

#define pair_line(p)                   (p)->object.sym_cons.line
#define pair_set_line(p, X)            (p)->object.sym_cons.line = X
#define pair_file(p)                   (p)->object.sym_cons.file
#define pair_set_file(p, X)            (p)->object.sym_cons.file = X
#define pair_raw_hash(p)               (p)->object.sym_cons.hash
#define pair_set_raw_hash(p, X)        (p)->object.sym_cons.hash = X
#define pair_raw_len(p)                (p)->object.sym_cons.line
#define pair_set_raw_len(p, X)         (p)->object.sym_cons.line = X
#define pair_raw_name(p)               (p)->object.sym_cons.fstr
#define pair_set_raw_name(p, X)        (p)->object.sym_cons.fstr = X
/* opt1 == raw_hash, opt2 == raw_name, opt3 == line|ctr + len, but hash/name/len only apply to the symbol table so there's no collision */

#else

#define S_NAME                         (1 << 25)
#define S_HASH                         (1 << 26)
#define S_LINE                         (1 << 27)
#define S_LEN                          (1 << 28)

/* these 3 fields (or 8 counting sym_cons) hold most of the varigated optimizer info, so they are used in many conflicting ways.
 * the bits and funcs here try to track each such use, and report any cross-talk or collisions.
 * all of this machinery vanishes if debugging is turned off.
 */
#define E_SET                          (1 << 0)
#define E_FAST                         (1 << 7)   /* fast list in member/assoc circular list check */
#define E_CFUNC                        (1 << 8)   /* c-function */
#define E_CLAUSE                       (1 << 9)   /* case clause */
#define E_LAMBDA                       (1 << 11)  /* lambda(*) */
#define E_SYM                          (1 << 12)  /* symbol */
#define E_PAIR                         (1 << 13)  /* pair */
#define E_CON                          (1 << 14)  /* constant from eval's point of view */
#define E_GOTO                         (1 << 15)  /* call-with-exit exit func */
#define E_ANY                          (1 << 16)  /* anything -- deliberate unchecked case */
#define E_SLOT                         (1 << 17)  /* slot */
#define E_MASK                         (E_FAST | E_CFUNC | E_CLAUSE | E_LAMBDA | E_SYM | E_PAIR | E_CON | E_GOTO | E_ANY | E_SLOT | S_HASH)

#define opt1_is_set(p)                 (((p)->debugger_bits & E_SET) != 0)
#define set_opt1_is_set(p)             (p)->debugger_bits |= E_SET
#define opt1_role_matches(p, Role)     (((p)->debugger_bits & E_MASK) == Role)
#define set_opt1_role(p, Role)         (p)->debugger_bits = (Role | ((p)->debugger_bits & ~E_MASK))
#define opt1(p, Role)                  opt1_1(T_Pair(p), Role, __func__, __LINE__)
#define set_opt1(p, x, Role)           set_opt1_1(T_Pair(p), x, Role, __func__, __LINE__)

#define F_SET                          (1 << 1)
#define F_KEY                          (1 << 18)  /* case key */
#define F_SLOW                         (1 << 19)  /* slow list in member/assoc circular list check */
#define F_SYM                          (1 << 20)  /* symbol */
#define F_PAIR                         (1 << 21)  /* pair */
#define F_CON                          (1 << 22)  /* constant as above */
#define F_CALL                         (1 << 23)  /* c-func */
#define F_LAMBDA                       (1 << 24)  /* lambda form */
#define F_MASK                         (F_KEY | F_SLOW | F_SYM | F_PAIR | F_CON | F_CALL | F_LAMBDA | S_NAME)

#define opt2_is_set(p)                 (((p)->debugger_bits & F_SET) != 0)
#define set_opt2_is_set(p)             (p)->debugger_bits |= F_SET
#define opt2_role_matches(p, Role)     (((p)->debugger_bits & F_MASK) == Role)
#define set_opt2_role(p, Role)         (p)->debugger_bits = (Role | ((p)->debugger_bits & ~F_MASK))
#define opt2(p, Role)                  opt2_1(sc, T_Pair(p), Role, __func__, __LINE__)
#define set_opt2(p, x, Role)           set_opt2_1(sc, T_Pair(p), (s7_pointer)(x), Role, __func__, __LINE__)

#define G_SET                          (1 << 2)
#define G_ARGLEN                       (1 << 3)  /* arglist length */
#define G_SYM                          (1 << 4)  /* expression symbol access */
#define G_AND                          (1 << 5)  /* and second clause */
#define G_DIRECT                       (1 << 6)  /* direct call info */
#define G_ANY                          (1 << 29)
#define G_CTR                          (1 << 30)
#define G_CON                          0x80000000 /* not (1LL < 31) ! */
#define G_MASK                         (G_ARGLEN | G_SYM | G_AND | G_ANY | G_CTR | G_CON | S_LINE | S_LEN | G_DIRECT)

#define opt3_is_set(p)                 (((p)->debugger_bits & G_SET) != 0)
#define set_opt3_is_set(p)             (p)->debugger_bits |= G_SET
#define opt3_role_matches(p, Role)     (((p)->debugger_bits & G_MASK) == Role)
#define set_opt3_role(p, Role)         (p)->debugger_bits = (Role | ((p)->debugger_bits & ~G_MASK))
#define opt3(p, Role)                  opt3_1(T_Pair(p), Role, __func__, __LINE__)
#define set_opt3(p, x, Role)           set_opt3_1(T_Pair(p), x, Role, __func__, __LINE__)

#define pair_line(p)                   s_line_1(T_Pair(p), __func__, __LINE__)
#define pair_set_line(p, X)            set_s_line_1(T_Pair(p), X, __func__, __LINE__)
#define pair_file(p)                   (T_Pair(p))->object.sym_cons.file
#define pair_set_file(p, X)            set_s_file_1(sc, T_Pair(p), X, __func__, __LINE__)
#define pair_raw_hash(p)               s_hash_1(T_Pair(p), __func__, __LINE__)
#define pair_set_raw_hash(p, X)        set_s_hash_1(T_Pair(p), X, __func__, __LINE__)
#define pair_raw_len(p)                s_len_1(T_Pair(p), __func__, __LINE__)
#define pair_set_raw_len(p, X)         set_s_len_1(T_Pair(p), X, __func__, __LINE__)
#define pair_raw_name(p)               s_name_1(T_Pair(p), __func__, __LINE__)
#define pair_set_raw_name(p, X)        set_s_name_1(T_Pair(p), X, __func__, __LINE__)

#define L_HIT                          (1LL < 40) /* "L_SET" is taken */
#define L_FUNC                         (1LL < 41)
#define L_DOX                          (1LL < 42)
#define L_CATCH                        (1LL < 43)
#define L_MASK                         (L_FUNC | L_DOX | L_CATCH)
#endif

#define opt1_fast(P)                   T_Lst(opt1(P,                E_FAST))
#define set_opt1_fast(P, X)            set_opt1(P, T_Pair(X),       E_FAST)
#define opt1_cfunc(P)                  T_Pos(opt1(P,                E_CFUNC))
#define set_opt1_cfunc(P, X)           set_opt1(P, T_Pos(X),        E_CFUNC)
#define opt1_lambda_unchecked(P)       opt1(P,                      E_LAMBDA) /* can be free/null? from s7_call? */
#define opt1_lambda(P)                 T_Clo(opt1(P,                E_LAMBDA))
#define set_opt1_lambda(P, X)          set_opt1(P, T_Pos(X),        E_LAMBDA)
#define opt1_goto(P)                   T_Pos(opt1(P,                E_GOTO))  /* used when checking for non-goto unknown in eval, so can't be T_Got */
#define set_opt1_goto(P, X)            set_opt1(P, T_Pos(X),        E_GOTO)
#define opt1_clause(P)                 T_Pos(opt1(P,                E_CLAUSE))
#define set_opt1_clause(P, X)          set_opt1(P, T_Pos(X),        E_CLAUSE)
#define opt1_sym(P)                    T_Sym(opt1(P,                E_SYM))
#define set_opt1_sym(P, X)             set_opt1(P, T_Sym(X),        E_SYM)
#define opt1_pair(P)                   T_Lst(opt1(P,                E_PAIR))
#define set_opt1_pair(P, X)            set_opt1(P, T_Lst(X),        E_PAIR)
#define opt1_con(P)                    T_Pos(opt1(P,                E_CON))
#define set_opt1_con(P, X)             set_opt1(P, T_Pos(X),        E_CON)
#define opt1_any(P)                    opt1(P,                      E_ANY)    /* can be free in closure_is_ok */
#define set_opt1_any(P, X)             set_opt1(P, X,               E_ANY)
#define opt1_slot(P)                   T_Slt(opt1(P,                E_SLOT))
#define set_opt1_slot(P, X)            set_opt1(P, T_Slt(X),        E_SLOT)

#define opt2_any(P)                    opt2(P,                      F_KEY)
#define set_opt2_any(P, X)             set_opt2(P, X,               F_KEY)
#define opt2_slow(P)                   T_Lst(opt2(P,                F_SLOW))
#define set_opt2_slow(P, X)            set_opt2(P, T_Pair(X),       F_SLOW)
#define opt2_sym(P)                    T_Sym(opt2(P,                F_SYM))
#define set_opt2_sym(P, X)             set_opt2(P, T_Sym(X),        F_SYM)
#define opt2_pair(P)                   T_Lst(opt2(P,                F_PAIR))
#define set_opt2_pair(P, X)            set_opt2(P, T_Lst(X),        F_PAIR)
#define opt2_con(P)                    T_Pos(opt2(P,                F_CON))
#define set_opt2_con(P, X)             set_opt2(P, T_Pos(X),        F_CON)
#define opt2_lambda(P)                 T_Pair(opt2(P,               F_LAMBDA))
#define set_opt2_lambda(P, X)          set_opt2(P, T_Pair(X),       F_LAMBDA)
#define opt2_direct_x_call(P)          opt2(P,                      F_LAMBDA)
#define set_opt2_direct_x_call(P, X)   set_opt2(P, (s7_pointer)(X), F_LAMBDA)

#define opt3_arglen(P)                 T_Int(opt3(cdr(P),           G_ARGLEN))
#define set_opt3_arglen(P, X)          set_opt3(cdr(P), T_Int(X),   G_ARGLEN)
#define opt3_sym(P)                    T_Sym(opt3(P,                G_SYM))
#define set_opt3_sym(P, X)             set_opt3(P, T_Sym(X),        G_SYM)
#define opt3_pair(P)                   T_Pair(opt3(P,               G_AND))
#define set_opt3_pair(P, X)            set_opt3(P, T_Pair(X),       G_AND)
#define opt3_any(P)                    opt3(P,                      G_ANY)
#define set_opt3_any(P, X)             set_opt3(P, X,               G_ANY)
#define opt3_direct_x(P)               opt3(P,                      G_DIRECT)
#define set_opt3_direct_x(P, X)        set_opt3(P, (s7_pointer)(X), G_DIRECT)

#if S7_DEBUGGING
#define opt3_con(p)                    opt3_con_1(T_Pair(p),           G_CON, __func__, __LINE__)
#define set_opt3_con(p, x)             set_opt3_con_1(T_Pair(p), x,    G_CON, __func__, __LINE__)
#define opt3_ctr(p)                    opt3_ctr_1(T_Pair(p),           G_CTR, __func__, __LINE__)
#define set_opt3_ctr(p, x)             set_opt3_ctr_1(T_Pair(p), x,    G_CTR, __func__, __LINE__)
#define increment_opt3_ctr(p)          increment_opt3_ctr_1(T_Pair(p), G_CTR, __func__, __LINE__)
#else
#define opt3_con(P)                    T_Pair(P)->object.cons_ext.ce.opt_type /* op_if_is_type */
#define set_opt3_con(P, X)             do {T_Pair(P)->object.cons_ext.ce.opt_type = X; clear_type_bit(P, T_LINE_NUMBER);} while (0)
#define opt3_ctr(P)                    T_Pair(P)->object.cons_ext.ce.ctr
#define set_opt3_ctr(P, X)             do {T_Pair(P)->object.cons_ext.ce.ctr = X; clear_type_bit(P, T_LINE_NUMBER); set_ctr3_is_set(P);} while(0)
#define increment_opt3_ctr(P)          do {if (ctr3_is_set(P)) P->object.cons_ext.ce.ctr++; else set_opt3_ctr(P, 0);} while (0)
#endif

#define c_callee(f)                    ((s7_function)opt2(f,      F_CALL))
#define c_call(f)                      ((s7_function)opt2(f,      F_CALL))
#define set_c_call_checked(f, _X_)     do {s7_pointer X; X = (s7_pointer)(_X_); set_opt2(f, X, F_CALL); if (X) set_has_fx(f); else clear_has_fx(f);} while (0)
#if S7_DEBUGGING
  #define set_c_call(f, _X_)           do {s7_pointer X; X = (s7_pointer)(_X_); if (!(X)) fprintf(stderr, "%s[%d] x_call null: %s\n", __func__, __LINE__, DISPLAY(f)); set_opt2(f, X, F_CALL); if (X) set_has_fx(f); else clear_has_fx(f);} while (0)
#else
  #define set_c_call(f, X)             do {set_opt2(f, (s7_pointer)(X), F_CALL); set_has_fx(f);} while (0)
#endif
#define set_c_call_direct(f, X)        do {set_opt2(f, (s7_pointer)(X), F_CALL); set_has_fx(f);} while (0)
#define set_c_call_unchecked(f, _X_)   do {s7_pointer X; X = (s7_pointer)(_X_); set_opt2(f, X, F_CALL); if (X) set_has_fx(f); else clear_has_fx(f);} while (0)
#if WITH_GCC
#define fx_call(Sc, F)                 ({s7_pointer _P_; _P_ = F; c_call(_P_)(Sc, car(_P_));})
#define d_call(Sc, F)                  ({s7_pointer _P_; _P_ = F; c_call(_P_)(Sc, cdr(_P_));})
#else
#define fx_call(Sc, F)                 c_call(F)(Sc, car(F))
#define d_call(Sc, F)                  c_call(F)(Sc, cdr(F))
#endif

#define car(p)                         (T_Pair(p))->object.cons.car
#define set_car(p, Val)                (T_Pair(p))->object.cons.car = T_Pos(Val)
#define cdr(p)                         (T_Pair(p))->object.cons.cdr
#define set_cdr(p, Val)                (T_Pair(p))->object.cons.cdr = T_Pos(Val)
#define unchecked_car(p)               (T_Pos(p))->object.cons.car
#define unchecked_cdr(p)               (T_Pos(p))->object.cons.cdr

#define caar(p)                        car(car(p))
#define cadr(p)                        car(cdr(p))
#define set_cadr(p, Val)               (T_Pair(p))->object.cons.cdr->object.cons.car = T_Pos(Val)
#define cdar(p)                        cdr(car(p))
#define set_cdar(p, Val)               (T_Pair(p))->object.cons.car->object.cons.cdr = T_Pos(Val)
#define cddr(p)                        cdr(cdr(p))

#define caaar(p)                       car(car(car(p)))
#define cadar(p)                       car(cdr(car(p)))
#define cdadr(p)                       cdr(car(cdr(p)))
#define caddr(p)                       car(cdr(cdr(p)))
#define set_caddr(p, Val)              (T_Pair(p))->object.cons.cdr->object.cons.cdr->object.cons.car = T_Pos(Val)
#define caadr(p)                       car(car(cdr(p)))
#define cdaar(p)                       cdr(car(car(p)))
#define cdddr(p)                       cdr(cdr(cdr(p)))
#define cddar(p)                       cdr(cdr(car(p)))

#define caaadr(p)                      car(car(car(cdr(p))))
#define caadar(p)                      car(car(cdr(car(p))))
#define cadaar(p)                      car(cdr(car(car(p))))
#define cadddr(p)                      car(cdr(cdr(cdr(p))))
#define caaddr(p)                      car(car(cdr(cdr(p))))
#define cddddr(p)                      cdr(cdr(cdr(cdr(p))))
#define caddar(p)                      car(cdr(cdr(car(p))))
#define cdadar(p)                      cdr(car(cdr(car(p))))
#define cdaddr(p)                      cdr(car(cdr(cdr(p))))
#define caaaar(p)                      car(car(car(car(p))))
#define cadadr(p)                      car(cdr(car(cdr(p))))
#define cdaadr(p)                      cdr(car(car(cdr(p))))
#define cdaaar(p)                      cdr(car(car(car(p))))
#define cdddar(p)                      cdr(cdr(cdr(car(p))))
#define cddadr(p)                      cdr(cdr(car(cdr(p))))
#define cddaar(p)                      cdr(cdr(car(car(p))))

#if WITH_GCC
  /* slightly tricky because cons can be called recursively */
  #define cons(Sc, A, B)   ({s7_pointer _X_, _A_, _B_; _A_ = A; _B_ = B; new_cell(Sc, _X_, T_PAIR | T_SAFE_PROCEDURE); set_car(_X_, _A_); set_cdr(_X_, _B_); _X_;})
#else
  #define cons(Sc, A, B)               s7_cons(Sc, A, B)
#endif

#define list_1(Sc, A)                  cons(Sc, A, Sc->nil)
#define list_2(Sc, A, B)               cons_unchecked(Sc, A, cons(Sc, B, Sc->nil))
#define list_3(Sc, A, B, C)            cons_unchecked(Sc, A, cons_unchecked(Sc, B, cons(Sc, C, Sc->nil)))
#define list_4(Sc, A, B, C, D)         cons_unchecked(Sc, A, cons_unchecked(Sc, B, cons_unchecked(Sc, C, cons(Sc, D, Sc->nil))))

#define is_string(p)                   (type(p) == T_STRING)
#define is_mutable_string(p)           ((typeflag(T_Pos(p)) & (TYPE_MASK | T_IMMUTABLE)) == T_STRING)
#define string_value(p)                (T_Str(p))->object.string.svalue
#define string_length(p)               (T_Str(p))->object.string.length
#define string_hash(p)                 (T_Str(p))->object.string.hash
#define string_block(p)                (T_Str(p))->object.string.block

#define character(p)                   (T_Chr(p))->object.chr.c
#define upper_character(p)             (T_Chr(p))->object.chr.up_c
#define is_char_alphabetic(p)          (T_Chr(p))->object.chr.alpha_c
#define is_char_numeric(p)             (T_Chr(p))->object.chr.digit_c
#define is_char_whitespace(p)          (T_Chr(p))->object.chr.space_c
#define is_char_uppercase(p)           (T_Chr(p))->object.chr.upper_c
#define is_char_lowercase(p)           (T_Chr(p))->object.chr.lower_c
#define character_name(p)              (T_Chr(p))->object.chr.c_name
#define character_name_length(p)       (T_Chr(p))->object.chr.length

#define optimize_op(P)                 (P)->tf.opts.opt_choice
#define set_optimize_op(P, Op)         (P)->tf.opts.opt_choice = Op
#define optimize_op_match(P, Q)        ((is_optimized(P)) && ((optimize_op(P) & 0xfffe) == (Q)))
#define op_no_hop(P)                   (optimize_op(P) & 0xfffe)
#define clear_hop(P)                   set_optimize_op(P, op_no_hop(P))
#define clear_optimize_op(P)           set_optimize_op(P, 0)
#define set_safe_optimize_op(P, Q)     do {set_optimized(P); set_optimize_op(P, Q);} while (0)
#define set_unsafe_optimize_op(P, Q)   do {set_unsafely_optimized(P); set_optimize_op(P, Q);} while (0)

#define is_symbol(p)                   (type(p) == T_SYMBOL)
#define is_normal_symbol(p)            ((is_symbol(p)) && (!is_keyword(p)))
#define is_safe_symbol(p)              ((is_symbol(p)) && (is_slot(symbol_to_slot(sc, p))))
#define symbol_name_cell(p)            T_Str((T_Sym(p))->object.sym.name)
#define symbol_set_name_cell(p, S)     (T_Sym(p))->object.sym.name = T_Str(S)
#define symbol_name(p)                 string_value(symbol_name_cell(p))
#define symbol_name_length(p)          string_length(symbol_name_cell(p))
#define gensym_block(p)                symbol_name_cell(p)->object.string.gensym_block
#define symbol_hmap(p)                 (s7_int)((intptr_t)(p) >> 8)
#define symbol_id(p)                   (T_Sym(p))->object.sym.id
#define symbol_set_id_unchecked(p, X)  (T_Sym(p))->object.sym.id = X
#if S7_DEBUGGING
static void symbol_set_id(s7_pointer p, s7_int id)
{
  if (id < symbol_id(p))
    {
      fprintf(stderr, "id mismatch: sym: %s %" print_s7_int ", let: %" print_s7_int "\n", symbol_name(p), symbol_id(p), id);
      abort();
    }
  (T_Sym(p))->object.sym.id = id;
}
#else
#define symbol_set_id(p, X)            (T_Sym(p))->object.sym.id = X
#endif
/* we need 64-bits here, since we don't want this thing to wrap around, and frames are created at a great rate
 *    callgrind says this is faster than an uint32_t!
 */
#define symbol_info(p)                 (symbol_name_cell(p))->object.string.block
#define symbol_type(p)                 block_size(symbol_info(p))
#define symbol_set_type(p, Type)       block_set_size(symbol_info(p), Type)
#define initial_slot(p)                symbol_info(p)->ex.ex_ptr
#define set_initial_slot(p, Val)       symbol_info(p)->ex.ex_ptr = T_Sld(Val)

#define global_slot(p)                 (T_Sym(p))->object.sym.global_slot
#define set_global_slot(p, Val)        (T_Sym(p))->object.sym.global_slot = T_Sld(Val)
#define local_slot(p)                  (T_Sym(p))->object.sym.local_slot
#define set_local_slot(p, Val)         (T_Sym(p))->object.sym.local_slot = T_Sln(Val)
#define keyword_symbol(p)              symbol_info(p)->nx.ksym               /* keyword only, so does not collide with documentation */
#define keyword_set_symbol(p, Val)     symbol_info(p)->nx.ksym = T_Sym(Val)
#define symbol_help(p)                 symbol_info(p)->nx.documentation
#define symbol_set_help(p, Doc)        symbol_info(p)->nx.documentation = Doc
#define symbol_tag(p)                  (T_Sym(p))->object.sym.tag
#define symbol_set_tag(p, Val)         (T_Sym(p))->object.sym.tag = Val
#define symbol_ctr(p)                  (T_Sym(p))->object.sym.ctr
#define symbol_set_ctr(p, Val)         (T_Sym(p))->object.sym.ctr = Val
#define symbol_increment_ctr(p)        (T_Sym(p))->object.sym.ctr++
#define symbol_tag2(p)                 symbol_info(p)->ln.tag
#define symbol_set_tag2(p, Val)        symbol_info(p)->ln.tag = Val
#define symbol_has_help(p)             (is_documented(symbol_name_cell(p)))
#define symbol_set_has_help(p)         set_documented(symbol_name_cell(p))

#define symbol_set_local_unchecked(Symbol, Id, Slot) do {set_local_slot(Symbol, Slot); symbol_set_id_unchecked(Symbol, Id); symbol_increment_ctr(Symbol);} while (0)
#define symbol_set_local(Symbol, Id, Slot) do {set_local_slot(Symbol, Slot); symbol_set_id(Symbol, Id); symbol_increment_ctr(Symbol);} while (0)
/* set slot before id in case Slot is an expression that tries to find the current Symbol slot (using its old Id obviously) */

#define is_slot(p)                     (type(p) == T_SLOT)
#define slot_symbol(p)                 T_Sym((T_Slt(p))->object.slt.sym)
#define slot_set_symbol(p, Sym)        (T_Slt(p))->object.slt.sym = T_Sym(Sym)
#define slot_value(p)                  T_Pos((T_Slt(p))->object.slt.val)
#define unchecked_slot_value(p)        p->object.slt.val
#define slot_set_value(p, Val)         (T_Slt(p))->object.slt.val = T_Pos(Val)
#define slot_set_value_with_hook(Slot, Value) \
  do {if (hook_has_functions(sc->rootlet_redefinition_hook)) slot_set_value_with_hook_1(sc, Slot, Value); else slot_set_value(Slot, Value);} while (0)
#define next_slot(p)                   (T_Slt(p))->object.slt.nxt
#define set_next_slot(p, Val)          (T_Slt(p))->object.slt.nxt = T_Sln(Val)
#define slot_set_pending_value(p, Val) do {(T_Slt(p))->object.slt.pending_value = T_Pos(Val); slot_set_has_pending_value(p);} while (0)
#if S7_DEBUGGING
static s7_pointer slot_pending_value(s7_pointer p) {if (slot_has_pending_value(p)) return(p->object.slt.pending_value); fprintf(stderr, "slot: no pending value\n"); abort();}
static s7_pointer slot_expression(s7_pointer p)    {if (slot_has_expression(p)) return(p->object.slt.expr); fprintf(stderr, "slot: no expression\n"); abort();}
#else
#define slot_pending_value(p)          (T_Slt(p))->object.slt.pending_value
#define slot_expression(p)             (T_Slt(p))->object.slt.expr
#endif
#define slot_set_expression(p, Val)    do {(T_Slt(p))->object.slt.expr = T_Pos(Val); slot_set_has_expression(p);} while (0)
#define slot_just_set_expression(p, Val) (T_Slt(p))->object.slt.expr = T_Pos(Val)
#define slot_setter(p)                 (T_Slt(p))->object.slt.expr
#define slot_set_setter_1(p, Val)      (T_Slt(p))->object.slt.expr = T_Prc(Val)
#define tis_slot(p) (p)
#define slot_end(sc) NULL
#define is_slot_end(p) (!(p))

#define is_syntax(p)                   (type(p) == T_SYNTAX)
#define syntax_symbol(p)               T_Sym((T_Syn(p))->object.syn.symbol)
#define syntax_set_symbol(p, Sym)      (T_Syn(p))->object.syn.symbol = T_Sym(Sym)
#define syntax_opcode(p)               (T_Syn(p))->object.syn.op
#define syntax_min_args(p)             (T_Syn(p))->object.syn.min_args
#define syntax_max_args(p)             (T_Syn(p))->object.syn.max_args
#define syntax_documentation(p)        (T_Syn(p))->object.syn.documentation

#define set_syntactic_pair(p)          typeflag(T_Pair(p)) = (T_PAIR | T_SYNTACTIC | (typeflag(p) & (0xffffffffffff0000 & ~T_OPTIMIZED)))
#define pair_set_syntax_op(p, X)       do {set_optimize_op(p, X); set_syntactic_pair(p);} while (0)
#define symbol_syntax_op_checked(p)    ((is_syntactic_pair(p)) ? optimize_op(p) : symbol_syntax_op(car(p)))
#define symbol_syntax_op(p)            syntax_opcode(slot_value(global_slot(p)))

#define ROOTLET_SIZE                   512
#define let_id(p)                      (T_Lid(p))->object.envr.id
#define is_let(p)                      (type(p) == T_LET)
#define let_slots(p)                   (T_Let(p))->object.envr.slots
#define let_set_slots(p, Slot)         (T_Let(p))->object.envr.slots = T_Sln(Slot)
#define outlet(p)                      (T_Let(p))->object.envr.nxt
#define set_outlet(p, ol)              (T_Let(p))->object.envr.nxt = T_Lid(ol)
#if S7_DEBUGGING
#define C_Let(p, role)                 check_let_ref(p, role, __func__, __LINE__)
#define S_Let(p, role)                 check_let_set(p, role, __func__, __LINE__)
#else
#define C_Let(p, role)                 p
#define S_Let(p, role)                 p
#endif
#define funclet_function(p)            T_Sym((C_Let(p, L_FUNC))->object.envr.edat.efnc.function)
#define funclet_set_function(p, F)     (S_Let(p, L_FUNC))->object.envr.edat.efnc.function = T_Sym(F)
#define let_line(p)                    (C_Let(p, L_FUNC))->object.envr.edat.efnc.line
#define let_set_line(p, L)             (S_Let(p, L_FUNC))->object.envr.edat.efnc.line = L
#define let_file(p)                    (C_Let(p, L_FUNC))->object.envr.edat.efnc.file
#define let_set_file(p, F)             (S_Let(p, L_FUNC))->object.envr.edat.efnc.file = F
#define dox_slot1(p)                   T_Slt((C_Let(p, L_DOX))->object.envr.edat.dox.dox1)
#define dox_set_slot1(p, S)            (S_Let(p, L_DOX))->object.envr.edat.dox.dox1 = T_Slt(S)
#define dox_slot2(p)                   T_Slt((C_Let(p, L_DOX))->object.envr.edat.dox.dox2)
#define dox_set_slot2(p, S)            (S_Let(p, L_DOX))->object.envr.edat.dox.dox2 = T_Slt(S)
#define dox_slot2_unchecked(p)         C_Let(p, L_DOX)->object.envr.edat.dox.dox2
#define dox_set_slot2_unchecked(p, S)  S_Let(p, L_DOX)->object.envr.edat.dox.dox2 = (S)

#define unique_name(p)                 (p)->object.unq.nm.name
#define unique_name_length(p)          (p)->object.unq.len
#define unknown_name(p)                (p)->object.unq.nm.unknown_name
#define is_unspecified(p)              (type(p) == T_UNSPECIFIED)
#define unique_car(p)                  (p)->object.unq.car
#define unique_cdr(p)                  (p)->object.unq.cdr

#define is_any_vector(p)               t_vector_p[type(p)]
#define is_normal_vector(p)            (type(p) == T_VECTOR)
#define vector_length(p)               (p)->object.vector.length
#define unchecked_vector_elements(p)   (p)->object.vector.elements.objects
#define unchecked_vector_element(p, i) ((p)->object.vector.elements.objects[i])
#define vector_element(p, i)           ((T_Vec(p))->object.vector.elements.objects[i])
#define vector_elements(p)             (T_Vec(p))->object.vector.elements.objects
#define vector_getter(p)               (T_Vec(p))->object.vector.vget
#define vector_setter(p)               (T_Vec(p))->object.vector.setv.vset
#define typed_vector_typer(p)          (T_Vec(p))->object.vector.setv.fset
#define vector_block(p)                (T_Vec(p))->object.vector.block
#define unchecked_vector_block(p)      p->object.vector.block

#define is_int_vector(p)               (type(p) == T_INT_VECTOR)
#define int_vector(p, i)               ((T_Ivc(p))->object.vector.elements.ints[i])
#define int_vector_ints(p)             (T_Ivc(p))->object.vector.elements.ints

#define is_float_vector(p)             (type(p) == T_FLOAT_VECTOR)
#define float_vector(p, i)             ((T_Fvc(p))->object.vector.elements.floats[i])
#define float_vector_floats(p)         (T_Fvc(p))->object.vector.elements.floats

#define is_byte_vector(p)              (type(p) == T_BYTE_VECTOR)
#define byte_vector_length(p)          (T_BVc(p))->object.vector.length
#define byte_vector_bytes(p)           (T_BVc(p))->object.vector.elements.bytes
#define byte_vector(p, i)              ((T_BVc(p))->object.vector.elements.bytes[i])
#define is_string_or_byte_vector(p)    ((type(p) == T_STRING) || (type(p) == T_BYTE_VECTOR))

#define vector_dimension_info(p)       ((vdims_t *)(T_Vec(p))->object.vector.block->ex.ex_info)
#define vector_set_dimension_info(p, d) (T_Vec(p))->object.vector.block->ex.ex_info = (void  *)d
#define vector_ndims(p)                vdims_rank(vector_dimension_info(p))
#define vector_dimension(p, i)         vdims_dims(vector_dimension_info(p))[i]
#define vector_dimensions(p)           vdims_dims(vector_dimension_info(p))
#define vector_offset(p, i)            vdims_offsets(vector_dimension_info(p))[i]
#define vector_offsets(p)              vdims_offsets(vector_dimension_info(p))
#define vector_rank(p)                 ((vector_dimension_info(p)) ? vector_ndims(p) : 1)
#define vector_has_dimensional_info(p) (vector_dimension_info(p))

#define subvector_vector(p)            T_Vec(((vector_dimension_info(T_SVec(p))) ? vdims_original(vector_dimension_info(p)) : (p)->object.vector.block->nx.ksym))
#define subvector_set_vector(p, vect)  (T_SVec(p))->object.vector.block->nx.ksym = T_Vec(vect)

#define rootlet_element(p, i)          unchecked_vector_element(p, i)
#define rootlet_elements(p)            unchecked_vector_elements(p)
#define rootlet_block(p)               unchecked_vector_block(p)
#define stack_element(p, i)            unchecked_vector_element(T_Stk(p), i)
#define stack_elements(p)              unchecked_vector_elements(T_Stk(p))
#define stack_block(p)                 unchecked_vector_block(T_Stk(p))

#define is_hash_table(p)               (type(p) == T_HASH_TABLE)
#define is_mutable_hash_table(p)       ((typeflag(T_Pos(p)) & (TYPE_MASK | T_IMMUTABLE)) == T_HASH_TABLE)
#define hash_table_mask(p)             (T_Hsh(p))->object.hasher.mask
#define hash_table_block(p)            (T_Hsh(p))->object.hasher.block
#define hash_table_set_block(p, b)     (T_Hsh(p))->object.hasher.block = b
#define hash_table_element(p, i)       (T_Hsh(p))->object.hasher.elements[i]
#define hash_table_elements(p)         (T_Hsh(p))->object.hasher.elements /* block data (dx) */
#define hash_table_entries(p)          hash_table_block(p)->nx.nx_int
#define hash_table_checker(p)          (T_Hsh(p))->object.hasher.hash_func
#define hash_table_mapper(p)           (T_Hsh(p))->object.hasher.loc
#define hash_table_checker_locked(p)   (hash_table_mapper(p) != default_hash_map)
#define hash_table_procedures(p)       T_Lst(hash_table_block(p)->ex.ex_ptr)
#define hash_table_set_procedures(p, Lst)  hash_table_block(p)->ex.ex_ptr = T_Lst(Lst)
#define hash_table_procedures_checker(p)   car(hash_table_procedures(p))
#define hash_table_procedures_mapper(p)    cdr(hash_table_procedures(p))
#define hash_table_key_typer(p)            opt1_any(hash_table_procedures(p))
#define hash_table_set_key_typer(p, Fnc)   set_opt1_any(p, Fnc)
#define hash_table_value_typer(p)          opt2_any(hash_table_procedures(p))
#define hash_table_set_value_typer(p, Fnc) set_opt2_any(p, Fnc)
#define weak_hash_iters(p)                 hash_table_block(p)->ln.tag

#if S7_DEBUGGING
#define T_Itr_Pos(p)                   titr_pos(sc, T_Itr(p), __func__, __LINE__)
#define T_Itr_Len(p)                   titr_len(T_Itr(p), __func__, __LINE__)
#define T_Itr_Hash(p)                  titr_hash(T_Itr(p), __func__, __LINE__)
#define T_Itr_Let(p)                   titr_let(T_Itr(p), __func__, __LINE__)
#define T_Itr_Pair(p)                  titr_pair(T_Itr(p), __func__, __LINE__)
#else
#define T_Itr_Pos(p)                   p
#define T_Itr_Len(p)                   p
#define T_Itr_Hash(p)                  p
#define T_Itr_Let(p)                   p
#define T_Itr_Pair(p)                  p
#endif

#define is_iterator(p)                 (type(p) == T_ITERATOR)
#define iterator_sequence(p)           (T_Itr(p))->object.iter.obj
#define iterator_position(p)           (T_Itr_Pos(p))->object.iter.lc.loc
#define iterator_length(p)             (T_Itr_Len(p))->object.iter.lw.len
#define iterator_next(p)               (T_Itr(p))->object.iter.next
#define iterator_is_at_end(p)          ((typeflag(T_Itr(p)) & T_ITER_OK) == 0)
#define iterator_slow(p)               T_Lst((T_Itr_Pair(p))->object.iter.lw.slow)
#define iterator_set_slow(p, Val)      (T_Itr_Pair(p))->object.iter.lw.slow = T_Lst(Val)
#define iterator_hash_current(p)       (T_Itr_Hash(p))->object.iter.lw.hcur
#define iterator_current(p)            (T_Itr(p))->object.iter.cur
#define iterator_current_slot(p)       T_Sln((T_Itr_Let(p))->object.iter.lc.lcur)
#define iterator_set_current_slot(p, Val) (T_Itr_Let(p))->object.iter.lc.lcur = T_Sln(Val)
#define iterator_let_cons(p)           (T_Itr_Let(p))->object.iter.cur

#define ITERATOR_END                   eof_object
#define ITERATOR_END_NAME              "#<eof>"

#define is_input_port(p)               (type(p) == T_INPUT_PORT)
#define is_output_port(p)              (type(p) == T_OUTPUT_PORT)
#define port_port(p)                   (T_Prt(p))->object.prt.port
#define is_string_port(p)              (port_type(p) == STRING_PORT)
#define is_file_port(p)                (port_type(p) == FILE_PORT)
#define is_function_port(p)            (port_type(p) == FUNCTION_PORT)
#define port_filename_block(p)         port_port(p)->filename_block
#define port_filename(p)               port_port(p)->filename
#define port_filename_length(p)        port_port(p)->filename_length
#define port_file(p)                   port_port(p)->file
#define port_data_block(p)             port_port(p)->block
#define port_line_number(p)            port_port(p)->line_number
#define port_file_number(p)            port_port(p)->file_number
#define port_data(p)                   (T_Prt(p))->object.prt.data
#define port_data_size(p)              (T_Prt(p))->object.prt.size
#define port_position(p)               (T_Prt(p))->object.prt.point
#define port_block(p)                  (T_Prt(p))->object.prt.block
#define port_type(p)                   port_port(p)->ptype
#define port_is_closed(p)              port_port(p)->is_closed
#define port_set_closed(p, Val)        port_port(p)->is_closed = Val /* this can't be a type bit because sweep checks it after the type has been cleared */
#define port_needs_free(p)             port_port(p)->needs_free
#define port_next(p)                   port_block(p)->nx.next
#define port_output_function(p)        port_port(p)->output_function /* these two are for function ports */
#define port_input_function(p)         port_port(p)->input_function
#define port_original_input_string(p)  port_port(p)->orig_str
#define port_read_character(p)         port_port(p)->read_character
#define port_read_line(p)              port_port(p)->read_line
#define port_display(p)                port_port(p)->display
#define port_write_character(p)        port_port(p)->write_character
#define port_write_string(p)           port_port(p)->write_string
#define port_read_semicolon(p)         port_port(p)->read_semicolon
#define port_read_white_space(p)       port_port(p)->read_white_space
#define port_read_name(p)              port_port(p)->read_name
#define port_read_sharp(p)             port_port(p)->read_sharp
#define port_gc_loc(p)                 port_port(p)->gc_loc
#define port_needs_unprotect(p)        port_port(p)->needs_unprotect

#define is_c_function(f)               (type(f) >= T_C_FUNCTION)
#define is_c_function_star(f)          (type(f) == T_C_FUNCTION_STAR)
#define is_any_c_function(f)           (type(f) >= T_C_FUNCTION_STAR)
#define c_function_data(f)             (T_Fnc(f))->object.fnc.c_proc
#define c_function_call(f)             (T_Fnc(f))->object.fnc.ff
#define c_function_required_args(f)    (T_Fnc(f))->object.fnc.required_args
#define c_function_optional_args(f)    (T_Fnc(f))->object.fnc.optional_args
#define c_function_all_args(f)         (T_Fnc(f))->object.fnc.all_args
#define c_function_name(f)             c_function_data(f)->name
#define c_function_name_length(f)      c_function_data(f)->name_length
#define c_function_documentation(f)    c_function_data(f)->doc
#define c_function_signature(f)        c_function_data(f)->signature
#define c_function_setter(f)           T_Prc(c_function_data(f)->setter)
#define c_function_set_setter(f, Val)  c_function_data(f)->setter = T_Prc(Val)
#define c_function_block(f)            (f)->object.fnc.c_proc->block /* no type checking here */
#define c_function_class(f)            c_function_data(f)->id
#define c_function_chooser(f)          c_function_data(f)->chooser
#define c_function_base(f)             T_App(c_function_data(f)->generic_ff)
#define c_function_set_base(f, Val)    c_function_data(f)->generic_ff = T_App(Val)
#define c_function_marker(f)           c_function_data(f)->cam.marker
#define c_function_set_marker(f, Val)  c_function_data(f)->cam.marker = Val
#define c_function_symbol(f)           c_function_data(f)->sam.c_sym

#define c_function_bool_setter(f)      c_function_data(f)->dam.bool_setter
#define c_function_set_bool_setter(f, Val) c_function_data(f)->dam.bool_setter = Val
#define c_function_arg_defaults(f)     c_function_data(T_Fst(f))->dam.arg_defaults
#define c_function_call_args(f)        c_function_data(T_Fst(f))->cam.call_args
#define c_function_arg_names(f)        c_function_data(T_Fst(f))->sam.arg_names

#define set_c_function(X, f)           do {set_opt1_cfunc(X, f); set_c_call_direct(X, c_function_call(f));} while (0)
#define c_function_opt_data(f)         c_function_data(f)->opt_data

#define is_c_macro(p)                  (type(p) == T_C_MACRO)
#define c_macro_data(f)                (T_Mac(f))->object.fnc.c_proc
#define c_macro_call(f)                (T_Mac(f))->object.fnc.ff
#define c_macro_name(f)                c_macro_data(f)->name
#define c_macro_name_length(f)         c_macro_data(f)->name_length
#define c_macro_required_args(f)       (T_Mac(f))->object.fnc.required_args
#define c_macro_all_args(f)            (T_Mac(f))->object.fnc.all_args
#define c_macro_setter(f)              T_Prc(c_macro_data(f)->setter)
#define c_macro_set_setter(f, Val)     c_macro_data(f)->setter = T_Prc(Val)

#define is_random_state(p)             (type(p) == T_RANDOM_STATE)
#if WITH_GMP
#define random_gmp_state(p)            p->object.rng.state /* sweep sees free cell in big_random_state gc_list and needs to call gmprandclear on its value */
#else
#define random_seed(p)                 (T_Ran(p))->object.rng.seed
#define random_carry(p)                (T_Ran(p))->object.rng.carry
#endif

#define continuation_block(p)          (T_Con(p))->object.cwcc.block
#define continuation_stack(p)          (T_Con(p))->object.cwcc.stack
#define continuation_set_stack(p, Val) (T_Con(p))->object.cwcc.stack = T_Stk(Val)
#define continuation_stack_end(p)      (T_Con(p))->object.cwcc.stack_end
#define continuation_stack_start(p)    (T_Con(p))->object.cwcc.stack_start
#define continuation_stack_top(p)      (continuation_stack_end(p) - continuation_stack_start(p))
#define continuation_op_stack(p)       (T_Con(p))->object.cwcc.op_stack
#define continuation_stack_size(p)     continuation_block(p)->nx.ix.i1
#define continuation_op_loc(p)         continuation_block(p)->nx.ix.i2
#define continuation_op_size(p)        continuation_block(p)->ex.jx.i3
#define continuation_key(p)            continuation_block(p)->ex.jx.i4

#define call_exit_goto_loc(p)          (T_Got(p))->object.rexit.goto_loc
#define call_exit_op_loc(p)            (T_Got(p))->object.rexit.op_stack_loc
#define call_exit_active(p)            (T_Got(p))->object.rexit.active

#define temp_stack_top(p)              (T_Stk(p))->object.stk.top
#define s7_stack_top(Sc)               ((Sc)->stack_end - (Sc)->stack_start)

#define is_continuation(p)             (type(p) == T_CONTINUATION)
#define is_goto(p)                     (type(p) == T_GOTO)
#define is_macro(p)                    (type(p) == T_MACRO)
/* #define is_bacro(p)                 (type(p) == T_BACRO) */
#define is_macro_star(p)               (type(p) == T_MACRO_STAR)
#define is_bacro_star(p)               (type(p) == T_BACRO_STAR)

#define is_closure(p)                  (type(p) == T_CLOSURE)
#define is_closure_star(p)             (type(p) == T_CLOSURE_STAR)
#define closure_args(p)                (T_Clo(p))->object.func.args
#define closure_set_args(p, Val)       (T_Clo(p))->object.func.args = T_Arg(Val)
#define closure_body(p)                (T_Pair((T_Clo(p))->object.func.body))
#define closure_set_body(p, Val)       (T_Clo(p))->object.func.body = T_Pair(Val)
#define closure_let(p)                 T_Lid((T_Clo(p))->object.func.env)
#define closure_set_let(p, L)          (T_Clo(p))->object.func.env = T_Lid(L)
#define closure_arity(p)               (T_Clo(p))->object.func.arity
#define closure_set_arity(p, A)        (T_Clo(p))->object.func.arity = A

#define closure_setter(p)              (T_Prc((T_Clo(p))->object.func.setter))
#define closure_set_setter(p, Val)     (T_Clo(p))->object.func.setter = T_Prc(Val)
#define closure_map_list(p)            (T_Pair((T_Clo(p))->object.func.setter))
#define closure_set_map_list(p, Val)   (T_Clo(p))->object.func.setter = T_Pair(Val)
#define closure_setter_or_map_list(p)  (T_Clo(p)->object.func.setter)
/* closure_map_list refers to a cyclic list detector in map; since in this case map makes a new closure for its own use,
 *   closure_map_list doesn't collide with closure_setter.
 */

#define CLOSURE_ARITY_NOT_SET          0x40000000
#define MAX_ARITY                      0x20000000
#define closure_arity_unknown(p)       (closure_arity(p) == CLOSURE_ARITY_NOT_SET)
#define is_thunk(Sc, Fnc)              ((type(Fnc) >= T_GOTO) && (s7_is_aritable(Sc, Fnc, 0)))

#define hook_has_functions(p)          (is_pair(s7_hook_functions(sc, T_Clo(p))))

#define catch_tag(p)                   (T_Cat(p))->object.rcatch.tag
#define catch_goto_loc(p)              (T_Cat(p))->object.rcatch.goto_loc
#define catch_op_loc(p)                (T_Cat(p))->object.rcatch.op_stack_loc
#define catch_handler(p)               T_Pos((T_Cat(p))->object.rcatch.handler)
#define catch_set_handler(p, val)      (T_Cat(p))->object.rcatch.handler = T_Pos(val)

#define catch_all_goto_loc(p)          (C_Let(p, L_CATCH))->object.envr.edat.ctall.goto_loc
#define catch_all_set_goto_loc(p, L)   (S_Let(p, L_CATCH))->object.envr.edat.ctall.goto_loc = L
#define catch_all_op_loc(p)            (C_Let(p, L_CATCH))->object.envr.edat.ctall.op_stack_loc
#define catch_all_set_op_loc(p, L)     (S_Let(p, L_CATCH))->object.envr.edat.ctall.op_stack_loc = L

enum {DWIND_INIT, DWIND_BODY, DWIND_FINISH};
#define dynamic_wind_state(p)          (T_Dyn(p))->object.winder.state
#define dynamic_wind_in(p)             (T_Dyn(p))->object.winder.in
#define dynamic_wind_out(p)            (T_Dyn(p))->object.winder.out
#define dynamic_wind_body(p)           (T_Dyn(p))->object.winder.body

#define is_c_object(p)                 (type(p) == T_C_OBJECT)
#define c_object_value(p)              (T_Obj(p))->object.c_obj.value
#define c_object_type(p)               (T_Obj(p))->object.c_obj.type
#define c_object_let(p)                T_Lid((T_Obj(p))->object.c_obj.e)
#define c_object_set_let(p, L)         (T_Obj(p))->object.c_obj.e = T_Lid(L)
#define c_object_mark(p)               (T_Obj(p))->object.c_obj.mark

#define c_object_info(Sc, p)           Sc->c_object_types[c_object_type(T_Obj(p))]
#define c_object_free(Sc, p)           c_object_info(Sc, p)->free
#define c_object_ref(Sc, p)            c_object_info(Sc, p)->ref
#define c_object_getf(Sc, p)           c_object_info(Sc, p)->getter
#define c_object_set(Sc, p)            c_object_info(Sc, p)->set
#define c_object_setf(Sc, p)           c_object_info(Sc, p)->setter
#if (!DISABLE_DEPRECATED)
  #define c_object_print(Sc, p)        c_object_info(Sc, p)->print
#endif
#define c_object_len(Sc, p)            c_object_info(Sc, p)->length
#define c_object_eql(Sc, p)            c_object_info(Sc, p)->equal
#define c_object_fill(Sc, p)           c_object_info(Sc, p)->fill
#define c_object_copy(Sc, p)           c_object_info(Sc, p)->copy
#define c_object_reverse(Sc, p)        c_object_info(Sc, p)->reverse
#define c_object_to_list(Sc, p)        c_object_info(Sc, p)->to_list
#define c_object_to_string(Sc, p)      c_object_info(Sc, p)->to_string
#define c_object_scheme_name(Sc, p)    T_Str(c_object_info(Sc, p)->scheme_name)

#define c_pointer(p)                   (T_Ptr(p))->object.cptr.c_pointer
#define c_pointer_type(p)              (T_Ptr(p))->object.cptr.c_type
#define c_pointer_info(p)              (T_Ptr(p))->object.cptr.info
#define c_pointer_weak1(p)             (T_Ptr(p))->object.cptr.weak1
#define c_pointer_weak2(p)             (T_Ptr(p))->object.cptr.weak2
#define c_pointer_set_weak1(p, q)      (T_Ptr(p))->object.cptr.weak1 = q
#define c_pointer_set_weak2(p, q)      (T_Ptr(p))->object.cptr.weak2 = q
#define is_c_pointer(p)                (type(p) == T_C_POINTER)

#define is_counter(p)                  (type(p) == T_COUNTER)
#define counter_result(p)              (T_Ctr(p))->object.ctr.result
#define counter_set_result(p, Val)     (T_Ctr(p))->object.ctr.result = T_Pos(Val)
#define counter_list(p)                (T_Ctr(p))->object.ctr.list
#define counter_set_list(p, Val)       (T_Ctr(p))->object.ctr.list = T_Pos(Val)
#define counter_capture(p)             (T_Ctr(p))->object.ctr.cap
#define counter_set_capture(p, Val)    (T_Ctr(p))->object.ctr.cap = Val
#define counter_let(p)                 T_Lid((T_Ctr(p))->object.ctr.env)
#define counter_set_let(p, L)          (T_Ctr(p))->object.ctr.env = T_Lid(L)
#define counter_slots(p)               (T_Ctr(p))->object.ctr.slots
#define counter_set_slots(p, Val)      (T_Ctr(p))->object.ctr.slots = T_Sln(Val)

#define is_baffle(p)                   (type(p) == T_BAFFLE)
#define baffle_key(p)                  (T_Bfl(p))->object.baffle_key

#if __cplusplus && HAVE_COMPLEX_NUMBERS
  using namespace std;                /* the code has to work in C as well as C++, so we can't scatter std:: all over the place */
  typedef complex<s7_double> s7_complex;
  static s7_double Real(complex<s7_double> x) {return(real(x));} /* protect the C++ name */
  static s7_double Imag(complex<s7_double> x) {return(imag(x));}
#endif

#define integer(p)                     (T_Int(p))->object.number.integer_value
#define set_integer(p, x)              integer(p) = x
#define real(p)                        (T_Rel(p))->object.number.real_value
#define set_real(p, x)                 real(p) = x
#define numerator(p)                   (T_Frc(p))->object.number.fraction_value.numerator
#define denominator(p)                 (T_Frc(p))->object.number.fraction_value.denominator
#define fraction(p)                    (((long_double)numerator(p)) / ((long_double)denominator(p)))
#define inverted_fraction(p)           (((long_double)denominator(p)) / ((long_double)numerator(p)))
#define real_part(p)                   (T_Cmp(p))->object.number.complex_value.rl
#define set_real_part(p, x)            real_part(p) = x
#define imag_part(p)                   (T_Cmp(p))->object.number.complex_value.im
#define set_imag_part(p, x)            imag_part(p) = x
#if HAVE_COMPLEX_NUMBERS
  #define as_c_complex(p)              CMPLX(real_part(p), imag_part(p))
#endif

#if WITH_GMP
#define big_integer(p)                 ((T_Bgi(p))->object.number.big_integer)
#define big_ratio(p)                   ((T_Bgf(p))->object.number.big_ratio)
#define big_real(p)                    ((T_Bgr(p))->object.number.big_real)
#define big_complex(p)                 ((T_Bgz(p))->object.number.big_complex)
#endif

#define print_name(p)                  (char *)((T_Num(p))->object.number.pval.name + 1)
#define print_name_length(p)           (T_Num(p))->object.number.pval.name[0]

static void set_print_name(s7_pointer p, const char *name, int32_t len)
{
  if ((len < (PRINT_NAME_SIZE - 1)) &&
      (!is_mutable(p)))
    {
      set_has_print_name(p);
      print_name_length(p) = (uint8_t)len;
      memcpy((void *)print_name(p), (void *)name, len);
      (print_name(p))[len] = 0;
    }
}

static s7_int s7_int_max = 0, s7_int_min = 0;
static int32_t s7_int32_max = 0, s7_int32_min = 0, s7_int_bits = 0, s7_int_digits = 0;
static int32_t s7_int_digits_by_radix[17];

#define S7_LLONG_MAX 9223372036854775807LL
#define S7_LLONG_MIN (-S7_LLONG_MAX - 1LL)

#define S7_LONG_MAX 2147483647LL
#define S7_LONG_MIN (-S7_LONG_MAX - 1LL)

#define S7_SHORT_MAX 32767
#define S7_SHORT_MIN -32768

static void init_int_limits(void)
{
  int32_t i, top;
#if WITH_GMP
#define S7_LOG_LLONG_MAX 36.736800
#define S7_LOG_LONG_MAX  16.6355322
#else
  /* actually not safe = (log (- (expt 2 63) 1)) and (log (- (expt 2 31) 1)) (using 63 and 31 bits) */
#define S7_LOG_LLONG_MAX 43.668274
#define S7_LOG_LONG_MAX  21.487562
#endif

  top = sizeof(s7_int);
  s7_int32_max = (top == 8) ? S7_LONG_MAX : S7_SHORT_MAX;
  s7_int32_min = (top == 8) ? S7_LONG_MIN : S7_SHORT_MIN;
  s7_int_bits = (top == 8) ? 63 : 31;
  s7_int_digits = (top == 8) ? 18 : 8;

  s7_int_max = (top == 8) ? S7_LLONG_MAX : S7_LONG_MAX;
  s7_int_min = (top == 8) ? S7_LLONG_MIN : S7_LONG_MIN;

  s7_int_digits_by_radix[0] = 0;
  s7_int_digits_by_radix[1] = 0;

  for (i = 2; i < 17; i++)
    s7_int_digits_by_radix[i] = (int32_t)(floor(((top == 8) ? S7_LOG_LLONG_MAX : S7_LOG_LONG_MAX) / log((double)i)));
}

static s7_pointer make_permanent_integer_unchecked(s7_int i)
{
  s7_pointer p;
  p = (s7_pointer)calloc(1, sizeof(s7_cell));
  set_type_bit(p, T_IMMUTABLE | T_INTEGER | T_UNHEAP);
  integer(p) = i;
  return(p);
}

#define NUM_SMALL_INTS 2048
static s7_pointer small_ints[NUM_SMALL_INTS + 1];
#define small_int(Val) small_ints[Val]
#define is_small(n) ((n & ~(NUM_SMALL_INTS - 1)) == 0)

static s7_pointer real_zero, real_NaN, real_pi, real_one, arity_not_set, max_arity, real_infinity, real_minus_infinity, minus_one, minus_two, mostfix, leastfix;

static void init_small_ints(void)
{
  const char *ones[10] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
  s7_cell *cells;
  int32_t i;
  cells = (s7_cell *)calloc((NUM_SMALL_INTS + 1), sizeof(s7_cell));
  for (i = 0; i <= NUM_SMALL_INTS; i++)
    {
      s7_pointer p;
      small_ints[i] = &cells[i];
      p = small_ints[i];
      set_type_bit(p, T_IMMUTABLE | T_INTEGER | T_UNHEAP);
      integer(p) = i;
    }
  for (i = 0; i < 10; i++)
    set_print_name(small_ints[i], ones[i], 1);

  /* setup a few other numbers while we're here */
  #define EXTRA_NUMBERS 10
  cells = (s7_cell *)calloc(EXTRA_NUMBERS, sizeof(s7_cell));

  #define init_real(Ptr, Num, Name, Name_Len) \
    do {set_type(Ptr, T_REAL | T_IMMUTABLE | T_UNHEAP); set_real(Ptr, Num); if (Name) set_print_name(Ptr, Name, Name_Len);} while (0)

  real_zero = &cells[0]; init_real(real_zero, 0.0, "0.0", 3);
  real_one = &cells[1]; init_real(real_one, 1.0, "1.0", 3);
  real_NaN = &cells[2]; init_real(real_NaN, NAN, "+nan.0", 6);
  real_infinity = &cells[3]; init_real(real_infinity, INFINITY, "+inf.0", 6);
  real_minus_infinity = &cells[4]; init_real(real_minus_infinity, -INFINITY, "-inf.0", 6);
  real_pi = &cells[5]; init_real(real_pi, 3.1415926535897932384626433832795029L, NULL, 0); /* M_PI is not good enough for s7_double = long double */

  #define init_integer(Ptr, Num, Name, Name_Len) \
    do {set_type(Ptr, T_INTEGER | T_IMMUTABLE | T_UNHEAP); set_integer(Ptr, Num); if (Name) set_print_name(Ptr, Name, Name_Len);} while (0)

  arity_not_set = &cells[6]; init_integer(arity_not_set, CLOSURE_ARITY_NOT_SET, NULL, 0);
  max_arity = &cells[7]; init_integer(max_arity, MAX_ARITY, NULL, 0);
  minus_one = &cells[8]; init_integer(minus_one, -1, "-1", 2);
  minus_two = &cells[9]; init_integer(minus_two, -2, "-2", 2);

  mostfix = make_permanent_integer_unchecked(s7_int_max);
  leastfix = make_permanent_integer_unchecked(s7_int_min);
  if (s7_int_bits == 63)
    {
      set_print_name(mostfix, "9223372036854775807", 19);
      set_print_name(leastfix, "-9223372036854775808", 20);
    }
  else
    {
      set_print_name(mostfix, "2147483647", 10);
      set_print_name(leastfix, "-2147483648", 11);
    }
}

static void slot_set_setter(s7_pointer p, s7_pointer val)
{
  if ((type(val) == T_C_FUNCTION) &&
      (c_function_has_bool_setter(val)))
    slot_set_setter_1(p, c_function_bool_setter(val));
  else slot_set_setter_1(p, val);
}


/* -------------------------------------------------------------------------------- */
#define GC_TRIGGER_SIZE 64

/* new_cell has to include the new cell's type.  In the free list, it is 0 (T_FREE).  If we remove it here,
 *   but then hit some error before setting the type, the GC sweep thinks it is a free cell already and
 *   does not return it to the free list: a memory leak.
 */

#define GC_STATS 1
#define HEAP_STATS 2
#define STACK_STATS 4

#define show_gc_stats(Sc) ((Sc->gc_stats & GC_STATS) != 0)
#define show_stack_stats(Sc) ((Sc->gc_stats & STACK_STATS) != 0)
#define show_heap_stats(Sc) ((Sc->gc_stats & HEAP_STATS) != 0)

#if (!S7_DEBUGGING)
#define new_cell(Sc, Obj, Type)			\
  do {						\
    if (Sc->free_heap_top <= Sc->free_heap_trigger) try_to_call_gc(Sc); \
    Obj = (*(--(Sc->free_heap_top))); \
    set_type(Obj, Type);	      \
    } while (0)

#define new_cell_no_check(Sc, Obj, Type) do {Obj = (*(--(Sc->free_heap_top))); set_type(Obj, Type);} while (0)
  /* since sc->free_heap_trigger is GC_TRIGGER_SIZE above the free heap base, we don't need
   *   to check it repeatedly after the first such check.
   */
#else

#define new_cell(Sc, Obj, Type)						\
  do {									\
    if (Sc->free_heap_top <= Sc->free_heap_trigger) {if (show_gc_stats(Sc)) fprintf(stderr, "%s[%d]: gc\n", __func__, __LINE__);  try_to_call_gc(Sc);} \
    Obj = (*(--(Sc->free_heap_top)));					\
    Obj->debugger_bits = 0; Obj->opt1_func = NULL; Obj->opt2_func = NULL; Obj->opt3_func = NULL; \
    set_type(Obj, Type);						\
  } while (0)

#define new_cell_no_check(Sc, Obj, Type)		    \
  do {							    \
    Obj = (*(--(Sc->free_heap_top)));			    \
    if (Sc->free_heap_top < Sc->free_heap) fprintf(stderr, "free heap exhausted\n"); \
    Obj->debugger_bits = 0; Obj->opt1_func = NULL; Obj->opt2_func = NULL; Obj->opt3_func = NULL; \
    set_type(Obj, Type);				    \
    } while (0)
#endif

#if WITH_GCC
#define make_integer(Sc, N) ({ s7_int _N_; _N_ = (N); (is_small(_N_) ? small_int(_N_) : ({ s7_pointer _I_; new_cell(Sc, _I_, T_INTEGER); integer(_I_) = _N_; _I_;}) ); })

#define make_real(Sc, X) ({ s7_pointer _R_; s7_double _N_ = (X); new_cell(Sc, _R_, T_REAL); set_real(_R_, _N_); _R_;})

#define make_complex(Sc, R, I)						\
  ({ s7_double _im_; _im_ = (I); ((_im_ == 0.0) ? make_real(Sc, R) : \
				  ({ s7_pointer _C_; new_cell(Sc, _C_, T_COMPLEX); set_real_part(_C_, R); set_imag_part(_C_, _im_); _C_;}) ); })

#define real_to_double(Sc, X, Caller)   ({ s7_pointer _x_; _x_ = (X); ((type(_x_) == T_REAL) ? real(_x_) : s7_number_to_real_with_caller(Sc, _x_, Caller)); })
#define rational_to_double(Sc, X)       ({ s7_pointer _x_; _x_ = (X); ((type(_x_) == T_INTEGER) ? (s7_double)integer(_x_) : fraction(_x_)); })

#else

#define make_integer(Sc, N)           s7_make_integer(Sc, N)
#define make_real(Sc, X)              s7_make_real(Sc, X)
#define make_complex(Sc, R, I)        s7_make_complex(Sc, R, I)
#define real_to_double(Sc, X, Caller) s7_number_to_real_with_caller(Sc, X, Caller)
#define rational_to_double(Sc, X)     s7_number_to_real(Sc, X)
#endif

static inline s7_pointer wrap_real(s7_scheme *sc, s7_double x) {real(sc->real_wrapper1) = x; return(sc->real_wrapper1);}
static inline s7_pointer wrap_integer1(s7_scheme *sc, s7_int x) {integer(sc->integer_wrapper1) = x; return(sc->integer_wrapper1);}
static inline s7_pointer wrap_integer2(s7_scheme *sc, s7_int x) {integer(sc->integer_wrapper2) = x; return(sc->integer_wrapper2);}
static inline s7_pointer wrap_integer3(s7_scheme *sc, s7_int x) {integer(sc->integer_wrapper3) = x; return(sc->integer_wrapper3);}
#if (!WITH_GMP)
static inline s7_pointer wrap_real2(s7_scheme *sc, s7_double x) {real(sc->real_wrapper2) = x; return(sc->real_wrapper2);}
#endif

/* 9007199254740991LL is where a truncated double starts to skip integers (expt 2 53) = ca 1e16
 *   (ceiling (+ 1e16 1)) -> 10000000000000000
 *   (> 9007199254740993.0 9007199254740992.0) -> #f ; in non-gmp 64-bit doubles
 * but we can't fix this except in the gmp case because:
 *   (integer-decode-float (+ (expt 2.0 62) 100)) -> (4503599627370496 10 1)
 *   (integer-decode-float (+ (expt 2.0 62) 500)) -> (4503599627370496 10 1)
 *   (> (+ (expt 2.0 62) 500) (+ (expt 2.0 62) 100)) -> #f ; non-gmp again
 * i.e. the bits are identical.  We can't even detect when it has happened, so should
 *   we just give an error for any floor (or whatever) of an arg>1e16?  (sin has a similar problem)?
 *   I think in the non-gmp case I'll throw an error in these cases because the results are bogus:
 *   (floor (+ (expt 2.0 62) 512)) -> 4611686018427387904
 *   (floor (+ (expt 2.0 62) 513)) -> 4611686018427388928
 * another case at the edge: (round 9007199254740992.51) -> 9007199254740992
 * This spells trouble for normal arithmetic in this range.  If no gmp,
 *    (- (+ (expt 2.0 62) 512) (+ (expt 2.0 62) 513)) = -1024.0 (should be -1.0)
 *    but we don't currently give an error in this case -- not sure what the right thing is.
 */


/* --------------------------------------------------------------------------------
 * local versions of some standard C library functions
 * timing tests involving these are very hard to interpret
 * local_memset and memclr are faster using int64_t than int32_t
 */

static void local_memset(void *s, uint8_t val, size_t n)
{
  uint8_t *s2;
#if S7_ALIGNED
  s2 = (uint8_t *)s;
#else
#if (defined(__x86_64__) || defined(__i386__))
  if (n >= 8)
    {
      int64_t ival;
      int64_t *s1 = (int64_t *)s;
      size_t n8 = n >> 3;
      ival = val | (val << 8) | (val << 16) | (((uint64_t)val) << 24); /* uint64_t casts make gcc/clang/fsanitize happy */
      ival = (((uint64_t)ival) << 32) | ival;
      do {*s1++ = ival;} while (--n8 > 0);
      n &= 7;
      s2 = (uint8_t *)s1;
    }
  else s2 = (uint8_t *)s;
#else
  s2 = (uint8_t *)s;
#endif
#endif
  while (n > 0)
    {
      *s2++ = val;
      n--;
    }
}

static inline s7_int safe_strlen(const char *str)
{
  /* this is safer than strlen, and slightly faster */
  char *tmp = (char *)str;
  if ((!tmp) || (!(*tmp))) return(0);
  while (*tmp++) {};
  return(tmp - str - 1);
}

static char *copy_string_with_length(const char *str, s7_int len)
{
  char *newstr;
#if S7_DEBUGGING
  if ((len <= 0) || (!str))
    fprintf(stderr, "%s[%d]: len: %" print_s7_int ", str: %s\n", __func__, __LINE__, len, str);
#endif
  newstr = (char *)malloc((len + 1) * sizeof(char));
  if (len != 0)
    memcpy((void *)newstr, (void *)str, len);
  newstr[len] = '\0';
  return(newstr);
}

static char *copy_string(const char *str)
{
  return(copy_string_with_length(str, safe_strlen(str)));
}

static bool local_strcmp(const char *s1, const char *s2)
{
  while (true)
    {
      if (*s1 != *s2++) return(false);
      if (*s1++ == 0) return(true);
    }
  return(true);
}

#define strings_are_equal(Str1, Str2) (local_strcmp(Str1, Str2))
/* this should only be used for internal strings -- scheme strings can have embedded nulls. */

static bool safe_strcmp(const char *s1, const char *s2)
{
  if ((!s1) || (!s2)) return(s1 == s2);
  return(local_strcmp(s1, s2));
}

static bool local_strncmp(const char *s1, const char *s2, size_t n)
{
#if S7_ALIGNED
  return(strncmp(s1, s2, n) == 0);
#else
#if (defined(__x86_64__) || defined(__i386__)) /* unaligned accesses are safe on i386 hardware, sez everyone */
  if (n >= 8)
    {
      int64_t *is1, *is2;
      size_t n8 = n >> 3;
      is1 = (int64_t *)s1;
      is2 = (int64_t *)s2;
      do {if (*is1++ != *is2++) return(false);} while (--n8 > 0);
      s1 = (const char *)is1;
      s2 = (const char *)is2;
      n &= 7;
    }
#endif
  while (n > 0)
    {
      if (*s1++ != *s2++) return(false);
      n--;
    }
  return(true);
#endif
}

#define strings_are_equal_with_length(Str1, Str2, Len) (local_strncmp(Str1, Str2, Len))

static size_t catstrs(char *dst, size_t len, ...) /* NULL-terminated arg list */
{
  const char *s, *dend;
  char *d;
  va_list ap;
  d = dst;
  dend = (const char *)(dst + len);
  while ((*d) && (d < dend)) d++;
  va_start(ap, len);
  for (s = va_arg(ap, const char *); s != NULL; s = va_arg(ap, const char *))
    while ((*s) && (d < dend)) {*d++ = *s++;}
  *d = '\0';
  va_end (ap);
  return(d - dst);
}

static size_t catstrs_direct(char *dst, const char *s1, ...) /* NULL-terminated arg list, dst is destination only (assumed empty), all args known to fit in dst */
{
  const char *s;
  char *d;
  va_list ap;
  d = dst;
  va_start(ap, s1);
  for (s = s1; s != NULL; s = va_arg(ap, const char *))
    while (*s) {*d++ = *s++;}
  *d = '\0';
  va_end (ap);
  return(d - dst);
}

static char *pos_int_to_str(s7_scheme *sc, s7_int num, s7_int *len, char endc)
{
  char *p, *op;

  p = (char *)(sc->int_to_str3 + INT_TO_STR_SIZE - 1);
  op = p;
  *p-- = '\0';
  if (endc != '\0') *p-- = endc;
  do {*p-- = "0123456789"[num % 10]; num /= 10;} while (num);
  (*len) = op - p;           /* this includes the trailing #\null */
  return((char *)(p + 1));
}

static char *pos_int_to_str_direct(s7_scheme *sc, s7_int num)
{
  char *p;
  p = (char *)(sc->int_to_str4 + INT_TO_STR_SIZE - 1);
  *p-- = '\0';
  do {*p-- = "0123456789"[num % 10]; num /= 10;} while (num);
  return((char *)(p + 1));
}

static char *pos_int_to_str_direct_1(s7_scheme *sc, s7_int num)
{
  char *p;
  p = (char *)(sc->int_to_str5 + INT_TO_STR_SIZE - 1);
  *p-- = '\0';
  do {*p-- = "0123456789"[num % 10]; num /= 10;} while (num);
  return((char *)(p + 1));
}


/* ---------------- forward decls ---------------- */

static void try_to_call_gc(s7_scheme *sc);
static s7_pointer eval(s7_scheme *sc, opcode_t first_op);
static s7_pointer prepackaged_type_name(s7_scheme *sc, s7_pointer x);
static const char *type_name(s7_scheme *sc, s7_pointer arg, int32_t article);
static void s7_warn(s7_scheme *sc, s7_int len, const char *ctrl, ...);
static s7_pointer safe_reverse_in_place(s7_scheme *sc, s7_pointer list);
static s7_pointer cons_unchecked(s7_scheme *sc, s7_pointer a, s7_pointer b);
static s7_pointer cons_unchecked_with_type(s7_scheme *sc, s7_pointer p, s7_pointer a, s7_pointer b);
static s7_pointer permanent_cons(s7_scheme *sc, s7_pointer a, s7_pointer b, uint64_t type);
static s7_pointer make_atom(s7_scheme *sc, char *q, int32_t radix, bool want_symbol, bool with_error);
static s7_pointer apply_error(s7_scheme *sc, s7_pointer obj, s7_pointer args);
static s7_pointer division_by_zero_error(s7_scheme *sc, s7_pointer caller, s7_pointer arg);
static s7_pointer file_error(s7_scheme *sc, const char *caller, const char *descr, const char *name);
static s7_pointer unbound_variable(s7_scheme *sc, s7_pointer sym);
static void check_for_substring_temp(s7_scheme *sc, s7_pointer expr);
static s7_pointer splice_in_values(s7_scheme *sc, s7_pointer args);
static void pop_input_port(s7_scheme *sc);
static s7_pointer object_to_truncated_string(s7_scheme *sc, s7_pointer p, s7_int len);
static token_t token(s7_scheme *sc);
static s7_pointer implicit_index(s7_scheme *sc, s7_pointer obj, s7_pointer indices);
static void free_hash_table(s7_scheme *sc, s7_pointer table);
static s7_pointer g_cdr(s7_scheme *sc, s7_pointer args);
static s7_pointer s7_length(s7_scheme *sc, s7_pointer lst);
static inline s7_pointer symbol_to_slot(s7_scheme *sc, s7_pointer symbol);
static inline s7_pointer make_simple_vector(s7_scheme *sc, s7_int len);
static inline s7_pointer make_symbol_with_length(s7_scheme *sc, const char *name, s7_int len);
static s7_pointer make_symbol(s7_scheme *sc, const char *name);

#if S7_DEBUGGING
  #define wrap_string(Sc, Str, Len) wrap_string_1(Sc, Str, Len, __func__, __LINE__)
  static s7_pointer wrap_string_1(s7_scheme *sc, const char *str, s7_int len, const char *func, int line);
#else
  static s7_pointer wrap_string(s7_scheme *sc, const char *str, s7_int len);
#endif

#if WITH_GMP
  static s7_int big_integer_to_s7_int(mpz_t n);
#else
  static double next_random(s7_pointer r);
#endif

#if S7_DEBUGGING && WITH_GCC
  static s7_pointer lookup_1(s7_scheme *sc, s7_pointer symbol);
  #define lookup(Sc, Sym) check_null_sym(Sc, lookup_1(Sc, Sym), Sym, __LINE__, __func__)
  static s7_pointer check_null_sym(s7_scheme *sc, s7_pointer p, s7_pointer sym, int32_t line, const char *func);
  #define lookup_unexamined(Sc, Sym) lookup_1(Sc, Sym)
#else
  static inline s7_pointer lookup(s7_scheme *sc, s7_pointer symbol);
  #define lookup_unexamined(Sc, Sym) lookup(Sc, Sym)
#endif

#if WITH_GCC
  #if S7_DEBUGGING
    #define lookup_checked(Sc, Sym) ({s7_pointer _x_; _x_ = lookup_1(Sc, Sym); ((_x_) ? _x_ : unbound_variable(Sc, Sym));})
  #else
    #define lookup_checked(Sc, Sym) ({s7_pointer _x_; _x_ = lookup(Sc, Sym); ((_x_) ? _x_ : unbound_variable(Sc, Sym));})
  #endif
#else
  #define lookup_checked(Sc, Sym) lookup(Sc, Sym)
#endif

static s7_pointer find_method(s7_scheme *sc, s7_pointer env, s7_pointer symbol);
static s7_pointer find_let(s7_scheme *sc, s7_pointer obj);
static bool call_begin_hook(s7_scheme *sc);
static s7_pointer default_vector_setter(s7_scheme *sc, s7_pointer vec, s7_int loc, s7_pointer val);
static s7_pointer default_vector_getter(s7_scheme *sc, s7_pointer vec, s7_int loc);

static s7_pointer simple_wrong_type_arg_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg, s7_pointer typnam, s7_pointer descr);
static s7_pointer wrong_type_arg_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg_n, s7_pointer arg, s7_pointer typnam, s7_pointer descr);
static s7_pointer out_of_range_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg_n, s7_pointer arg, s7_pointer descr);
static s7_pointer simple_out_of_range_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg, s7_pointer descr);

/* putting off the type description until s7_error via the sc->unused marker below makes it possible
 *    for gcc to speed up the functions that call these as tail-calls.  1-2% overall speedup!
 */
#define simple_wrong_type_argument(Sc, Caller, Arg, Desired_Type) \
  simple_wrong_type_arg_error_prepackaged(Sc, symbol_name_cell(Caller), Arg, sc->unused, prepackaged_type_names[Desired_Type])

#define wrong_type_argument(Sc, Caller, Num, Arg, Desired_Type)	\
  wrong_type_arg_error_prepackaged(Sc, symbol_name_cell(Caller), make_integer(Sc, Num), Arg, sc->unused, prepackaged_type_names[Desired_Type])

#define simple_wrong_type_argument_with_type(Sc, Caller, Arg, Type) \
  simple_wrong_type_arg_error_prepackaged(Sc, symbol_name_cell(Caller), Arg, sc->unused, Type)

#define wrong_type_argument_with_type(Sc, Caller, Num, Arg, Type)	\
  wrong_type_arg_error_prepackaged(Sc, symbol_name_cell(Caller), make_integer(Sc, Num), Arg, sc->unused, Type)

#define simple_out_of_range(Sc, Caller, Arg, Description)   simple_out_of_range_error_prepackaged(Sc, symbol_name_cell(Caller), Arg, Description)
#define out_of_range(Sc, Caller, Arg_Num, Arg, Description) out_of_range_error_prepackaged(Sc, symbol_name_cell(Caller), Arg_Num, Arg, Description)


/* ---------------- evaluator ops ---------------- */

/* C=constant, S=symbol, A=fx-callable, Q=quote, D=list of constants, FX=list of A's */
enum {OP_UNOPT, HOP_UNOPT, OP_SYM, HOP_SYM, OP_CON, HOP_CON,
      OP_PAIR_SYM, HOP_PAIR_SYM, OP_PAIR_PAIR, HOP_PAIR_PAIR, OP_PAIR_ANY, HOP_PAIR_ANY,
      OP_SAFE_C_D, HOP_SAFE_C_D, OP_SAFE_C_AND2, HOP_SAFE_C_AND2, OP_SAFE_C_OR2, HOP_SAFE_C_OR2,
      OP_SAFE_C_S, HOP_SAFE_C_S, OP_SAFE_CAR_S, HOP_SAFE_CAR_S, OP_SAFE_CDR_S, HOP_SAFE_CDR_S, OP_SAFE_CADR_S, HOP_SAFE_CADR_S,
      OP_SAFE_IS_PAIR_S, HOP_SAFE_IS_PAIR_S, OP_SAFE_IS_NULL_S, HOP_SAFE_IS_NULL_S, OP_SAFE_IS_SYMBOL_S, HOP_SAFE_IS_SYMBOL_S, /* order matters here */
      OP_SAFE_C_SS, HOP_SAFE_C_SS, OP_SAFE_C_SC, HOP_SAFE_C_SC, OP_SAFE_C_CS, HOP_SAFE_C_CS, OP_SAFE_C_CQ, HOP_SAFE_C_CQ,
      OP_SAFE_C_SSS, HOP_SAFE_C_SSS, OP_SAFE_C_SCS, HOP_SAFE_C_SCS, OP_SAFE_C_SSC, HOP_SAFE_C_SSC, OP_SAFE_C_CSS, HOP_SAFE_C_CSS,
      OP_SAFE_C_SCC, HOP_SAFE_C_SCC, OP_SAFE_C_CSC, HOP_SAFE_C_CSC, OP_SAFE_C_CCS, HOP_SAFE_C_CCS,
      OP_SAFE_C_ALL_S, HOP_SAFE_C_ALL_S,
      OP_SAFE_C_opDq, HOP_SAFE_C_opDq, OP_SAFE_C_opSq, HOP_SAFE_C_opSq,
      OP_SAFE_C_opDq_opSq, HOP_SAFE_C_opDq_opSq, OP_SAFE_C_opSq_opDq, HOP_SAFE_C_opSq_opDq,
      OP_SAFE_C_opSSq, HOP_SAFE_C_opSSq, OP_SAFE_C_opSCq, HOP_SAFE_C_opSCq,
      OP_SAFE_C_opCSq, HOP_SAFE_C_opCSq, OP_SAFE_C_S_opSq, HOP_SAFE_C_S_opSq,
      OP_SAFE_C_C_opSCq, HOP_SAFE_C_C_opSCq,
      OP_SAFE_C_S_opSCq, HOP_SAFE_C_S_opSCq, OP_SAFE_C_S_opCSq, HOP_SAFE_C_S_opCSq,
      OP_SAFE_C_opSq_S, HOP_SAFE_C_opSq_S, OP_SAFE_C_CAR_S_S, HOP_SAFE_C_CAR_S_S, OP_SAFE_C_opSq_C, HOP_SAFE_C_opSq_C,
      OP_SAFE_C_opSq_opSq, HOP_SAFE_C_opSq_opSq, OP_SAFE_C_S_opSSq, HOP_SAFE_C_S_opSSq, OP_SAFE_C_C_opSq, HOP_SAFE_C_C_opSq,
      OP_SAFE_C_C_opCSq, HOP_SAFE_C_C_opCSq, OP_SAFE_C_opCSq_C, HOP_SAFE_C_opCSq_C,
      OP_SAFE_C_S_opDq, HOP_SAFE_C_S_opDq, OP_SAFE_C_opSSq_C, HOP_SAFE_C_opSSq_C, OP_SAFE_C_C_opSSq, HOP_SAFE_C_C_opSSq,
      OP_SAFE_C_C_opDq, HOP_SAFE_C_C_opDq, OP_SAFE_C_opDq_S, HOP_SAFE_C_opDq_S,
      OP_SAFE_C_opDq_opDq, HOP_SAFE_C_opDq_opDq, OP_SAFE_C_opDq_C, HOP_SAFE_C_opDq_C,
      OP_SAFE_C_opSCq_opSCq, HOP_SAFE_C_opSCq_opSCq, OP_SAFE_C_opSSq_opSSq, HOP_SAFE_C_opSSq_opSSq,
      OP_SAFE_C_opSSq_opDq, HOP_SAFE_C_opSSq_opDq, OP_SAFE_C_opSSq_opSq, HOP_SAFE_C_opSSq_opSq, OP_SAFE_C_opSq_opSSq, HOP_SAFE_C_opSq_opSSq,
      OP_SAFE_C_opSSq_S, HOP_SAFE_C_opSSq_S, OP_SAFE_C_opSCq_S, HOP_SAFE_C_opSCq_S, OP_SAFE_C_opCSq_S, HOP_SAFE_C_opCSq_S,
      OP_SAFE_C_opSCq_C, HOP_SAFE_C_opSCq_C, OP_SAFE_C_opDq_opSSq, HOP_SAFE_C_opDq_opSSq,
      OP_SAFE_C_S_op_opSq_Cq, HOP_SAFE_C_S_op_opSq_Cq,
      OP_SAFE_C_S_op_S_opSSqq, HOP_SAFE_C_S_op_S_opSSqq, OP_SAFE_C_S_op_S_opSqq, HOP_SAFE_C_S_op_S_opSqq,
      OP_SAFE_C_op_opSSq_q_C, HOP_SAFE_C_op_opSSq_q_C, OP_SAFE_C_op_opSq_q_C, HOP_SAFE_C_op_opSq_q_C,
      OP_SAFE_C_op_opSSq_q_S, HOP_SAFE_C_op_opSSq_q_S, OP_SAFE_C_op_opSq_q_S, HOP_SAFE_C_op_opSq_q_S,
      OP_SAFE_C_S_op_opSSq_opSSqq, HOP_SAFE_C_S_op_opSSq_opSSqq, OP_SAFE_C_op_opSSq_Sq_S, HOP_SAFE_C_op_opSSq_Sq_S,
      OP_SAFE_C_op_opSq_q, HOP_SAFE_C_op_opSq_q,
      OP_SAFE_C_op_S_opSq_q, HOP_SAFE_C_op_S_opSq_q, OP_SAFE_C_op_opSq_S_q, HOP_SAFE_C_op_opSq_S_q,
      OP_SAFE_C_opSq_CS, HOP_SAFE_C_opSq_CS,

      OP_SAFE_C_A, HOP_SAFE_C_A, OP_SAFE_C_AA, HOP_SAFE_C_AA,
      OP_SAFE_C_AAA, HOP_SAFE_C_AAA, OP_SAFE_C_AAAA, HOP_SAFE_C_AAAA,
      OP_SAFE_C_FX, HOP_SAFE_C_FX, OP_SAFE_C_ALL_CA, HOP_SAFE_C_ALL_CA,
      OP_SAFE_C_SSA, HOP_SAFE_C_SSA, OP_SAFE_C_SAS, HOP_SAFE_C_SAS,
      OP_SAFE_C_CSA, HOP_SAFE_C_CSA, OP_SAFE_C_SCA, HOP_SAFE_C_SCA, OP_SAFE_C_CAC, HOP_SAFE_C_CAC,
      OP_SAFE_C_SSSC, HOP_SAFE_C_SSSC,
      OP_SAFE_C_opAq, HOP_SAFE_C_opAq, OP_SAFE_C_opAAq, HOP_SAFE_C_opAAq, OP_SAFE_C_opAAAq, HOP_SAFE_C_opAAAq,
      OP_SAFE_C_S_opAq, HOP_SAFE_C_S_opAq, OP_SAFE_C_opAq_S, HOP_SAFE_C_opAq_S,
      OP_SAFE_C_S_opAAq, HOP_SAFE_C_S_opAAq, OP_SAFE_C_S_opAAAq, HOP_SAFE_C_S_opAAAq,
      OP_SAFE_IFA_SS_A, HOP_SAFE_IFA_SS_A,
      OP_SAFE_C_STAR, HOP_SAFE_C_STAR, OP_SAFE_C_STAR_A, HOP_SAFE_C_STAR_A, OP_SAFE_C_STAR_AA, HOP_SAFE_C_STAR_AA, OP_SAFE_C_STAR_FX, HOP_SAFE_C_STAR_FX,
      OP_SAFE_C_P, HOP_SAFE_C_P,

      OP_THUNK, HOP_THUNK, OP_THUNK_P, HOP_THUNK_P,
      OP_SAFE_THUNK, HOP_SAFE_THUNK, OP_SAFE_THUNK_P, HOP_SAFE_THUNK_P, OP_SAFE_THUNK_A, HOP_SAFE_THUNK_A,

      OP_CLOSURE_S, HOP_CLOSURE_S, OP_CLOSURE_S_P, HOP_CLOSURE_S_P,
      OP_SAFE_CLOSURE_S, HOP_SAFE_CLOSURE_S, OP_SAFE_CLOSURE_S_P, HOP_SAFE_CLOSURE_S_P, OP_SAFE_CLOSURE_S_A, HOP_SAFE_CLOSURE_S_A,
      OP_CLOSURE_C, HOP_CLOSURE_C, OP_CLOSURE_C_P, HOP_CLOSURE_C_P,
      OP_SAFE_CLOSURE_C, HOP_SAFE_CLOSURE_C, OP_SAFE_CLOSURE_C_P, HOP_SAFE_CLOSURE_C_P, OP_SAFE_CLOSURE_C_A, HOP_SAFE_CLOSURE_C_A,

      OP_CLOSURE_A, HOP_CLOSURE_A, OP_CLOSURE_A_P, HOP_CLOSURE_A_P, OP_CLOSURE_SUB_P, HOP_CLOSURE_SUB_P,
      OP_SAFE_CLOSURE_A, HOP_SAFE_CLOSURE_A, OP_SAFE_CLOSURE_A_P, HOP_SAFE_CLOSURE_A_P, OP_SAFE_CLOSURE_A_A, HOP_SAFE_CLOSURE_A_A,

      OP_CLOSURE_P, HOP_CLOSURE_P, OP_SAFE_CLOSURE_P, HOP_SAFE_CLOSURE_P,

      OP_CLOSURE_AP, HOP_CLOSURE_AP, OP_CLOSURE_PA, HOP_CLOSURE_PA,
      OP_SAFE_CLOSURE_AP, HOP_SAFE_CLOSURE_AP, OP_SAFE_CLOSURE_PA, HOP_SAFE_CLOSURE_PA,
      OP_CLOSURE_FA, HOP_CLOSURE_FA,

      OP_CLOSURE_SS, HOP_CLOSURE_SS, OP_CLOSURE_SS_P, HOP_CLOSURE_SS_P,
      OP_SAFE_CLOSURE_SS, HOP_SAFE_CLOSURE_SS, OP_SAFE_CLOSURE_SS_P, HOP_SAFE_CLOSURE_SS_P, OP_SAFE_CLOSURE_SS_A, HOP_SAFE_CLOSURE_SS_A,
      OP_CLOSURE_SC, HOP_CLOSURE_SC, OP_CLOSURE_SC_P, HOP_CLOSURE_SC_P,
      OP_SAFE_CLOSURE_SC, HOP_SAFE_CLOSURE_SC, OP_SAFE_CLOSURE_SC_P, HOP_SAFE_CLOSURE_SC_P,
      OP_CLOSURE_CS, HOP_CLOSURE_CS,
      OP_SAFE_CLOSURE_CS, HOP_SAFE_CLOSURE_CS,

      OP_CLOSURE_AA, HOP_CLOSURE_AA, OP_CLOSURE_AA_P, HOP_CLOSURE_AA_P,
      OP_SAFE_CLOSURE_AA, HOP_SAFE_CLOSURE_AA, OP_SAFE_CLOSURE_AA_P, HOP_SAFE_CLOSURE_AA_P, OP_SAFE_CLOSURE_AA_A, HOP_SAFE_CLOSURE_AA_A,

      OP_CLOSURE_FX, HOP_CLOSURE_FX, OP_CLOSURE_ALL_S, HOP_CLOSURE_ALL_S, OP_CLOSURE_ANY_FX, HOP_CLOSURE_ANY_FX,
      OP_SAFE_CLOSURE_SA, HOP_SAFE_CLOSURE_SA, OP_SAFE_CLOSURE_SAA, HOP_SAFE_CLOSURE_SAA, OP_SAFE_CLOSURE_FX, HOP_SAFE_CLOSURE_FX,

      OP_CLOSURE_STAR_A, HOP_CLOSURE_STAR_A, OP_CLOSURE_STAR_FX, HOP_CLOSURE_STAR_FX,
      OP_SAFE_CLOSURE_STAR_A, HOP_SAFE_CLOSURE_STAR_A, OP_SAFE_CLOSURE_STAR_AA, HOP_SAFE_CLOSURE_STAR_AA,
      OP_SAFE_CLOSURE_STAR_FX, HOP_SAFE_CLOSURE_STAR_FX, OP_SAFE_CLOSURE_STAR_FX_0, HOP_SAFE_CLOSURE_STAR_FX_0,
      OP_SAFE_CLOSURE_STAR_FX_1, HOP_SAFE_CLOSURE_STAR_FX_1, OP_SAFE_CLOSURE_STAR_FX_2, HOP_SAFE_CLOSURE_STAR_FX_2,

      /* these can't be embedded, and have to be the last thing called */
      OP_APPLY_SS, HOP_APPLY_SS, OP_APPLY_SA, HOP_APPLY_SA, OP_APPLY_SL, HOP_APPLY_SL,
      OP_C_FX, HOP_C_FX, OP_CALL_WITH_EXIT, HOP_CALL_WITH_EXIT, OP_CALL_WITH_EXIT_P, HOP_CALL_WITH_EXIT_P,
      OP_C_CATCH, HOP_C_CATCH, OP_C_CATCH_ALL, HOP_C_CATCH_ALL, OP_C_CATCH_ALL_P, HOP_C_CATCH_ALL_P, OP_C_CATCH_ALL_FX, HOP_C_CATCH_ALL_FX,
      OP_C_S_opSq, HOP_C_S_opSq, OP_C_S_opDq, HOP_C_S_opDq, OP_C_SS, HOP_C_SS,
      OP_C_S, HOP_C_S, OP_READ_S, HOP_READ_S, OP_C_P, HOP_C_P, OP_C_AP, HOP_C_AP, OP_NOT_P, HOP_NOT_P,
      OP_C_A, HOP_C_A, OP_C_SCS, HOP_C_SCS,
      OP_C_FA, HOP_C_FA, OP_C_AA, HOP_C_AA,

      OP_SAFE_C_PP, HOP_SAFE_C_PP,
      OP_SAFE_C_opSq_P, HOP_SAFE_C_opSq_P,
      OP_SAFE_C_SP, HOP_SAFE_C_SP, OP_SAFE_C_CP, HOP_SAFE_C_CP,
      OP_SAFE_C_AP, HOP_SAFE_C_AP, OP_SAFE_C_PA, HOP_SAFE_C_PA,
      OP_SAFE_C_PS, HOP_SAFE_C_PS, OP_SAFE_C_PC, HOP_SAFE_C_PC,
      OP_SAFE_C_SSP, HOP_SAFE_C_SSP, OP_SAFE_C_FP, HOP_SAFE_C_FP,

      OP_S, OP_S_S, OP_S_C, OP_S_A, OP_C_FA_1, OP_S_AA,
      OP_GOTO, OP_GOTO_A,
      OP_ITERATE, OP_CONTINUATION_A, OP_VECTOR_A, OP_STRING_A, OP_C_OBJECT_A, OP_PAIR_A, OP_HASH_TABLE_A, OP_ENVIRONMENT_C, OP_ENVIRONMENT_A,
      OP_VECTOR_AA,
      OP_UNKNOWN, OP_UNKNOWN_ALL_S, OP_UNKNOWN_FX, OP_UNKNOWN_G, OP_UNKNOWN_GG, OP_UNKNOWN_A, OP_UNKNOWN_AA,

      OP_GC_PROTECT,
      OP_READ_INTERNAL, OP_EVAL,
      OP_EVAL_ARGS, OP_EVAL_ARGS1, OP_EVAL_ARGS2, OP_EVAL_ARGS3, OP_EVAL_ARGS4, OP_EVAL_ARGS5,
      OP_APPLY, OP_EVAL_MACRO, OP_LAMBDA, OP_QUOTE, OP_MACROEXPAND,
      OP_DEFINE, OP_DEFINE1, OP_BEGIN, OP_BEGIN0, OP_BEGIN1, OP_BEGIN_UNCHECKED,
      OP_IF, OP_IF1, OP_WHEN, OP_UNLESS, OP_SET, OP_SET1, OP_SET2,
      OP_LET, OP_LET1, OP_LET_STAR, OP_LET_STAR1, OP_LET_STAR2,
      OP_LETREC, OP_LETREC1, OP_LETREC_STAR, OP_LETREC_STAR1,
      OP_LET_TEMPORARILY, OP_LET_TEMP_UNCHECKED, OP_LET_TEMP_INIT1, OP_LET_TEMP_INIT2, OP_LET_TEMP_DONE, OP_LET_TEMP_DONE1,
      OP_COND, OP_COND1, OP_FEED_TO_1, OP_COND_SIMPLE, OP_COND1_SIMPLE, OP_COND_SIMPLE_P, OP_COND1_SIMPLE_P,
      OP_AND, OP_AND1, OP_OR, OP_OR1,
      OP_DEFINE_MACRO, OP_DEFINE_MACRO_STAR, OP_DEFINE_EXPANSION,
      OP_CASE,
      OP_READ_LIST, OP_READ_NEXT, OP_READ_DOT, OP_READ_QUOTE,
      OP_READ_QUASIQUOTE, OP_READ_UNQUOTE, OP_READ_APPLY_VALUES,
      OP_READ_VECTOR, OP_READ_BYTE_VECTOR, OP_READ_INT_VECTOR, OP_READ_FLOAT_VECTOR, OP_READ_DONE,
      OP_LOAD_RETURN_IF_EOF, OP_LOAD_CLOSE_AND_POP_IF_EOF, OP_EVAL_DONE,
      OP_CATCH, OP_DYNAMIC_WIND, OP_DEFINE_CONSTANT, OP_DEFINE_CONSTANT1,
      OP_DO, OP_DO_END, OP_DO_END1, OP_DO_STEP, OP_DO_STEP2, OP_DO_INIT,
      OP_DEFINE_STAR, OP_LAMBDA_STAR, OP_LAMBDA_STAR_DEFAULT, OP_ERROR_QUIT, OP_UNWIND_INPUT, OP_UNWIND_OUTPUT,
      OP_ERROR_HOOK_QUIT,
      OP_WITH_LET, OP_WITH_LET1, OP_WITH_LET_UNCHECKED, OP_WITH_LET_S,
      OP_WITH_BAFFLE, OP_WITH_BAFFLE_UNCHECKED, OP_EXPANSION,
      OP_FOR_EACH, OP_FOR_EACH_1, OP_FOR_EACH_2, OP_FOR_EACH_3,
      OP_MAP, OP_MAP_1, OP_MAP_2, OP_MAP_GATHER, OP_MAP_GATHER_1, OP_MAP_GATHER_2, OP_MAP_GATHER_3,
      OP_BARRIER, OP_DEACTIVATE_GOTO,
      OP_DEFINE_BACRO, OP_DEFINE_BACRO_STAR,
      OP_GET_OUTPUT_STRING,
      OP_SORT, OP_SORT1, OP_SORT2, OP_SORT3, OP_SORT_PAIR_END, OP_SORT_VECTOR_END, OP_SORT_STRING_END,
      OP_EVAL_STRING,
      OP_MEMBER_IF, OP_ASSOC_IF, OP_MEMBER_IF1, OP_ASSOC_IF1,
      OP_LAMBDA_UNCHECKED, OP_LET_UNCHECKED, OP_CATCH_1, OP_CATCH_2, OP_CATCH_ALL,
      OP_SET_UNCHECKED, OP_SET_SYMBOL_C, OP_SET_SYMBOL_S, OP_SET_SYMBOL_P, OP_SET_SYMBOL_A,
      OP_SET_SYMBOL_opSq, OP_SET_SYMBOL_opDq, OP_SET_SYMBOL_opSSq,
      OP_SET_NORMAL, OP_SET_PAIR, OP_SET_DILAMBDA, OP_SET_DILAMBDA_P, OP_SET_DILAMBDA_P_1, OP_SET_PAIR_A, OP_SET_PAIR_P, OP_SET_PAIR_ZA,
      OP_SET_PAIR_P_1, OP_SET_WITH_SETTER, OP_SET_PWS, OP_SET_LET_S, OP_SET_LET_FX, OP_SET_SAFE,
      OP_INCREMENT_1, OP_DECREMENT_1, OP_SET_CONS,
      OP_INCREMENT_SS, OP_INCREMENT_SSS, OP_INCREMENT_SP, OP_INCREMENT_SA, OP_INCREMENT_SAA,
      OP_LETREC_UNCHECKED, OP_LETREC_STAR_UNCHECKED, OP_COND_UNCHECKED,
      OP_LAMBDA_STAR_UNCHECKED, OP_DO_UNCHECKED, OP_DEFINE_UNCHECKED, OP_DEFINE_STAR_UNCHECKED, OP_DEFINE_FUNCHECKED, OP_DEFINE_CONSTANT_UNCHECKED,
      OP_DEFINE_WITH_SETTER, OP_DEFINE_MACRO_WITH_SETTER,

      OP_LET_NO_VARS, OP_NAMED_LET, OP_NAMED_LET_NO_VARS, OP_NAMED_LET_STAR, OP_LET_FX, OP_LET_FX_2, OP_LET_FX_3, 
      OP_LET_STAR_FX, OP_LET_STAR_FX_A,
      OP_LET_opSSq, OP_LET_opSSq_E, OP_LET_opaSSq, OP_LET_opaSSq_E,
      OP_LET_ONE, OP_LET_ONE_1, OP_LET_ONE_2, OP_LET_ONE_P, OP_LET_ONE_P_1, OP_LET_ONE_P_2, 
      OP_LET_A, OP_LET_A_P, OP_LET_A_A,

      OP_CASE_A_E_S, OP_CASE_A_I_S, OP_CASE_A_G_S, OP_CASE_A_E_G, OP_CASE_A_G_G, OP_CASE_A_S_S, OP_CASE_A_S_G,
      OP_CASE_S_E_S, OP_CASE_S_I_S, OP_CASE_S_G_S, OP_CASE_S_E_G, OP_CASE_S_G_G, OP_CASE_S_S_S, OP_CASE_S_S_G,
      OP_CASE_P_E_S, OP_CASE_P_I_S, OP_CASE_P_G_S, OP_CASE_P_E_G, OP_CASE_P_G_G, OP_CASE_P_S_S, OP_CASE_P_S_G,
      OP_CASE_E_S, OP_CASE_I_S, OP_CASE_G_S, OP_CASE_E_G, OP_CASE_G_G, OP_CASE_S_S, OP_CASE_S_G,

      OP_IF_UNCHECKED, OP_AND_P, OP_AND_P1, OP_AND_AP, OP_AND_SAFE_AA, OP_AND_PAIR_P,
      OP_AND_SAFE_P, OP_AND_SAFE_P1, OP_AND_SAFE_P2, OP_AND_SAFE_P3, OP_AND_SAFE_P_REST, 
      OP_OR_P, OP_OR_P1, OP_OR_AP, OP_OR_SAFE_P, OP_OR_SAFE_AA,
      OP_COND_FEED, OP_COND_FEED_1, 
      OP_WHEN_S, OP_WHEN_A, OP_WHEN_P, OP_WHEN_AND_AP, OP_UNLESS_S, OP_UNLESS_A, OP_UNLESS_P,

      OP_IF_S_P, OP_IF_S_P_P, OP_IF_S_R, OP_IF_S_N, OP_IF_S_N_N,
      OP_IF_D_P, OP_IF_D_P_P, OP_IF_D_R, OP_IF_D_N, OP_IF_D_N_N,
      OP_IF_CS_P, OP_IF_CS_P_P, OP_IF_CS_R, OP_IF_CS_N, OP_IF_CS_N_N,
      OP_IF_CSS_P, OP_IF_CSS_P_P, OP_IF_CSS_R, OP_IF_CSS_N, OP_IF_CSS_N_N,
      OP_IF_CSC_P, OP_IF_CSC_P_P, OP_IF_CSC_R, OP_IF_CSC_N, OP_IF_CSC_N_N,
      OP_IF_opSq_P, OP_IF_opSq_P_P, OP_IF_opSq_R, OP_IF_opSq_N, OP_IF_opSq_N_N,
      OP_IF_S_opDq_P, OP_IF_S_opDq_P_P, OP_IF_S_opDq_R, OP_IF_S_opDq_N, OP_IF_S_opDq_N_N,
      OP_IF_IS_TYPE_S_P, OP_IF_IS_TYPE_S_P_P, OP_IF_IS_TYPE_S_R, OP_IF_IS_TYPE_S_N, OP_IF_IS_TYPE_S_N_N,
      OP_IF_IS_TYPE_opSq_P, OP_IF_IS_TYPE_opSq_P_P, OP_IF_IS_TYPE_opSq_R, OP_IF_IS_TYPE_opSq_N, OP_IF_IS_TYPE_opSq_N_N,
      OP_IF_A_P, OP_IF_A_P_P, OP_IF_A_R, OP_IF_A_N, OP_IF_A_N_N,
      OP_IF_AND2_P, OP_IF_AND2_P_P, OP_IF_AND2_R, OP_IF_AND2_N, OP_IF_AND2_N_N,
      OP_IF_AND3_P, OP_IF_AND3_P_P, OP_IF_AND3_R, OP_IF_AND3_N, OP_IF_AND3_N_N,
      OP_IF_P_P, OP_IF_P_P_P, OP_IF_P_R, OP_IF_P_N, OP_IF_P_N_N,
      OP_IF_ANDP_P, OP_IF_ANDP_P_P, OP_IF_ANDP_R, OP_IF_ANDP_N, OP_IF_ANDP_N_N,
      OP_IF_ORP_P, OP_IF_ORP_P_P, OP_IF_ORP_R, OP_IF_ORP_N, OP_IF_ORP_N_N,
      OP_IF_OR2_P, OP_IF_OR2_P_P, OP_IF_OR2_R, OP_IF_OR2_N, OP_IF_OR2_N_N,
      OP_IF_PPP, OP_IF_PP, OP_IF_PR, OP_IF_PRR, OP_WHEN_PP, OP_UNLESS_PP,

      OP_COND_FX, OP_COND_FX_2, OP_COND_FX_P, OP_COND_FX_1P_ELSE, OP_COND_FX_2P_ELSE,
      OP_SIMPLE_DO, OP_SIMPLE_DO_STEP, OP_SAFE_DOTIMES, OP_SAFE_DOTIMES_STEP, OP_SAFE_DOTIMES_STEP_P, OP_SAFE_DOTIMES_STEP_O,
      OP_SAFE_DO, OP_SAFE_DO_STEP, OP_DOX, OP_DOX_STEP, OP_DOX_STEP_P, OP_DOX_NO_BODY, OP_DOX_INIT,
      OP_DOTIMES_P, OP_DOTIMES_STEP_P,
      OP_DO_NO_VARS, OP_DO_NO_VARS_NO_OPT, OP_DO_NO_VARS_NO_OPT_1,

      OP_SAFE_C_P_1, OP_SAFE_C_PP_1, OP_SAFE_C_PP_3_MV, OP_SAFE_C_PP_5, OP_SAFE_C_PP_6_MV,
      OP_SAFE_C_SP_1, OP_SAFE_C_SP_MV, OP_SAFE_CONS_SP_1, OP_SAFE_MEMQ_SP_1, OP_SAFE_ADD_SP_1, OP_SAFE_MULTIPLY_SP_1, OP_SAFE_SUBTRACT_SP_1,
      OP_SAFE_C_PS_1, OP_SAFE_C_PC_1, OP_SAFE_C_PS_MV, OP_SAFE_C_PC_MV,
      OP_EVAL_MACRO_MV, OP_MACROEXPAND_1, OP_APPLY_LAMBDA,
      OP_SAFE_CLOSURE_P_1, OP_CLOSURE_P_1, OP_SAFE_CLOSURE_AP_1, OP_SAFE_CLOSURE_PA_1,
      OP_INCREMENT_SP_1, OP_INCREMENT_SP_MV,
      OP_SAFE_C_FP_1, OP_SAFE_C_FP_MV_1, OP_SAFE_C_SSP_1, OP_SAFE_C_SSP_MV_1,
      OP_C_P_1, OP_C_P_MV, OP_C_AP_1, OP_NOT_P_1,
      OP_CLOSURE_AP_1, OP_CLOSURE_PA_1,
      OP_CLOSURE_P_MV, OP_CLOSURE_AP_MV, OP_CLOSURE_PA_MV,
      OP_SAFE_C_PA_1, OP_SAFE_C_PA_MV,

      OP_SET_WITH_LET_1, OP_SET_WITH_LET_2, OP_S7_LET,
      OP_MAX_DEFINED_1};

#define OP_MAX_DEFINED (OP_MAX_DEFINED_1 + 1)

typedef enum{E_C_P, E_C_PP, E_C_CP, E_C_SP, E_C_PC, E_C_PS} combine_op_t;

#if S7_DEBUGGING || OP_NAMES

static const char* op_names[OP_MAX_DEFINED_1] =
     {"unopt", "h_unopt", "sym", "h_sym", "con", "h_con",
      "pair_sym", "h_pair_sym", "pair_pair", "h_pair_pair", "pair_any", "h_pair_any",
      "safe_c_d", "h_safe_c_d", "safe_c_and2", "h_safe_c_and2", "safe_c_or2", "h_safe_c_or2",
      "safe_c_s", "h_safe_c_s", "safe_car_s", "h_safe_car_s", "safe_cdr_s", "h_safe_cdr_s", "safe_cadr_s", "h_safe_cadr_s",
      "safe_is_pair_s", "h_safe_is_pair_s", "safe_is_null_s", "h_safe_is_null_s", "safe_is_symbol_s", "h_safe_is_symbol_s",
      "safe_c_ss", "h_safe_c_ss", "safe_c_sc", "h_safe_c_sc", "safe_c_cs", "h_safe_c_cs", "safe_c_cq", "h_safe_c_cq",
      "safe_c_sss", "h_safe_c_sss", "safe_c_scs", "h_safe_c_scs", "safe_c_ssc", "h_safe_c_ssc", "safe_c_css", "h_safe_c_css",
      "safe_c_scc", "h_safe_c_scc", "safe_c_csc", "h_safe_c_csc", "safe_c_ccs", "h_safe_c_ccs",
      "safe_c_all_s", "h_safe_c_all_s",
      "safe_c_opdq", "h_safe_c_opdq", "safe_c_opsq", "h_safe_c_opsq",
      "safe_c_opdq_opsq", "h_safe_c_opdq_opsq", "safe_c_opsq_opdq", "h_safe_c_opsq_opdq",
      "safe_c_opssq", "h_safe_c_opssq", "safe_c_opscq", "h_safe_c_opscq",
      "safe_c_opcsq", "h_safe_c_opcsq", "safe_c_s_opsq", "h_safe_c_s_opsq",
      "safe_c_c_opscq", "h_safe_c_c_opscq",
      "safe_c_s_opscq", "h_safe_c_s_opscq", "safe_c_s_opcsq", "h_safe_c_s_opcsq",
      "safe_c_opsq_s", "h_safe_c_opsq_s", "safe_c_car_s_s", "h_safe_c_car_s_s", "safe_c_opsq_c", "h_safe_c_opsq_c",
      "safe_c_opsq_opsq", "h_safe_c_opsq_opsq", "safe_c_s_opssq", "h_safe_c_s_opssq", "safe_c_c_opsq", "h_safe_c_c_opsq",
      "safe_c_c_opcsq", "h_safe_c_c_opcsq", "safe_c_opcsq_c", "h_safe_c_opcsq_c",
      "safe_c_s_opdq", "h_safe_c_s_opdq", "safe_c_opssq_c", "h_safe_c_opssq_c", "safe_c_c_opssq", "h_safe_c_c_opssq",
      "safe_c_c_opdq", "h_safe_c_c_opdq", "safe_c_opdq_s", "h_safe_c_opdq_s",
      "safe_c_opdq_opdq", "h_safe_c_opdq_opdq", "safe_c_opdq_c", "h_safe_c_opdq_c",
      "safe_c_opscq_opscq", "h_safe_c_opscq_opscq", "safe_c_opssq_opssq", "h_safe_c_opssq_opssq",
      "safe_c_opssq_opdq", "h_safe_c_opssq_opdq", "safe_c_opssq_opsq", "h_safe_c_opssq_opsq", "safe_c_opsq_opssq", "h_safe_c_opsq_opssq",
      "safe_c_opssq_s", "h_safe_c_opssq_s", "safe_c_opscq_s", "h_safe_c_opscq_s", "safe_c_opcsq_s", "h_safe_c_opcsq_s",
      "safe_c_opscq_c", "h_safe_c_opscq_c", "safe_c_opdq_opssq", "h_safe_c_opdq_opssq",
      "safe_c_s_op_opsq_cq", "h_safe_c_s_op_opsq_cq",
      "safe_c_s_op_s_opssqq", "h_safe_c_s_op_s_opssqq", "safe_c_s_op_s_opsqq", "h_safe_c_s_op_s_opsqq",
      "safe_c_op_opssq_q_c", "h_safe_c_op_opssq_q_c", "safe_c_op_opsq_q_c", "h_safe_c_op_opsq_q_c",
      "safe_c_op_opssq_q_s", "h_safe_c_op_opssq_q_s", "safe_c_op_opsq_q_s", "h_safe_c_op_opsq_q_s",
      "safe_c_s_op_opssq_opssqq", "h_safe_c_s_op_opssq_opssqq", "safe_c_opssq_sq_s", "h_safe_c_opssq_sq_s",
      "safe_c_op_opsq_q", "h_safe_c_op_opsq_q",
      "safe_c_op_s_opsq_q", "h_safe_c_op_s_opsq_q", "safe_c_op_opsq_s_q", "h_safe_c_op_opsq_s_q",
      "safe_c_opsq_cs", "h_safe_c_opsq_cs",

      "safe_c_a", "h_safe_c_a", "safe_c_aa", "h_safe_c_aa",
      "safe_c_aaa", "h_safe_c_aaa", "safe_c_aaaa", "h_safe_c_aaaa",
      "safe_c_fx", "h_safe_c_fx", "safe_c_all_ca", "h_safe_c_all_ca",
      "safe_c_ssa", "h_safe_c_ssa", "safe_c_sas", "h_safe_c_sas",
      "safe_c_csa", "h_safe_c_csa", "safe_c_sca", "h_safe_c_sca", "safe_c_cac", "h_safe_c_cac",
      "safe_c_sssc", "h_safe_c_sssc",
      "safe_c_opaq", "h_safe_c_opaq", "safe_c_opaaq", "h_safe_c_opaaq", "safe_c_opaaaq", "h_safe_c_opaaaq",
      "safe_c_s_opaq", "h_safe_c_s_opaq", "safe_c_opaq_s", "h_safe_c_opaq_s",
      "safe_c_s_opaaq", "h_safe_c_s_opaaq", "safe_c_s_opaaaq", "h_safe_c_s_opaaaq",
      "safe_ifa_ss_a", "h_safe_ifa_ss_a",
      "safe_c*", "h_safe_c*", "safe_c*_a", "h_safe_c*_a", "safe_c*_aa", "h_safe_c*_aa", "safe_c*_fx", "h_safe_c*_fx",
      "safe_c_p", "h_safe_c_p",

      "thunk", "h_thunk", "thunk_p", "h_thunk_p",
      "safe_thunk", "h_safe_thunk", "safe_thunk_p", "h_safe_thunk_p", "safe_thunk_a", "h_safe_thunk_a",

      "closure_s", "h_closure_s", "closure_s_p", "h_closure_s_p",
      "safe_closure_s", "h_safe_closure_s", "safe_closure_s_p", "h_safe_closure_s_p", "safe_closure_s_a", "h_safe_closure_s_a",
      "closure_c", "h_closure_c", "closure_c_p", "h_closure_c_p",
      "safe_closure_c", "h_safe_closure_c", "safe_closure_c_p", "h_safe_closure_c_p", "safe_closure_c_a", "h_safe_closure_c_a",

      "closure_a", "h_closure_a", "closure_a_p", "h_closure_a_p", "closure_sub_p", "h_closure_sub_p",
      "safe_closure_a", "h_safe_closure_a", "safe_closure_a_p", "h_safe_closure_a_p", "safe_closure_a_a", "h_safe_closure_a_a",

      "closure_p", "h_closure_p", "safe_closure_p", "h_safe_closure_p",
      "closure_ap", "h_closure_ap", "closure_pa", "h_closure_pa",
      "safe_closure_ap", "h_safe_closure_ap", "safe_closure_pa", "h_safe_closure_pa",
      "closure_fa", "h_closure_fa",

      "closure_ss", "h_closure_ss", "closure_ss_p", "h_closure_ss_p",
      "safe_closure_ss", "h_safe_closure_ss", "safe_closure_ss_p", "h_safe_closure_ss_p", "safe_closure_ss_a", "h_safe_closure_ss_a",
      "closure_sc", "h_closure_sc", "closure_sc_p", "h_closure_sc_p",
      "safe_closure_sc", "h_safe_closure_sc", "safe_closure_sc_p", "h_safe_closure_sc_p",
      "closure_cs", "h_closure_cs",
      "safe_closure_cs", "h_safe_closure_cs",
      "closure_aa", "h_closure_aa", "closure_aa_p", "h_closure_aa_p",
      "safe_closure_aa", "h_safe_closure_aa", "safe_closure_aa_p", "h_safe_closure_aa_p", "safe_closure_aa_a", "h_safe_closure_aa_a",

      "closure_fx", "h_closure_fx", "closure_all_s", "h_closure_all_s", "closure_any_fx", "h_closure_any_fx",

      "safe_closure_sa", "h_safe_closure_sa", "safe_closure_saa", "h_safe_closure_saa", "safe_closure_fx", "h_safe_closure_fx",

      "closure*_a", "h_closure*_a", "closure*_fx", "h_closure*_fx",
      "safe_closure*_a", "h_safe_closure*_a", "safe_closure*_aa", "h_safe_closure*_aa",
      "safe_closure*_fx", "h_safe_closure*_fx", "safe_closure*_fx_0", "h_safe_closure*_fx_0",
      "safe_closure*_fx_1", "h_safe_closure*_fx_1", "safe_closure*_fx_2", "h_safe_closure*_fx_2",

      "apply_ss", "h_apply_ss", "apply_sa", "h_apply_sa", "apply_sl", "h_apply_sl",
      "c_fx", "h_c_fx", "call_with_exit", "h_call_with_exit", "call_with_exit_p", "h_call_with_exit_p",
      "c_catch", "h_c_catch", "c_catch_all", "h_c_catch_all", "c_catch_all_p", "h_c_catch_all_p", "c_catch_all_fx", "h_c_catch_all_fx",
      "c_s_opsq", "h_c_s_opsq", "c_s_opdq", "h_c_s_opdq", "c_ss", "h_c_ss",
      "c_s", "h_c_s", "read_s", "h_read_s", "c_p", "h_c_p", "c_ap", "h_c_ap", "c_not", "h_c_not",
      "c_a", "h_c_a", "c_scs", "h_c_scs",
      "c_fa", "h_c_fa", "c_aa", "h_c_aa",

      "safe_c_pp", "h_safe_c_pp",
      "safe_c_opsq_p", "h_safe_c_opsq_p",
      "safe_c_sp", "h_safe_c_sp", "safe_c_cp", "h_safe_c_cp",
      "safe_c_ap", "h_safe_c_ap", "safe_c_pa", "h_safe_c_pa",
      "safe_c_ps", "h_safe_c_ps", "safe_c_pc", "h_safe_c_pc",
      "safe_c_ssp", "h_safe_c_ssp", "safe_c_fp", "h_safe_c_fp",
      "s", "s_s", "s_c", "s_a", "c_fa_1", "s_aa",
      "goto", "goto_a",
      "iterate", "continuation_a", "vector_a", "string_a", "c_object_a", "pair_a", "hash_table_a", "environment_c", "environment_a",
      "vector_aa",
      "unknown", "unknown_all_s", "unknown_fx", "unknown_g", "unknown_gg", "unknown_a", "unknown_aa",

      "gc_protect",
      "read_internal", "eval",
      "eval_args", "eval_args1", "eval_args2", "eval_args3", "eval_args4", "eval_args5",
      "apply", "eval_macro", "lambda", "quote", "macroexpand",
      "define", "define1", "begin", "begin0", "begin1", "begin_unchecked",
      "if", "if1", "when", "unless", "set", "set1", "set2",
      "let", "let1", "let*", "let*1", "let*2",
      "letrec", "letrec1", "letrec*", "letrec*1",
      "let_temporarily", "let_temp_unchecked", "let_temp_init1", "let_temp_init2", "let_temp_done", "let_temp_done1",
      "cond", "cond1", "feed_to_1", "cond_simple", "cond1_simple", "cond_simple_p", "cond1_simple_p",
      "and", "and1", "or", "or1",
      "define_macro", "define_macro*", "define_expansion",
      "case", "read_list", "read_next", "read_dot", "read_quote",
      "read_quasiquote", "read_unquote", "read_apply_values",
      "read_vector", "read_byte_vector", "read_int_vector", "read_float_vector", "read_done",
      "load_return_if_eof", "load_close_and_pop_if_eof", "eval_done",
      "catch", "dynamic_wind", "define_constant", "define_constant1",
      "do", "do_end", "do_end1", "do_step", "do_step2", "do_init",
      "define*", "lambda*", "lambda*_default", "error_quit", "unwind_input", "unwind_output",
      "error_hook_quit",
      "with_let", "with_let1", "with_let_unchecked", "with_let_s",
      "with_baffle", "with_baffle_unchecked", "expansion",
      "for_each", "for_each_1", "for_each_2", "for_each_3",
      "map", "map_1", "map_2", "map_gather", "map_gather_1", "map_gather_2", "map_gather_3",
      "barrier", "deactivate_goto",
      "define_bacro", "define_bacro*",
      "get_output_string",
      "sort", "sort1", "sort2", "sort3", "sort_pair_end", "sort_vector_end", "sort_string_end",
      "eval_string",
      "member_if", "assoc_if", "member_if1", "assoc_if1",
      "lambda_unchecked", "let_unchecked", "catch_1", "catch_2", "catch_all",
      "set_unchecked", "set_symbol_c", "set_symbol_s", "set_symbol_p", "set_symbol_a",
      "set_symbol_opsq", "set_symbol_opdq", "set_symbol_opssq",
      "set_normal", "set_pair", "set_dilambda", "set_dilambda_p", "set_dilambda_p_1",
      "set_pair_a", "set_pair_p", "set_pair_za",
      "set_pair_p_1", "set_with_setter", "set_pws", "set_let_s", "set_let_fx", "set_safe",
      "increment_1", "decrement_1", "set_cons",
      "increment_ss", "increment_sss", "increment_sp", "increment_sa", "increment_saa",
      "letrec_unchecked", "letrec*_unchecked", "cond_unchecked",
      "lambda*_unchecked", "do_unchecked", "define_unchecked", "define*_unchecked", "define_funchecked", "define_constant_unchecked",
      "define_with_setter", "define_macro_with_setter",

      "let_no_vars", "named_let", "named_let_no_vars", "named_let*", "let_fx", "let_fx_2", "let_fx_3", 
      "let*_fx", "let*_fx_a",
      "let_opssq", "let_opssq_e", "let_opassq", "let_opassq_e",
      "let_one", "let_one_1", "let_one_2", "let_one_p", "let_one_p_1", "let_one_p_1", 
      "let_a", "let_a_p", "let_a_a",

      "case_a_e_s", "case_a_i_s", "case_a_g_s", "case_a_e_g", "case_a_g_g", "case_a_s_s", "case_a_s_g",
      "case_s_e_s", "case_s_i_s", "case_s_g_s", "case_s_e_g", "case_s_g_g", "case_s_s_s", "case_s_s_g",
      "case_p_e_s", "case_p_i_s", "case_p_g_s", "case_p_e_g", "case_p_g_g", "case_p_s_s", "case_p_s_g",
      "case_e_s", "case_i_s", "case_g_s", "case_e_g", "case_g_g", "case_s_s", "case_s_g",

      "if_unchecked", "and_p", "and_p1", "and_ap", "and_safe_aa", "and_pair_p",
      "and_safe_p", "and_safe_p1", "op_and_safe_p2", "and_safe_p3", "and_safe_p_rest", 
      "or_p", "or_p1", "or_ap", "or_safe_p", "or_safe_aa",
      "cond_feed", "cond_feed_1", 
      "when_s", "when_a", "when_p", "when_and_ap", "unless_s", "unless_a", "unless_p",

      "if_s_p", "if_s_p_p", "if_s_r", "if_s_n", "if_s_n_n",
      "if_d_p", "if_d_p_p", "if_d_r", "if_d_n", "if_d_n_n",
      "if_cs_p", "if_cs_p_p", "if_cs_r", "if_cs_n", "if_cs_n_n",
      "if_css_p", "if_css_p_p", "if_css_r","if_css_n", "if_css_n_n",
      "if_csc_p", "if_csc_p_p", "if_csc_r", "if_csc_n", "if_csc_n_n",
      "if_opsq_p", "if_opsq_p_p", "if_opsq_r", "if_opsq_n", "if_opsq_n_n",
      "if_s_opdq_p", "if_s_opdq_p_p", "if_s_opdq_r","if_s_opdq_n", "if_s_opdq_n_n",
      "if_is_type_s_p", "if_is_type_s_p_p", "if_is_type_s_r", "if_is_type_s_n", "if_is_type_s_n_n",
      "if_is_type_opsq_p", "if_is_type_opsq_p_p", "if_is_type_opsq_r", "if_is_type_opsq_n", "if_is_type_opsq_n_n",
      "if_a_p", "if_a_p_p", "if_a_r", "if_a_n", "if_a_n_n",
      "if_and2_p", "if_and2_p_p", "if_and2_r","if_and2_n", "if_and2_n_n",
      "if_and3_p", "if_and3_p_p", "if_and3_r","if_and3_n", "if_and3_n_n",
      "if_p_p", "if_p_p_p", "if_p_r", "if_p_n", "if_p_n_n",
      "if_andp_p", "if_andp_p_p", "if_andp_r", "if_andp_n", "if_andp_n_n",
      "if_orp_p", "if_orp_p_p", "if_orp_r","if_orp_n", "if_orp_n_n",
      "if_or2_p", "if_or2_p_p", "if_or2_r","if_or2_n", "if_or2_n_n",
      "if_ppp", "if_pp", "if_pr", "if_prr", "when_pp", "unless_pp",

      "cond_fx", "cond_fx_2", "cond_fx_p", "cond_fx_1p_else", "cond_fx_2p_else",
      "simple_do", "simple_do_step", "safe_dotimes", "safe_dotimes_step", "safe_dotimes_step_p", "safe_dotimes_step_o",
      "safe_do", "safe_do_step", "dox", "dox_step", "dox_step_p", "dox_no_body", "dox_init",
      "dotimes_p", "dotimes_step_p",
      "do_no_vars", "do_no_vars_no_opt", "do_no_vars_no_opt_1",

      "safe_c_p_1", "safe_c_pp_1", "safe_c_pp_3_mv", "safe_c_pp_5", "safe_c_pp_6_mv",
      "safe_c_sp_1", "safe_c_sp_mv", "safe_cons_sp_1", "safe_memq_sp_1", "safe_add_sp_1", "safe_multiply_sp_1", "safe_subtract_sp_1",
      "safe_c_ps_1", "safe_c_pc_1", "safe_c_ps_mv", "safe_c_pc_mv",
      "eval_macro_mv", "macroexpand_1", "apply_lambda",
      "safe_closure_p_1", "closure_p_1", "safe_closure_ap_1", "safe_closure_pa_1",
      "increment_sp_1", "increment_sp_mv",
      "safe_c_fp_1", "safe_c_fp_mv_1", "safe_c_ssp_1", "safe_c_ssp_mv_1",
      "c_p_1", "c_p_mv", "c_ap_1", "not_1",
      "closure_ap_1", "closure_pa_1",
      "closure_p_mv", "closure_ap_mv", "closure_pa_mv",
      "safe_c_pa_1", "safe_c_pa_mv",

      "set_with_let_1", "set_with_let_2", "*s7*",
};
#endif

#define op_names op_names
#define OPT_MAX_DEFINED OP_GC_PROTECT

#define in_reader(Sc)     ((sc->cur_op >= OP_READ_LIST) && (sc->cur_op <= OP_READ_DONE) && (is_input_port(Sc->input_port)))
#define is_safe_c_op(op)  ((op >= OP_SAFE_C_D) && (op < OP_THUNK))
#define is_unknown_op(op) ((op >= OP_UNKNOWN) && (op <= OP_UNKNOWN_AA))
#define is_fxa_op(op)     ((op >= OP_SAFE_C_D) && (op < OP_SAFE_C_A))
#define is_h_safe_c_d(P)  ((is_optimized(P)) && (optimize_op(P) >= HOP_SAFE_C_D) && (optimize_op(P) < OP_SAFE_C_S) && ((optimize_op(P) & 1) != 0))
#define is_h_safe_c_s(P)  ((is_optimized(P)) && (optimize_op(P) >= HOP_SAFE_C_S) && (optimize_op(P) <= HOP_SAFE_IS_SYMBOL_S) && ((optimize_op(P) & 1) != 0))
#define is_safe_c_s(P)    ((is_optimized(P)) && (optimize_op(P) >= HOP_SAFE_C_S) && (optimize_op(P) <= HOP_SAFE_IS_SYMBOL_S))

static bool is_h_optimized(s7_pointer p)
{
  return((is_optimized(p)) &&
	 ((optimize_op(p) & 1) != 0) &&
	 (optimize_op(p) < OP_S));
}

static bool is_not_h_optimized(s7_pointer p)
{
  return((is_optimized(p)) &&
	 ((optimize_op(p) & 1) == 0) &&
	 (optimize_op(p) < OP_S));
}

/* -------- */
static s7_pointer set_elist_1(s7_scheme *sc, s7_pointer x1)
{
  set_car(sc->elist_1, x1);
  return(sc->elist_1);
}

static s7_pointer set_elist_2(s7_scheme *sc, s7_pointer x1, s7_pointer x2)
{
  set_car(sc->elist_2, x1);
  set_cadr(sc->elist_2, x2);
  return(sc->elist_2);
}

static s7_pointer set_elist_3(s7_scheme *sc, s7_pointer x1, s7_pointer x2, s7_pointer x3)
{
  s7_pointer p;
  p = sc->elist_3;
  set_car(p, x1); p = cdr(p);
  set_car(p, x2); p = cdr(p);
  set_car(p, x3);
  return(sc->elist_3);
}

static s7_pointer set_elist_4(s7_scheme *sc, s7_pointer x1, s7_pointer x2, s7_pointer x3, s7_pointer x4)
{
  s7_pointer p;
  p = sc->elist_4;
  set_car(p, x1); p = cdr(p);
  set_car(p, x2); p = cdr(p);
  set_car(p, x3); p = cdr(p);
  set_car(p, x4);
  return(sc->elist_4);
}

static s7_pointer set_elist_5(s7_scheme *sc, s7_pointer x1, s7_pointer x2, s7_pointer x3, s7_pointer x4, s7_pointer x5)
{
  s7_pointer p;
  p = sc->elist_5;
  set_car(p, x1); p = cdr(p);
  set_car(p, x2); p = cdr(p);
  set_car(p, x3); p = cdr(p);
  set_car(p, x4); p = cdr(p);
  set_car(p, x5);
  return(sc->elist_5);
}

static s7_pointer set_wlist_3(s7_pointer lst, s7_pointer x1, s7_pointer x2, s7_pointer x3)
{
  s7_pointer p;
  p = lst;
  set_car(p, x1); p = cdr(p);
  set_car(p, x2); p = cdr(p);
  set_car(p, x3);
  return(lst);
}

static s7_pointer set_wlist_4(s7_pointer lst, s7_pointer x1, s7_pointer x2, s7_pointer x3, s7_pointer x4)
{
  s7_pointer p;
  p = lst;
  set_car(p, x1); p = cdr(p);
  set_car(p, x2); p = cdr(p);
  set_car(p, x3); p = cdr(p);
  set_car(p, x4);
  return(lst);
}

static s7_pointer set_plist_1(s7_scheme *sc, s7_pointer x1)
{
  set_car(sc->plist_1, x1);
  return(sc->plist_1);
}

static s7_pointer set_plist_2(s7_scheme *sc, s7_pointer x1, s7_pointer x2)
{
  set_car(sc->plist_2, x1);
  set_car(sc->plist_2_2, x2);
  return(sc->plist_2);
}

static s7_pointer set_qlist_2(s7_scheme *sc, s7_pointer x1, s7_pointer x2)
{
  set_car(sc->qlist_2, x1);
  set_cadr(sc->qlist_2, x2);
  return(sc->qlist_2);
}

static s7_pointer set_qlist_3(s7_scheme *sc, s7_pointer x1, s7_pointer x2, s7_pointer x3)
{
  set_car(sc->qlist_3, x1);
  set_cadr(sc->qlist_3, x2);
  set_caddr(sc->qlist_3, x3);
  return(sc->qlist_3);
}

static s7_pointer set_clist_1(s7_scheme *sc, s7_pointer x1)
{
  set_car(sc->clist_1, x1);
  return(sc->clist_1);
}

static s7_pointer set_plist_3(s7_scheme *sc, s7_pointer x1, s7_pointer x2, s7_pointer x3)
{
  return(set_wlist_3(sc->plist_3, x1, x2, x3));
}

static int32_t position_of(s7_pointer p, s7_pointer args)
{
  int32_t i;
  for (i = 1; p != args; i++, args = cdr(args));
  return(i);
}

s7_pointer s7_method(s7_scheme *sc, s7_pointer obj, s7_pointer method)
{
  if (has_active_methods(sc, obj))
    return(find_method(sc, find_let(sc, obj), method));
  return(sc->undefined);
}

/* if a method is shadowing a built-in like abs, it should expect the same args as abs and
 *   behave the same -- no multiple values etc.
 */
static s7_pointer copy_list(s7_scheme *sc, s7_pointer lst);

#define check_method(Sc, Obj, Method, Args)		\
  {							\
    s7_pointer func;					\
    if ((has_active_methods(sc, Obj)) &&				\
	((func = find_method(Sc, find_let(Sc, Obj), Method)) != Sc->undefined)) \
      return(s7_apply_function(Sc, func, copy_list(Sc, Args))); \
  }

#define check_method_uncopied(Sc, Obj, Method, Args)		\
  {							\
    s7_pointer func;					\
    if ((has_active_methods(sc, Obj)) &&				\
	((func = find_method(Sc, find_let(Sc, Obj), Method)) != Sc->undefined)) \
      return(s7_apply_function(Sc, func, Args)); \
  }

/* #define apply_known_method(Sc, Let, Method, Args) return(s7_apply_function(Sc, find_method(Sc, Let, Method), Args)) */

static s7_pointer apply_boolean_method(s7_scheme *sc, s7_pointer obj, s7_pointer method)
{
  s7_pointer func;
  func = find_method(sc, find_let(sc, obj), method);
  if (func == sc->undefined) return(sc->F);
  return(s7_apply_function(sc, func, list_1(sc, obj)));
}

static s7_pointer missing_method_error(s7_scheme *sc, s7_pointer method, s7_pointer obj)
{
  return(s7_error(sc, sc->missing_method_symbol, set_elist_3(sc, missing_method_string, method, obj)));
}

#define check_boolean_method(Sc, Checker, Method, Args)	       \
  {							       \
    s7_pointer p;					       \
    p = car(Args);					       \
    if (Checker(p)) return(Sc->T);			       \
    if (!has_active_methods(sc, p)) return(Sc->F);			       \
    return(apply_boolean_method(Sc, p, Method));	       \
  }

#define check_boolean_not_method(Sc, Checker, Method, Args)		\
  {									\
    s7_pointer p;							\
    p = lookup(sc, cadar(Args));			\
    if (Checker(p)) return(Sc->F);					\
    if (!has_active_methods(sc, p)) return(Sc->T);					\
    return((apply_boolean_method(Sc, p, Method) == sc->F) ? sc->T : sc->F); \
  }

static s7_pointer find_and_apply_method(s7_scheme *sc, s7_pointer lt, s7_pointer sym, s7_pointer args)
{
  s7_pointer func;
  func = find_method(sc, lt, sym);
  if (func != sc->undefined)
    return(s7_apply_function(sc, func, args));
  return(missing_method_error(sc, sym, lt));
}

static s7_pointer method_or_bust(s7_scheme *sc, s7_pointer obj, s7_pointer method, s7_pointer args, uint8_t typ, int32_t num)
{
  if (has_active_methods(sc, obj))
    return(find_and_apply_method(sc, find_let(sc, obj), method, args));
  return(wrong_type_argument(sc, method, num, obj, typ));
}

static s7_pointer immutable_object_error(s7_scheme *sc, s7_pointer info) {return(s7_error(sc, sc->error_symbol, info));}

static s7_pointer mutable_method_or_bust(s7_scheme *sc, s7_pointer obj, s7_pointer method, s7_pointer args, uint8_t typ, int32_t num)
{
  if (has_active_methods(sc, obj))
    return(find_and_apply_method(sc, find_let(sc, obj), method, args));
  if (type(obj) != typ)
    return(wrong_type_argument(sc, method, num, obj, typ));
  if (is_immutable(obj))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, method, obj)));
  return(wrong_type_argument(sc, method, num, obj, typ));
}

static s7_pointer method_or_bust_one_arg(s7_scheme *sc, s7_pointer obj, s7_pointer method, s7_pointer args, uint8_t typ)
{
  if (has_active_methods(sc, obj))
    return(find_and_apply_method(sc, find_let(sc, obj), method, args));
  return(simple_wrong_type_argument(sc, method, obj, typ));
}

static s7_pointer method_or_bust_with_type(s7_scheme *sc, s7_pointer obj, s7_pointer method, s7_pointer args, s7_pointer typ, int32_t num)
{
  if (has_active_methods(sc, obj))
    return(find_and_apply_method(sc, find_let(sc, obj), method, args));
  return(wrong_type_argument_with_type(sc, method, num, obj, typ));
}

static s7_pointer method_or_bust_with_type_one_arg(s7_scheme *sc, s7_pointer obj, s7_pointer method, s7_pointer args, s7_pointer typ)
{
  if (has_active_methods(sc, obj))
    return(find_and_apply_method(sc, find_let(sc, obj), method, args));
  return(simple_wrong_type_argument_with_type(sc, method, obj, typ));
}

#define eval_error_any(Sc, ErrType, ErrMsg, Len, Obj) return(s7_error(Sc, ErrType, set_elist_2(Sc, wrap_string(Sc, ErrMsg, Len), Obj)))
#define eval_error(Sc, ErrMsg, Len, Obj)              eval_error_any(Sc, Sc->syntax_error_symbol, ErrMsg, Len, Obj)
#define eval_type_error(Sc, ErrMsg, Len, Obj)         eval_error_any(Sc, Sc->wrong_type_arg_symbol, ErrMsg, Len, Obj)
#define eval_range_error(Sc, ErrMsg, Len, Obj)        eval_error_any(Sc, Sc->out_of_range_symbol, ErrMsg, Len, Obj)

#define eval_error_no_return(Sc, ErrType, ErrMsg, Len, Obj) \
  s7_error(Sc, ErrType, set_elist_2(Sc, wrap_string(Sc, ErrMsg, Len), Obj))

#define eval_error_with_caller(Sc, ErrMsg, Len, Caller, Obj)	\
  return(s7_error(Sc, Sc->syntax_error_symbol, set_elist_3(Sc, wrap_string(Sc, ErrMsg, Len), Caller, Obj)))

#define eval_error_with_caller2(Sc, ErrMsg, Len, Caller, Name, Obj)	\
  return(s7_error(Sc, Sc->syntax_error_symbol, set_elist_4(Sc, wrap_string(Sc, ErrMsg, Len), Caller, Name, Obj)))


/* -------------------------------- constants -------------------------------- */

s7_pointer s7_f(s7_scheme *sc) {return(sc->F);}
s7_pointer s7_t(s7_scheme *sc) {return(sc->T);}

s7_pointer s7_nil(s7_scheme *sc)             {return(sc->nil);}
bool s7_is_null(s7_scheme *sc, s7_pointer p) {return(is_null(p));}
static bool is_null_b(s7_pointer p)          {return(type(p) == T_NIL);}

s7_pointer s7_undefined(s7_scheme *sc)                {return(sc->undefined);}
s7_pointer s7_unspecified(s7_scheme *sc)              {return(sc->unspecified);}
bool s7_is_unspecified(s7_scheme *sc, s7_pointer val) {return(is_unspecified(val));}

static s7_pointer g_is_undefined(s7_scheme *sc, s7_pointer args)
{
  #define H_is_undefined "(undefined? val) returns #t if val is #<undefined> or its reader equivalent"
  #define Q_is_undefined sc->pl_bt
  check_boolean_method(sc, is_undefined, sc->is_undefined_symbol, args);
}

static s7_pointer g_is_unspecified(s7_scheme *sc, s7_pointer args)
{
  #define H_is_unspecified "(unspecified? val) returns #t if val is #<unspecified>"
  #define Q_is_unspecified sc->pl_bt
  check_boolean_method(sc, is_unspecified, sc->is_unspecified_symbol, args);
}


/* -------------------------------- eof-object? -------------------------------- */
s7_pointer eof_object = NULL;

s7_pointer s7_eof_object(s7_scheme *sc) {return(eof_object);}

static s7_pointer g_is_eof_object(s7_scheme *sc, s7_pointer args)
{
  #define H_is_eof_object "(eof-object? val) returns #t if val is the end-of-file object"
  #define Q_is_eof_object sc->pl_bt
  check_boolean_method(sc, is_eof, sc->is_eof_object_symbol, args);
}

static bool s7_is_eof_object(s7_pointer p) {return(p == eof_object);}


/* -------------------------------- not -------------------------------- */
static s7_pointer g_not(s7_scheme *sc, s7_pointer args)
{
  #define H_not "(not obj) returns #t if obj is #f, otherwise #t: (not ()) -> #f"
  #define Q_not sc->pl_bt
  return((car(args) == sc->F) ? sc->T : sc->F);
}

static bool not_b_7p(s7_scheme *sc, s7_pointer p) {return(p == sc->F);}

bool s7_boolean(s7_scheme *sc, s7_pointer x) {return(x != sc->F);}
s7_pointer s7_make_boolean(s7_scheme *sc, bool x) {return(make_boolean(sc, x));}


/* -------------------------------- boolean? -------------------------------- */
bool s7_is_boolean(s7_pointer x)
{
  return(type(x) == T_BOOLEAN);
}

static s7_pointer g_is_boolean(s7_scheme *sc, s7_pointer args)
{
  #define H_is_boolean "(boolean? obj) returns #t if obj is #f or #t: (boolean? ()) -> #f"
  #define Q_is_boolean sc->pl_bt
  check_boolean_method(sc, s7_is_boolean, sc->is_boolean_symbol, args);
}

/* -------------------------------- constant? -------------------------------- */
static inline bool is_constant_symbol(s7_scheme *sc, s7_pointer sym)
{
  if (is_immutable_symbol(sym))    /* for keywords */
    return(true);
  if (is_possibly_constant(sym))
    {
      s7_pointer slot;
      slot = symbol_to_slot(sc, sym);
      return((is_slot(slot)) && (is_immutable_slot(slot)));
    }
  return(false);
}

#define is_constant(sc, p) ((type(p) != T_SYMBOL) || (is_constant_symbol(sc, p)))

static s7_pointer g_is_constant(s7_scheme *sc, s7_pointer args)
{
  #define H_is_constant "(constant? obj) returns #t if obj either evaluates to itself, or is a symbol whose binding is constant"
  #define Q_is_constant sc->pl_bt
  return(make_boolean(sc, is_constant(sc, car(args))));
}

static s7_pointer is_constant_p_p(s7_scheme *sc, s7_pointer p) {return(make_boolean(sc, is_constant(sc, p)));}


/* -------------------------------- immutable? -------------------------------- */
bool s7_is_immutable(s7_pointer p)
{
  return(is_immutable(p));
}

static s7_pointer g_is_immutable(s7_scheme *sc, s7_pointer args)
{
  #define H_is_immutable "(immutable? sequence) returns #t if the sequence is immutable. (This function is work-in-progress)"
  #define Q_is_immutable sc->pl_bt
  return((is_immutable(car(args))) ? sc->T : sc->F);
}

/* -------------------------------- immutable! -------------------------------- */
s7_pointer s7_immutable(s7_pointer p)
{
  set_immutable(p);
  return(p);
}

static s7_pointer g_immutable(s7_scheme *sc, s7_pointer args)
{
  #define H_immutable "(immutable! sequence) declares that the sequence's entries can't be changed. The sequence is returned."
  #define Q_immutable s7_make_signature(sc, 2, sc->T, sc->T)
  s7_pointer p;
  p = car(args);
  if (is_symbol(p))
    {
      s7_pointer slot;
      slot = symbol_to_slot(sc, p);
      if (is_slot(slot))
	{
	  set_immutable(slot);
	  return(p);  /* symbol is not set immutable ? */
	}
    }
  return(s7_immutable(p));
}


/* -------------------------------- GC -------------------------------- */

/* in most code, pairs, lets, and slots dominate the heap -- each about 25% to 40% of the
 *   total cell allocations.  In snd-test, reals are 50%. slots need not be in the heap,
 *   but moving them out to their own free list was actually slower because we need (in that
 *   case) to manage them in the sweep process by tracking lets.
 */

#if S7_DEBUGGING
static s7_int s7_gc_protect_2(s7_scheme *sc, s7_pointer x, int32_t line)
{
  s7_int loc;
  loc = s7_gc_protect(sc, x);
  if (loc > 8192)
    {
      fprintf(stderr, "infinite loop or memory leak at line %d %s?\n", line, string_value(s7_object_to_string(sc, current_code(sc), false)));
      abort();
    }
  return(loc);
}
#define s7_gc_protect_1(Sc, X) s7_gc_protect_2(Sc, X, __LINE__)
#else
#define s7_gc_protect_1(Sc, X) s7_gc_protect(Sc, X)
#endif

static void resize_gc_protect(s7_scheme *sc)
{
  s7_int i, size, new_size;
  block_t *ob, *nb;
  size = sc->protected_objects_size;
  new_size = 2 * size;
  ob = vector_block(sc->protected_objects);
  nb = reallocate(sc, ob, new_size * sizeof(s7_pointer));
  block_info(nb) = NULL;
  vector_block(sc->protected_objects) = nb;
  vector_elements(sc->protected_objects) = (s7_pointer *)block_data(nb);
  vector_length(sc->protected_objects) = new_size;
  sc->protected_objects_size = new_size;
  sc->gpofl = (s7_int *)realloc(sc->gpofl, new_size * sizeof(s7_int));
  for (i = size; i < new_size; i++)
    {
      vector_element(sc->protected_objects, i) = sc->unused;
      sc->gpofl[++sc->gpofl_loc] = i;
    }
}

s7_inline s7_int s7_gc_protect(s7_scheme *sc, s7_pointer x)
{
  s7_int loc;
  if (sc->gpofl_loc < 0)
    resize_gc_protect(sc);
  loc = sc->gpofl[sc->gpofl_loc--];
  vector_element(sc->protected_objects, loc) = x;
  return(loc);
}

#if (!DISABLE_DEPRECATED)
void s7_gc_unprotect(s7_scheme *sc, s7_pointer x)
{
  s7_int i;
  for (i = 0; i < sc->protected_objects_size; i++)
    if (vector_element(sc->protected_objects, i) == x)
      {
	vector_element(sc->protected_objects, i) = sc->unused;
	sc->gpofl[++sc->gpofl_loc] = i;
	return;
      }
}
#endif

void s7_gc_unprotect_at(s7_scheme *sc, s7_int loc)
{
  if (loc < sc->protected_objects_size)
    {
      if (vector_element(sc->protected_objects, loc) != sc->unused)
	sc->gpofl[++sc->gpofl_loc] = loc;
      vector_element(sc->protected_objects, loc) = sc->unused;
    }
}

s7_pointer s7_gc_protected_at(s7_scheme *sc, s7_int loc)
{
  s7_pointer obj;

  obj = sc->unspecified;
  if (loc < sc->protected_objects_size)
    obj = vector_element(sc->protected_objects, loc);
  if (obj == sc->unused)
    return(sc->unspecified);

  return(obj);
}

#define gc_protected_at(Sc, Loc) vector_element(Sc->protected_objects, Loc)

static void (*mark_function[NUM_TYPES])(s7_pointer p);

void s7_mark(s7_pointer p)
{
  if (!is_marked(p))
    (*mark_function[unchecked_type(p)])(p);
}

static inline void gc_mark(s7_pointer p)
{
  if (!is_marked(p))
    (*mark_function[unchecked_type(p)])(p);
}

static inline void mark_slot(s7_pointer p)
{
  set_mark(p);
  gc_mark(slot_value(p));
  if (slot_has_setter(p))
    gc_mark(slot_setter(p));
  set_mark(slot_symbol(p));
}

static void mark_noop(s7_pointer p) {}

static void close_output_port(s7_scheme *sc, s7_pointer p);
static void remove_gensym_from_symbol_table(s7_scheme *sc, s7_pointer sym);
static void cull_weak_hash_table(s7_scheme *sc, s7_pointer table);

static void process_iterator(s7_scheme *sc, s7_pointer s1)
{
  if (is_weak_hash_iterator(s1))
    {
      s7_pointer h;
      clear_weak_hash_iterator(s1);
      h = iterator_sequence(s1);
      if (unchecked_type(h) == T_HASH_TABLE)
	{
#if S7_DEBUGGING
	  if (weak_hash_iters(h) == 0)
	    fprintf(stderr, "in gc weak has iters wrapping under!\n");
#endif
	  weak_hash_iters(h)--;
	}
    }
}

static void process_multivector(s7_scheme *sc, s7_pointer s1)
{
  vdims_t *info;
  info = vector_dimension_info(s1);  /* a multidimensional empty vector can have dimension info, wrapped vectors always have dimension info */
  if ((info) &&
      (info != sc->wrap_only))
    {
      if (vector_elements_should_be_freed(info)) /* a kludge for foreign code convenience */
	{
	  free(vector_elements(s1));
	  vector_elements_should_be_freed(info) = false;
	}
      liberate(sc, info);
      vector_set_dimension_info(s1, NULL);
    }
  liberate(sc, vector_block(s1));
}

static void process_input_port(s7_scheme *sc, s7_pointer s1)
{
  if (!port_is_closed(s1))
    {
      if (is_file_port(s1))
	{
	  if (port_file(s1))
	    {
	      fclose(port_file(s1));
	      port_file(s1) = NULL;
	    }
	}
      else
	{
	  if ((is_string_port(s1)) &&
	      (port_needs_unprotect(s1)))
	    {
	      s7_gc_unprotect_at(sc, port_gc_loc(s1));
	      port_needs_unprotect(s1) = false;
	    }
	}
    }
  if (port_needs_free(s1))
    {
      if (port_data(s1))
	{
	  liberate(sc, port_data_block(s1));
	  port_data_block(s1) = NULL;
	  port_data(s1) = NULL;
	  port_data_size(s1) = 0;
	}
      port_needs_free(s1) = false;
    }
  if (port_filename(s1))
    {
      liberate(sc, port_filename_block(s1));
      port_filename(s1) = NULL;
    }
  liberate(sc, port_block(s1));
}

static void process_output_port(s7_scheme *sc, s7_pointer s1)
{
  close_output_port(sc, s1); /* needed for free filename, etc */
  liberate(sc, port_block(s1));
  if (port_needs_free(s1))
    {
      if (port_data_block(s1))
	{
	  liberate(sc, port_data_block(s1));
	  port_data_block(s1) = NULL;
	}
      port_needs_free(s1) = false;
    }
}

static void process_continuation(s7_scheme *sc, s7_pointer s1)
{
  if (continuation_op_stack(s1))
    {
      free(continuation_op_stack(s1));
      continuation_op_stack(s1) = NULL;
    }
  liberate_block(sc, continuation_block(s1));
}

static void sweep(s7_scheme *sc)
{
  s7_int i, j;
  s7_pointer s1;
  gc_list *gp;

  #define process_gc_list(Code)			\
    if (gp->loc > 0)				\
      {						\
        for (i = 0, j = 0; i < gp->loc; i++)		\
          {						\
            s1 = gp->list[i];				\
            if (is_free_and_clear(s1))			\
              {						\
                Code;					\
              }						\
            else gp->list[j++] = s1;			\
          }						\
        gp->loc = j;					\
      }							\

  gp = sc->strings;
  process_gc_list(liberate(sc, string_block(s1)))

  gp = sc->gensyms;
  process_gc_list(remove_gensym_from_symbol_table(sc, s1); liberate(sc, gensym_block(s1)))
  if (gp->loc == 0) mark_function[T_SYMBOL] = mark_noop;

  gp = sc->unknowns;
  process_gc_list(free(unknown_name(s1)))

  gp = sc->c_objects;
  process_gc_list((*(c_object_free(sc, s1)))(c_object_value(s1)))

  gp = sc->lambdas;
  process_gc_list(liberate(sc, c_function_block(s1)))

  gp = sc->vectors;
  process_gc_list(liberate(sc, vector_block(s1)))

  gp = sc->multivectors;
  process_gc_list(process_multivector(sc, s1));

  gp = sc->hash_tables;
  if (gp->loc > 0)
    {
      for (i = 0, j = 0; i < gp->loc; i++)
	{
	  s1 = gp->list[i];
	  if (is_free_and_clear(s1))
	    free_hash_table(sc, s1);
	  else
	    {
	      if ((is_weak_hash_table(s1)) &&
		  (weak_hash_iters(s1) == 0))
		cull_weak_hash_table(sc, s1);
	      gp->list[j++] = s1;
	    }
	}
      gp->loc = j;
    }

  gp = sc->weak_hash_iterators;
  process_gc_list(process_iterator(sc, s1));

  gp = sc->input_ports;
  process_gc_list(process_input_port(sc, s1));

  gp = sc->output_ports;
  process_gc_list(process_output_port(sc, s1));

  gp = sc->continuations;
  process_gc_list(process_continuation(sc, s1));

  gp = sc->weak_refs;
  if (gp->loc > 0)
    {
      for (i = 0, j = 0; i < gp->loc; i++)
	{
	  s1 = gp->list[i];
	  if (!is_free_and_clear(s1))
	    {
	      if (is_free_and_clear(c_pointer_weak1(s1)))
		c_pointer_weak1(s1) = sc->F;
	      if (is_free_and_clear(c_pointer_weak2(s1)))
		c_pointer_weak2(s1) = sc->F;
	      if ((c_pointer_weak1(s1) != sc->F) ||
		  (c_pointer_weak2(s1) != sc->F))
		gp->list[j++] = s1;
	    }
	}
      gp->loc = j;
    }

#if WITH_GMP
  gp = sc->big_integers;
  process_gc_list(mpz_clear(big_integer(s1)))

  gp = sc->big_ratios;
  process_gc_list(mpq_clear(big_ratio(s1)))

  gp = sc->big_reals;
  process_gc_list(mpfr_clear(big_real(s1)))

  gp = sc->big_complexes;
  process_gc_list(mpc_clear(big_complex(s1)))

  gp = sc->big_random_states;
  process_gc_list(gmp_randclear(random_gmp_state(s1)))
#endif
}

static inline void add_to_gc_list(gc_list *gp, s7_pointer p)
{
  if (gp->loc == gp->size)
    {
      gp->size *= 2;
      gp->list = (s7_pointer *)realloc(gp->list, gp->size * sizeof(s7_pointer));
    }
  gp->list[gp->loc++] = p;
}

static gc_list *make_gc_list(void)
{
  gc_list *gp;
  #define INIT_GC_CACHE_SIZE 4
  gp = (gc_list *)malloc(sizeof(gc_list));
  gp->size = INIT_GC_CACHE_SIZE;
  gp->loc = 0;
  gp->list = (s7_pointer *)malloc(gp->size * sizeof(s7_pointer));
  return(gp);
}

static void just_mark(s7_pointer p)
{
  set_mark(p);
}

static void add_gensym(s7_scheme *sc, s7_pointer p)
{
  add_to_gc_list(sc->gensyms, p);
  mark_function[T_SYMBOL] = just_mark;
}

#define add_c_object(sc, p)      add_to_gc_list(sc->c_objects, p)
#define add_hash_table(sc, p)    add_to_gc_list(sc->hash_tables, p)
#define add_string(sc, p)        add_to_gc_list(sc->strings, p)
#define add_input_port(sc, p)    add_to_gc_list(sc->input_ports, p)
#define add_output_port(sc, p)   add_to_gc_list(sc->output_ports, p)
#define add_continuation(sc, p)  add_to_gc_list(sc->continuations, p)
#define add_unknown(sc, p)       add_to_gc_list(sc->unknowns, p)
#define add_vector(sc, p)        add_to_gc_list(sc->vectors, p)
#define add_multivector(sc, p)   add_to_gc_list(sc->multivectors, p)
#define add_lambda(sc, p)        add_to_gc_list(sc->lambdas, p)
#define add_weak_ref(sc, p)      add_to_gc_list(sc->weak_refs, p)
#define add_weak_hash_iterator(sc, p) add_to_gc_list(sc->weak_hash_iterators, p)

#if WITH_GMP
#define add_big_integer(sc, p)   add_to_gc_list(sc->big_integers, p)
#define add_big_ratio(sc, p)     add_to_gc_list(sc->big_ratios, p)
#define add_big_real(sc, p)      add_to_gc_list(sc->big_reals, p)
#define add_big_complex(sc, p)    add_to_gc_list(sc->big_complexes, p)
#define add_big_random_state(sc, p) add_to_gc_list(sc->big_random_states, p)
#endif

static void init_gc_caches(s7_scheme *sc)
{
  sc->strings = make_gc_list();
  sc->gensyms = make_gc_list();
  sc->unknowns = make_gc_list();
  sc->vectors = make_gc_list();
  sc->multivectors = make_gc_list();
  sc->hash_tables = make_gc_list();
  sc->input_ports = make_gc_list();
  sc->output_ports = make_gc_list();
  sc->continuations = make_gc_list();
  sc->c_objects = make_gc_list();
  sc->lambdas = make_gc_list();
  sc->weak_refs = make_gc_list();
  sc->weak_hash_iterators = make_gc_list();
#if WITH_GMP
  sc->big_integers = make_gc_list();
  sc->big_ratios = make_gc_list();
  sc->big_reals = make_gc_list();
  sc->big_complexes = make_gc_list();
  sc->big_random_states = make_gc_list();
#endif

  /* slightly unrelated... */
  sc->setters_size = 4;
  sc->setters_loc = 0;
  sc->setters = (s7_pointer *)malloc(sc->setters_size * sizeof(s7_pointer));
}

static void add_setter(s7_scheme *sc, s7_pointer p, s7_pointer setter)
{
  /* setters GC-protected. The c_function_setter field can't be used because the built-in functions
   *   are often removed from the heap and never thereafter marked.  Only closures and macros are protected here.
   */
  s7_int i;
#if S7_DEBUGGING
  if ((!is_any_closure(setter)) && (!is_any_macro(setter)))
    fprintf(stderr, "add_setter: %s %d?\n", DISPLAY(setter), type(setter));
#endif
  for (i = 0; i < sc->setters_loc; i++)
    {
      s7_pointer x;
      x = sc->setters[i];
      if (car(x) == p)
	{
	  set_cdr(x, setter);
	  return;
 	}
    }
  if (sc->setters_loc == sc->setters_size)
    {
      sc->setters_size *= 2;
      sc->setters = (s7_pointer *)realloc(sc->setters, sc->setters_size * sizeof(s7_pointer));
    }
  sc->setters[sc->setters_loc++] = permanent_cons(sc, p, setter, T_PAIR | T_IMMUTABLE);
}

static void mark_symbol_vector(s7_pointer p, s7_int len)
{
  set_mark(p);
  if (mark_function[T_SYMBOL] != mark_noop) /* else no gensyms */
    {
      s7_int i;
      s7_pointer *e;
      e = vector_elements(p);
      for (i = 0; i < len; i++)
	if (is_gensym(e[i]))
	  set_mark(e[i]);
    }
}

static void mark_simple_vector(s7_pointer p, s7_int len)
{
  s7_int i;
  s7_pointer *e;
  set_mark(p);
  e = vector_elements(p);
  for (i = 0; i < len; i++)
    set_mark(e[i]);
}

static void just_mark_vector(s7_pointer p, s7_int len)
{
  set_mark(p);
}

static void mark_vector_1(s7_pointer p, s7_int top)
{
  s7_pointer *tp, *tend, *tend4;

  set_mark(p);

  tp = (s7_pointer *)(vector_elements(p));
  if (!tp) return;
  tend = (s7_pointer *)(tp + top);

  tend4 = (s7_pointer *)(tend - 8);
  while (tp <= tend4)
    LOOP_8(gc_mark(*tp++));
  while (tp < tend)
    gc_mark(*tp++);
}

static void mark_let(s7_pointer env)
{
  s7_pointer x;
  for (x = env; is_let(x) && (!is_marked(x)); x = outlet(x))
    {
      s7_pointer y;
      set_mark(x);
      for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	if (!is_marked(y)) /* slot value might be the enclosing let */
	  mark_slot(y);
    }
}

static void mark_owlet(s7_scheme *sc)
{
  /* sc->error_type and friends are slots in owlet */
  mark_slot(sc->error_type);
  slot_set_value(sc->error_data, sc->F);
  mark_slot(sc->error_data);
  /* error_data is normally a permanent list with impermanent contents, so we have to traverse it explicitly
   *   mark_owlet is not called very often
   */
  mark_slot(sc->error_code);
  /* can sc->code be garbage at EVAL when sc->cur_code is set? or freed later by hand? */
  mark_slot(sc->error_line);
  mark_slot(sc->error_file);
#if WITH_HISTORY
  mark_slot(sc->error_history);
#endif
  set_mark(sc->owlet);
  mark_let(outlet(sc->owlet));
}

static void mark_c_pointer(s7_pointer p)
{
  set_mark(p);
  gc_mark(c_pointer_type(p));
  gc_mark(c_pointer_info(p));
}

static void mark_c_proc_star(s7_pointer p)
{
  set_mark(p);
  if (!c_func_has_simple_defaults(p))
    {
      s7_pointer arg;
      for (arg = c_function_call_args(p); is_pair(arg); arg = cdr(arg))
	gc_mark(car(arg));
    }
}

static void mark_pair(s7_pointer p)
{
  do {
    set_mark(p);
    gc_mark(car(p)); /* expanding this to avoid recursion is slower */
    p = cdr(p);
  } while ((is_pair(p)) && (!is_marked(p))); /* ((typeflag(p) & (TYPE_MASK | T_GC_MARK)) == T_PAIR) is much slower */
  gc_mark(p);
}
/* in snd-14 or so through 15.3, sc->temp_cell_2|3 were used for trailing args in eval, but that meant
 *   the !is_marked check below (which is intended to catch cyclic lists) caused cells to be missed;
 *   since sc->args could contain permanently marked cells, if these were passed to g_vector, for example, and
 *   make_vector_1 triggered a GC call, we needed to mark both the permanent (always marked) cell and its contents,
 *   and continue through the rest of the list.  But adding temp_cell_2|3 to sc->permanent_objects was not enough.
 *   Now I've already forgotten the rest of the story, and it was just an hour ago! -- the upshot is that temp_cell_2|3
 *   are not now used as arg list members.
 */

static void mark_counter(s7_pointer p)
{
  set_mark(p);
  gc_mark(counter_result(p));
  gc_mark(counter_list(p));
  gc_mark(counter_let(p));
}

static void mark_closure(s7_pointer p)
{
  set_mark(p);
  gc_mark(closure_args(p));
  gc_mark(closure_body(p));
  mark_let(closure_let(p));
  gc_mark(closure_setter_or_map_list(p));
}

static void mark_stack_1(s7_pointer p, s7_int top)
{
  s7_pointer *tp, *tend;
  set_mark(p);

  tp = (s7_pointer *)(stack_elements(p));
  if (!tp) return;
  tend = (s7_pointer *)(tp + top);

  while (tp < tend)
    {
      gc_mark(*tp++);
      gc_mark(*tp++);
      gc_mark(*tp++);
      tp++;
    }
}

static void mark_stack(s7_pointer p)
{
  /* we can have a bare stack waiting for a continuation to hold it if the new_cell for the continuation triggers the GC!  But we need a top-of-stack?? */
  mark_stack_1(p, temp_stack_top(p));
}

static void mark_continuation(s7_pointer p)
{
  uint32_t i;
  set_mark(p);
  if (!is_marked(continuation_stack(p))) /* can these be cyclic? */
    mark_stack_1(continuation_stack(p), continuation_stack_top(p));
  for (i = 0; i < continuation_op_loc(p); i++)
    gc_mark(continuation_op_stack(p)[i]);
}

static void mark_vector(s7_pointer p)
{
  if (is_typed_vector(p))
    c_function_marker(typed_vector_typer(p))(p, vector_length(p));
  else mark_vector_1(p, vector_length(p));
}

static void mark_vector_possibly_shared(s7_pointer p)
{
  /* If a subvector (an inner dimension) of a vector is the only remaining reference
   *    to the main vector, we want to make sure the main vector is not GC'd until
   *    the subvector is also GC-able.  The subvector field either points to the
   *    parent vector, or it is sc->F, so we need to check for a vector parent if
   *    the current is multidimensional (this will include 1-dim slices).  We need
   *    to keep the parent case separate (i.e. sc->F means the current is the original)
   *    so that we only free once (or remove_from_heap once).
   *
   * If we have a subvector of a subvector, and the middle and original are not otherwise
   *   in use, we mark the middle one, but (since it itself is not in use anywhere else)
   *   we don't mark the original!  So we need to follow the share-vector chain marking every one.
   *
   * To remove a cell from the heap, we need its current heap location so that we can replace it.
   *   The heap is allocated as needed in monolithic blocks of (say) 1/2M s7_cells. When a cell
   *   is replaced, the new cell (at heap[x] say) is no longer from the original block. Since the
   *   GC clears all type bits when it frees a cell, we can't use a type bit to distinguish the
   *   replacements from the originals, but we need that info because in the base case, we use
   *   the distance of the cell from the base cell to get "x", its location.  In the replacement
   *   case, we add the location at the end of the s7_cell (s7_big_cell).  We track the current
   *   heap blocks via the sc->heap_blocks list.  To get the location of "p" above, we run through
   *   that list looking for a block it fits in.  If none is found, we assume it is an s7_big_cell
   *   and use the saved location.
   */
  if (is_subvector(p))
    mark_vector_possibly_shared(subvector_vector(p));

  /* mark_vector_1 does not check the marked bit, so if subvector below is in a cycle involving
   *   the calling vector, we get infinite recursion unless we check the mark bit here.
   */
  if (!is_marked(p))
    mark_vector_1(p, vector_length(p));
}

static void mark_int_or_float_vector(s7_pointer p)
{
  set_mark(p);
}

static void mark_int_or_float_vector_possibly_shared(s7_pointer p)
{
  if (is_subvector(p))
    mark_int_or_float_vector_possibly_shared(subvector_vector(p));
  set_mark(p);
}

static void mark_c_object(s7_pointer p)
{
  set_mark(p);
  (*(c_object_mark(p)))(c_object_value(p));
}

static void mark_catch(s7_pointer p)
{
  set_mark(p);
  gc_mark(catch_tag(p));
  gc_mark(catch_handler(p));
}

static void mark_dynamic_wind(s7_pointer p)
{
  set_mark(p);
  gc_mark(dynamic_wind_in(p));
  gc_mark(dynamic_wind_out(p));
  gc_mark(dynamic_wind_body(p));
}

/* if is_typed_hash_table then if c_function_marker(key|value_typer) is just_mark_vector, we can ignore that field,
 *    if it's mark_simple_vector, we just set_mark (key|value), else we gc_mark
 */
static void mark_hash_table(s7_pointer p)
{
  set_mark(p);
  gc_mark(hash_table_procedures(p));
  if (hash_table_entries(p) > 0)
    {
      s7_int len;
      hash_entry_t **entries, **last;

      entries = hash_table_elements(p);
      len = hash_table_mask(p) + 1;
      last = (hash_entry_t **)(entries + len);

      if ((is_weak_hash_table(p)) &&
	  (weak_hash_iters(p) == 0))
	{
	  while (entries < last)
	    {
	      hash_entry_t *xp;
	      for (xp = *entries++; xp; xp = hash_entry_next(xp))
		gc_mark(hash_entry_value(xp));
	      for (xp = *entries++; xp; xp = hash_entry_next(xp))
		gc_mark(hash_entry_value(xp));
	    }
	}
      else
	{
	  while (entries < last) /* counting entries here was slightly faster */
	    {
	      hash_entry_t *xp;
	      for (xp = *entries++; xp; xp = hash_entry_next(xp))
		{
		  gc_mark(hash_entry_key(xp));
		  gc_mark(hash_entry_value(xp));
		}
	      for (xp = *entries++; xp; xp = hash_entry_next(xp))
		{
		  gc_mark(hash_entry_key(xp));
		  gc_mark(hash_entry_value(xp));
		}}}}
}

static void mark_iterator(s7_pointer p)
{
  set_mark(p);
  gc_mark(iterator_sequence(p));
  if (is_mark_seq(p))
    gc_mark(iterator_current(p));
}

static void mark_input_port(s7_pointer p)
{
  set_mark(p);
  set_mark(port_original_input_string(p));
}

#define clear_type(p) typeflag(p) = T_FREE

static void init_mark_functions(void)
{
  mark_function[T_FREE]                = mark_noop;
  mark_function[T_UNDEFINED]           = just_mark;
  mark_function[T_EOF_OBJECT]          = mark_noop;
  mark_function[T_UNSPECIFIED]         = mark_noop;
  mark_function[T_NIL]                 = mark_noop;
  mark_function[T_UNUSED]              = mark_noop;
  mark_function[T_BOOLEAN]             = mark_noop;
  mark_function[T_SYNTAX]              = mark_noop;
  mark_function[T_CHARACTER]           = mark_noop;
  mark_function[T_SYMBOL]              = mark_noop; /* this changes to just_mark when gensyms are in the heap */
  mark_function[T_STRING]              = just_mark;
  mark_function[T_BYTE_VECTOR]         = just_mark;
  mark_function[T_INTEGER]             = just_mark;
  mark_function[T_RATIO]               = just_mark;
  mark_function[T_REAL]                = just_mark;
  mark_function[T_COMPLEX]             = just_mark;
  mark_function[T_BIG_INTEGER]         = just_mark;
  mark_function[T_BIG_RATIO]           = just_mark;
  mark_function[T_BIG_REAL]            = just_mark;
  mark_function[T_BIG_COMPLEX]         = just_mark;
  mark_function[T_RANDOM_STATE]        = just_mark;
  mark_function[T_GOTO]                = just_mark;
  mark_function[T_OUTPUT_PORT]         = just_mark;
  mark_function[T_BAFFLE]              = just_mark;
  mark_function[T_C_MACRO]             = just_mark;
  mark_function[T_C_POINTER]           = mark_c_pointer;
  mark_function[T_C_FUNCTION]          = just_mark;
  mark_function[T_C_FUNCTION_STAR]     = just_mark;  /* changes to mark_c_proc_star if defaults involve an expression */
  mark_function[T_C_ANY_ARGS_FUNCTION] = just_mark;
  mark_function[T_C_OPT_ARGS_FUNCTION] = just_mark;
  mark_function[T_C_RST_ARGS_FUNCTION] = just_mark;
  mark_function[T_PAIR]                = mark_pair;
  mark_function[T_CLOSURE]             = mark_closure;
  mark_function[T_CLOSURE_STAR]        = mark_closure;
  mark_function[T_CONTINUATION]        = mark_continuation;
  mark_function[T_INPUT_PORT]          = mark_input_port;
  mark_function[T_VECTOR]              = mark_vector; /* this changes if subvector created (similarly below) */
  mark_function[T_INT_VECTOR]          = mark_int_or_float_vector;
  mark_function[T_FLOAT_VECTOR]        = mark_int_or_float_vector;
  mark_function[T_MACRO]               = mark_closure;
  mark_function[T_BACRO]               = mark_closure;
  mark_function[T_MACRO_STAR]          = mark_closure;
  mark_function[T_BACRO_STAR]          = mark_closure;
  mark_function[T_C_OBJECT]            = mark_c_object;
  mark_function[T_CATCH]               = mark_catch;
  mark_function[T_DYNAMIC_WIND]        = mark_dynamic_wind;
  mark_function[T_HASH_TABLE]          = mark_hash_table;
  mark_function[T_ITERATOR]            = mark_iterator;
  mark_function[T_LET]                 = mark_let;
  mark_function[T_STACK]               = mark_stack;
  mark_function[T_COUNTER]             = mark_counter;
  mark_function[T_SLOT]                = mark_slot;
}

static void mark_op_stack(s7_scheme *sc)
{
  s7_pointer *p, *tp;
  tp = sc->op_stack_now;
  p = sc->op_stack;
  while (p < tp)
    gc_mark(*p++);
}

static void mark_rootlet(s7_scheme *sc)
{
  s7_pointer ge;
  s7_pointer *tmp, *top;

  ge = sc->rootlet;
  tmp = rootlet_elements(ge);
  top = (s7_pointer *)(tmp + sc->rootlet_entries);

  set_mark(ge);
  while (tmp < top)
    gc_mark(slot_value(*tmp++));
  /* slot_setter is handled below with an explicit list -- more code than its worth probably */
  /* we're not marking slot_symbol above which makes me worry that a top-level gensym won't be protected
   *   (apply define (gensym) '(32)), then try to get the GC to clobber {gensym}-0,
   *   but I can't get it to break, so they must be protected somehow; apparently they are
   *   removed from the heap!  At least:
   *   (define-macro (defit) (let ((n (gensym))) `(define (,n) (format #t "fun")))) (defit)
   *   removes the function from the heap (protecting the gensym).
   */
}

/* arrays for permanent_objects are not needed yet: init: cells: 0, lets: 0, s7test: cells: 4, lets: 10, snd-test: cells: 14, lets: 1147 */

static void mark_permanent_objects(s7_scheme *sc)
{
  gc_obj *g;
  for (g = sc->permanent_objects; g; g = (gc_obj *)(g->nxt))
    gc_mark(g->p);
}

static void unmark_permanent_objects(s7_scheme *sc)
{
  gc_obj *g;
  for (g = sc->permanent_objects; g; g = (gc_obj *)(g->nxt))
    clear_mark(g->p);
  for (g = sc->permanent_lets; g; g = (gc_obj *)(g->nxt))
    clear_mark(g->p);
}


#if (!MS_WINDOWS)
  #include <time.h>
  #include <sys/time.h>
#endif

#if S7_DEBUGGING
static char *describe_type_bits(s7_scheme *sc, s7_pointer obj);
static bool has_odd_bits(s7_pointer obj);
#endif
void s7_show_let(s7_scheme *sc);

static int64_t gc(s7_scheme *sc)
{
  s7_cell **old_free_heap_top;
#if (!MS_WINDOWS)
  struct timeval start_time;
  struct timezone z0;
#endif

  /* mark all live objects (the symbol table is in permanent memory, not the heap) */

#if (!MS_WINDOWS)
  if (show_gc_stats(sc))
    gettimeofday(&start_time, &z0);
  /* this is apparently deprecated in favor of clock_gettime -- what compile-time switch to use here?
   *   _POSIX_TIMERS, or perhaps use CLOCK_REALTIME, but clock_gettime requires -lrt -- no thanks.
   */
#endif
  mark_rootlet(sc);
  if (sc->args) gc_mark(sc->args);
  mark_let(sc->envir);

  /* slot_set_value(sc->error_data, sc->F); */
  /* the other choice here is to explicitly mark slot_value(sc->error_data) as we do eval_history1/2 below.
   *    in both cases, the values are permanent lists that do not mark impermanent contents.
   *    this will need circular list checks, and can't depend on marked to exit early
   */
  /* mark_let(sc->owlet); */

#if WITH_HISTORY
  {
    s7_pointer p1, p2;
    for (p1 = sc->eval_history1, p2 = sc->eval_history2; ; p2 = cdr(p2))
      {
	gc_mark(car(p1));
	gc_mark(car(p2));
	p1 = cdr(p1);
	if (p1 == sc->eval_history1) break; /* these are circular lists */
      }
  }
#endif
  mark_owlet(sc);

  gc_mark(sc->code);
  mark_current_code(sc); /* probably redundant if with_history */
  mark_stack_1(sc->stack, s7_stack_top(sc));
  gc_mark(sc->u);
  gc_mark(sc->v);
  gc_mark(sc->w);
  gc_mark(sc->x);
  gc_mark(sc->y);
  gc_mark(sc->z);
  gc_mark(sc->value);

  gc_mark(sc->temp1);
  gc_mark(sc->temp2);
  gc_mark(sc->temp3);
  gc_mark(sc->temp4);
  gc_mark(sc->temp5);
  gc_mark(sc->temp6);
  gc_mark(sc->temp7);
  gc_mark(sc->temp8);
  gc_mark(sc->temp9);
  gc_mark(sc->temp10);
  {
    int32_t i;
    for (i = 0; i < T_TEMPS_SIZE; i++) {gc_mark(sc->t_temps[i]);}
  }
  set_mark(sc->input_port);
  gc_mark(sc->input_port_stack);
  set_mark(sc->output_port);
  set_mark(sc->error_port);
  gc_mark(sc->stacktrace_defaults);
  gc_mark(sc->autoload_table);
  gc_mark(sc->default_rng);

  /* permanent lists that might escape and therefore need GC protection */
  mark_pair(sc->temp_cell_1);
  mark_pair(sc->temp_cell_2);
  gc_mark(car(sc->t1_1));
  gc_mark(car(sc->t2_1)); gc_mark(car(sc->t2_2));
  gc_mark(car(sc->t3_1)); gc_mark(car(sc->t3_2)); gc_mark(car(sc->t3_3));
  gc_mark(car(sc->a4_1)); gc_mark(car(sc->a4_2)); gc_mark(car(sc->a4_3)); gc_mark(car(sc->a4_4));
  gc_mark(car(sc->plist_1));
  gc_mark(car(sc->clist_1));
  gc_mark(car(sc->plist_2)); gc_mark(cadr(sc->plist_2));
  gc_mark(car(sc->qlist_2)); gc_mark(cadr(sc->qlist_2));
  gc_mark(car(sc->qlist_3)); gc_mark(cadr(sc->qlist_3)); gc_mark(caddr(sc->qlist_3));
  gc_mark(sc->u1_1);

  {
    s7_pointer p;
    for (p = sc->wrong_type_arg_info; is_pair(p); p = cdr(p)) gc_mark(car(p));
    for (p = sc->simple_wrong_type_arg_info; is_pair(p); p = cdr(p)) gc_mark(car(p));
    for (p = sc->out_of_range_info; is_pair(p); p = cdr(p)) gc_mark(car(p));
    for (p = sc->simple_out_of_range_info; is_pair(p); p = cdr(p)) gc_mark(car(p));
    gc_mark(car(sc->elist_1));
    gc_mark(car(sc->elist_2));
    gc_mark(cadr(sc->elist_2));
    for (p = sc->plist_3; is_pair(p); p = cdr(p)) gc_mark(car(p));
    for (p = sc->elist_3; is_pair(p); p = cdr(p)) gc_mark(car(p));
    for (p = sc->elist_4; is_pair(p); p = cdr(p)) gc_mark(car(p));
    for (p = sc->elist_5; is_pair(p); p = cdr(p)) gc_mark(car(p));
  }

  {
    s7_int i;
    s7_pointer p;
    for (i = 1; i < NUM_SAFE_LISTS; i++)
      if ((is_pair(sc->safe_lists[i])) &&
	  (list_is_in_use(sc->safe_lists[i])))
	for (p = sc->safe_lists[i]; is_pair(p); p = cdr(p))
	  gc_mark(car(p));

    for (i = 0; i < sc->setters_loc; i++)
      gc_mark(cdr(sc->setters[i]));

    for (i = 0; i < sc->num_fdats; i++)
      if (sc->fdats[i])
	gc_mark(sc->fdats[i]->curly_arg);
  }
  mark_vector(sc->protected_objects);
  mark_vector(sc->protected_setters);
  set_mark(sc->protected_setter_symbols);

  /* now protect recent allocations using the free_heap cells above the current free_heap_top (if any).
   * cells above sc->free_heap_top might be malloc'd garbage (after heap reallocation), so we keep track of
   *   where the last actually freed cells were after the previous GC call.  We're trying to
   *   GC protect the previous GC_TEMPS_SIZE allocated pointers so that the caller doesn't have
   *   to gc-protect every temporary cell.
   * There's one remaining possible problem.  s7_remove_from_heap frees cells outside
   *   the GC and might push free_heap_top beyond its previous_free_heap_top, then
   *   an immediate explicit gc call might not see those temp cells.
   */
  {
    s7_pointer *tmps, *tmps_top;

    tmps = sc->free_heap_top;
    tmps_top = tmps + GC_TEMPS_SIZE;
    if (tmps_top > sc->previous_free_heap_top)
      tmps_top = sc->previous_free_heap_top;

    while (tmps < tmps_top)
      gc_mark(*tmps++);
  }
  mark_op_stack(sc);
  mark_permanent_objects(sc);

  /* free up all unmarked objects */
  old_free_heap_top = sc->free_heap_top;

  {
    s7_pointer *fp, *tp, *heap_top;
    fp = sc->free_heap_top;

    tp = sc->heap;
    heap_top = (s7_pointer *)(sc->heap + sc->heap_size);

#if S7_DEBUGGING
#define gc_call(P, Tp)							\
    p = (*tp++);							\
    if (is_marked(T_Any(p)))						\
      clear_mark(p);							\
    else								\
      {									\
        if (!is_free_and_clear(p))					\
          {								\
	    p->debugger_bits = 0; p->opt1_func = NULL; p->opt2_func = NULL; p->opt3_func = NULL; \
	    if (has_odd_bits(p))					\
	      {char *s; fprintf(stderr, "odd bits: %s\n", s = describe_type_bits(sc, p)); free(s);} \
            clear_type(p);						\
            (*fp++) = p;						\
          }}
#else
  #define gc_call(P, Tp) p = (*tp++); if (is_marked(p)) clear_mark(p); else {if (!is_free_and_clear(p)) {clear_type(p); (*fp++) = p;}}
#endif

    while (tp < heap_top)          /* != here or ^ makes no difference */
      {
	s7_pointer p;
	LOOP_8(gc_call(p, tp));
	LOOP_8(gc_call(p, tp));
	LOOP_8(gc_call(p, tp));
	LOOP_8(gc_call(p, tp));
      }

    sc->free_heap_top = fp;
    sweep(sc);
  }

  unmark_permanent_objects(sc);
  sc->gc_freed = (int64_t)(sc->free_heap_top - old_free_heap_top);

  if (show_gc_stats(sc))
    {
#if (!MS_WINDOWS)
      struct timeval t0;
      double secs;
      gettimeofday(&t0, &z0);
      secs = (t0.tv_sec - start_time.tv_sec) +  0.000001 * (t0.tv_usec - start_time.tv_usec);
      s7_warn(sc, 256, "gc freed %" print_s7_int "/%" print_s7_int " (free: %" print_pointer "), time: %f\n", sc->gc_freed, sc->heap_size, (intptr_t)(sc->free_heap_top - sc->free_heap), secs);
#else
      s7_warn(sc, 128, "gc freed %" print_s7_int "/%" print_s7_int "\n", sc->gc_freed, sc->heap_size);
#endif
    }
  sc->previous_free_heap_top = sc->free_heap_top;

  return(sc->gc_freed); /* needed by cell allocator to decide when to increase heap size */
}

void s7_gc_stats(s7_scheme *sc, bool on) {sc->gc_stats = (on) ? GC_STATS : 0;}

static void resize_heap_to(s7_scheme *sc, int64_t size)
{
  int64_t old_size, old_free, k;
  s7_cell *cells;
  s7_pointer p;
  heap_block_t *hp;

  old_size = sc->heap_size;
  old_free = sc->free_heap_top - sc->free_heap;

  if (size == 0)
    {
      if (sc->heap_size < 512000)
	sc->heap_size *= 2;
      else sc->heap_size += 512000;
    }
  else
    {
      if (size > sc->heap_size)
	while (sc->heap_size < size) sc->heap_size *= 2;
    }

  sc->heap = (s7_cell **)realloc(sc->heap, sc->heap_size * sizeof(s7_cell *));
  if (!(sc->heap))
    s7_warn(sc, 256, "heap reallocation failed! tried to get %" print_s7_int " bytes\n", (int64_t)(sc->heap_size * sizeof(s7_cell *)));

  sc->free_heap = (s7_cell **)realloc(sc->free_heap, sc->heap_size * sizeof(s7_cell *));
  if (!(sc->free_heap))
    s7_warn(sc, 256, "free heap reallocation failed! tried to get %" print_s7_int " bytes\n", (int64_t)(sc->heap_size * sizeof(s7_cell *)));

  sc->free_heap_trigger = (s7_cell **)(sc->free_heap + GC_TRIGGER_SIZE);
  sc->free_heap_top = sc->free_heap + old_free; /* incremented below, added old_free 21-Aug-12?!? */

  cells = (s7_cell *)calloc(sc->heap_size - old_size, sizeof(s7_cell));
  for (p = cells, k = old_size; k < sc->heap_size;)
    {
      LOOP_8(sc->heap[k++] = p; (*sc->free_heap_top++) = p++);
      LOOP_8(sc->heap[k++] = p; (*sc->free_heap_top++) = p++);
      LOOP_8(sc->heap[k++] = p; (*sc->free_heap_top++) = p++);
      LOOP_8(sc->heap[k++] = p; (*sc->free_heap_top++) = p++);
    }
  hp = (heap_block_t *)malloc(sizeof(heap_block_t));
  hp->start = (intptr_t)cells;
  hp->end = (intptr_t)cells + ((sc->heap_size - old_size) * sizeof(s7_cell));
  hp->offset = old_size;
  hp->next = sc->heap_blocks;
  sc->heap_blocks = hp;

  sc->previous_free_heap_top = sc->free_heap_top;

  if (show_heap_stats(sc))
    s7_warn(sc, 256, "heap grows to %" print_s7_int " (old free/size: %" print_s7_int "/%" print_s7_int ")\n", sc->heap_size, old_free, old_size);

  if (sc->heap_size >= sc->max_heap_size)
    {
#if S7_DEBUGGING
      fprintf(stderr, "heap %" print_s7_int ", %s\n", sc->heap_size, DISPLAY(current_code(sc)));
      s7_show_let(sc);
      abort();
#endif
      s7_error(sc, make_symbol(sc, "heap-too-big"), set_elist_1(sc, wrap_string(sc, "heap has grown past (*s7* 'max-heap-size)", 41)));
    }
}

#define resize_heap(Sc) resize_heap_to(Sc, 0)

static void try_to_call_gc(s7_scheme *sc)
{
  /* called only from new_cell */
  if (sc->gc_off)
    {
      /* we can't just return here!  Someone needs a new cell, and once the heap free list is exhausted, segfault */
      resize_heap(sc);
    }
  else
    {
#if (!S7_DEBUGGING)
      int64_t freed_heap;
      freed_heap = gc(sc);
      if ((freed_heap < sc->heap_size / 2) &&
	  (freed_heap < 1000000)) /* if huge heap */
	resize_heap(sc);
#else
      gc(sc);
      if ((int64_t)(sc->free_heap_top - sc->free_heap) < sc->heap_size / 2)
	resize_heap(sc);
#endif
    }
}
  /* originally I tried to mark each temporary value until I was done with it, but
   *   that way madness lies... By delaying GC of _every_ %$^#%@ pointer, I can dispense
   *   with hundreds of individual protections.  So the free_heap's last GC_TEMPS_SIZE
   *   allocated pointers are protected during the mark sweep.
   */

static s7_pointer g_gc(s7_scheme *sc, s7_pointer args)
{
  #define H_gc "(gc (on #t)) runs the garbage collector.  If 'on' is supplied, it turns the GC on or off. \
Evaluation produces a surprising amount of garbage, so don't leave the GC off for very long!"
  #define Q_gc s7_make_signature(sc, 2, sc->T, sc->is_boolean_symbol)

  /* g_gc can't be called in a situation where these lists matter (I think...) */
  set_elist_1(sc, sc->nil);
  set_plist_1(sc, sc->nil);
  set_elist_2(sc, sc->nil, sc->nil);
  set_plist_2(sc, sc->nil, sc->nil);
  set_clist_1(sc, sc->nil);
  set_qlist_2(sc, sc->nil, sc->nil);
  set_qlist_3(sc, sc->nil, sc->nil, sc->nil);
  set_elist_3(sc, sc->nil, sc->nil, sc->nil);
  set_plist_3(sc, sc->nil, sc->nil, sc->nil);
  set_elist_4(sc, sc->nil, sc->nil, sc->nil, sc->nil);
  set_elist_5(sc, sc->nil, sc->nil, sc->nil, sc->nil, sc->nil);

  if (is_not_null(args))
    {
      if (!s7_is_boolean(car(args)))
	return(method_or_bust_one_arg(sc, car(args), sc->gc_symbol, args, T_BOOLEAN));
      sc->gc_off = (car(args) == sc->F);
      if (sc->gc_off)
	return(sc->F);
    }
  gc(sc);
  return(sc->unspecified);
}

s7_pointer s7_gc_on(s7_scheme *sc, bool on)
{
  sc->gc_off = !on;
  return(s7_make_boolean(sc, on));
}

static void check_heap_size(s7_scheme *sc, s7_int size)
{
  s7_int free_cells;
  free_cells = sc->free_heap_top - sc->free_heap;
  if (free_cells < size)
    {
      gc(sc);
      while ((sc->free_heap_top - sc->free_heap) < size)
	resize_heap(sc);
    }
}

#define ALLOC_POINTER_SIZE 256
static s7_cell *alloc_pointer(s7_scheme *sc)
{
  if (sc->alloc_pointer_k == ALLOC_POINTER_SIZE)     /* if either no current block or the block is used up, make a new block */
    {
      sc->permanent_cells += ALLOC_POINTER_SIZE;
      sc->alloc_pointer_cells = (s7_cell *)calloc(ALLOC_POINTER_SIZE, sizeof(s7_cell));
      sc->alloc_pointer_k = 0;
    }
  return(&(sc->alloc_pointer_cells[sc->alloc_pointer_k++]));
}

#define ALLOC_BIG_POINTER_SIZE 256
static s7_big_cell *alloc_big_pointer(s7_scheme *sc, int64_t loc)
{
  s7_big_pointer p;
  if (sc->alloc_big_pointer_k == ALLOC_BIG_POINTER_SIZE)
    {
      sc->permanent_cells += ALLOC_BIG_POINTER_SIZE;
      sc->alloc_big_pointer_cells = (s7_big_cell *)calloc(ALLOC_BIG_POINTER_SIZE, sizeof(s7_big_cell));
      sc->alloc_big_pointer_k = 0;
    }
  p = (&(sc->alloc_big_pointer_cells[sc->alloc_big_pointer_k++]));
  p->big_hloc = loc;
  return(p);
}


static void add_permanent_object(s7_scheme *sc, s7_pointer obj)
{
  gc_obj *g;
  g = (gc_obj *)malloc(sizeof(gc_obj));
  g->p = obj;
  g->nxt = sc->permanent_objects;
  sc->permanent_objects = g;
}

static void add_permanent_let(s7_scheme *sc, s7_pointer obj)
{
  gc_obj *g;
  g = (gc_obj *)malloc(sizeof(gc_obj));
  g->p = obj;
  g->nxt = sc->permanent_lets;
  sc->permanent_lets = g;
}

#if S7_DEBUGGING
static const char *type_name_from_type(int32_t typ, int32_t article);

#define free_cell(Sc, P) free_cell_1(Sc, P, __LINE__)
static void free_cell_1(s7_scheme *sc, s7_pointer p, int32_t line)
#else
static void free_cell(s7_scheme *sc, s7_pointer p)
#endif
{
#if S7_DEBUGGING
  /* anything that needs gc_list attention should not be freed here */
  uint8_t typ;
  typ = unchecked_type(p);
  if ((t_freeze_p[typ]) || ((typ == T_SYMBOL) && (is_gensym(p))))
    fprintf(stderr, "free_cell of %s?\n", type_name_from_type(typ, 0));
  p->debugger_bits = 0;
  p->opt1_func = NULL;
  p->opt2_func = NULL;
  p->opt3_func = NULL;
  p->explicit_free_line = line;
#endif
  clear_type(p);
  (*(sc->free_heap_top++)) = p;
}

static void free_vlist(s7_scheme *sc, s7_pointer lst)
{
  if (is_pair(lst))
    {
      s7_pointer p, np;
      for (p = lst, np = cdr(lst); is_pair(p); p = np, np = unchecked_cdr(np))
	free_cell(sc, p);
    }
}

static int64_t heap_location(s7_scheme *sc, s7_pointer p)
{
  heap_block_t *hp;
  for (hp = sc->heap_blocks; hp; hp = hp->next)
    {
      if (((intptr_t)p >= hp->start) && ((intptr_t)p < hp->end))
	return(hp->offset + (((intptr_t)p - hp->start) / sizeof(s7_cell)));
    }
  return(((s7_big_pointer)p)->big_hloc);
}

#if S7_DEBUGGING
static void check_heap_location(s7_scheme *sc, s7_pointer x, int64_t loc, const char *func, int line)
{
  if ((in_heap(x)) && ((loc < 0) || (loc > sc->heap_size) || (sc->heap[loc] != x)))
    {
      s7_int i;
      char *s;
      heap_block_t *hp;
      fprintf(stderr, "%s[%d]: sc->heap[%" print_s7_int "] (%p) is not %p\n", func, line, loc, ((loc >= 0) && (loc < sc->heap_size)) ? sc->heap[loc] : NULL, x);
      for (i = 0; i < sc->heap_size; i++)
	if (sc->heap[i] == x)
	  break;
      if (i < sc->heap_size)
	fprintf(stderr, "  correct location: %" print_s7_int "\n", i);
      else fprintf(stderr, "  %p is not in the heap\n", x);
      fprintf(stderr, "  bits: %s\n", s = describe_type_bits(sc, x));
      free(s);
      fprintf(stderr, "blocks (x is %" print_s7_int ", big_hloc: %" print_s7_int "):\n", (intptr_t)x, ((s7_big_pointer)x)->big_hloc);
      for (hp = sc->heap_blocks; hp; hp = hp->next)
	{
	  fprintf(stderr, "  %" print_s7_int ": %" print_s7_int " to %" print_s7_int "\n", hp->offset, hp->start, hp->end);
	  if (((intptr_t)x >= hp->start) && ((intptr_t)x < hp->end))
	    fprintf(stderr, "   (found it here: %" print_s7_int "\n", hp->offset + (((intptr_t)x - hp->start) / sizeof(s7_cell)));
	}
      abort();
    }
}
#endif

#if S7_DEBUGGING
static int petrified_pointers = 0;
#endif

static inline s7_pointer petrify(s7_scheme *sc, s7_pointer x)
{
  s7_pointer p;
  int64_t loc;
  loc = heap_location(sc, x);
#if S7_DEBUGGING
  check_heap_location(sc, x, loc, __func__, __LINE__);
  petrified_pointers++;
#endif
  p = (s7_pointer)alloc_big_pointer(sc, loc);
  sc->heap[loc] = p;
  free_cell(sc, p);
  unheap(sc, x);
  return(x);
}

static inline void s7_remove_from_heap(s7_scheme *sc, s7_pointer x)
{
  /* global functions are very rarely redefined, so we can remove the function body from
   *   the heap when it is defined.  If redefined, we currently lose the memory held by the
   *   old definition.  (It is not trivial to recover this memory because it is allocated
   *   in blocks, not by the pointer, I think, but s7_define is the point to try).
   *
   * There is at least one problem with this: if, for example, a function has
   *    a quoted (constant) list, then uses list-set! to change an element of it,
   *    then a GC happens, and the new element is GC'd because no one in the heap
   *    points to it, then we call the function again, and it tries to access
   *    that element.
   *
   *    (define (bad-idea)
   *      (let ((lst '(1 2 3)))
   *        (let ((result (list-ref lst 1)))
   *          (list-set! lst 1 (* 2.0 16.6))
   *          (gc)
   *          result)))
   *
   *     put that in a file, load it (to force removal), then call bad-idea a few times.
   * so... if (*s7* 'safety) is not 0, remove-from-heap is disabled.
   */
  if (not_in_heap(x)) return;
  if (is_pair(x))
    {
      s7_pointer p;
      p = x;
      do {
	petrify(sc, p);
	s7_remove_from_heap(sc, car(p));
	p = cdr(p);
      } while (is_pair(p) && (in_heap(p)));
      if (in_heap(p)) petrify(sc, p);
      return;
    }

  switch (type(x))
    {
    case T_HASH_TABLE:
    case T_LET:
    case T_VECTOR:
      /* not int|float_vector or string because none of their elements are GC-able (so unheap below is ok)
       *   but hash-table and let seem like they need protection? And let does happen via define-class.
       */
      add_permanent_object(sc, x);
      return;

    case T_SYMBOL:
      if (is_gensym(x))
	{
	  s7_int i;
	  gc_list *gp;
	  int64_t loc;
	  loc = heap_location(sc, x);
#if S7_DEBUGGING
	  check_heap_location(sc, x, loc, __func__, __LINE__);
	  petrified_pointers++;
#endif
	  sc->heap[loc] = (s7_pointer)alloc_big_pointer(sc, loc);
	  free_cell(sc, sc->heap[loc]);
	  unheap(sc, x);

	  gp = sc->gensyms;
	  for (i = 0; i < gp->loc; i++) /* sc->gensyms reaches size 512 during s7test, but this search is called 3 times and costs nothing */
	    if (gp->list[i] == x)
	      {
		s7_int j;
		for (j = i + 1; i < gp->loc - 1; i++, j++)
		  gp->list[i] = gp->list[j];
		gp->list[i] = NULL;
		gp->loc--;
		if (gp->loc == 0) mark_function[T_SYMBOL] = mark_noop;
		break;
	      }
	}
      return;

    case T_CLOSURE: case T_CLOSURE_STAR:
    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
      return;

    default:
      break;
    }

  petrify(sc, x);
}


/* -------------------------------- stacks -------------------------------- */

#define OP_STACK_INITIAL_SIZE 8

#define stop_at_error true
#if S7_DEBUGGING

static void push_op_stack(s7_scheme *sc, s7_pointer op)
{
  (*sc->op_stack_now++) = T_Pos(op);
  if (sc->op_stack_now > (sc->op_stack + sc->op_stack_size))
    {
      fprintf(stderr, "%sop_stack overflow%s\n", BOLD_TEXT, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
}

static s7_pointer pop_op_stack(s7_scheme *sc)
{
  s7_pointer op;
  op = (*(--(sc->op_stack_now)));
  if (sc->op_stack_now < sc->op_stack)
    {
      fprintf(stderr, "%sop_stack underflow%s\n", BOLD_TEXT, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  return(T_Pos(op));
}
#else
#define push_op_stack(Sc, Op) (*Sc->op_stack_now++) = Op
#define pop_op_stack(Sc)      (*(--(Sc->op_stack_now)))
#endif

static void initialize_op_stack(s7_scheme *sc)
{
  int32_t i;
  sc->op_stack = (s7_pointer *)malloc(OP_STACK_INITIAL_SIZE * sizeof(s7_pointer));
  sc->op_stack_size = OP_STACK_INITIAL_SIZE;
  sc->op_stack_now = sc->op_stack;
  sc->op_stack_end = (s7_pointer *)(sc->op_stack + sc->op_stack_size);
  for (i = 0; i < OP_STACK_INITIAL_SIZE; i++)
    sc->op_stack[i] = sc->nil;
}

static void resize_op_stack(s7_scheme *sc)
{
  int32_t i, loc, new_size;
  loc = (int32_t)(sc->op_stack_now - sc->op_stack);
  new_size = sc->op_stack_size * 2;
  sc->op_stack = (s7_pointer *)realloc((void *)(sc->op_stack), new_size * sizeof(s7_pointer));
  for (i = sc->op_stack_size; i < new_size; i++)
    sc->op_stack[i] = sc->nil;
  sc->op_stack_size = (uint32_t)new_size;
  sc->op_stack_now = (s7_pointer *)(sc->op_stack + loc);
  sc->op_stack_end = (s7_pointer *)(sc->op_stack + sc->op_stack_size);
}

#define stack_code(Stack, Loc)  stack_element(Stack, Loc - 3)
#define stack_let(Stack, Loc)   stack_element(Stack, Loc - 2)
#define stack_args(Stack, Loc)  stack_element(Stack, Loc - 1)
#define stack_op(Stack, Loc)    ((opcode_t)(stack_element(Stack, Loc)))

#if S7_DEBUGGING
static void pop_stack(s7_scheme *sc)
{
  sc->stack_end -= 4;
  if (sc->stack_end < sc->stack_start)
    {
      fprintf(stderr, "%sstack underflow%s\n", BOLD_TEXT, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  /* here and in push_stack, both code and args might be non-free only because they've been retyped
   *   inline (as in named let) -- they actually don't make sense in these cases, but are ignored,
   *   and are carried around as GC protection in other cases.
   */
  sc->code =  T_Pos(sc->stack_end[0]);
  sc->envir = T_Lid(sc->stack_end[1]);
  sc->args =  T_Pos(sc->stack_end[2]);
  sc->cur_op = (opcode_t)(sc->stack_end[3]);

  if (sc->cur_op > OP_MAX_DEFINED)
    {
      fprintf(stderr, "%spop_stack[%d] invalid opcode: %" print_pointer " %s\n", BOLD_TEXT, __LINE__, sc->cur_op, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
}

static void pop_stack_no_op(s7_scheme *sc)
{
  sc->stack_end -= 4;
  if (sc->stack_end < sc->stack_start)
    {
      fprintf(stderr, "%sstack underflow%s\n", BOLD_TEXT, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  sc->code =  T_Pos(sc->stack_end[0]);
  sc->envir = T_Lid(sc->stack_end[1]);
  sc->args =  T_Pos(sc->stack_end[2]);
}

static void push_stack(s7_scheme *sc, opcode_t op, s7_pointer args, s7_pointer code)
{
  if (sc->stack_end >= sc->stack_start + sc->stack_size)
    {
      fprintf(stderr, "%sstack overflow%s\n", BOLD_TEXT, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  if (op > OP_MAX_DEFINED)
    {
      fprintf(stderr, "%spush_stack[%d] invalid opcode: %" print_pointer " %s\n", BOLD_TEXT, __LINE__, sc->cur_op, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  if (code) sc->stack_end[0] = T_Pos(code);
  sc->stack_end[1] = T_Lid(sc->envir);
  if (args) sc->stack_end[2] = T_Pos(args);
  sc->stack_end[3] = (s7_pointer)op;
  sc->stack_end += 4;
}

#define push_stack_no_code(Sc, Op, Args)        push_stack(Sc, Op, Args, sc->unused)
#define push_stack_no_let_no_code(Sc, Op, Args) push_stack(Sc, Op, Args, sc->unused)
#define push_stack_no_args(Sc, Op, Code)        push_stack(Sc, Op, sc->unused, Code)
#define push_stack_no_let(Sc, Op, Args, Code)   push_stack(Sc, Op, Args, Code)
#define push_stack_op(Sc, Op)                   push_stack(Sc, Op, sc->unused, sc->unused)
#define push_stack_op_let(Sc, Op)               push_stack(Sc, Op, sc->unused, sc->unused)
/* in the non-debugging case, the sc->unused's here are not set, so we can (later) pop free cells */

#else

#define pop_stack(Sc) do {Sc->stack_end -= 4; memcpy((void *)Sc, (void *)(Sc->stack_end), 4 * sizeof(s7_pointer));} while (0)
#define pop_stack_no_op(Sc) {Sc->stack_end -= 4; memcpy((void *)Sc, (void *)(Sc->stack_end), 3 * sizeof(s7_pointer));} while (0)

#define push_stack(Sc, Op, Args, Code) \
  do { \
      Sc->stack_end[0] = Code; \
      Sc->stack_end[1] = Sc->envir; \
      Sc->stack_end[2] = Args; \
      Sc->stack_end[3] = (s7_pointer)Op; \
      Sc->stack_end += 4; \
  } while (0)

#define push_stack_no_code(Sc, Op, Args) \
  do { \
      Sc->stack_end[1] = Sc->envir; \
      Sc->stack_end[2] = Args; \
      Sc->stack_end[3] = (s7_pointer)Op; \
      Sc->stack_end += 4; \
  } while (0)

#define push_stack_no_let_no_code(Sc, Op, Args) \
  do { \
      Sc->stack_end[2] = Args; \
      Sc->stack_end[3] = (s7_pointer)Op; \
      Sc->stack_end += 4; \
  } while (0)

#define push_stack_no_args(Sc, Op, Code) \
  do { \
      Sc->stack_end[0] = Code; \
      Sc->stack_end[1] = Sc->envir; \
      Sc->stack_end[3] = (s7_pointer)Op; \
      Sc->stack_end += 4; \
  } while (0)

#define push_stack_no_let(Sc, Op, Args, Code) \
  do { \
      Sc->stack_end[0] = Code; \
      Sc->stack_end[2] = Args; \
      Sc->stack_end[3] = (s7_pointer)Op; \
      Sc->stack_end += 4; \
  } while (0)

#define push_stack_op(Sc, Op) \
  do { \
      Sc->stack_end[3] = (s7_pointer)Op; \
      Sc->stack_end += 4; \
  } while (0)

#define push_stack_op_let(Sc, Op) \
  do { \
      Sc->stack_end[1] = Sc->envir; \
      Sc->stack_end[3] = (s7_pointer)Op; \
      Sc->stack_end += 4; \
  } while (0)
#endif
/* since we don't GC mark the stack past the stack_top, push_stack_no_args and friends can cause pop_stack to set
 *   sc->code and sc->args to currently free objects.
 */

#define main_stack_op(Sc)   ((opcode_t)(Sc->stack_end[-1]))
/* #define main_stack_args(Sc) (Sc->stack_end[-2]) */
/* #define main_stack_let(Sc)  (Sc->stack_end[-3]) */
/* #define main_stack_code(Sc) (Sc->stack_end[-4]) */
/* #define pop_main_stack(Sc)  Sc->stack_end -= 4 */

/* beware of main_stack_code!  If a function has a tail-call, the main_stack_code that form sees
 *   if main_stack_op==op-begin1 can change from call to call -- the begin actually refers
 *   to the caller, which is dependent on where the current function was called, so we can't hard-wire
 *   any optimizations based on that sequence.
 */

static void stack_reset(s7_scheme *sc)
{
  sc->stack_end = sc->stack_start;
  push_stack_op(sc, OP_EVAL_DONE);
  push_stack_op(sc, OP_BARRIER);
}

static void resize_stack(s7_scheme *sc)
{
  uint64_t loc;
  uint32_t new_size;
  block_t *ob, *nb;

  loc = s7_stack_top(sc);
  new_size = sc->stack_size * 2;

  /* how can we trap infinite recursion?  Is a warning in order here? I think I'll add 'max-stack-size */
  if (new_size > sc->max_stack_size)
    s7_error(sc, make_symbol(sc, "stack-too-big"), set_elist_1(sc, wrap_string(sc, "stack has grown past (*s7* 'max-stack-size)", 43)));

  ob = stack_block(sc->stack);
  nb = reallocate(sc, ob, new_size * sizeof(s7_pointer));
  block_info(nb) = NULL;
  stack_block(sc->stack) = nb;
  stack_elements(sc->stack) = (s7_pointer *)block_data(nb);
  if (!stack_elements(sc->stack))
    {
      s7_warn(sc, 32, "can't allocate additional stack\n");
#if S7_DEBUGGING
      abort();
#endif
      s7_error(sc, make_symbol(sc, "stack-too-big"), set_elist_1(sc, wrap_string(sc, "no room to expand stack?", 24)));
    }
  {
    s7_pointer *orig;
    s7_int i, left;
    i = sc->stack_size;
    left = new_size - i - 8;
    orig = stack_elements(sc->stack);
    while (i <= left)
      LOOP_8(orig[i++] = sc->nil);
    for (; i < new_size; i++)
      orig[i] = sc->nil;
  }
  vector_length(sc->stack) = new_size;
  sc->stack_size = new_size;

  sc->stack_start = stack_elements(sc->stack);
  sc->stack_end = (s7_pointer *)(sc->stack_start + loc);
  sc->stack_resize_trigger = (s7_pointer *)(sc->stack_start + sc->stack_size / 2);

  if (show_stack_stats(sc))
    {
      s7_warn(sc, 128, "stack grows to %u, %s\n", new_size, DISPLAY_80(sc->code));
      s7_show_let(sc);
    }
}

#define check_stack_size(Sc) do {if (Sc->stack_end >= Sc->stack_resize_trigger) resize_stack(Sc);} while (0)

s7_pointer s7_gc_protect_via_stack(s7_scheme *sc, s7_pointer x)
{
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, x);
  return(x);
}


/* -------------------------------- symbols -------------------------------- */

static inline uint64_t raw_string_hash(const uint8_t *key, s7_int len)
{
  uint64_t x;
  uint8_t *cx = (uint8_t *)&x;
  x = 0;
  if (len <= 8)
    memcpy((void *)cx, (void *)key, len);
  else
    {
      uint64_t y;
      uint8_t *cy = (uint8_t *)&y;
      memcpy((void *)cx, (void *)key, 8);
      y = 0;
      len -= 8;
      memcpy((void *)cy, (void *)(key + 8), (len > 8) ? 8 : len);
      x += y;  /* better than |= but still not great if (for example) > 1B gensyms -- maybe add z? */
    }
  return(x);
}

static uint8_t *alloc_symbol(s7_scheme *sc)
{
  #define SYMBOL_SIZE (3 * sizeof(s7_cell) + sizeof(block_t))
  #define ALLOC_SYMBOL_SIZE (64 * SYMBOL_SIZE)
  uint8_t *result;

  if (sc->alloc_symbol_k == ALLOC_SYMBOL_SIZE)
    {
      sc->alloc_symbol_cells = (uint8_t *)malloc(ALLOC_SYMBOL_SIZE);
      sc->alloc_symbol_k = 0;
    }
  result = &(sc->alloc_symbol_cells[sc->alloc_symbol_k]);
  sc->alloc_symbol_k += SYMBOL_SIZE;
  return(result);
}

static s7_pointer permanent_slot(s7_scheme *sc, s7_pointer symbol, s7_pointer value);

static inline s7_pointer new_symbol(s7_scheme *sc, const char *name, s7_int len, uint64_t hash, uint32_t location)
{
  /* name might not be null-terminated, these are permanent symbols even in s7_gensym; g_gensym handles everything separately */
  s7_pointer x, str, p;
  uint8_t *base, *val;

  base = alloc_symbol(sc);
  x = (s7_pointer)base;
  str = (s7_pointer)(base + sizeof(s7_cell));
  p = (s7_pointer)(base + 2 * sizeof(s7_cell));
  val = (uint8_t *)alloc_permanent_string(sc, len + 1);
  memcpy((void *)val, (void *)name, len);
  val[len] = '\0';

  typeflag(str) = T_STRING | T_IMMUTABLE | T_UNHEAP;       /* avoid debugging confusion involving set_type (also below) */
  string_length(str) = len;
  string_value(str) = (char *)val;
  string_hash(str) = hash;

  typeflag(x) = T_SYMBOL | T_UNHEAP;
  symbol_set_name_cell(x, str);
  set_global_slot(x, sc->undefined);                       /* was sc->nil */
  symbol_info(x) = (block_t *)(base + 3 * sizeof(s7_cell));
  set_initial_slot(x, sc->undefined);
  symbol_set_local_unchecked(x, 0LL, sc->nil);
  symbol_set_tag(x, 0);
  symbol_set_tag2(x, 0);
  symbol_set_ctr(x, 0);
  symbol_set_type(x, 0);

  if (len > 1)                                             /* not 0, otherwise : is a keyword */
    {
      if ((name[0] == ':') || (name[len - 1] == ':'))
	{
	  s7_pointer slot, ksym;
	  set_type_bit(x, T_IMMUTABLE | T_KEYWORD | T_GLOBAL);
	  ksym = make_symbol_with_length(sc, (name[0] == ':') ? (char *)(name + 1) : name, len - 1);
	  keyword_set_symbol(x, ksym);
	  set_has_keyword(ksym);
	  /* the keyword symbol needs to be permanent (not a gensym) else we have to laboriously gc-protect it */
	  if ((is_gensym(ksym)) &&
	      (in_heap(ksym)))
	    s7_remove_from_heap(sc, ksym);
	  slot = permanent_slot(sc, x, x);
	  set_global_slot(x, slot);
	  set_local_slot(x, slot);
	}
    }
  typeflag(p) = T_PAIR | T_IMMUTABLE | T_UNHEAP;
  set_car(p, x);
  set_cdr(p, vector_element(sc->symbol_table, location));
  vector_element(sc->symbol_table, location) = p;
  pair_set_raw_hash(p, hash);
  pair_set_raw_len(p, (uint32_t)len); /* symbol name length, so it ought to fit! */
  pair_set_raw_name(p, string_value(str));

  return(x);
}

static inline s7_pointer make_symbol_with_length(s7_scheme *sc, const char *name, s7_int len)
{
  s7_pointer x;
  uint64_t hash;
  uint32_t location;

  hash = raw_string_hash((const uint8_t *)name, len);
  location = hash % SYMBOL_TABLE_SIZE;

  if (len <= 8)
    {
      for (x = vector_element(sc->symbol_table, location); is_pair(x); x = cdr(x))
	if ((hash == pair_raw_hash(x)) &&
	    (len == pair_raw_len(x)))
	  return(car(x));
    }
  else
    {
      for (x = vector_element(sc->symbol_table, location); is_pair(x); x = cdr(x))
	if ((hash == pair_raw_hash(x)) &&
	    (len == pair_raw_len(x)) &&
	    (strings_are_equal_with_length(name, pair_raw_name(x), len))) /* length here because name might not be null-terminated */
	  return(car(x));
    }
  return(new_symbol(sc, name, len, hash, location));
}

static s7_pointer make_symbol(s7_scheme *sc, const char *name)
{
  return(make_symbol_with_length(sc, name, safe_strlen(name)));
}

s7_pointer s7_make_symbol(s7_scheme *sc, const char *name)
{
  if (!name) return(sc->F);
  return(make_symbol_with_length(sc, name, safe_strlen(name)));
}

static s7_pointer symbol_table_find_by_name(s7_scheme *sc, const char *name, uint64_t hash, uint32_t location)
{
  s7_pointer x;
  for (x = vector_element(sc->symbol_table, location); is_not_null(x); x = cdr(x))
    if ((hash == pair_raw_hash(x)) &&
	(strings_are_equal(name, pair_raw_name(x))))
      return(car(x));
  return(sc->nil);
}

s7_pointer s7_symbol_table_find_name(s7_scheme *sc, const char *name)
{
  uint64_t hash;
  uint32_t location;
  s7_pointer result;

  hash = raw_string_hash((const uint8_t *)name, safe_strlen(name));
  location = hash % SYMBOL_TABLE_SIZE;
  result = symbol_table_find_by_name(sc, name, hash, location);
  if (is_null(result))
    return(NULL);

  return(result);
}

#define FILLED true
#define NOT_FILLED false


/* -------------------------------- symbol-table -------------------------------- */
static s7_pointer g_symbol_table(s7_scheme *sc, s7_pointer args)
{
  #define H_symbol_table "(symbol-table) returns a vector containing the current symbol-table symbols"
  #define Q_symbol_table s7_make_signature(sc, 1, sc->is_vector_symbol)

  s7_pointer lst, x;
  s7_pointer *els;
  int32_t i, j, syms = 0;

  /* this can't be optimized by returning the actual symbol-table (a vector of lists), because
   *    gensyms can cause the table's lists and symbols to change at any time.  This wreaks havoc
   *    on traversals like for-each.  So, symbol-table returns a snap-shot of the table contents
   *    at the time it is called, and we call gc before making the list.  I suppose the next step
   *    is to check that we have room, and increase the heap here if necessary!
   *
   *    (define (for-each-symbol func num) (for-each (lambda (sym) (if (> num 0) (for-each-symbol func (- num 1)) (func sym))) (symbol-table)))
   *    (for-each-symbol (lambda (sym) (gensym) 1))
   */

  for (i = 0; i < SYMBOL_TABLE_SIZE; i++)
    for (x = vector_element(sc->symbol_table, i); is_not_null(x); x = cdr(x))
      syms++;
  sc->w = make_simple_vector(sc, syms);
  els = vector_elements(sc->w);

  for (i = 0, j = 0; i < SYMBOL_TABLE_SIZE; i++)
    for (x = vector_element(sc->symbol_table, i); is_not_null(x); x = cdr(x))
      els[j++] = car(x);

  lst = sc->w;
  sc->w = sc->nil;
  return(lst);
}

bool s7_for_each_symbol_name(s7_scheme *sc, bool (*symbol_func)(const char *symbol_name, void *data), void *data)
{
  /* this includes the special constants #<unspecified> and so on for simplicity -- are there any others? */
  int32_t i;
  s7_pointer x;

  for (i = 0; i < SYMBOL_TABLE_SIZE; i++)
    for (x = vector_element(sc->symbol_table, i); is_not_null(x); x = cdr(x))
      if (symbol_func(symbol_name(car(x)), data))
	return(true);

  return((symbol_func("#t", data))             ||
	 (symbol_func("#f", data))             ||
	 (symbol_func("#<unspecified>", data)) ||
	 (symbol_func("#<undefined>", data))   ||
	 (symbol_func("#<eof>", data))         ||
	 (symbol_func("#true", data))          ||
	 (symbol_func("#false", data)));
}

bool s7_for_each_symbol(s7_scheme *sc, bool (*symbol_func)(const char *symbol_name, void *data), void *data)
{
  int32_t i;
  s7_pointer x;

  for (i = 0; i < SYMBOL_TABLE_SIZE; i++)
    for (x = vector_element(sc->symbol_table, i); is_not_null(x); x = cdr(x))
      if (symbol_func(symbol_name(car(x)), data))
	return(true);

  return(false);
}

/* -------------------------------- gensym -------------------------------- */
static void remove_gensym_from_symbol_table(s7_scheme *sc, s7_pointer sym)
{
  /* sym is a free cell at this point (we're called after the GC), but the name_cell is still intact */
  s7_pointer x, name;
  uint32_t location;

  name = symbol_name_cell(sym);
  location = string_hash(name) % SYMBOL_TABLE_SIZE;
  x = vector_element(sc->symbol_table, location);

  if (car(x) == sym)
    vector_element(sc->symbol_table, location) = cdr(x);
  else
    {
      s7_pointer y;
	for (y = x, x = cdr(x); is_pair(x); y = x, x = cdr(x))
	if (car(x) == sym)
	  {
	    set_cdr(y, cdr(x));
	    return;
	  }
#if S7_DEBUGGING
      fprintf(stderr, "could not remove %s?\n", string_value(name));
#endif
    }
}

s7_pointer s7_gensym(s7_scheme *sc, const char *prefix)
{
  block_t *b;
  char *name;
  uint32_t location;
  s7_int len;
  uint64_t hash;
  s7_pointer x;

  len = safe_strlen(prefix) + 32;
  b = mallocate(sc, len);
  name = (char *)block_data(b);
  /* there's no point in heroic efforts here to avoid name collisions -- the user can screw up no matter what we do */
  name[0] = '\0';
  len = catstrs(name, len, "{", (prefix) ? prefix : "", "}-", pos_int_to_str_direct(sc, sc->gensym_counter++), NULL);
  hash = raw_string_hash((const uint8_t *)name, len);
  location = hash % SYMBOL_TABLE_SIZE;
  x = new_symbol(sc, name, len, hash, location);  /* not T_GENSYM -- might be called from outside */
  liberate(sc, b);
  return(x);
}

static bool s7_is_gensym(s7_pointer g) {return((is_symbol(g)) && (is_gensym(g)));}

static s7_pointer g_is_gensym(s7_scheme *sc, s7_pointer args)
{
  #define H_is_gensym "(gensym? sym) returns #t if sym is a gensym"
  #define Q_is_gensym sc->pl_bt

  check_boolean_method(sc, s7_is_gensym, sc->is_gensym_symbol, args);
}

static s7_pointer g_gensym(s7_scheme *sc, s7_pointer args)
{
  #define H_gensym "(gensym (prefix \"gensym\")) returns a new, unused symbol"
  #define Q_gensym s7_make_signature(sc, 2, sc->is_gensym_symbol, sc->is_string_symbol)

  const char *prefix;
  char *name, *p, *base;
  s7_int len, plen, nlen;
  uint32_t location;
  uint64_t hash;
  s7_pointer x, str, stc;
  block_t *b, *ib;

  /* get symbol name */
  if (is_not_null(args))
    {
      s7_pointer gname;
      gname = car(args);
      if (!is_string(gname))
	return(method_or_bust_one_arg(sc, gname, sc->gensym_symbol, args, T_STRING));
      prefix = string_value(gname);
      plen = safe_strlen(prefix);
    }
  else
    {
      prefix = "gensym";
      plen = 6;
    }
  len = plen + 32; /* why 32 -- we need room for the gensym_counter integer, but (length "9223372036854775807") = 19 */

  b = mallocate(sc, len + sizeof(block_t) + 2 * sizeof(s7_cell));
  /* only 16 of block_t size is actually needed here because only the ln.tag (symbol_tag2) field is used in the embedded block_t */
  base = (char *)block_data(b);
  str = (s7_cell *)base;
  stc = (s7_cell *)(base + sizeof(s7_cell));
  ib = (block_t *)(base + 2 * sizeof(s7_cell));
  name = (char *)(base + sizeof(block_t) + 2 * sizeof(s7_cell));

  name[0] = '{';
  if (plen > 0) memcpy((void *)(name + 1), prefix, plen);
  name[plen + 1] = '}';
  name[plen + 2] = '-'; /* {gensym}-nnn */

  p = pos_int_to_str(sc, sc->gensym_counter++, &len, '\0');
  memcpy((void *)(name + plen + 3), (void *)p, len);
  nlen = len + plen + 2;

  hash = raw_string_hash((const uint8_t *)name, nlen);
  location = hash % SYMBOL_TABLE_SIZE;

  /* make-string for symbol name */
#if S7_DEBUGGING
  typeflag(str) = 0; /* here and below, this is needed to avoid set_type check errors (mallocate above) */
#endif
  set_type(str, T_STRING | T_IMMUTABLE | T_UNHEAP);
  string_length(str) = nlen;
  string_value(str) = name;
  string_hash(str) = hash;

  /* allocate the symbol in the heap so GC'd when inaccessible */
  new_cell(sc, x, T_SYMBOL | T_GENSYM);
  symbol_set_name_cell(x, str);
  symbol_info(x) = ib;
  set_global_slot(x, sc->undefined);
  /* set_initial_slot(x, sc->undefined); */
  symbol_set_local_unchecked(x, 0LL, sc->nil);
  symbol_set_ctr(x, 0);
  symbol_set_tag(x, 0);
  symbol_set_tag2(x, 0);
  gensym_block(x) = b;

  /* place new symbol in symbol-table, but using calloc so we can easily free it (remove it from the table) in GC sweep */
#if S7_DEBUGGING
  typeflag(stc) = 0;
#endif
  set_type(stc, T_PAIR | T_IMMUTABLE | T_UNHEAP);
  set_car(stc, x);
  set_cdr(stc, vector_element(sc->symbol_table, location));
  vector_element(sc->symbol_table, location) = stc;
  pair_set_raw_hash(stc, hash);
  pair_set_raw_len(stc, (uint32_t)string_length(str));
  pair_set_raw_name(stc, string_value(str));

  add_gensym(sc, x);
  return(x);
}


/* -------------------------------- syntax? -------------------------------- */
bool s7_is_syntax(s7_pointer p) {return(is_syntax(p));}

static s7_pointer g_is_syntax(s7_scheme *sc, s7_pointer args)
{
  #define H_is_syntax "(syntax? obj) returns #t if obj is a syntactic value (e.g. lambda)"
  #define Q_is_syntax sc->pl_bt

  check_boolean_method(sc, is_syntax, sc->is_syntax_symbol, args);
}


/* -------------------------------- symbol? -------------------------------- */
bool s7_is_symbol(s7_pointer p) {return(is_symbol(p));}

static s7_pointer g_is_symbol(s7_scheme *sc, s7_pointer args)
{
  #define H_is_symbol "(symbol? obj) returns #t if obj is a symbol"
  #define Q_is_symbol sc->pl_bt

  check_boolean_method(sc, is_symbol, sc->is_symbol_symbol, args);
}

const char *s7_symbol_name(s7_pointer p) {return(symbol_name(p));}

s7_pointer s7_name_to_value(s7_scheme *sc, const char *name)
{
  return(s7_symbol_value(sc, make_symbol(sc, name)));
}


/* -------------------------------- symbol->string -------------------------------- */
static inline s7_pointer make_string_with_length(s7_scheme *sc, const char *str, s7_int len)
{
  s7_pointer x;
  new_cell(sc, x, T_STRING | T_SAFE_PROCEDURE);
  string_block(x) = mallocate(sc, len + 1);
  string_value(x) = (char *)block_data(string_block(x));
  if (len > 0)
    memcpy((void *)string_value(x), (void *)str, len);
  string_value(x)[len] = 0;
  string_length(x) = len;
  string_hash(x) = 0;
  add_string(sc, x);
  return(x);
}

static s7_pointer g_symbol_to_string(s7_scheme *sc, s7_pointer args)
{
  #define H_symbol_to_string "(symbol->string sym) returns the symbol sym converted to a string"
  #define Q_symbol_to_string s7_make_signature(sc, 2, sc->is_string_symbol, sc->is_symbol_symbol)
  s7_pointer sym;

  sym = car(args);
  if (!is_symbol(sym))
    return(method_or_bust_one_arg(sc, sym, sc->symbol_to_string_symbol, args, T_SYMBOL));
  /* s7_make_string uses strlen which stops at an embedded null */
  return(make_string_with_length(sc, symbol_name(sym), symbol_name_length(sym)));    /* return a copy */
}

static s7_pointer g_symbol_to_string_uncopied(s7_scheme *sc, s7_pointer args)
{
  s7_pointer sym;

  sym = car(args);
  if (!is_symbol(sym))
    return(method_or_bust_one_arg(sc, sym, sc->symbol_to_string_symbol, args, T_SYMBOL));
  if (is_gensym(sym))
    return(make_string_with_length(sc, symbol_name(sym), symbol_name_length(sym)));    /* return a copy of gensym name (which will be freed) */
  return(symbol_name_cell(sym));
}

static s7_pointer symbol_to_string_p(s7_scheme *sc, s7_pointer sym)
{
  if (!is_symbol(sym))
    simple_wrong_type_argument(sc, sc->symbol_to_string_symbol, sym, T_SYMBOL);
  return(make_string_with_length(sc, symbol_name(sym), symbol_name_length(sym)));
}

static s7_pointer symbol_to_string_uncopied_p(s7_scheme *sc, s7_pointer sym)
{
  if (!is_symbol(sym))
    simple_wrong_type_argument(sc, sc->symbol_to_string_symbol, sym, T_SYMBOL);
  if (is_gensym(sym))
    return(make_string_with_length(sc, symbol_name(sym), symbol_name_length(sym)));
  return(symbol_name_cell(sym));
}


/* -------------------------------- string->symbol -------------------------------- */
static inline s7_pointer g_string_to_symbol_1(s7_scheme *sc, s7_pointer str, s7_pointer caller)
{
  if (is_string(str))
    {
      if (string_length(str) > 0)
	return(make_symbol_with_length(sc, string_value(str), string_length(str)));
      return(simple_wrong_type_argument_with_type(sc, caller, str, wrap_string(sc, "a non-null string", 17)));
      /* currently if the string has an embedded null, it marks the end of the new symbol name. */
    }
  return(method_or_bust_one_arg(sc, str, caller, list_1(sc, str), T_STRING));
}

static s7_pointer g_string_to_symbol(s7_scheme *sc, s7_pointer args)
{
  #define H_string_to_symbol "(string->symbol str) returns the string str converted to a symbol"
  #define Q_string_to_symbol s7_make_signature(sc, 2, sc->is_symbol_symbol, sc->is_string_symbol)
  return(g_string_to_symbol_1(sc, car(args), sc->string_to_symbol_symbol));
}

static s7_pointer string_to_symbol_p_p(s7_scheme *sc, s7_pointer p)
{
  return(g_string_to_symbol_1(sc, p, sc->string_to_symbol_symbol));
}


/* -------------------------------- symbol -------------------------------- */
static s7_pointer g_string_append_1(s7_scheme *sc, s7_pointer args, s7_pointer caller);

static s7_pointer g_symbol(s7_scheme *sc, s7_pointer args)
{
  #define H_symbol "(symbol str ...) returns its string arguments concatenated and converted to a symbol"
  #define Q_symbol s7_make_circular_signature(sc, 1, 2, sc->is_symbol_symbol, sc->is_string_symbol)

  s7_int len = 0, cur_len;
  s7_pointer p, sym;
  block_t *b;
  char *name;

  for (p = args; is_pair(p); p = cdr(p))
    if (is_string(car(p)))
      len += string_length(car(p));
    else break;

  if (is_pair(p))
    {
      if (is_null(cdr(args)))
	return(g_string_to_symbol_1(sc, car(args), sc->symbol_symbol));
      return(g_string_to_symbol_1(sc, g_string_append_1(sc, args, sc->symbol_symbol), sc->symbol_symbol));
    }
  if (len == 0)
    return(simple_wrong_type_argument_with_type(sc, sc->symbol_symbol, car(args), wrap_string(sc, "a non-null string", 17)));

  b = mallocate(sc, len + 1);
  name = (char *)block_data(b);
  /* can't use catstrs_direct here because it stops at embedded null */
  cur_len = 0;
  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer str;
      str = car(p);
      if (string_length(str) > 0)
	{
	  memcpy((void *)(name + cur_len), (void *)string_value(str), string_length(str));
	  cur_len += string_length(str);
	}
    }
  name[len] = '\0';
  sym = make_symbol_with_length(sc, name, len);
  liberate(sc, b);
  return(sym);
}


/* -------- symbol sets -------- */
static inline s7_pointer add_symbol_to_list(s7_scheme *sc, s7_pointer sym)
{
  symbol_set_tag(sym, sc->syms_tag);
  symbol_set_tag2(sym, sc->syms_tag2);
  return(sym);
}

static inline void clear_symbol_list(s7_scheme *sc)
{
  sc->syms_tag++;
  if (sc->syms_tag == 0)
    {
      sc->syms_tag = 1; /* we're assuming (in let_equal) that this tag is not 0 */
      sc->syms_tag2++;
    }
}

#define symbol_is_in_list(Sc, Sym) ((symbol_tag(Sym) == Sc->syms_tag) && (symbol_tag2(Sym) == Sc->syms_tag2))


/* -------------------------------- environments -------------------------------- */

#define new_frame(Sc, Old_Env, New_Env)		      \
  do {						      \
    s7_pointer _x_;				      \
      new_cell(Sc, _x_, T_LET | T_SAFE_PROCEDURE);    \
      let_id(_x_) = ++sc->let_number;		      \
      let_set_slots(_x_, slot_end(Sc));	              \
      set_outlet(_x_, Old_Env);			      \
      New_Env = _x_;				      \
  } while (0)
/* this macro is noticeably faster than using the equivalent inlined new_frame_in_env function below */

static inline s7_pointer new_frame_in_env(s7_scheme *sc, s7_pointer old_env)
{
  s7_pointer x;
  new_cell(sc, x, T_LET | T_SAFE_PROCEDURE);
  let_id(x) = ++sc->let_number;
  let_set_slots(x, slot_end(sc));
  set_outlet(x, old_env);
  return(x);
}

static inline s7_pointer make_simple_let(s7_scheme *sc) /* called only in op_let_fx */
{
  s7_pointer frame;
  new_cell(sc, frame, T_LET | T_SAFE_PROCEDURE);
  let_id(frame) = sc->let_number + 1;
  let_set_slots(frame, slot_end(sc));
  set_outlet(frame, sc->envir);
  return(frame);
}

/* in all these macros, symbol_set_local should follow slot_set_value so that we can evaluate the slot's value in its old state. */
#define add_slot(Frame, Symbol, Value)			\
  do {							\
    s7_pointer _slot_, _sym_, _val_;			\
    _sym_ = Symbol; _val_ = Value;			\
    new_cell_no_check(sc, _slot_, T_SLOT);		\
    slot_set_symbol(_slot_, _sym_);			\
    slot_set_value(_slot_, _val_);			\
    symbol_set_local(_sym_, let_id(Frame), _slot_);	\
    set_next_slot(_slot_, let_slots(Frame));		\
    let_set_slots(Frame, _slot_);	                \
  } while (0)

#define new_frame_with_slot(Sc, Old_Env, New_Env, Symbol, Value) \
  do {								 \
    s7_pointer _x_, _slot_, _sym_, _val_;			 \
    _sym_ = Symbol; _val_ = Value;				\
    new_cell(Sc, _x_, T_LET | T_SAFE_PROCEDURE);		\
    let_id(_x_) = ++sc->let_number;				\
    set_outlet(_x_, Old_Env);			                \
    New_Env = _x_;						\
    new_cell_no_check(Sc, _slot_, T_SLOT);	                \
    slot_set_symbol(_slot_, _sym_);				\
    slot_set_value(_slot_, _val_);	                        \
    symbol_set_local(_sym_, sc->let_number, _slot_);            \
    set_next_slot(_slot_, slot_end(Sc));			        \
    let_set_slots(_x_, _slot_);					\
  } while (0)

#define new_frame_with_two_slots(Sc, Old_Env, New_Env, Symbol1, Value1, Symbol2, Value2) \
  do {                                   \
    s7_pointer _x_, _slot_, _sym1_, _val1_, _sym2_, _val2_;		\
    _sym1_ = Symbol1; _val1_ = Value1;					\
    _sym2_ = Symbol2; _val2_ = Value2;					\
    new_cell(Sc, _x_, T_LET | T_SAFE_PROCEDURE);			\
    let_id(_x_) = ++sc->let_number;					\
    set_outlet(_x_, Old_Env);				                \
    New_Env = _x_;							\
    new_cell_no_check(Sc, _slot_, T_SLOT);		                \
    slot_set_symbol(_slot_, _sym1_);					\
    slot_set_value(_slot_, _val1_);					\
    symbol_set_local(_sym1_, sc->let_number, _slot_);			\
    let_set_slots(_x_, _slot_);			                        \
    new_cell_no_check(Sc, _x_, T_SLOT);			                \
    slot_set_symbol(_x_, _sym2_);					\
    slot_set_value(_x_, _val2_);					\
    symbol_set_local(_sym2_, sc->let_number, _x_);			\
    set_next_slot(_x_, slot_end(Sc));				        \
    set_next_slot(_slot_, _x_);			                        \
  } while (0)

static s7_pointer reuse_as_let(s7_scheme *sc, s7_pointer frame, s7_pointer next_frame)
{
  /* we're reusing frame here as a let -- it was probably a pair */
#if S7_DEBUGGING
  frame->debugger_bits = 0;
#endif
  set_type(frame, T_LET | T_SAFE_PROCEDURE);
  let_set_slots(frame, slot_end(sc));
  set_outlet(frame, next_frame);
  let_id(frame) = ++sc->let_number;
  return(frame);
}

static s7_pointer reuse_as_slot(s7_pointer slot, s7_pointer symbol, s7_pointer value)
{
#if S7_DEBUGGING
  slot->debugger_bits = 0;
#endif
  set_type(slot, T_SLOT);
  slot_set_symbol(slot, symbol);
  slot_set_value(slot, T_Pos(value));
  return(slot);
}

static s7_pointer old_frame_with_slot(s7_scheme *sc, s7_pointer env, s7_pointer val)
{
  s7_pointer x, sym;
  uint64_t id;

  id = ++sc->let_number;
  let_id(env) = id;
  x = let_slots(env);
  slot_set_value(x, val);
  sym = slot_symbol(x);
  symbol_set_local(sym, id, x);
  return(env);
}

static s7_pointer old_frame_with_two_slots(s7_scheme *sc, s7_pointer env, s7_pointer val1, s7_pointer val2)
{
  s7_pointer x, sym;
  uint64_t id;

  id = ++sc->let_number;
  let_id(env) = id;
  x = let_slots(env);
  slot_set_value(x, val1);
  sym = slot_symbol(x);
  symbol_set_local(sym, id, x);
  x = next_slot(x);
  slot_set_value(x, val2);
  sym = slot_symbol(x);
  symbol_set_local(sym, id, x);
  return(env);
}

static s7_pointer old_frame_with_three_slots(s7_scheme *sc, s7_pointer env, s7_pointer val1, s7_pointer val2, s7_pointer val3)
{
  s7_pointer x, sym;
  uint64_t id;

  id = ++sc->let_number;
  let_id(env) = id;
  x = let_slots(env);

  slot_set_value(x, val1);
  sym = slot_symbol(x);
  symbol_set_local(sym, id, x);
  x = next_slot(x);

  slot_set_value(x, val2);
  sym = slot_symbol(x);
  symbol_set_local(sym, id, x);
  x = next_slot(x);

  slot_set_value(x, val3);
  sym = slot_symbol(x);
  symbol_set_local(sym, id, x);
  return(env);
}


#if S7_DEBUGGING
static s7_int permanent_slots = 0;
#endif

static s7_pointer permanent_slot(s7_scheme *sc, s7_pointer symbol, s7_pointer value)
{
  s7_pointer x;
  x = alloc_pointer(sc);
#if S7_DEBUGGING
  permanent_slots++;
#endif
  set_type(x, T_SLOT | T_UNHEAP);
  slot_set_symbol(x, symbol);
  slot_set_value(x, value);
  return(x);
}

static s7_pointer reverse_slots(s7_scheme *sc, s7_pointer list);

static s7_pointer make_permanent_let(s7_scheme *sc, s7_pointer vars)
{
  s7_pointer frame, var;
  frame = alloc_pointer(sc);
#if S7_DEBUGGING
  permanent_slots++;
#endif
  set_type(frame, T_LET | T_SAFE_PROCEDURE | T_UNHEAP);
  let_id(frame) = ++sc->let_number;
  set_outlet(frame, sc->envir);
  let_set_slots(frame, slot_end(sc));
  for (var = vars; is_pair(var); var = cdr(var))
    {
      s7_pointer slot;
      slot = permanent_slot(sc, caar(var), sc->F);
      add_permanent_let(sc, slot);
      symbol_set_local(caar(var), sc->let_number, slot);
      set_next_slot(slot, let_slots(frame));
      let_set_slots(frame, slot);
    }
  let_set_slots(frame, reverse_slots(sc, let_slots(frame)));
  add_permanent_let(sc, frame); /* need to mark outlet and maybe slot values */
  return(frame);
}

static s7_pointer activate_permanent_let_star(s7_scheme *sc, s7_pointer frame, s7_pointer vars)
{
  s7_pointer slot, var;
  let_id(frame) = ++sc->let_number;
  set_outlet(frame, sc->envir);
  sc->envir = frame;
  for (var = vars, slot = let_slots(frame); is_pair(var); var = cdr(var), slot = next_slot(slot))
    {
      slot_set_value(slot, fx_call(sc, cdar(var)));
      symbol_set_local(caar(var), sc->let_number, slot);
    }
  return(frame);
}


static s7_pointer find_let(s7_scheme *sc, s7_pointer obj)
{
  if (is_let(obj)) return(obj);
  switch (type(obj))
    {
    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
    case T_CLOSURE: case T_CLOSURE_STAR:
      return(closure_let(obj));

    case T_C_OBJECT:
      return(c_object_let(obj));

    case T_C_POINTER:
      if ((is_let(c_pointer_info(obj))) &&
	  (c_pointer_info(obj) != sc->rootlet))
	return(c_pointer_info(obj));
    }
  return(sc->nil);
}

static s7_pointer call_setter(s7_scheme *sc, s7_pointer slot, s7_pointer old_value);

static inline s7_pointer checked_slot_set_value(s7_scheme *sc, s7_pointer y, s7_pointer value)
{
  if (slot_has_setter(y))
    slot_set_value(y, call_setter(sc, y, value));
  else 
    {
      if (is_immutable_slot(y))
	return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->let_set_symbol, slot_symbol(y))));
      slot_set_value(y, value);
    }
  return(slot_value(y));
}

static s7_pointer let_fill(s7_scheme *sc, s7_pointer args)
{
  s7_pointer e, val;
  e = car(args);

  if (e == sc->rootlet)
    return(out_of_range(sc, sc->fill_symbol, small_int(1), e, wrap_string(sc, "can't fill! rootlet", 19)));
  if (e == sc->owlet) /* (owlet) copies sc->owlet, so this probably can't happen */
    return(out_of_range(sc, sc->fill_symbol, small_int(1), e, wrap_string(sc, "can't fill! owlet", 17)));
  if (is_funclet(e))
    return(out_of_range(sc, sc->fill_symbol, small_int(1), e, wrap_string(sc, "can't fill! a funclet", 21)));
  if (is_immutable(e))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->fill_symbol, e)));

  val = cadr(args);
  if (val == sc->undefined)
    {
      let_set_slots(e, slot_end(sc));
      let_id(e) = ++sc->let_number; /* else previous symbol_id matches! */
    }
  else
    {
      s7_pointer p;
      for (p = let_slots(e); tis_slot(p); p = next_slot(p))
	checked_slot_set_value(sc, p, val);
    }
  return(val);
}

static s7_pointer find_method(s7_scheme *sc, s7_pointer env, s7_pointer symbol)
{
  s7_pointer x;
  if (symbol_id(symbol) == 0) /* this means the symbol has never been used locally, so how can it be a method? */
    return(sc->undefined);

  if (let_id(env) == symbol_id(symbol))
    return(slot_value(local_slot(symbol)));

  for (x = env; symbol_id(symbol) < let_id(x); x = outlet(x));

  if (let_id(x) == symbol_id(symbol))
    return(slot_value(local_slot(symbol)));

  for (; is_let(x); x = outlet(x))
    {
      s7_pointer y;
      for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	if (slot_symbol(y) == symbol)
	  return(slot_value(y));
    }
  return(sc->undefined);
}

static s7_int let_length(s7_scheme *sc, s7_pointer e)
{
  /* used by length, applicable_length, copy, and some length optimizations */
  s7_int i;
  s7_pointer p;

  if (e == sc->rootlet)
    return(sc->rootlet_entries);

  if (has_active_methods(sc, e))
    {
      s7_pointer length_func;
      length_func = find_method(sc, e, sc->length_symbol);
      if (length_func != sc->undefined)
	{
	  p = s7_apply_function(sc, length_func, list_1(sc, e));
	  if (s7_is_integer(p))
	    return(s7_integer(p));
	  return(-1); /* ?? */
	}
    }
  for (i = 0, p = let_slots(e); tis_slot(p); i++, p = next_slot(p));
  return(i);
}


static void slot_set_value_with_hook_1(s7_scheme *sc, s7_pointer slot, s7_pointer value)
{
  /* (set! (hook-functions *rootlet-redefinition-hook*) (list (lambda (hook) (format *stderr* "~A ~A~%" (hook 'symbol) (hook 'value))))) */
  s7_pointer symbol;
  symbol = slot_symbol(slot);
  if ((global_slot(symbol) == slot) &&
      (value != slot_value(slot)))
    s7_call(sc, sc->rootlet_redefinition_hook, set_elist_2(sc, symbol, value));
  slot_set_value(slot, value);
}

static s7_pointer make_slot_1(s7_scheme *sc, s7_pointer env, s7_pointer symbol, s7_pointer value)
{
  /* env is not rootlet and is a let */
  s7_pointer slot;
  new_cell(sc, slot, T_SLOT);
  slot_set_symbol(slot, symbol);
  slot_set_value(slot, value);
  set_next_slot(slot, let_slots(env));
  let_set_slots(env, slot);
  set_local(symbol);
  /* this is called by varlet so we have to be careful about the resultant let_id
   *   check for greater to ensure shadowing stays in effect, and equal to do updates (set! in effect)
   */
  if (let_id(env) >= symbol_id(symbol))
    symbol_set_local(symbol, let_id(env), slot);
  return(slot);
}

static hash_entry_t *hash_eq(s7_scheme *sc, s7_pointer table, s7_pointer key);
static s7_pointer hash_table_iterate(s7_scheme *sc, s7_pointer iterator);
static void remove_function_from_heap(s7_scheme *sc, s7_pointer value);

static void remove_let_from_heap(s7_scheme *sc, s7_pointer lt)
{
  s7_pointer p;
  for (p = let_slots(lt); tis_slot(p); p = next_slot(p))
    {
      s7_pointer val;
      val = slot_value(p);
      if ((has_closure_let(val)) &&
	  (in_heap(closure_args(val))))
	remove_function_from_heap(sc, val);
      else
	{
	  /* an experiment... */
	  if ((is_hash_table(val)) &&
	      (!hash_table_removed(val)))
	    {
	      s7_pointer iterator, ip;
	      s7_int gc_iter;
	      s7_int i, len;

	      len = hash_table_entries(val);
	      iterator = s7_make_iterator(sc, val);
	      gc_iter = s7_gc_protect_1(sc, iterator);
	      ip = cons(sc, sc->F, sc->F);
	      iterator_current(iterator) = ip;
	      set_mark_seq(iterator);
	      for (i = 0; i < len; i++)
		{
		  s7_pointer key_val;
		  key_val = hash_table_iterate(sc, iterator);
		  if ((has_closure_let(cdr(key_val))) &&
		      (in_heap(closure_args(cdr(key_val)))))
		    remove_function_from_heap(sc, cdr(key_val));
		}
	      hash_table_set_removed(val);
	      s7_gc_unprotect_at(sc, gc_iter);
	      iterator_current(iterator) = sc->nil;
	      free_cell(sc, ip);
	      free_cell(sc, iterator);
	    }
	}
    }
  let_set_removed(lt);
}

static void remove_function_from_heap(s7_scheme *sc, s7_pointer value)
{
  s7_pointer lt;

  s7_remove_from_heap(sc, closure_args(value));
  s7_remove_from_heap(sc, closure_body(value));

  /* remove closure if it's local to current func (meaning (define f (let ...) (lambda ...)) removes the enclosing let) */
  lt = closure_let(value);
  if ((is_let(lt)) && (!let_removed(lt)) && (lt != sc->rootlet) && (lt != sc->shadow_rootlet))
    {
      lt = outlet(lt);
      if ((is_let(lt)) && (!let_removed(lt)) && (lt != sc->rootlet) && (lt != sc->shadow_rootlet))
	{
	  remove_let_from_heap(sc, lt);
	  lt = outlet(lt);
	  if ((is_let(lt)) && (!let_removed(lt)) && (lt != sc->rootlet) && (lt != sc->shadow_rootlet))
	    remove_let_from_heap(sc, lt);
	}
    }
}

s7_pointer s7_make_slot(s7_scheme *sc, s7_pointer env, s7_pointer symbol, s7_pointer value)
{
  if ((!is_let(env)) ||
      (env == sc->rootlet))
    {
      s7_pointer ge, slot;
      if (is_immutable(sc->rootlet))
	return(immutable_object_error(sc, set_elist_2(sc, wrap_string(sc, "can't define '~S; rootlet is immutable", 38), symbol)));
      if ((sc->safety == NO_SAFETY) &&
	  (has_closure_let(value)))
	remove_function_from_heap(sc, value);

      /* first look for existing slot -- this is not always checked before calling s7_make_slot */
      if (is_slot(global_slot(symbol)))
	{
	  slot = global_slot(symbol);
	  symbol_increment_ctr(symbol);
	  slot_set_value_with_hook(slot, value);
	  return(slot);
	}

      ge = sc->rootlet;
      slot = permanent_slot(sc, symbol, value);
      rootlet_element(ge, sc->rootlet_entries++) = slot;
      if (sc->rootlet_entries >= vector_length(ge))
	{
	  s7_int i, len;
	  block_t *ob, *nb;
	  vector_length(ge) *= 2;
	  len = vector_length(ge);
	  ob = rootlet_block(ge);
	  nb = reallocate(sc, ob, len * sizeof(s7_pointer));
	  block_info(nb) = NULL;
	  rootlet_block(ge) = nb;
	  rootlet_elements(ge) = (s7_pointer *)block_data(nb);
	  for (i = sc->rootlet_entries; i < len; i++)
	    rootlet_element(ge, i) = sc->nil;
	}
      set_global_slot(symbol, slot);

      if (symbol_id(symbol) == 0)    /* never defined locally? */
	{
	  if (!is_gensym(symbol))
	    {
	      if (initial_slot(symbol) == sc->undefined)
		set_initial_slot(symbol, permanent_slot(sc, symbol, value));
	    }
	  set_local_slot(symbol, slot);
	  set_global(symbol);
	}
      symbol_increment_ctr(symbol);
      if (is_gensym(symbol))
	s7_remove_from_heap(sc, symbol);
      return(slot);
    }

  return(make_slot_1(sc, env, symbol, value));
  /* there are about the same number of frames as local variables -- this strikes me as surprising, but it holds up across a lot of code. */
}

static s7_pointer make_slot(s7_scheme *sc, s7_pointer variable, s7_pointer value)
{
  /* this is for a do-loop optimization -- an unattached slot */
  s7_pointer y;
  new_cell(sc, y, T_SLOT);
  slot_set_symbol(y, variable);
  slot_set_value(y, value);
  return(y);
}


/* -------------------------------- let? -------------------------------- */
bool s7_is_let(s7_pointer e) {return(is_let(e));}

static s7_pointer g_is_let(s7_scheme *sc, s7_pointer args)
{
  #define H_is_let "(let? obj) returns #t if obj is a let (an environment)."
  #define Q_is_let sc->pl_bt

  check_boolean_method(sc, is_let, sc->is_let_symbol, args);
}


/* -------------------------------- unlet -------------------------------- */
#define UNLET_ENTRIES 512 /* 397 if not --disable-deprecated etc */

static void save_unlet(s7_scheme *sc)
{
  int32_t i, k = 0;
  s7_pointer x;
  s7_pointer *inits;
  block_t *block;

  sc->unlet = (s7_pointer)calloc(1, sizeof(s7_cell));
  set_type(sc->unlet, T_VECTOR | T_UNHEAP);
  vector_length(sc->unlet) = UNLET_ENTRIES;
  block = mallocate(sc, UNLET_ENTRIES * sizeof(s7_pointer));
  vector_block(sc->unlet) = block;
  vector_elements(sc->unlet) = (s7_pointer *)block_data(block);
  vector_set_dimension_info(sc->unlet, NULL);
  vector_getter(sc->unlet) = default_vector_getter;
  vector_setter(sc->unlet) = default_vector_setter;
  inits = vector_elements(sc->unlet);
  s7_vector_fill(sc, sc->unlet, sc->nil);

  for (i = 0; i < SYMBOL_TABLE_SIZE; i++)
    for (x = vector_element(sc->symbol_table, i); is_not_null(x); x = cdr(x))
      {
	s7_pointer sym;
	sym = car(x);
	if ((!is_gensym(sym)) && (is_slot(initial_slot(sym))))
	  {
	    s7_pointer val;
	    val = slot_value(initial_slot(sym));
	    if ((is_c_function(val)) || (is_syntax(val))) /* we're assuming the initial_slots values of these guys need no GC protection */
	      inits[k++] = initial_slot(sym);

	    /* non-c_functions that are not 'set! (and therefore initial_slot GC) protected by default:
	     *    make-hook hook-functions
	     * if these initial_slot values are added to unlet, they need explicit GC protection.
	     */
	    /* (let ((begin +)) (with-let (unlet) (begin 1 2))) */
#if S7_DEBUGGING
	    if (k >= UNLET_ENTRIES)
	      fprintf(stderr, "unlet overflow\n");
#endif
	  }
      }
}

static s7_pointer g_unlet(s7_scheme *sc, s7_pointer args)
{
  /* add sc->unlet bindings to the current environment */
  #define H_unlet "(unlet) returns a let that establishes the original bindings of all the predefined functions"
  #define Q_unlet s7_make_signature(sc, 1, sc->is_let_symbol)

  /* slightly confusing:
   *    ((unlet) 'abs) -> #<undefined>
   *    (defined? 'abs (unlet)) -> #t
   * this is because unlet sets up a local environment of unshadowed symbols, and s7_let_ref only looks at the local env chain
   *   (that is, if env is not the global env, then the global env is not searched).
   */
  int32_t i;
  s7_pointer *inits;
  s7_pointer x;

  sc->w = new_frame_in_env(sc, sc->envir);
  inits = vector_elements(sc->unlet);

  for (i = 0; (i < UNLET_ENTRIES) && (is_slot(inits[i])); i++)
    {
      s7_pointer sym;
      x = slot_value(inits[i]);
      sym = slot_symbol(inits[i]);
      if ((x != slot_value(global_slot(sym))) || /* it has been changed globally */
	  ((!is_global(sym)) &&                  /* it might be shadowed locally */
	   (s7_symbol_local_value(sc, sym, sc->envir) != slot_value(global_slot(sym)))))
	make_slot_1(sc, sc->w, sym, x);
    }
  /* if (set! + -) then + needs to be overridden, but the local bit isn't set, so we have to check the actual values in the non-local case.
   *   (define (f x) (with-let (unlet) (+ x 1)))
   */
  x = sc->w;
  sc->w = sc->nil;
  return(x);
}


/* -------------------------------- openlet? -------------------------------- */
bool s7_is_openlet(s7_pointer e) {return(has_methods(e));}

static s7_pointer g_is_openlet(s7_scheme *sc, s7_pointer args)
{
  #define H_is_openlet "(openlet? obj) returns #t is 'obj' has methods."
  #define Q_is_openlet sc->pl_bt
  s7_pointer e;

  e = car(args);  /* if e is not a let, should this raise an error? -- no, easier to use this way in cond */
  check_method(sc, e, sc->is_openlet_symbol, args);
  return(make_boolean(sc, has_methods(e)));
}


/* -------------------------------- openlet -------------------------------- */
s7_pointer s7_openlet(s7_scheme *sc, s7_pointer e)
{
  set_has_methods(e);
  return(e);
}

static s7_pointer g_openlet(s7_scheme *sc, s7_pointer args)
{
  #define H_openlet "(openlet e) tells the built-in generic functions that the let 'e might have an over-riding method."
  #define Q_openlet sc->pcl_e
  s7_pointer e, elet, func;

  e = car(args);
  if ((e == sc->rootlet) || (e == sc->nil))
    s7_error(sc, sc->error_symbol, set_elist_1(sc, wrap_string(sc, "can't openlet rootlet", 21)));
  elet = find_let(sc, e); /* returns nil if no let found, so has to follow error check above */
  if (!is_let(elet))
    return(simple_wrong_type_argument_with_type(sc, sc->openlet_symbol, e, a_let_string));

  if ((has_active_methods(sc, e)) &&
      ((func = find_method(sc, elet, sc->openlet_symbol)) != sc->undefined))
    return(s7_apply_function(sc, func, args));

  set_has_methods(e);
  return(e);
}


/* -------------------------------- openlets/coverlets -------------------------------- */
static s7_pointer g_openlets(s7_scheme *sc, s7_pointer args)
{
  #define H_openlets "(openlets) (re)activates any open lets"
  #define Q_openlets s7_make_signature(sc, 1, sc->is_boolean_symbol)

  sc->has_openlets = true;
  return(sc->T);
}

static s7_pointer g_coverlets(s7_scheme *sc, s7_pointer args)
{
  #define H_coverlets "(coverlets) deactivates any open lets"
  #define Q_coverlets s7_make_signature(sc, 1, sc->is_boolean_symbol)

  sc->has_openlets = false;
  return(sc->F);
}


/* -------------------------------- coverlet -------------------------------- */
static s7_pointer g_coverlet(s7_scheme *sc, s7_pointer args)
{
  s7_pointer e;
  #define H_coverlet "(coverlet e) undoes an earlier openlet."
  #define Q_coverlet sc->pcl_e

  e = car(args);
  sc->temp3 = e;
  check_method_uncopied(sc, e, sc->coverlet_symbol, list_1(sc, e));
  sc->temp3 = sc->nil;
  if (e == sc->rootlet)
    s7_error(sc, sc->error_symbol, set_elist_1(sc, wrap_string(sc, "can't coverlet rootlet", 22)));

  if ((is_let(e)) ||
      (has_closure_let(e)) ||
      ((is_c_object(e)) && (c_object_let(e) != sc->nil)) ||
      ((is_c_pointer(e)) && (is_let(c_pointer_info(e)))))
    {
      clear_has_methods(e);
      return(e);
    }
  return(simple_wrong_type_argument_with_type(sc, sc->coverlet_symbol, e, a_let_string));
}


/* -------------------------------- varlet -------------------------------- */
static void append_let(s7_scheme *sc, s7_pointer new_e, s7_pointer old_e)
{
  s7_pointer x;

  if (old_e == sc->rootlet)
    return;

  if (new_e != sc->rootlet)
    {
      for (x = let_slots(old_e); tis_slot(x); x = next_slot(x))
	make_slot_1(sc, new_e, slot_symbol(x), slot_value(x)); /* not add_slot here because we might run off the free heap end */
    }
  else
    {
      for (x = let_slots(old_e); tis_slot(x); x = next_slot(x))
	{
	  s7_pointer sym, val;
	  sym = slot_symbol(x);
	  val = slot_value(x);
	  if (is_slot(global_slot(sym)))
	    slot_set_value(global_slot(sym), val);
	  else s7_make_slot(sc, new_e, sym, val);
	}
    }
}

static s7_pointer check_c_obj_env(s7_scheme *sc, s7_pointer old_e, s7_pointer caller)
{
  if (is_c_object(old_e))
    old_e = c_object_let(old_e);
  if (!is_let(old_e))
    return(simple_wrong_type_argument_with_type(sc, caller, old_e, a_let_string));
  return(old_e);
}

s7_pointer s7_varlet(s7_scheme *sc, s7_pointer env, s7_pointer symbol, s7_pointer value)
{
  if (!is_let(env))
    return(wrong_type_argument_with_type(sc, sc->varlet_symbol, 1, env, a_let_string));

  if (!is_symbol(symbol))
    return(wrong_type_argument_with_type(sc, sc->varlet_symbol, 2, symbol, a_symbol_string));

  if ((is_slot(global_slot(symbol))) &&
      (is_syntax(slot_value(global_slot(symbol)))))
    return(wrong_type_argument_with_type(sc, sc->varlet_symbol, 2, symbol, wrap_string(sc, "a non-syntactic name", 20)));

  if (env == sc->rootlet)
    {
      if (is_slot(global_slot(symbol)))
	slot_set_value(global_slot(symbol), value);
      else s7_make_slot(sc, env, symbol, value);
    }
  else make_slot_1(sc, env, symbol, value);
  return(value);
}

static s7_pointer g_varlet(s7_scheme *sc, s7_pointer args)
{
  #define H_varlet "(varlet env ...) adds its arguments (a let, a cons: symbol . value, or two arguments, the symbol and its value) \
to the let env, and returns env.  (varlet (curlet) 'a 1) adds 'a to the current environment with the value 1."
  #define Q_varlet s7_make_circular_signature(sc, 2, 4, sc->is_let_symbol, \
                     s7_make_signature(sc, 2, sc->is_let_symbol, sc->is_null_symbol), \
                       s7_make_signature(sc, 3, sc->is_pair_symbol, sc->is_symbol_symbol, sc->is_let_symbol), \
                         sc->T)
  /* varlet = with-let + define */
  s7_pointer x, e, sym, val, p;

  e = car(args);
  if (is_null(e))
    e = sc->rootlet;
  else
    {
      check_method(sc, e, sc->varlet_symbol, args);
      if (!is_let(e))
	return(wrong_type_argument_with_type(sc, sc->varlet_symbol, 1, e, a_let_string));
      if (is_immutable(e))
	return(s7_wrong_type_arg_error(sc, "varlet", 1, e, "a mutable let"));
    }
  for (x = cdr(args); is_pair(x); x = cdr(x))
    {
      p = car(x);
      switch (type(p))
	{
	case T_SYMBOL:
	  if (is_keyword(p))
	    sym = keyword_symbol(p);
	  else sym = p;
	  if (!is_pair(cdr(x)))
	    s7_error(sc, sc->error_symbol, set_elist_3(sc, value_is_missing_string, sc->varlet_symbol, car(x)));
	  if (is_constant_symbol(sc, sym))
	    return(wrong_type_argument_with_type(sc, sc->varlet_symbol, position_of(x, args), sym, a_non_constant_symbol_string));
	  x = cdr(x);
	  val = car(x);
	  break;

	case T_PAIR:
	  sym = car(p);
	  if (!is_symbol(sym))
	    return(wrong_type_argument_with_type(sc, sc->varlet_symbol, position_of(x, args), p, a_symbol_string));
	  if (is_constant_symbol(sc, sym))
	    return(wrong_type_argument_with_type(sc, sc->varlet_symbol, position_of(x, args), sym, a_non_constant_symbol_string));
	  val = cdr(p);
	  break;

	case T_LET:
	  append_let(sc, e, check_c_obj_env(sc, p, sc->varlet_symbol));
	  continue;

	default:
	  return(wrong_type_argument_with_type(sc, sc->varlet_symbol, position_of(x, args), p, a_symbol_string));
	}

      if ((has_let_fallback(e)) && 
	  ((sym == sc->let_ref_fallback_symbol) || (sym == sc->let_set_fallback_symbol)))
	return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "varlet can't shadow ~S", 22), sym)));

      if (e == sc->rootlet)
	{
	  if (is_slot(global_slot(sym)))
	    {
	      if (is_syntax(slot_value(global_slot(sym))))
		return(wrong_type_argument_with_type(sc, sc->varlet_symbol, position_of(x, args), p, wrap_string(sc, "a non-syntactic keyword", 23)));
	      /*  without this check we can end up turning our code into gibberish:
	       *    (set! quote 1) -> ;can't set! quote
	       *    (varlet (rootlet) '(quote . 1)), :quote -> 1
	       * or worse set quote to a function of one arg that tries to quote something -- infinite loop
	       */
	      slot_set_value_with_hook(global_slot(sym), val);
	    }
	  else s7_make_slot(sc, e, sym, val);
	}
      else make_slot_1(sc, e, sym, val);
      /* this used to check for sym already defined, and set its value, but that greatly slows down
       *   the most common use (adding a slot), and makes it hard to shadow explicitly.  Don't use
       *   varlet as a substitute for set!/let-set!.
       */
    }
  return(e);
}


/* -------------------------------- cutlet -------------------------------- */
static s7_pointer g_cutlet(s7_scheme *sc, s7_pointer args)
{
  #define H_cutlet "(cutlet e symbol ...) removes symbols from the let e."
  #define Q_cutlet s7_make_circular_signature(sc, 2, 3, sc->is_let_symbol, sc->is_let_symbol, sc->is_symbol_symbol)

  s7_pointer e, syms;
  #define THE_UN_ID ++sc->let_number

  e = car(args);
  if (is_null(e))
    e = sc->rootlet;
  else
    {
      check_method(sc, e, sc->cutlet_symbol, args);
      if (!is_let(e))
	return(wrong_type_argument_with_type(sc, sc->cutlet_symbol, 1, e, a_let_string));
      if (is_immutable(e))
	return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->cutlet_symbol, e)));
    }
  /* besides removing the slot we have to make sure the symbol_id does not match else
   *   let-ref and others will use the old slot!  What's the un-id?  Perhaps the next one?
   *   (let ((b 1)) (let ((b 2)) (cutlet (curlet) 'b)) b)
   */

  for (syms = cdr(args); is_pair(syms); syms = cdr(syms))
    {
      s7_pointer sym, slot;
      sym = car(syms);

      if (!is_symbol(sym))
	return(wrong_type_argument_with_type(sc, sc->cutlet_symbol, position_of(syms, args), sym, a_symbol_string));

      if (is_keyword(sym))
	sym = keyword_symbol(sym);

      if (e == sc->rootlet)
	{
	  if (is_slot(global_slot(sym)))
	    {
	      symbol_set_id(sym, THE_UN_ID);
	      slot_set_value(global_slot(sym), sc->undefined);
	    }
	}
      else
	{
	  if ((has_let_fallback(e)) &&
	      ((sym == sc->let_ref_fallback_symbol) || (sym == sc->let_set_fallback_symbol)))
	    return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "cutlet can't remove ~S", 22), sym)));

	  slot = let_slots(e);
	  if (tis_slot(slot))
	    {
	      if (slot_symbol(slot) == sym)
		{
		  let_set_slots(e, next_slot(let_slots(e)));
		  symbol_set_id(sym, THE_UN_ID);
		}
	      else
		{
		  s7_pointer last_slot;
		  last_slot = slot;
		  for (slot = next_slot(let_slots(e)); tis_slot(slot); last_slot = slot, slot = next_slot(slot))
		    if (slot_symbol(slot) == sym)
		      {
			symbol_set_id(sym, THE_UN_ID);
			set_next_slot(last_slot, next_slot(slot));
			break;
		      }}}}}
  return(e);
}


/* -------------------------------- sublet -------------------------------- */
static s7_pointer sublet_1(s7_scheme *sc, s7_pointer e, s7_pointer bindings, s7_pointer caller)
{
  s7_pointer new_e;
  if (e == sc->rootlet)
    new_e = new_frame_in_env(sc, sc->nil);
  else new_e = new_frame_in_env(sc, e);
  set_all_methods(new_e, e);

  if (!is_null(bindings))
    {
      s7_pointer x;
      sc->temp3 = new_e;

      for (x = bindings; is_pair(x); x = cdr(x))
	{
	  s7_pointer p, sym, val;

	  p = car(x);
	  switch (type(p))
	    {
	      /* should this insist on one style of field arg?  i.e. (cons sym val) throughout, or :sym val etc? */
	    case T_SYMBOL:
	      if (is_keyword(p))
		sym = keyword_symbol(p);
	      else sym = p;
	      if (!is_pair(cdr(x)))
		s7_error(sc, sc->error_symbol, set_elist_3(sc, value_is_missing_string, caller, car(x)));
	      x = cdr(x);
	      val = car(x);
	      break;

	    case T_PAIR:
	      sym = car(p);
	      if (!is_symbol(sym))
		return(wrong_type_argument_with_type(sc, caller, position_of(x, bindings), p, a_symbol_string));
	      if (is_keyword(sym))
		sym = keyword_symbol(sym);
	      val = cdr(p);
	      break;

	    case T_LET:
	      append_let(sc, new_e, check_c_obj_env(sc, p, caller));
	      continue;

	    default:
	      return(wrong_type_argument_with_type(sc, caller, position_of(x, bindings), p, a_symbol_string));
	    }

	  if (is_constant_symbol(sc, sym))
	    return(wrong_type_argument_with_type(sc, caller, position_of(x, bindings), sym, a_non_constant_symbol_string));
	  if ((is_slot(global_slot(sym))) &&
	      (is_syntax(slot_value(global_slot(sym)))))
	    return(wrong_type_argument_with_type(sc, caller, 2, sym, wrap_string(sc, "a non-syntactic name", 20)));

	  /* here we know new_e is a let and is not rootlet */
	  make_slot_1(sc, new_e, sym, val);
	  if (sym == sc->let_ref_fallback_symbol)
	    set_has_let_ref_fallback(new_e);
	  else
	    {
	      if (sym == sc->let_set_fallback_symbol)
		set_has_let_set_fallback(new_e);
	    }
	}
      sc->temp3 = sc->nil;
    }
  return(new_e);
}

s7_pointer s7_sublet(s7_scheme *sc, s7_pointer e, s7_pointer bindings)
{
  return(sublet_1(sc, e, bindings, sc->sublet_symbol));
}

static s7_pointer g_sublet(s7_scheme *sc, s7_pointer args)
{
  #define H_sublet "(sublet env ...) adds its arguments (each a let or a cons: '(symbol . value)) to env, and returns the new environment."
  #define Q_sublet Q_varlet
  s7_pointer e;

  e = car(args);
  if (is_null(e))
    e = sc->rootlet;
  else
    {
      check_method(sc, e, sc->sublet_symbol, args);
      if (!is_let(e))
	return(wrong_type_argument_with_type(sc, sc->sublet_symbol, 1, e, a_let_string));
    }
  return(sublet_1(sc, e, cdr(args), sc->sublet_symbol));
}


/* -------------------------------- inlet -------------------------------- */
s7_pointer s7_inlet(s7_scheme *sc, s7_pointer args)
{
  #define H_inlet "(inlet ...) adds its arguments, each a let, a cons: '(symbol . value), or a keyword/value pair, to a new environment, and returns the \
new environment. (inlet :a 1 :b 2) or (inlet '(a . 1) '(b . 2))"
  #define Q_inlet s7_make_circular_signature(sc, 1, 2, sc->is_let_symbol, sc->T)

  return(sublet_1(sc, sc->rootlet, args, sc->inlet_symbol));
}

#define g_inlet s7_inlet

static s7_pointer g_simple_inlet(s7_scheme *sc, s7_pointer args)
{
  /* here all args are paired with normal symbol/value, no fallbacks, no immutable symbols etc */
  s7_pointer new_e, x;
  int64_t id;
  new_e = new_frame_in_env(sc, sc->nil);
  sc->temp3 = new_e;
  id = let_id(new_e);
  for (x = args; is_pair(x); x = cddr(x))
    {
      s7_pointer symbol, slot;
      symbol = car(x);
      if (is_keyword(symbol))                 /* (inlet ':allow-other-keys 3) */
	symbol = keyword_symbol(symbol);
      if (is_constant_symbol(sc, symbol))     /* (inlet 'pi 1) */
	return(wrong_type_argument_with_type(sc, sc->inlet_symbol, 1, symbol, a_non_constant_symbol_string));
      new_cell_no_check(sc, slot, T_SLOT);
      slot_set_symbol(slot, symbol);
      slot_set_value(slot, cadr(x));
      set_next_slot(slot, let_slots(new_e));
      let_set_slots(new_e, slot);
      set_local(symbol);
      symbol_set_local(symbol, id, slot);
    }
  sc->temp3 = sc->nil;
  return(new_e);
}

static s7_pointer inlet_p_pp(s7_scheme *sc, s7_pointer symbol, s7_pointer value)
{
  s7_pointer x, slot;

  if (!is_symbol(symbol))
    return(sublet_1(sc, sc->nil, list_2(sc, symbol, value), sc->inlet_symbol));
  if (is_keyword(symbol))
    symbol = keyword_symbol(symbol);
  if (is_constant_symbol(sc, symbol))
    return(wrong_type_argument_with_type(sc, sc->inlet_symbol, 1, symbol, a_non_constant_symbol_string));

  new_cell(sc, x, T_LET | T_SAFE_PROCEDURE);
  sc->temp3 = x;
  let_id(x) = ++sc->let_number;
  set_outlet(x, sc->nil);
  new_cell_no_check(sc, slot, T_SLOT);
  slot_set_symbol(slot, symbol);
  slot_set_value(slot, value);
  set_next_slot(slot, slot_end(sc));
  let_set_slots(x, slot);
  set_local(symbol);
  symbol_set_local(symbol, let_id(x), slot);
  sc->temp3 = sc->nil;
  return(x);
}

static s7_pointer g_local_inlet(s7_scheme *sc, s7_int num_args, ...)
{
  va_list ap;
  s7_int i;
  s7_pointer new_e;
  int64_t id;

  new_e = new_frame_in_env(sc, sc->nil);
  sc->temp3 = new_e;
  id = let_id(new_e);

  va_start(ap, num_args);
  for (i = 0; i < num_args; i += 2)
    {
      s7_pointer symbol, slot, value;
      symbol = va_arg(ap, s7_pointer);
      value = va_arg(ap, s7_pointer);
      if (is_keyword(symbol))                 /* (inlet ':allow-other-keys 3) */
	symbol = keyword_symbol(symbol);
      new_cell_no_check(sc, slot, T_SLOT);
      slot_set_symbol(slot, symbol);
      slot_set_value(slot, value);
      set_next_slot(slot, let_slots(new_e));
      let_set_slots(new_e, slot);
      set_local(symbol);
      symbol_set_local(symbol, id, slot);
    }
  va_end(ap);

  sc->temp3 = sc->nil;
  return(new_e);
}

static bool is_proper_quote(s7_scheme *sc, s7_pointer p)
{
  return((is_quoted_pair(p)) &&
	 (is_pair(cdr(p))) &&
	 (is_null(cddr(p))));
}

static s7_pointer inlet_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if ((args > 0) &&
      ((args % 2) == 0))
    {
      s7_pointer p;
      for (p = cdr(expr); is_pair(p); p = cddr(p))
	{
	  s7_pointer sym;
	  if (!is_proper_quote(sc, car(p)))             /* 'abs etc, but tricky: ':abs */
	    return(f);
	  sym = cadar(p);
	  if ((!is_symbol(sym)) ||
	      (is_possibly_constant(sym)) ||            /* define-constant etc */
	      (is_syntactic_symbol(sym))  ||            /* (inlet 'if 3) */
	      ((is_slot(global_slot(sym))) &&
	       (is_syntactic(slot_value(global_slot(sym))))) ||
	      (sym == sc->let_ref_fallback_symbol) ||
	      (sym == sc->let_set_fallback_symbol))
	    return(f);
	}
      return(sc->simple_inlet);
    }
  return(f);
}


/* -------------------------------- let->list -------------------------------- */
s7_pointer s7_let_to_list(s7_scheme *sc, s7_pointer env)
{
  s7_pointer x;

  sc->temp3 = sc->w;
  sc->w = sc->nil;

  if (env == sc->rootlet)
    {
      s7_int i, lim2;
      s7_pointer *entries;

      entries = rootlet_elements(env);
      lim2 = sc->rootlet_entries;
      if (lim2 & 1) lim2--;

      for (i = 0; i < lim2; )
	{
	  sc->w = cons_unchecked(sc, cons(sc, slot_symbol(entries[i]), slot_value(entries[i])), sc->w); i++;
	  sc->w = cons_unchecked(sc, cons_unchecked(sc, slot_symbol(entries[i]), slot_value(entries[i])), sc->w); i++;
	}
      if (lim2 < sc->rootlet_entries)
	sc->w = cons_unchecked(sc, cons(sc, slot_symbol(entries[i]), slot_value(entries[i])), sc->w);
    }
  else
    {
      s7_pointer iter, func;
      /* need to check make-iterator method before dropping into let->list */

      if ((has_active_methods(sc, env)) &&
	  ((func = find_method(sc, env, sc->make_iterator_symbol)) != sc->undefined))
	iter = s7_apply_function(sc, func, list_1(sc, env));
      else iter = sc->nil;

      if (is_null(iter))
	{
	  for (x = let_slots(env); tis_slot(x); x = next_slot(x))
	    sc->w = cons_unchecked(sc, cons(sc, slot_symbol(x), slot_value(x)), sc->w);
	}
      else
	{
	  /* (begin (load "mockery.scm") (let ((lt ((*mock-pair* 'mock-pair) 1 2 3))) (format *stderr* "~{~A ~}" lt))) */
	  while (true)
	    {
	      x = s7_iterate(sc, iter);
	      if (iterator_is_at_end(iter)) break;
	      sc->w = cons(sc, x, sc->w);
	    }
	  sc->w = safe_reverse_in_place(sc, sc->w);
	}
    }
  x = sc->w;
  sc->w = sc->temp3;
  sc->temp3 = sc->nil;
  return(x);
}

#if (!WITH_PURE_S7)
static s7_pointer g_let_to_list(s7_scheme *sc, s7_pointer args)
{
  #define H_let_to_list "(let->list env) returns env's bindings as a list of cons's: '(symbol . value)."
  #define Q_let_to_list s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_let_symbol)

  s7_pointer env;
  env = car(args);
  check_method(sc, env, sc->let_to_list_symbol, args);
  if (!is_let(env))
    {
      if (is_c_object(env))
	env = c_object_let(env);
      else
	{
	  if (is_c_pointer(env))
	    env = c_pointer_info(env);
	}
      if (!is_let(env))
        return(simple_wrong_type_argument_with_type(sc, sc->let_to_list_symbol, env, a_let_string));
    }
  return(s7_let_to_list(sc, env));
}
#endif


/* -------------------------------- let-ref -------------------------------- */

static s7_pointer call_let_ref_fallback(s7_scheme *sc, s7_pointer env, s7_pointer symbol)
{
  s7_pointer p;
  /* args could be protected via let = stack_end[1] */
  push_stack_no_let(sc, OP_GC_PROTECT, sc->value, sc->code);
  p = s7_apply_function(sc, find_method(sc, env, sc->let_ref_fallback_symbol), set_qlist_2(sc, env, symbol));
  sc->stack_end -= 4;
  sc->code =  T_Pos(sc->stack_end[0]);
  sc->value =  T_Pos(sc->stack_end[2]);
  return(p);
}

static s7_pointer call_let_set_fallback(s7_scheme *sc, s7_pointer env, s7_pointer symbol, s7_pointer value)
{
  s7_pointer p;
  push_stack_no_let(sc, OP_GC_PROTECT, sc->value, sc->code);
  p = s7_apply_function(sc, find_method(sc, env, sc->let_set_fallback_symbol), set_qlist_3(sc, env, symbol, value));
  sc->stack_end -= 4;
  sc->code =  T_Pos(sc->stack_end[0]);
  sc->value =  T_Pos(sc->stack_end[2]);
  return(p);
}

inline s7_pointer s7_let_ref(s7_scheme *sc, s7_pointer env, s7_pointer symbol)
{
  s7_pointer x, y;
  /* (let ((a 1)) ((curlet) 'a))
   * ((rootlet) 'abs)
   */
  if (!is_let(env))
    return(wrong_type_argument_with_type(sc, sc->let_ref_symbol, 1, env, a_let_string));

  if (!is_symbol(symbol))
    {
      if (has_let_ref_fallback(env))
	return(call_let_ref_fallback(sc, env, symbol));
      return(wrong_type_argument_with_type(sc, sc->let_ref_symbol, 2, symbol, a_symbol_string));
    }

  check_method_uncopied(sc, env, sc->let_ref_symbol, list_2(sc, env, symbol));
  /* a let-ref method is almost impossible to write without creating an infinite loop:
   *   any reference to the let will probably call let-ref somewhere, calling us again, and looping.
   *   This is not a problem in c-objects and funclets because c-object-ref and funclet-ref don't exist.
   */

  if (is_keyword(symbol))
    symbol = keyword_symbol(symbol);

  if (env == sc->rootlet)
    {
      y = global_slot(symbol);
      if (is_slot(y))
	return(slot_value(y));
      return(sc->undefined);
    }

  if (let_id(env) == symbol_id(symbol))
    return(slot_value(local_slot(symbol))); /* this obviously has to follow the global-env check */

  for (x = env; is_let(x); x = outlet(x))
    for (y = let_slots(x); tis_slot(y); y = next_slot(y))
      if (slot_symbol(y) == symbol)
	return(slot_value(y));

  if (has_methods(env)) /* this is not a redundant check -- if has_methods, don't check global slot */
    {
      /* If a let is a mock-hash-table (for example), implicit
       *   indexing of the hash-table collides with the same thing for the let (field names
       *   versus keys), and we can't just try again here because that makes it too easy to
       *   get into infinite recursion.  So, 'let-ref-fallback...
       */
      if (has_let_ref_fallback(env))
	return(call_let_ref_fallback(sc, env, symbol));
    }
  else
    {
      y = global_slot(symbol);  /* (let () ((curlet) 'pi)) */
      if (is_slot(y))
	return(slot_value(y));
    }
  return(sc->undefined);
}

static s7_pointer g_let_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_let_ref "(let-ref env sym) returns the value of the symbol sym in the environment env"
  #define Q_let_ref s7_make_signature(sc, 3, sc->T, sc->is_let_symbol, sc->is_symbol_symbol)
  return(s7_let_ref(sc, car(args), cadr(args)));
}

static s7_pointer slot_in_let(s7_scheme *sc, s7_pointer e, s7_pointer sym)
{
  s7_pointer y;
  for (y = let_slots(e); tis_slot(y); y = next_slot(y))
    if (slot_symbol(y) == sym)
      return(y);
  return(sc->undefined);
}

static s7_pointer lint_let_ref_1(s7_scheme *sc, s7_pointer lt, s7_pointer sym)
{
  s7_pointer x, y;
  for (x = lt; is_let(x); x = outlet(x))
    for (y = let_slots(x); tis_slot(y); y = next_slot(y))
      if (slot_symbol(y) == sym)
	return(slot_value(y));

  if (has_methods(lt))
    {
      if (has_let_ref_fallback(lt))
	return(call_let_ref_fallback(sc, lt, sym));
    }
  else
    {
      y = global_slot(sym);
      if (is_slot(y))
	return(slot_value(y));
    }
  return(sc->undefined);
}

static s7_pointer let_ref_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(s7_let_ref(sc, p1, p2));}

static inline s7_pointer g_lint_let_ref(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lt, y, sym;
  lt = car(args);
  if (!is_let(lt))
    return(wrong_type_argument_with_type(sc, sc->let_ref_symbol, 1, lt, a_let_string));
  sym = cadr(args);
  for (y = let_slots(lt); tis_slot(y); y = next_slot(y))
    if (slot_symbol(y) == sym)
      return(slot_value(y));
  return(lint_let_ref_1(sc, outlet(lt), sym));
}

static s7_pointer let_ref_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if ((!ops) || (!is_global(sc->let_ref_symbol))) return(f);
  if ((is_h_safe_c_d(expr)) && (raw_opt1(expr) == sc->lint_let_ref))
    return(raw_opt1(expr));

  if (optimize_op(expr) == HOP_SAFE_C_opSq_C)
    {
      s7_pointer arg1, arg2;
      arg1 = cadr(expr);
      arg2 = caddr(expr);
      if ((car(arg1) == sc->cdr_symbol) &&
	  (is_quoted_pair(arg2)) &&
	  (is_symbol(cadr(arg2))) &&
	  (!is_possibly_constant(cadr(arg2))))
	{
	  set_opt3_sym(cdr(expr), cadr(arg2));
	  return(sc->lint_let_ref);
	}
    }
  return(f);
}

static bool op_environment_c(s7_scheme *sc)
{
  s7_pointer s;
  s = lookup_checked(sc, car(sc->code));
  if (!is_let(s)) {sc->last_function = s; return(false);}
  sc->value = s7_let_ref(sc, T_Pos(s), opt3_any(sc->code));
  return(true);
}

static bool op_environment_a(s7_scheme *sc)
{
  s7_pointer s;
  s = lookup_checked(sc, car(sc->code));
  if (!is_let(s)) {sc->last_function = s; return(false);}
  sc->value = s7_let_ref(sc, s, fx_call(sc, cdr(sc->code)));
  return(true);
}


/* -------------------------------- let-set! -------------------------------- */
static s7_pointer let_set_1(s7_scheme *sc, s7_pointer env, s7_pointer symbol, s7_pointer value)
{
  s7_pointer x, y;

  if (is_keyword(symbol))
    symbol = keyword_symbol(symbol);

  if (env == sc->rootlet)
    {
      if (is_constant_symbol(sc, symbol))  /* (let-set! (rootlet) 'pi #f) */
	return(wrong_type_argument_with_type(sc, sc->let_set_symbol, 2, symbol, a_non_constant_symbol_string));

      y = global_slot(symbol);
      if (is_slot(y))
	{
	  if (is_syntax(slot_value(y)))
	    return(wrong_type_argument_with_type(sc, sc->let_set_symbol, 2, symbol, wrap_string(sc, "a non-syntactic keyword", 23)));

	  if (slot_has_setter(y))
	    slot_set_value(y, call_setter(sc, y, value));
	  else slot_set_value(y, value);
	  return(slot_value(y));
	}
      return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, wrap_string(sc, "let-set!: ~A is not defined in ~A", 33), symbol, env)));
    }

  if (let_id(env) == symbol_id(symbol))
   {
     y = local_slot(symbol);
     if (is_slot(y))
       return(checked_slot_set_value(sc, y, value));
   }

  for (x = env; is_let(x); x = outlet(x))
    for (y = let_slots(x); tis_slot(y); y = next_slot(y))
      if (slot_symbol(y) == symbol)
	return(checked_slot_set_value(sc, y, value));

  if (has_methods(env))
    {
      if (has_let_set_fallback(env))
	return(call_let_set_fallback(sc, env, symbol, value));
    }

  return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, wrap_string(sc, "let-set!: ~A is not defined in ~A", 33), symbol, env)));
  /* not sure about this -- what's the most useful choice? */
}

s7_pointer s7_let_set(s7_scheme *sc, s7_pointer env, s7_pointer symbol, s7_pointer value)
{
  if (!is_let(env))
    return(wrong_type_argument_with_type(sc, sc->let_set_symbol, 1, env, a_let_string));

  if (is_immutable(env)) /* opt_p_ppp_fff can't check at opt time for immutable let, and it calls us */
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->let_set_symbol, env)));

  if (!is_symbol(symbol))
    {
      if (has_let_set_fallback(env))
	return(call_let_set_fallback(sc, env, symbol, value));
      return(wrong_type_argument_with_type(sc, sc->let_set_symbol, 2, symbol, a_symbol_string));
    }

  check_method_uncopied(sc, env, sc->let_set_symbol, sc->w = list_3(sc, env, symbol, value));
  return(let_set_1(sc, env, symbol, value));
}

static s7_pointer g_let_set(s7_scheme *sc, s7_pointer args)
{
  /* (let ((a 1)) (set! ((curlet) 'a) 32) a) */
  #define H_let_set "(let-set! env sym val) sets the symbol sym's value in the environment env to val"
  #define Q_let_set s7_make_signature(sc, 4, sc->T, sc->is_let_symbol, sc->is_symbol_symbol, sc->T)

  return(s7_let_set(sc, car(args), cadr(args), caddr(args)));
}

static s7_pointer let_set_p_ppp(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_pointer p3)
{
  return(s7_let_set(sc, p1, p2, p3));
}

static s7_pointer let_set_p_ppp_1(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_pointer p3)
{
  return(let_set_1(sc, p1, p2, p3));
}

static s7_pointer let_set_p_ppp_2(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_pointer p3)
{
  if (!is_symbol(p2))
    return(wrong_type_argument_with_type(sc, sc->let_set_symbol, 2, p2, a_symbol_string));
  return(let_set_1(sc, p1, p2, p3));
}

static s7_pointer g_lint_let_set_1(s7_scheme *sc, s7_pointer lt1, s7_pointer sym, s7_pointer val)
{
  s7_pointer lt, x, y;

  lt = (is_pair(lt1)) ? cdr(lt1) : g_cdr(sc, set_plist_1(sc, lt1));
  if (!is_let(lt))
    return(wrong_type_argument_with_type(sc, sc->let_set_symbol, 1, lt, a_let_string));
  if (is_immutable(lt))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->let_set_symbol, lt)));

  if (lt == sc->rootlet)
    {
      y = global_slot(sym);
      if (is_slot(y))
	{
	  if (slot_has_setter(y))
	    slot_set_value(y, call_setter(sc, y, val));
	  else slot_set_value(y, val);
	  return(slot_value(y));
	}
      return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, wrap_string(sc, "let-set!: ~A is not defined in ~A", 33), sym, lt)));
    }

  for (x = lt; is_let(x); x = outlet(x))
    for (y = let_slots(x); tis_slot(y); y = next_slot(y))
      if (slot_symbol(y) == sym)
	{
	  if (slot_has_setter(y))
	    slot_set_value(y, call_setter(sc, y, val));
	  else slot_set_value(y, val);
	  return(slot_value(y));
	}

  if (has_methods(lt))
    {
      if (has_let_set_fallback(lt))
	return(call_let_set_fallback(sc, lt, sym, val));
    }
  else
    {
      y = global_slot(sym);
      if (is_slot(y))
	{
	  if (slot_has_setter(y))
	    slot_set_value(y, call_setter(sc, y, val));
	  else slot_set_value(y, val);
	  return(slot_value(y));
	}
    }
  return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, wrap_string(sc, "let-set!: ~A is not defined in ~A", 33), sym, lt)));
}

static s7_pointer g_lint_let_set(s7_scheme *sc, s7_pointer args)
{
  return(g_lint_let_set_1(sc, lookup_checked(sc, opt3_sym(args)), opt1_con(args), lookup(sc, opt2_sym(args))));
}

static s7_pointer let_set_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if ((!ops) || (!is_global(sc->let_set_symbol))) return(f);
  if ((is_h_safe_c_d(expr)) && (raw_opt1(expr) == sc->lint_let_set))
    return(raw_opt1(expr));

  if (optimize_op(expr) == HOP_SAFE_C_opSq_CS)
    {
      s7_pointer arg1, arg2, arg3;
      arg1 = cadr(expr);
      arg2 = caddr(expr);
      arg3 = cadddr(expr);
      if ((car(arg1) == sc->cdr_symbol) &&
	  (car(arg2) == sc->quote_symbol) &&
	  (is_symbol(cadr(arg2))) &&
	  (!is_possibly_constant(cadr(arg2))) &&
	  (is_symbol(arg3)) &&
	  (!is_possibly_constant(arg3)))
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->lint_let_set);
	}
    }
  return(f);
}


static s7_pointer reverse_slots(s7_scheme *sc, s7_pointer list)
{
  s7_pointer p = list, result, q;
  result = slot_end(sc);

  while (tis_slot(p))
    {
      q = next_slot(p);
      set_next_slot(p, result);
      result = p;
      p = q;
    }
  return(result);
}

static s7_pointer let_copy(s7_scheme *sc, s7_pointer env)
{
  if (is_let(env))
    {
      s7_pointer new_e;

      if (env == sc->rootlet)   /* (copy (rootlet)) or (copy (funclet abs)) etc */
	return(sc->rootlet);

      /* we can't make copy handle environments-as-objects specially because the make-object function in define-class uses copy to make a new object!
       *   So if it is present, we get it here, and then there's almost surely trouble.
       */
      new_e = new_frame_in_env(sc, outlet(env));
      set_all_methods(new_e, env);
      sc->temp3 = new_e;
      if (tis_slot(let_slots(env)))
	{
	  s7_int id;
	  s7_pointer x, y = NULL;

	  id = let_id(new_e);
	  for (x = let_slots(env); tis_slot(x); x = next_slot(x))
	    {
	      s7_pointer z;
	      new_cell(sc, z, T_SLOT);
	      slot_set_symbol(z, slot_symbol(x));
	      slot_set_value(z, slot_value(x));
	      if (symbol_id(slot_symbol(z)) != id) /* keep shadowing intact */
		symbol_set_local(slot_symbol(x), id, z);
	      if (slot_has_setter(x))
		{
		  slot_set_setter(z, slot_setter(x));
		  slot_set_has_setter(z);
		}
	      if (tis_slot(let_slots(new_e)))
		set_next_slot(y, z);
	      else let_set_slots(new_e, z);
	      set_next_slot(z, slot_end(sc));              /* in case GC runs during this loop */
	      y = z;
	    }
	}
      /* We can't do a (normal) loop here then reverse the slots later because the symbol's local_slot has to
       *    match the unshadowed slot, not the last in the list:
       *    (let ((e1 (inlet 'a 1 'a 2))) (let ((e2 (copy e1))) (list (equal? e1 e2) (equal? (e1 'a) (e2 'a)))))
       */
      sc->temp3 = sc->nil;
      return(new_e);
    }
  return(sc->nil);
}


/* -------------------------------- rootlet -------------------------------- */
static s7_pointer g_rootlet(s7_scheme *sc, s7_pointer ignore)
{
  #define H_rootlet "(rootlet) returns the current top-level definitions (symbol bindings)."
  #define Q_rootlet s7_make_signature(sc, 1, sc->is_let_symbol)
  return(sc->rootlet);
}
/* as with the symbol-table, this function can lead to disaster -- user could
 *   clobber the environment etc.  But we want it to be editable and augmentable,
 *   so I guess I'll leave it alone.  (See curlet|funclet as well).
 */

s7_pointer s7_rootlet(s7_scheme *sc) {return(sc->rootlet);}

/* shadow_rootlet is a convenience for foreign function writers -- the C code can act as if it were loading everything into rootlet,
 *   but when actually loaded, everything can be shunted into a separate namespace (*motif* for example).
 */
s7_pointer s7_shadow_rootlet(s7_scheme *sc) {return(sc->shadow_rootlet);}

s7_pointer s7_set_shadow_rootlet(s7_scheme *sc, s7_pointer let)
{
  s7_pointer old_let;
  old_let = sc->shadow_rootlet;
  sc->shadow_rootlet = let;
  return(old_let); /* like s7_set_curlet below */
}


/* -------------------------------- curlet -------------------------------- */
static s7_pointer g_curlet(s7_scheme *sc, s7_pointer args)
{
  #define H_curlet "(curlet) returns the current definitions (symbol bindings)"
  #define Q_curlet s7_make_signature(sc, 1, sc->is_let_symbol)

  sc->capture_let_counter++;
  if (is_let(sc->envir))
    return(sc->envir);
  return(sc->rootlet);
}

s7_pointer s7_curlet(s7_scheme *sc)
{
  sc->capture_let_counter++;
  return(sc->envir);
}

static void update_symbol_ids(s7_scheme *sc, s7_pointer e)
{
  s7_pointer p;
  for (p = let_slots(e); tis_slot(p); p = next_slot(p))
    {
      s7_pointer sym;
      sym = slot_symbol(p);
      if (symbol_id(sym) != sc->let_number)
	symbol_set_local(sym, sc->let_number, p);
    }
}

s7_pointer s7_set_curlet(s7_scheme *sc, s7_pointer e)
{
  s7_pointer old_e;
  old_e = sc->envir;
  sc->envir = e;

  if ((is_let(e)) && (let_id(e) > 0)) /* might be () [id=-1] or rootlet [id=0] etc */
    {
      let_id(e) = ++sc->let_number;
      update_symbol_ids(sc, e);
    }

  return(old_e);
}


/* -------------------------------- outlet -------------------------------- */
s7_pointer s7_outlet(s7_scheme *sc, s7_pointer e) {return(outlet(e));}

static s7_pointer g_outlet(s7_scheme *sc, s7_pointer args)
{
  #define H_outlet "(outlet env) is the environment that contains env."
  #define Q_outlet s7_make_signature(sc, 2, sc->is_let_symbol, sc->is_let_symbol)

  s7_pointer env;

  env = car(args);
  if (!is_let(env))
    return(s7_wrong_type_arg_error(sc, "outlet", 1, env, "a let")); /* not a method call here! */

  if ((env == sc->rootlet) ||
      (is_null(outlet(env))))
    return(sc->rootlet);
  return(outlet(env));
}

static s7_pointer g_set_outlet(s7_scheme *sc, s7_pointer args)
{
  /* (let ((a 1)) (let ((b 2)) (set! (outlet (curlet)) (rootlet)) ((curlet) 'a))) */
  s7_pointer env, new_outer;

  env = car(args);
  if (!is_let(env))
    return(s7_wrong_type_arg_error(sc, "set! outlet", 1, env, "a let"));
  if (is_immutable(env))
    return(s7_wrong_type_arg_error(sc, "set! outlet", 1, env, "a mutable let"));

  new_outer = cadr(args);
  if (!is_let(new_outer))
    return(s7_wrong_type_arg_error(sc, "set! outlet", 2, new_outer, "a let"));

  if (env != sc->rootlet)
    set_outlet(env, (new_outer == sc->rootlet) ? sc->nil : new_outer);
  return(new_outer);
}

static inline s7_pointer symbol_to_slot(s7_scheme *sc, s7_pointer symbol)
{
  s7_pointer x;
  if (let_id(sc->envir) == symbol_id(symbol))
    return(local_slot(symbol));
  for (x = sc->envir; symbol_id(symbol) < let_id(x); x = outlet(x));
  if (let_id(x) == symbol_id(symbol))
    return(local_slot(symbol));
  for (; is_let(x); x = outlet(x))
    {
      s7_pointer y;
      for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	if (slot_symbol(y) == symbol)
	  return(y);
    }
  return(global_slot(symbol));
}

#if WITH_GCC && S7_DEBUGGING
static s7_pointer lookup_1(s7_scheme *sc, s7_pointer symbol)
#else
static inline s7_pointer lookup(s7_scheme *sc, s7_pointer symbol) /* lookup_checked includes the unbound_variable call */
#endif
{
  s7_pointer x;
  if (let_id(sc->envir) == symbol_id(symbol))
    return(slot_value(local_slot(symbol)));
  for (x = sc->envir; symbol_id(symbol) < let_id(x); x = outlet(x));
  if (let_id(x) == symbol_id(symbol))
    return(slot_value(local_slot(symbol)));
  for (; is_let(x); x = outlet(x))
    {
      s7_pointer y;
      for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	if (slot_symbol(y) == symbol)
	  return(slot_value(y));
    }
  x = global_slot(symbol);
  if (is_slot(x)) return(slot_value(x));
#if WITH_GCC
  return(NULL); /* much faster than various alternatives */
#else
  return(unbound_variable(sc, symbol));
#endif
}

s7_pointer s7_slot(s7_scheme *sc, s7_pointer symbol)
{
  return(symbol_to_slot(sc, symbol));
}

s7_pointer s7_slot_value(s7_pointer slot)
{
  return(slot_value(slot));
}

s7_pointer s7_slot_set_value(s7_scheme *sc, s7_pointer slot, s7_pointer value)
{
  slot_set_value(slot, value);
  return(value);
}

void s7_slot_set_real_value(s7_scheme *sc, s7_pointer slot, s7_double value)
{
  set_real(slot_value(slot), value);
}

static s7_pointer symbol_to_local_slot(s7_scheme *sc, s7_pointer symbol, s7_pointer e)
{
  if (!is_let(e))
    return(global_slot(symbol));

  if (symbol_id(symbol) != 0)
    {
      s7_pointer y;
      for (y = let_slots(e); tis_slot(y); y = next_slot(y))
	if (slot_symbol(y) == symbol)
	  return(y);
    }
  return(sc->undefined);
}

s7_pointer s7_symbol_value(s7_scheme *sc, s7_pointer sym)
{
  s7_pointer x;
  x = symbol_to_slot(sc, sym);
  if (is_slot(x))
    return(slot_value(x));
  return(sc->undefined);
}

s7_pointer s7_symbol_local_value(s7_scheme *sc, s7_pointer sym, s7_pointer local_env)
{
  /* restrict the search to local_env outward */
  if ((local_env == sc->rootlet) || (is_global(sym)))
    {
      if (is_slot(global_slot(sym)))
	return(slot_value(global_slot(sym)));
      return(sc->undefined);
    }

  if (is_let(local_env))
    {
      s7_pointer x;

      if (let_id(local_env) == symbol_id(sym))
	return(slot_value(local_slot(sym)));
      for (x = local_env; symbol_id(sym) < let_id(x); x = outlet(x));
      if (let_id(x) == symbol_id(sym))
	return(slot_value(local_slot(sym)));

      for (; is_let(x); x = outlet(x))
	{
	  s7_pointer y;
	  for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	    if (slot_symbol(y) == sym)
	      return(slot_value(y));
	}
      /* need to check rootlet before giving up */
      if (is_slot(global_slot(sym)))
	return(slot_value(global_slot(sym)));

      /* (let ((e (curlet))) (let ((a 1)) (symbol->value 'a e))) -> #<undefined> not 1 */
      return(sc->undefined); /* 29-Nov-17 */
    }
  return(s7_symbol_value(sc, sym));
}


/* -------------------------------- symbol->value -------------------------------- */

#define find_global_symbol_checked(Sc, Sym) ((is_global(Sym)) ? slot_value(global_slot(Sym)) : lookup_checked(Sc, Sym))

static s7_pointer g_s7_let_ref_fallback(s7_scheme *sc, s7_pointer args);

static s7_pointer g_symbol_to_value(s7_scheme *sc, s7_pointer args)
{
  #define H_symbol_to_value "(symbol->value sym (env (curlet))) returns the binding of (the value associated with) the \
symbol sym in the given environment: (let ((x 32)) (symbol->value 'x)) -> 32"
  #define Q_symbol_to_value s7_make_signature(sc, 3, sc->T, sc->is_symbol_symbol, sc->is_let_symbol)
  /* (symbol->value 'x e) => (e 'x)? */

  s7_pointer sym;
  sym = car(args);

  if (!is_symbol(sym))
    return(method_or_bust(sc, sym, sc->symbol_to_value_symbol, args, T_SYMBOL, 1));

  if (is_not_null(cdr(args)))
    {
      s7_pointer local_env;

      local_env = cadr(args);
      if (local_env == sc->unlet_symbol)
	return((is_slot(initial_slot(sym))) ? slot_value(initial_slot(sym)) : sc->undefined);

      if (!is_let(local_env))
	return(method_or_bust_with_type(sc, local_env, sc->symbol_to_value_symbol, args, a_let_string, 2));

      if (local_env == sc->s7_let)
	return(g_s7_let_ref_fallback(sc, set_qlist_2(sc, local_env, sym)));

      return(s7_symbol_local_value(sc, sym, local_env));
    }

  if (is_global(sym))
    return(slot_value(global_slot(sym)));

  return(s7_symbol_value(sc, sym));
}

s7_pointer s7_symbol_set_value(s7_scheme *sc, s7_pointer sym, s7_pointer val)
{
  s7_pointer x;
  /* if immutable should this return an error? */
  x = symbol_to_slot(sc, sym);
  if (is_slot(x))
    slot_set_value(x, val); /* with_hook? */
  return(val);
}


/* -------------------------------- symbol->dynamic-value -------------------------------- */

static s7_pointer find_dynamic_value(s7_scheme *sc, s7_pointer x, s7_pointer sym, int64_t *id)
{
  for (; symbol_id(sym) < let_id(x); x = outlet(x));

  if (let_id(x) == symbol_id(sym))
    {
      (*id) = let_id(x);
      return(slot_value(local_slot(sym)));
    }
  for (; (is_let(x)) && (let_id(x) > (*id)); x = outlet(x))
    {
      s7_pointer y;
      for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	if (slot_symbol(y) == sym)
	  {
	    (*id) = let_id(x);
	    return(slot_value(y));
	  }
    }
  return(sc->unused);
}

static s7_pointer g_symbol_to_dynamic_value(s7_scheme *sc, s7_pointer args)
{
  #define H_symbol_to_dynamic_value "(symbol->dynamic-value sym) returns the dynamic binding of the symbol sym"
  #define Q_symbol_to_dynamic_value s7_make_signature(sc, 2, sc->T, sc->is_symbol_symbol)

  s7_pointer sym, val;
  int64_t i, top_id;

  sym = car(args);
  if (!is_symbol(sym))
    return(method_or_bust(sc, sym, sc->symbol_to_dynamic_value_symbol, args, T_SYMBOL, 1));

  if (is_global(sym))
    return(slot_value(global_slot(sym)));

  if (let_id(sc->envir) == symbol_id(sym))
    return(slot_value(local_slot(sym)));

  top_id = -1;
  val = find_dynamic_value(sc, sc->envir, sym, &top_id);
  if (top_id == symbol_id(sym))
    return(val);

  for (i = s7_stack_top(sc) - 1; i > 0; i -= 4)
    {
      s7_pointer cur_val;
      cur_val = find_dynamic_value(sc, stack_let(sc->stack, i), sym, &top_id);
      if (cur_val != sc->unused)
	val = cur_val;
      if (top_id == symbol_id(sym))
	return(val);
    }

  if (val == sc->unused)
    return(s7_symbol_value(sc, sym));
  return(val);
}


typedef bool (safe_sym_t)(s7_scheme *sc, s7_pointer sym, s7_pointer e);

static bool direct_memq(s7_pointer symbol, s7_pointer symbols)
{
  s7_pointer x;
  for (x = symbols; is_pair(x); x = cdr(x))
    if (car(x) == symbol)
	return(true);
  return(false);
}

static bool direct_assq(s7_pointer symbol, s7_pointer symbols)
{ /* used only below in do_symbol_is_safe */
  s7_pointer x;
  for (x = symbols; is_pair(x); x = cdr(x))
    if (caar(x) == symbol)
      return(true);
  return(false);
}

static bool do_symbol_is_safe(s7_scheme *sc, s7_pointer sym, s7_pointer e)
{
  return((is_slot(global_slot(sym))) ||
	 (direct_assq(sym, e)) ||
	 (is_slot(symbol_to_slot(sc, sym))));
}

static bool let_symbol_is_safe(s7_scheme *sc, s7_pointer sym, s7_pointer e)
{
  if (is_slot(global_slot(sym)))
    return(true);
  if (is_null(e))
    e = sc->rootlet;
  return((!is_with_let_let(e)) &&
	 (is_slot(symbol_to_slot(sc, sym))));
}

static bool let_symbol_is_safe_or_listed(s7_scheme *sc, s7_pointer sym, s7_pointer e)
{
  return((symbol_is_in_list(sc, sym)) ||
	 (let_symbol_is_safe(sc, sym, e)));
}

static bool let_star_symbol_is_safe(s7_scheme *sc, s7_pointer sym, s7_pointer e)
{
  return((symbol_is_in_list(sc, sym)) ||
	 (is_slot(global_slot(sym))) ||
	 ((is_let(e)) && (!is_with_let_let(e)) && (is_slot(symbol_to_slot(sc, sym)))));
}

static bool pair_symbol_is_safe(s7_scheme *sc, s7_pointer sym, s7_pointer e)
{
  return((is_slot(global_slot(sym))) ||
	 (direct_memq(sym, e)));
}

static inline s7_pointer collect_variables(s7_scheme *sc, s7_pointer lst, s7_pointer e)
{
  /* collect local variable names from let/do (pre-error-check) */
  s7_pointer p;
  sc->w = e;
  for (p = lst; is_pair(p); p = cdr(p))
    sc->w = cons(sc, add_symbol_to_list(sc, caar(p)), sc->w);
  return(sc->w);
}

static s7_pointer collect_parameters(s7_scheme *sc, s7_pointer lst, s7_pointer e)
{
  /* collect local variable names from lambda arglists (pre-error-check) */
  s7_pointer p;
  if (is_symbol(lst))
    return(cons(sc, add_symbol_to_list(sc, lst), e));
  sc->w = e;
  for (p = lst; is_pair(p); p = cdr(p))
    {
      s7_pointer car_p;
      car_p = car(p);
      if (is_pair(car_p))
	car_p = car(car_p);
      if ((is_symbol(car_p)) &&
	  (!is_keyword(car_p)))
	sc->w = cons(sc, add_symbol_to_list(sc, car_p), sc->w);
    }
  if (is_symbol(p)) /* rest arg */
    sc->w = cons(sc, add_symbol_to_list(sc, p), sc->w);
  return(sc->w);
}

typedef enum {OPT_F, OPT_T, OPT_OOPS} opt_t;
static opt_t optimize(s7_scheme *sc, s7_pointer code, int32_t hop, s7_pointer e);

static void clear_all_optimizations(s7_scheme *sc, s7_pointer p)
{
  /* I believe that we would not have been optimized to begin with if the tree were circular,
   *   and this tree is supposed to be a function call + args -- a circular list here is a bug.
   */
  if (is_pair(p))
    {
      if ((is_optimized(p)) &&
	  ((optimize_op(p) & 1) == 0)) /* protect possibly shared code?  Elsewhere we assume these aren't changed */
	{
	  clear_optimized(p);     /* includes T_SYNTACTIC */
	  clear_optimize_op(p);
	}
      clear_all_optimizations(sc, cdr(p));
      clear_all_optimizations(sc, car(p));
    }
}

static s7_pointer make_macro(s7_scheme *sc, opcode_t op)
{
  s7_pointer cx, mac;
  uint64_t typ;

  if (op == OP_DEFINE_MACRO)
    typ = T_MACRO | T_DONT_EVAL_ARGS | T_COPY_ARGS;
  else
    {
      if (op == OP_DEFINE_MACRO_STAR)
	typ = T_MACRO_STAR | T_DONT_EVAL_ARGS | T_COPY_ARGS;
      else
	{
	  if (op == OP_DEFINE_BACRO)
	    typ = T_BACRO | T_DONT_EVAL_ARGS | T_COPY_ARGS;
	  else
	    {
	      if (op == OP_DEFINE_BACRO_STAR)
		typ = T_BACRO_STAR | T_DONT_EVAL_ARGS | T_COPY_ARGS;
	      else
		{
		  if ((op == OP_DEFINE_EXPANSION) &&
		      (!is_let(sc->envir)))        /* local expansions are just normal macros */
		    typ = T_MACRO | T_EXPANSION | T_DONT_EVAL_ARGS | T_COPY_ARGS;
		  else typ = T_MACRO | T_DONT_EVAL_ARGS | T_COPY_ARGS;
		}
	    }
	}
    }

  new_cell_no_check(sc, mac, typ);
  sc->temp6 = mac;
  closure_set_args(mac, cdar(sc->code));
  closure_set_body(mac, cdr(sc->code));
  closure_set_setter(mac, sc->F);
  closure_set_let(mac, sc->envir);
  closure_set_arity(mac, CLOSURE_ARITY_NOT_SET);

  sc->capture_let_counter++;
  sc->code = caar(sc->code);
  if ((op == OP_DEFINE_EXPANSION) &&
      (!is_let(sc->envir)))
    set_type(sc->code, T_EXPANSION | T_SYMBOL | (typeflag(sc->code) & T_UNHEAP)); /* see comment under READ_TOK */
  /* symbol? macro name has already been checked, find name in environment, and define it */
  cx = symbol_to_local_slot(sc, sc->code, sc->envir);
  if (is_slot(cx))
    slot_set_value_with_hook(cx, mac);
  else s7_make_slot(sc, sc->envir, sc->code, mac); /* was current but we've checked immutable already */

  clear_symbol_list(sc); /* tracks names local to this macro */
  if (optimize(sc, closure_body(mac), 1, collect_parameters(sc, closure_args(mac), sc->nil)) == OPT_OOPS)
    clear_all_optimizations(sc, closure_body(mac));

  sc->temp6 = sc->nil;
  return(mac);
}

static s7_pointer make_closure(s7_scheme *sc, s7_pointer args, s7_pointer code, uint64_t type, int32_t arity)
{
  /* this is called every time a lambda form is evaluated, or during letrec, etc */
  s7_pointer x;
  new_cell(sc, x, (type | closure_bits(code)));
  closure_set_args(x, args);
  closure_set_body(x, code);
  if (is_pair(cdr(code))) set_closure_has_multiform(x); else set_closure_has_one_form(x);
  closure_set_let(x, sc->envir);
  closure_set_setter(x, sc->F);
  closure_set_arity(x, arity);
  sc->capture_let_counter++;
  return(x);
}

#define make_closure_with_let(Sc, X, Args, Code, Env, Arity)	\
  do {							\
    new_cell(Sc, X, T_CLOSURE | T_COPY_ARGS | closure_bits(Code));	\
    closure_set_args(X, Args);						\
    closure_set_body(X, Code);				                \
    if (is_pair(cdr(Code))) set_closure_has_multiform(X); else set_closure_has_one_form(X);\
    closure_set_let(X, Env);						\
    closure_set_setter(X, sc->F);					\
    closure_set_arity(X, Arity);					\
    sc->capture_let_counter++;						\
  } while (0)

static int32_t closure_length(s7_scheme *sc, s7_pointer e)
{
  /* we can't use let_length(sc, closure_let(e)) because the closure_let(closure)
   *   changes.  So the open bit is not always on.  Besides, the fallbacks need to be for closures, not environments.
   */
  s7_pointer length_func;
  length_func = find_method(sc, closure_let(e), sc->length_symbol);
  if (length_func != sc->undefined)
    return((int32_t)s7_integer(s7_apply_function(sc, length_func, list_1(sc, e))));

  /* there are cases where this should raise a wrong-type-arg error, but for now... */
  return(-1);
}

static s7_pointer copy_tree_with_type(s7_scheme *sc, s7_pointer tree)
{
  /* if sc->safety > NO_SAFETY, '(1 2) is set immutable by the reader, but eval (in that safety case) calls
   *   copy_body on the incoming tree, so we have to preserve T_IMMUTABLE in that case.
   * if tree is something like (+ 1 (car '#1=(2 . #1#))), we have to see the quoted list and not copy it.
   */
#if WITH_GCC
  #define COPY_TREE_WITH_TYPE(P) ({s7_pointer _p; _p = P; \
                                   cons_unchecked_with_type(sc, _p, (is_unquoted_pair(car(_p))) ? copy_tree_with_type(sc, car(_p)) : car(_p), \
                                                                    (is_unquoted_pair(cdr(_p))) ? copy_tree_with_type(sc, cdr(_p)) : cdr(_p));})
#else
  #define COPY_TREE_WITH_TYPE(P) copy_tree_with_type(sc, P)
#endif

  return(cons_unchecked_with_type(sc, tree,
				  (is_unquoted_pair(car(tree))) ? COPY_TREE_WITH_TYPE(car(tree)) : car(tree),
				  (is_unquoted_pair(cdr(tree))) ? COPY_TREE_WITH_TYPE(cdr(tree)) : cdr(tree)));
}

static s7_pointer copy_tree(s7_scheme *sc, s7_pointer tree)
{
#if WITH_GCC
  #define COPY_TREE(P) ({s7_pointer _p; _p = P; \
                         cons_unchecked(sc, (is_pair(car(_p))) ? copy_tree(sc, car(_p)) : car(_p), \
                                            (is_pair(cdr(_p))) ? copy_tree(sc, cdr(_p)) : cdr(_p));})
#else
  #define COPY_TREE(P) copy_tree(sc, P)
#endif

  return(cons_unchecked(sc,
			(is_pair(car(tree))) ? COPY_TREE(car(tree)) : car(tree),
			(is_pair(cdr(tree))) ? COPY_TREE(cdr(tree)) : cdr(tree)));
}


/* -------------------------------- tree-cyclic? -------------------------------- */
#define TREE_NOT_CYCLIC 0
#define TREE_CYCLIC 1
#define TREE_HAS_PAIRS 2

static int tree_is_cyclic_or_has_pairs(s7_scheme *sc, s7_pointer tree)
{
  s7_pointer fast, slow;
  bool has_pairs = false;

  if (!is_pair(tree)) return(TREE_NOT_CYCLIC);
  slow = tree;
  fast = tree;
  while (true)
    {
      if (tree_is_collected(fast)) return(TREE_CYCLIC);
      if ((!has_pairs) &&
	  (is_unquoted_pair(car(fast))))
	has_pairs = true;
      fast = cdr(fast);
      if (!is_pair(fast))
	{
	  if (!has_pairs) return(TREE_NOT_CYCLIC);
	  break;
	}
      if (tree_is_collected(fast)) return(TREE_CYCLIC);
      if ((!has_pairs) &&
	  (is_unquoted_pair(car(fast))))
	has_pairs = true;
      fast = cdr(fast);
      if (!is_pair(fast))
	{
	  if (!has_pairs) return(TREE_NOT_CYCLIC);
	  break;
	}
      slow = cdr(slow);
      if (fast == slow) return(TREE_CYCLIC);
    }
#if S7_DEBUGGING
  if (!has_pairs) fprintf(stderr, "at end but no pairs: %s\n", DISPLAY(tree));
#endif
  return(TREE_HAS_PAIRS);
}

/* we can't use shared_info here because tree_is_cyclic may be called in the midst of output that depends on sc->circle_info */

static bool tree_is_cyclic_1(s7_scheme *sc, s7_pointer tree)
{
  s7_pointer p;
  for (p = tree; is_pair(p); p = cdr(p))
    {
      tree_set_collected(p);
      if (sc->tree_pointers_top == sc->tree_pointers_size)
	{
	  if (sc->tree_pointers_size == 0)
	    {
	      sc->tree_pointers_size = 8;
	      sc->tree_pointers = (s7_pointer *)malloc(sc->tree_pointers_size * sizeof(s7_pointer));
	    }
	  else
	    {
	      sc->tree_pointers_size *= 2;
	      sc->tree_pointers = (s7_pointer *)realloc(sc->tree_pointers, sc->tree_pointers_size * sizeof(s7_pointer));
	    }
	}
      sc->tree_pointers[sc->tree_pointers_top++] = p;
      if (is_unquoted_pair(car(p)))
	{
	  int32_t i, old_top, result;
	  old_top = sc->tree_pointers_top;
	  result = tree_is_cyclic_or_has_pairs(sc, car(p));
	  if ((result == TREE_CYCLIC) ||
	      (tree_is_cyclic_1(sc, car(p))))
	    return(true);
	  for (i = old_top; i < sc->tree_pointers_top; i++)
	    tree_clear_collected(sc->tree_pointers[i]);
	  sc->tree_pointers_top = old_top;
	}
    }
  return(false);
}

static bool tree_is_cyclic(s7_scheme *sc, s7_pointer tree)
{
  int32_t i, result;

  result = tree_is_cyclic_or_has_pairs(sc, tree);
  if (result == TREE_NOT_CYCLIC) return(false);
  if (result == TREE_CYCLIC) return(true);

#if S7_DEBUGGING
  if (sc->tree_pointers_top != 0)
    fprintf(stderr, "top: %d\n", sc->tree_pointers_top);
#endif

  result = tree_is_cyclic_1(sc, tree);
  for (i = 0; i < sc->tree_pointers_top; i++)
    tree_clear_collected(sc->tree_pointers[i]);
  sc->tree_pointers_top = 0;

 return(result);
}

static s7_pointer g_tree_is_cyclic(s7_scheme *sc, s7_pointer args)
{
  #define H_tree_is_cyclic "(tree-cyclic? tree) returns #t if the tree has a cycle."
  #define Q_tree_is_cyclic sc->pl_bt
  return(make_boolean(sc, tree_is_cyclic(sc, car(args))));
}

static inline s7_int tree_len(s7_scheme *sc, s7_pointer p);

static s7_pointer copy_body(s7_scheme *sc, s7_pointer p)
{
  sc->w = p;
  if (tree_is_cyclic(sc, p))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "copy: tree is cyclic", 20));
  check_heap_size(sc, tree_len(sc, p) * 2);
  if (sc->safety > NO_SAFETY)
    sc->w = copy_tree_with_type(sc, p);
  else sc->w = copy_tree(sc, p);
  p = sc->w;
  sc->w = sc->nil;
  return(p);
}

static s7_pointer copy_closure(s7_scheme *sc, s7_pointer fnc)
{
  /* copy the source tree annotating (for eventual optimization), return a thing of the same type as fnc */
  s7_pointer x, body;

  body = copy_body(sc, closure_body(fnc));
  new_cell(sc, x, typeflag(fnc) & (~T_COLLECTED)); /* I'm paranoid about that is_collected bit */
  closure_set_args(x, closure_args(fnc));
  closure_set_body(x, body);
  closure_set_setter(x, closure_setter(fnc));
  closure_set_arity(x, closure_arity(fnc));
  closure_set_let(x, closure_let(fnc));
  return(x);
}


/* -------------------------------- defined? -------------------------------- */
static s7_pointer g_is_defined(s7_scheme *sc, s7_pointer args)
{
  #define H_is_defined "(defined? symbol (env (curlet)) ignore-globals) returns #t if symbol has a binding (a value) in the environment env.  Only env is searched if ignore-globals is not #f."
  #define Q_is_defined s7_make_signature(sc, 4, sc->is_boolean_symbol, sc->is_symbol_symbol, sc->is_let_symbol, sc->is_boolean_symbol)

  s7_pointer sym;
  /* is this correct?
   *    (defined? '_x) #f (symbol->value '_x) #<undefined>
   *    (define x #<undefined>) (defined? 'x) #t
   * can't return the value here because it might be #f
   */

  sym = car(args);
  if (!is_symbol(sym))
    return(method_or_bust(sc, sym, sc->is_defined_symbol, args, T_SYMBOL, 1));

  if (is_pair(cdr(args)))
    {
      s7_pointer e, b, x;

      e = cadr(args);
      if (!is_let(e))
	return(wrong_type_argument_with_type(sc, sc->is_defined_symbol, 2, e, a_let_string));
      if (e == sc->s7_let)
	return(make_boolean(sc, is_s7_let_field(sym)));

      if (is_pair(cddr(args)))
	{
	  b = caddr(args);
	  if (!s7_is_boolean(b))
	    return(method_or_bust_with_type(sc, b, sc->is_defined_symbol, args, a_boolean_string, 3));
	}
      else b = sc->F;

      if (e == sc->rootlet) /* we checked (let? e) above */
	{
	  if (b == sc->F)
	    return(make_boolean(sc, is_slot(global_slot(sym)))); /* new_symbol and gensym initialize global_slot to #<undefined> */
	  return(sc->F);
	}

      x = symbol_to_local_slot(sc, sym, e);
      if (is_slot(x))
	return(sc->T);

      if (b == sc->T)
	return(sc->F);
      return(make_boolean(sc, is_slot(global_slot(sym))));
    }
  if (is_global(sym))
    return(sc->T);
  return(make_boolean(sc, is_slot(symbol_to_slot(sc, sym))));
}

bool s7_is_defined(s7_scheme *sc, const char *name)
{
  s7_pointer x;
  x = s7_symbol_table_find_name(sc, name);
  if (x)
    {
      x = symbol_to_slot(sc, x);
      return(is_slot(x));
    }
  return(false);
}

static bool is_defined_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_symbol(p))
    simple_wrong_type_argument(sc, sc->is_defined_symbol, p, T_SYMBOL);
  return(is_slot(symbol_to_slot(sc, p)));
}

static bool is_defined_b_7pp(s7_scheme *sc, s7_pointer p, s7_pointer e) {return(g_is_defined(sc, set_plist_2(sc, p, e)) != sc->F);}

void s7_define(s7_scheme *sc, s7_pointer envir, s7_pointer symbol, s7_pointer value)
{
  s7_pointer x;
  if ((envir == sc->nil) ||
      (envir == sc->rootlet))
    envir = sc->shadow_rootlet;
  x = symbol_to_local_slot(sc, symbol, envir);
  if (is_slot(x))
    slot_set_value_with_hook(x, value);
  else
    {
      s7_make_slot(sc, envir, symbol, value); /* I think this means C code can override "constant" defs */
      /* if envir is sc->nil or rootlet, s7_make_slot makes a permanent_slot */
      if ((envir == sc->shadow_rootlet) &&
	  (!is_slot(global_slot(symbol))))
	{
	  set_global(symbol); /* is_global => global_slot is usable */
	  set_global_slot(symbol, local_slot(symbol));
	}
    }
}

s7_pointer s7_define_variable(s7_scheme *sc, const char *name, s7_pointer value)
{
  s7_pointer sym;
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, value);
  return(sym);
}

s7_pointer s7_define_variable_with_documentation(s7_scheme *sc, const char *name, s7_pointer value, const char *help)
{
  s7_pointer sym;
  sym = s7_define_variable(sc, name, value);
  symbol_set_has_help(sym);
  symbol_set_help(sym, copy_string(help));
  return(sym);
}

s7_pointer s7_define_constant(s7_scheme *sc, const char *name, s7_pointer value)
{
  s7_pointer sym;
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, value);
  set_immutable(sym);
  set_possibly_constant(sym);
  set_immutable(global_slot(sym));
  set_immutable(local_slot(sym));
  return(sym);
}

/* (define (func a) (let ((cvar (+ a 1))) cvar)) (define-constant cvar 23) (func 1) -> ;can't bind an immutable object: cvar
 * (let ((aaa 1)) (define-constant aaa 32) (set! aaa 3)) -> set!: can't alter immutable object: aaa
 */

s7_pointer s7_define_constant_with_documentation(s7_scheme *sc, const char *name, s7_pointer value, const char *help)
{
  s7_pointer sym;
  sym = s7_define_constant(sc, name, value);
  symbol_set_has_help(sym);
  symbol_set_help(sym, copy_string(help));
  return(value); /* inconsistent with variable above, but consistent with define_function? */
}


/* -------------------------------- keyword? -------------------------------- */

bool s7_is_keyword(s7_pointer obj) {return(is_keyword(obj));}

static s7_pointer g_is_keyword(s7_scheme *sc, s7_pointer args)
{
  #define H_is_keyword "(keyword? obj) returns #t if obj is a keyword, (keyword? :rest) -> #t"
  #define Q_is_keyword sc->pl_bt
  check_boolean_method(sc, is_keyword, sc->is_keyword_symbol, args);
}


/* -------------------------------- string->keyword -------------------------------- */
s7_pointer s7_make_keyword(s7_scheme *sc, const char *key)
{
  s7_pointer sym;
  block_t *b;
  char *name;
  size_t slen;
  slen = (size_t)safe_strlen(key);
  b = mallocate(sc, slen + 2);
  name = (char *)block_data(b);
  catstrs_direct(name, ":", key, NULL);              /* use catstrs_direct to get around a bug in gcc 8.1 */
  sym = make_symbol_with_length(sc, name, slen + 1); /* keyword slot etc taken care of here (in new_symbol actually) */
  liberate(sc, b);
  return(sym);
}

static s7_pointer g_string_to_keyword(s7_scheme *sc, s7_pointer args)
{
  #define H_string_to_keyword "(string->keyword str) prepends ':' to str and defines that as a keyword"
  #define Q_string_to_keyword s7_make_signature(sc, 2, sc->is_keyword_symbol, sc->is_string_symbol)

  s7_pointer str;
  str = car(args);
  if (!is_string(str))
    return(method_or_bust_one_arg(sc, str, sc->string_to_keyword_symbol, args, T_STRING));
  if ((string_length(str) == 0) ||
      (string_value(str)[0] == '\0'))
    return(s7_error(sc, sc->out_of_range_symbol, set_elist_2(sc, wrap_string(sc, "string->keyword wants a non-null string: ~S", 43), str)));
  return(s7_make_keyword(sc, string_value(str)));
}


/* -------------------------------- keyword->symbol -------------------------------- */
static s7_pointer g_keyword_to_symbol(s7_scheme *sc, s7_pointer args)
{
  #define H_keyword_to_symbol "(keyword->symbol key) returns a symbol with the same name as key but no prepended colon"
  #define Q_keyword_to_symbol s7_make_signature(sc, 2, sc->is_symbol_symbol, sc->is_keyword_symbol)

  s7_pointer sym;
  sym = car(args);
  if (!is_keyword(sym))
    return(method_or_bust_with_type_one_arg(sc, sym, sc->keyword_to_symbol_symbol, args, wrap_string(sc, "a keyword", 9)));
  return(keyword_symbol(sym));
}

s7_pointer s7_keyword_to_symbol(s7_scheme *sc, s7_pointer key) {return(keyword_symbol(key));}


/* -------------------------------- symbol->keyword -------------------------------- */
static s7_pointer symbol_to_keyword(s7_scheme *sc, s7_pointer sym)
{
  return(s7_make_keyword(sc, symbol_name(sym)));
}

static s7_pointer g_symbol_to_keyword(s7_scheme *sc, s7_pointer args)
{
  #define H_symbol_to_keyword "(symbol->keyword sym) returns a keyword with the same name as sym, but with a colon prepended"
  #define Q_symbol_to_keyword s7_make_signature(sc, 2, sc->is_keyword_symbol, sc->is_symbol_symbol)

  if (!is_symbol(car(args)))
    return(method_or_bust_one_arg(sc, car(args), sc->symbol_to_keyword_symbol, args, T_SYMBOL));
  return(symbol_to_keyword(sc, car(args)));
}


/* -------------------------------- c-pointer? -------------------------------- */
bool s7_is_c_pointer(s7_pointer arg) {return(is_c_pointer(arg));}

bool s7_is_c_pointer_of_type(s7_pointer arg, s7_pointer type)
{
  return((is_c_pointer(arg)) && (c_pointer_type(arg) == type));
}

static s7_pointer g_is_c_pointer(s7_scheme *sc, s7_pointer args)
{
  #define H_is_c_pointer "(c-pointer? obj type) returns #t if obj is a C pointer being held in s7.  If type is given, the c_pointer's type is also checked."
  #define Q_is_c_pointer s7_make_signature(sc, 3, sc->is_boolean_symbol, sc->T, sc->T)

  s7_pointer p;
  p = car(args);
  if (!is_c_pointer(p))
    {
      if (!has_active_methods(sc, p)) return(sc->F);
      return(apply_boolean_method(sc, p, sc->is_c_pointer_symbol));
    }
  if (is_pair(cdr(args)))
    return(make_boolean(sc, c_pointer_type(p) == cadr(args)));
  return(sc->T);
}


/* -------------------------------- c-pointer -------------------------------- */
void *s7_c_pointer(s7_pointer p)
{
  if ((is_number(p)) &&
      (s7_integer(p) == 0))
    return(NULL); /* special case where the null pointer has been cons'd up by hand */

  if (!is_c_pointer(p))
    return(NULL);

  return(c_pointer(p));
}

s7_pointer s7_make_c_pointer_with_type(s7_scheme *sc, void *ptr, s7_pointer type, s7_pointer info)
{
  s7_pointer x;
  new_cell(sc, x, T_C_POINTER);
  c_pointer(x) = ptr;
  c_pointer_type(x) = type;
  c_pointer_info(x) = info;
  c_pointer_weak1(x) = sc->F;
  c_pointer_weak2(x) = sc->F;
  return(x);
}

s7_pointer s7_make_c_pointer(s7_scheme *sc, void *ptr) {return(s7_make_c_pointer_with_type(sc, ptr, sc->F, sc->F));}

static s7_pointer g_c_pointer(s7_scheme *sc, s7_pointer args)
{
  #define H_c_pointer "(c-pointer int type info unmarked) returns a c-pointer object. The type and info args are optional, defaulting to #f."
  #define Q_c_pointer s7_make_circular_signature(sc, 2, 3, sc->is_c_pointer_symbol, sc->is_integer_symbol, sc->T)

  s7_pointer arg, type, info, weak1, weak2, cp;
  intptr_t p;

  type = sc->F;
  info = sc->F;
  weak1 = sc->F;
  weak2 = sc->F;
  arg = car(args);
  if (!s7_is_integer(arg))
    return(method_or_bust(sc, arg, sc->c_pointer_symbol, args, T_INTEGER, 1));
  p = (intptr_t)s7_integer(arg);             /* (c-pointer (bignum "1234")) */
  args = cdr(args);
  if (is_pair(args))
    {
      type = car(args);
      args = cdr(args);
      if (is_pair(args))
	{
	  info = car(args);
	  args = cdr(args);
	  if (is_pair(args))
	    {
	      weak1 = car(args);
	      args = cdr(args);
	      if (is_pair(args))
		weak2 = car(args);
	    }
	}
    }
  cp = s7_make_c_pointer_with_type(sc, (void *)p, type, info);
  c_pointer_set_weak1(cp, weak1);
  c_pointer_set_weak2(cp, weak2);
  if ((weak1 != sc->F) || (weak2 != sc->F))
    add_weak_ref(sc, cp);
  return(cp);
}


/* -------------------------------- c-pointer-info -------------------------------- */
static s7_pointer c_pointer_info_p_p(s7_scheme *sc, s7_pointer p)
{
  if (!is_c_pointer(p))
    return(method_or_bust(sc, p, sc->c_pointer_info_symbol, list_1(sc, p), T_C_POINTER, 1));
  return(c_pointer_info(p));
}

static s7_pointer g_c_pointer_info(s7_scheme *sc, s7_pointer args)
{
  #define H_c_pointer_info "(c-pointer-info obj) returns the c-pointer info field"
  #define Q_c_pointer_info s7_make_signature(sc, 2, sc->T, sc->is_c_pointer_symbol)
  return(c_pointer_info_p_p(sc, car(args)));
}


/* -------------------------------- c-pointer-type -------------------------------- */
s7_pointer s7_c_pointer_type(s7_pointer p)
{
  if (!is_c_pointer(p))
    return(NULL); /* as above */
  return(c_pointer_type(p));
}

static s7_pointer c_pointer_type_p_p(s7_scheme *sc, s7_pointer p)
{
  if (!is_c_pointer(p))
    return(method_or_bust(sc, p, sc->c_pointer_type_symbol, list_1(sc, p), T_C_POINTER, 1));
  return(c_pointer_type(p));
}

static s7_pointer g_c_pointer_type(s7_scheme *sc, s7_pointer args)
{
  #define H_c_pointer_type "(c-pointer-type obj) returns the c-pointer type field"
  #define Q_c_pointer_type s7_make_signature(sc, 2, sc->T, sc->is_c_pointer_symbol)
  return(c_pointer_type_p_p(sc, car(args)));
}


/* -------------------------------- c-pointer-weak1/2 -------------------------------- */
static s7_pointer c_pointer_weak1_p_p(s7_scheme *sc, s7_pointer p)
{
  if (!is_c_pointer(p))
    return(method_or_bust(sc, p, sc->c_pointer_weak1_symbol, list_1(sc, p), T_C_POINTER, 1));
  return(c_pointer_weak1(p));
}

static s7_pointer g_c_pointer_weak1(s7_scheme *sc, s7_pointer args)
{
  #define H_c_pointer_weak1 "(c-pointer-weak1 obj) returns the c-pointer weak1 field"
  #define Q_c_pointer_weak1 s7_make_signature(sc, 2, sc->T, sc->is_c_pointer_symbol)
  return(c_pointer_weak1_p_p(sc, car(args)));
}

static s7_pointer c_pointer_weak2_p_p(s7_scheme *sc, s7_pointer p)
{
  if (!is_c_pointer(p))
    return(method_or_bust(sc, p, sc->c_pointer_weak2_symbol, list_1(sc, p), T_C_POINTER, 1));
  return(c_pointer_weak2(p));
}

static s7_pointer g_c_pointer_weak2(s7_scheme *sc, s7_pointer args)
{
  #define H_c_pointer_weak2 "(c-pointer-weak2 obj) returns the c-pointer weak2 field"
  #define Q_c_pointer_weak2 s7_make_signature(sc, 2, sc->T, sc->is_c_pointer_symbol)
  return(c_pointer_weak2_p_p(sc, car(args)));
}


/* -------------------------------- c-pointer->list -------------------------------- */
static s7_pointer g_c_pointer_to_list(s7_scheme *sc, s7_pointer args)
{
  #define H_c_pointer_to_list "(c-pointer->list obj) returns the c-pointer data as (list pointer-as-int type info)"
  #define Q_c_pointer_to_list s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_c_pointer_symbol)

  s7_pointer p;
  p = car(args);
  if (!is_c_pointer(p))
    return(method_or_bust(sc, p, sc->c_pointer_to_list_symbol, args, T_C_POINTER, 1));
  return(s7_list(sc, 3, s7_make_integer(sc, (s7_int)((intptr_t)c_pointer(p))), c_pointer_type(p), c_pointer_info(p)));
}


/* -------------------------------- continuations and gotos -------------------------------- */

enum {NO_JUMP, CALL_WITH_EXIT_JUMP, THROW_JUMP, CATCH_JUMP, ERROR_JUMP, ERROR_QUIT_JUMP};
enum {NO_SET_JUMP, READ_SET_JUMP, LOAD_SET_JUMP, DYNAMIC_WIND_SET_JUMP, S7_CALL_SET_JUMP, EVAL_SET_JUMP};


/* ----------------------- continuation? -------------------------------- */
static s7_pointer g_is_continuation(s7_scheme *sc, s7_pointer args)
{
  #define H_is_continuation "(continuation? obj) returns #t if obj is a continuation"
  #define Q_is_continuation sc->pl_bt

  check_boolean_method(sc, is_continuation, sc->is_continuation_symbol, args);
  /* is this the right thing?  It returns #f for call-with-exit ("goto") because
   *   that form of continuation can't continue (via a jump back to its context).
   * how to recognize the call-with-exit function?  "goto" is an internal name.
   */
}

static bool s7_is_continuation(s7_pointer p) {return(is_continuation(p));}


static s7_pointer protected_list_copy(s7_scheme *sc, s7_pointer a)
{
  s7_pointer slow, fast, p;

  sc->w = cons(sc, car(a), sc->nil);
  p = sc->w;

  slow = fast = cdr(a);
  while (true)
    {
      if (!is_pair(fast))
	{
	  if (is_null(fast))
	    return(sc->w);
	  set_cdr(p, fast);
	  return(sc->w);
	}

      set_cdr(p, cons(sc, car(fast), sc->nil));
      p = cdr(p);

      fast = cdr(fast);
      if (!is_pair(fast))
	{
	  if (is_null(fast))
	    return(sc->w);
	  set_cdr(p, fast);
	  return(sc->w);
	}
      /* if unrolled further, it's a lot slower? */
      set_cdr(p, cons(sc, car(fast), sc->nil));
      p = cdr(p);

      fast = cdr(fast);
      slow = cdr(slow);
      if (fast == slow)
	{
	  /* try to preserve the original cyclic structure */
	  s7_pointer p1, f1, p2, f2;
	  set_match_pair(a);
	  for (p1 = sc->w, f1 = a; !(is_matched_pair(cdr(f1))); f1 = cdr(f1), p1 = cdr(p1))
	    set_match_pair(f1);
	  for (p2 = sc->w, f2 = a; cdr(f1) != f2; f2 = cdr(f2), p2 = cdr(p2))
	    clear_match_pair(f2);
	  for (f1 = f2; is_pair(f1); f1 = cdr(f1), f2 = cdr(f2))
	    {
	      clear_match_pair(f1);
	      f1 = cdr(f1);
	      clear_match_pair(f1);
	      if (f1 == f2) break;
	    }
	  if (is_null(p1))
	    set_cdr(p2, p2);
	  else set_cdr(p1, p2);
	  return(sc->w);
	}
    }
  return(sc->w);
}

static s7_pointer copy_counter(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer nobj;
  new_cell(sc, nobj, T_COUNTER);
  counter_set_result(nobj, counter_result(obj));
  counter_set_list(nobj, counter_list(obj));
  counter_set_capture(nobj, counter_capture(obj));
  counter_set_let(nobj, counter_let(obj));
  counter_set_slots(nobj, counter_slots(obj));
  return(nobj);
}

static s7_pointer copy_stack(s7_scheme *sc, s7_pointer old_v, int64_t top)
{
  #define CC_INITIAL_STACK_SIZE 256 /* 128 is too small here */
  int64_t i, len;
  s7_pointer new_v;
  s7_pointer *nv, *ov;

  /* stacks can grow temporarily, so sc->stack_size grows, but we don't normally need all that
   *   leftover space here, so choose the original stack size if it's smaller.
   */
  len = vector_length(old_v);
  if (len > CC_INITIAL_STACK_SIZE)
    {
      if (top < CC_INITIAL_STACK_SIZE / 4)
	len = CC_INITIAL_STACK_SIZE;
    }
  else
    {
      if (len < CC_INITIAL_STACK_SIZE)
	len = CC_INITIAL_STACK_SIZE;
    }
  if ((int64_t)(sc->free_heap_top - sc->free_heap) < (int64_t)(sc->heap_size / 4)) gc(sc);
  /* this gc call is needed if there are lots of call/cc's -- by pure bad luck
   *   we can end up hitting the end of the gc free list time after time while
   *   in successive copy_stack's below, causing s7 to core up until it runs out of memory.
   *   It seems like it would make more sense to use len*32 or something similar as the
   *   trigger, but that was slower in my timing tests!?
   */

  new_v = make_simple_vector(sc, len);
  set_type(new_v, T_STACK);
  temp_stack_top(new_v) = top;
  nv = stack_elements(new_v);
  ov = stack_elements(old_v);
  if (len > 0)
    memcpy((void *)nv, (void *)ov, ((len > vector_length(old_v)) ? vector_length(old_v) : len) * sizeof(s7_pointer));

  s7_gc_on(sc, false);

  for (i = 2; i < top; i += 4)
    {
      s7_pointer p;
      p = ov[i];                               /* args */
      if (is_pair(p))                          /* args need not be a list (it can be a port or #f, etc) */
	{
	  nv[i] = protected_list_copy(sc, p);  /* args (copy is needed -- see s7test.scm) */
	  set_type(nv[i], (typeflag(p) & (~T_COLLECTED))); /* carry over T_IMMUTABLE */
	}
      /* lst can be dotted or circular here.  The circular list only happens in a case like:
       *    (dynamic-wind (lambda () (eq? (let ((lst (cons 1 2))) (set-cdr! lst lst) lst) (call/cc (lambda (k) k)))) (lambda () #f) (lambda () #f))
       */
      else
	{
	  if (is_counter(p))                   /* these can only occur in this context */
	    nv[i] = copy_counter(sc, p);
	}
    }
  s7_gc_on(sc, true);
  return(new_v);
}

static inline s7_pointer make_goto(s7_scheme *sc)
{
  s7_pointer x;
  new_cell(sc, x, T_GOTO);
  call_exit_goto_loc(x) = s7_stack_top(sc);
  call_exit_op_loc(x) = (int32_t)(sc->op_stack_now - sc->op_stack);
  call_exit_active(x) = true;
  return(x);
}

static s7_pointer *copy_op_stack(s7_scheme *sc)
{
  int32_t len;
  s7_pointer *ops;
  ops = (s7_pointer *)malloc(sc->op_stack_size * sizeof(s7_pointer));
  len = (int32_t)(sc->op_stack_now - sc->op_stack);
  if (len > 0)
    memcpy((void *)ops, (void *)(sc->op_stack), len * sizeof(s7_pointer));
  return(ops);
}

/* (with-baffle . body) calls body guaranteeing that there can be no jumps into the
 *    middle of it from outside -- no outer evaluation of a continuation can jump across this
 *    barrier:  The flip-side of call-with-exit.
 *    It sets a T_BAFFLE var in a new env, that has a unique key.  Call/cc then always
 *    checks the env chain for any such variable, saving the localmost.  Apply of a continuation
 *    looks for such a saved variable, if none, go ahead, else check the current env (before the
 *    jump) for that variable.  If none, error, else go ahead.  This is different from a delimited
 *    continuation which simply delimits the extent of the continuation (why not use lambda?) -- we want to block it
 *    from coming at us from some unknown place.
 */

static s7_pointer make_baffle(s7_scheme *sc)
{
  s7_pointer x;
  new_cell(sc, x, T_BAFFLE);
  baffle_key(x) = sc->baffle_ctr++;
  return(x);
}

static bool find_baffle(s7_scheme *sc, s7_int key)
{
  /* search backwards through sc->envir for sc->baffle_symbol with key as value */
  s7_pointer x, y;
  for (x = sc->envir; is_let(x); x = outlet(x))
    for (y = let_slots(x); tis_slot(y); y = next_slot(y))
      if ((slot_symbol(y) == sc->baffle_symbol) &&
	  (baffle_key(slot_value(y)) == key))
	return(true);

  if ((is_slot(global_slot(sc->baffle_symbol))) &&
      (is_baffle(slot_value(global_slot(sc->baffle_symbol)))))
    return(baffle_key(slot_value(global_slot(sc->baffle_symbol))) == key);

  return(false);
}

static s7_int find_any_baffle(s7_scheme *sc)
{
  /* search backwards through sc->envir for any sc->baffle_symbol */
  if (sc->baffle_ctr > 0)
    {
      s7_pointer x, y;
      for (x = sc->envir; is_let(x); x = outlet(x))
	for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	  if (slot_symbol(y) == sc->baffle_symbol)
	    return(baffle_key(slot_value(y)));

      if ((is_slot(global_slot(sc->baffle_symbol))) &&
	  (is_baffle(slot_value(global_slot(sc->baffle_symbol)))))
	return(baffle_key(slot_value(global_slot(sc->baffle_symbol))));
    }
  return(-1);
}

/* -------------------------------- call/cc -------------------------------- */
s7_pointer s7_make_continuation(s7_scheme *sc)
{
  s7_pointer x, stack;
  int64_t loc;
  block_t *block;

  loc = s7_stack_top(sc);
  stack = copy_stack(sc, sc->stack, loc);
  sc->temp8 = stack;

  new_cell(sc, x, T_CONTINUATION);
  block = mallocate_block(sc);
  continuation_block(x) = block;
  continuation_set_stack(x, stack);
  continuation_stack_size(x) = vector_length(continuation_stack(x));   /* copy_stack can return a smaller stack than the current one */
  continuation_stack_start(x) = stack_elements(continuation_stack(x));
  continuation_stack_end(x) = (s7_pointer *)(continuation_stack_start(x) + loc);
  continuation_op_stack(x) = copy_op_stack(sc);                        /* no heap allocation here */
  continuation_op_loc(x) = (int32_t)(sc->op_stack_now - sc->op_stack);
  continuation_op_size(x) = sc->op_stack_size;
  continuation_key(x) = find_any_baffle(sc);
  sc->temp8 = sc->nil;

  add_continuation(sc, x);
  return(x);
}

static void let_temp_done(s7_scheme *sc, s7_pointer args, s7_pointer code, s7_pointer let)
{
  /* called in call/cc, call-with-exit and, catch (unwind to catch) */
  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
  sc->args = T_Pos(args);
  sc->code = code;
  sc->envir = let;
  eval(sc, OP_LET_TEMP_DONE);
}

static bool check_for_dynamic_winds(s7_scheme *sc, s7_pointer c)
{
  /* called only from call_with_current_continuation.
   *   if call/cc jumps into a dynamic-wind, the init/finish funcs are wrapped in with-baffle
   *   so they'll complain.  Otherwise we're supposed to re-run the init func before diving
   *   into the body.  Similarly for let-temporarily.  If a call/cc jumps out of a dynamic-wind
   *   body-func, we're supposed to call the finish-func.  The continuation is called at
   *   s7_stack_top(sc); the continuation form is at continuation_stack_top(c).
   */
  int64_t i;
  opcode_t op;

  /* check sc->stack for dynamic-winds we're jumping out of */
  for (i = s7_stack_top(sc) - 1; i > 0; i -= 4)
    {
      op = stack_op(sc->stack, i);
      switch (op)
	{
	case OP_DYNAMIC_WIND:
	case OP_LET_TEMP_DONE:
	  {
	    s7_pointer x;
	    int64_t j, s_base = 0;
	    x = stack_code(sc->stack, i);
	    for (j = 3; j < continuation_stack_top(c); j += 4)
	      if (((stack_op(continuation_stack(c), j) == OP_DYNAMIC_WIND) ||
		   (stack_op(continuation_stack(c), j) == OP_LET_TEMP_DONE)) &&
		  (x == stack_code(continuation_stack(c), j)))
		{
		  s_base = i;
		  break;
		}
	    if (s_base == 0)
	      {
		if (op == OP_DYNAMIC_WIND)
		  {
		    if (dynamic_wind_state(x) == DWIND_BODY)
		      {
			dynamic_wind_state(x) = DWIND_FINISH;
			if (dynamic_wind_out(x) != sc->F)
			  {
			    push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
			    sc->args = sc->nil;
			    sc->code = dynamic_wind_out(x);
			    eval(sc, OP_APPLY);
			  }
		      }
		  }
		else let_temp_done(sc, stack_args(sc->stack, i), stack_code(sc->stack, i), stack_let(sc->stack, i));
	      }
	  }
	  break;

	case OP_BARRIER:
	  if (i > continuation_stack_top(c))  /* otherwise it's some unproblematic outer eval-string? */
	    return(false);                    /*    but what if we've already evaluated a dynamic-wind closer? */
	  break;

	case OP_DEACTIVATE_GOTO:              /* here we're jumping out of an unrelated call-with-exit block */
	  if (i > continuation_stack_top(c))
	    call_exit_active(stack_args(sc->stack, i)) = false;
	  break;

	default:
	  break;
	}
    }

  /* check continuation-stack for dynamic-winds we're jumping into */
  for (i = s7_stack_top(sc) - 1; i < continuation_stack_top(c); i += 4)
    {
      op = stack_op(continuation_stack(c), i);
      if (op == OP_DYNAMIC_WIND)
	{
	  s7_pointer x;
	  x = stack_code(continuation_stack(c), i);
	  if (dynamic_wind_in(x) != sc->F)
	    {
	      push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
	      sc->args = sc->nil;
	      sc->code = dynamic_wind_in(x);
	      eval(sc, OP_APPLY);
	    }
	  dynamic_wind_state(x) = DWIND_BODY;
	}
      else
	{
	  if (op == OP_DEACTIVATE_GOTO)
	    call_exit_active(stack_args(continuation_stack(c), i)) = true;
	  /* not let_temp_done here! */
	  /* if op == OP_LET_TEMP_DONE, we're jumping back into a let-temporarily.  MIT and Chez scheme say they remember the
	   *   let-temp vars (fluid-let or parameters in their terminology) at the point of the call/cc, and restore them
	   *   on re-entry; that strikes me as incoherently complex -- they've wrapped a hidden dynamic-wind around the
	   *   call/cc to restore all let-temp vars!  I think let-temp here should be the same as let -- if you jump back
	   *   in, nothing hidden happens. So, 
	   *     (let ((x #f) (cc #f)) (let-temporarily ((x 1)) (set! x 2) (call/cc (lambda (r) (set! cc r))) (display x) (unless (= x 2) (newline) (exit)) (set! x 3) (cc)))
	   *   behaves the same (in this regard) if let-temp is replaced with let.
	   */
	}
    }
  return(true);
}

static bool call_with_current_continuation(s7_scheme *sc)
{
  s7_pointer c;
  c = sc->code;

  /* check for (baffle ...) blocking the current attempt to continue */
  if ((continuation_key(c) >= 0) &&
      (!(find_baffle(sc, continuation_key(c))))) /* should this raise an error? */
    return(false);

  if (!check_for_dynamic_winds(sc, c))
    return(true);

  /* we push_stack sc->code before calling an embedded eval above, so sc->code should still be c here, etc */
  sc->stack = copy_stack(sc, continuation_stack(c), continuation_stack_top(c));
  sc->stack_size = continuation_stack_size(c);
  sc->stack_start = stack_elements(sc->stack);
  sc->stack_end = (s7_pointer *)(sc->stack_start + continuation_stack_top(c));
  sc->stack_resize_trigger = (s7_pointer *)(sc->stack_start + sc->stack_size / 2);

  {
    int32_t i, top;
    top = continuation_op_loc(c);
    sc->op_stack_now = (s7_pointer *)(sc->op_stack + top);
    sc->op_stack_size = continuation_op_size(c);
    sc->op_stack_end = (s7_pointer *)(sc->op_stack + sc->op_stack_size);
    for (i = 0; i < top; i++)
      sc->op_stack[i] = continuation_op_stack(c)[i];
  }

  if (is_null(sc->args))
    sc->value = sc->nil;
  else
    {
      if (is_null(cdr(sc->args)))
	sc->value = car(sc->args);
      else sc->value = splice_in_values(sc, sc->args);
    }
  return(true);
}

static s7_pointer g_call_cc(s7_scheme *sc, s7_pointer args)
{
  #define H_call_cc "(call-with-current-continuation (lambda (continuer)...)) is always a mistake!"
  #define Q_call_cc s7_make_signature(sc, 2, sc->T, sc->is_procedure_symbol)

  s7_pointer p;
  p = car(args);                             /* this is the procedure passed to call/cc */
  if (!is_t_procedure(p))                    /* this includes continuations */
    {
      check_method(sc, p, sc->call_cc_symbol, args);
      check_method(sc, p, sc->call_with_current_continuation_symbol, args);
      return(simple_wrong_type_argument_with_type(sc, sc->call_cc_symbol, p, a_procedure_string));
    }
  if (!s7_is_aritable(sc, p, 1))
    return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "call/cc procedure, ~A, should take one argument", 47), p)));

  sc->w = s7_make_continuation(sc);
  push_stack(sc, OP_APPLY, list_1(sc, sc->w), p);
  sc->w = sc->nil;

  return(sc->nil);
}

/* we can't naively optimize call/cc to call-with-exit if the continuation is only
 *   used as a function in the call/cc body because it might (for example) be wrapped
 *   in a lambda form that is being exported.  See b-func in s7test for an example.
 */

static void apply_continuation(s7_scheme *sc)
{
  if (!call_with_current_continuation(sc))
    s7_error(sc, sc->baffled_symbol,
	     set_elist_1(sc, wrap_string(sc, "continuation can't jump into with-baffle", 40)));
}

static bool op_continuation_a(s7_scheme *sc)
{
  s7_pointer s, code;
  code = sc->code;
  s = lookup_checked(sc, car(code));
  if (!is_continuation(s)) {sc->last_function = s; return(false);}
  sc->code = s;
  sc->args = set_plist_1(sc, fx_call(sc, cdr(code)));
  apply_continuation(sc);
  return(true);
}


/* -------------------------------- with-baffle -------------------------------- */
static s7_pointer check_with_baffle(s7_scheme *sc)
{
  if (!s7_is_proper_list(sc, sc->code))
    eval_error(sc, "with-baffle: unexpected dot? ~A", 31, sc->code);
  if (!is_null(cdr(sc->code)))
    pair_set_syntax_op(sc->code, OP_WITH_BAFFLE_UNCHECKED);
  return(sc->code);
}

static bool op_with_baffle_unchecked(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  if (is_null(sc->code))
    {
      sc->value = sc->nil;
      return(true);
    }
  new_frame(sc, sc->envir, sc->envir);
  make_slot_1(sc, sc->envir, sc->baffle_symbol, make_baffle(sc));
  return(false);
}


/* -------------------------------- call-with-exit -------------------------------- */
static void call_with_exit(s7_scheme *sc)
{
  int64_t i, new_stack_top, quit = 0;

  if (!call_exit_active(sc->code))
    s7_error(sc, sc->invalid_escape_function_symbol, set_elist_1(sc, wrap_string(sc, "call-with-exit escape procedure called outside its block", 56)));

  call_exit_active(sc->code) = false;
  new_stack_top = call_exit_goto_loc(sc->code);
  sc->op_stack_now = (s7_pointer *)(sc->op_stack + call_exit_op_loc(sc->code));

  /* look for dynamic-wind in the stack section that we are jumping out of */
  for (i = s7_stack_top(sc) - 1; i > new_stack_top; i -= 4)
    {
      opcode_t op;

      op = stack_op(sc->stack, i);
      switch (op)
	{
	case OP_DYNAMIC_WIND:
	  {
	    s7_pointer lx;
	    lx = stack_code(sc->stack, i);
	    if (dynamic_wind_state(lx) == DWIND_BODY)
	      {
		dynamic_wind_state(lx) = DWIND_FINISH;
		if (dynamic_wind_out(lx) != sc->F)
		  {
		    push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
		    sc->args = sc->nil;
		    sc->code = dynamic_wind_out(lx);
		    eval(sc, OP_APPLY);
		  }}}
	  break;

	case OP_EVAL_STRING:
	  s7_close_input_port(sc, sc->input_port);
	  pop_input_port(sc);
	  break;

	case OP_BARRIER:                /* oops -- we almost certainly went too far */
	  goto SET_VALUE;

	case OP_DEACTIVATE_GOTO:        /* here we're jumping into an unrelated call-with-exit block */
	  call_exit_active(stack_args(sc->stack, i)) = false;
	  break;

	case OP_LET_TEMP_DONE:
	  let_temp_done(sc, stack_args(sc->stack, i), stack_code(sc->stack, i), stack_let(sc->stack, i));
	  break;

	  /* call/cc does not close files, but I think call-with-exit should */
	case OP_GET_OUTPUT_STRING:
	case OP_UNWIND_OUTPUT:
	  {
	    s7_pointer x;
	    x = stack_code(sc->stack, i);                /* "code" = port that we opened */
	    s7_close_output_port(sc, x);
	    x = stack_args(sc->stack, i);                /* "args" = port that we shadowed, if not #<unused> */
	    if (x != sc->unused)
	      sc->output_port = x;
	  }
	  break;

	case OP_UNWIND_INPUT:
	  s7_close_input_port(sc, stack_code(sc->stack, i)); /* "code" = port that we opened */
	  sc->input_port = stack_args(sc->stack, i);         /* "args" = port that we shadowed */
	  break;

	case OP_EVAL_DONE: /* goto called in a method -- put off the inner eval return(s) until we clean up the stack */
	  quit++;
	  break;

	default:
	  break;
	}
    }

  /* is this right? maybe the SET_VALUE should skip setting stack_end? */
 SET_VALUE:
  sc->stack_end = (s7_pointer *)(sc->stack_start + new_stack_top);

  /* the return value should have an implicit values call, just as in call/cc */
  if (is_null(sc->args))
    sc->value = sc->nil;
  else
    {
      if (is_null(cdr(sc->args)))
	sc->value = car(sc->args);
      else sc->value = splice_in_values(sc, sc->args);
    }

  if (quit > 0)
    {
      if (sc->longjmp_ok)
	{
	  pop_stack(sc);
	  longjmp(sc->goto_start, CALL_WITH_EXIT_JUMP);
	}
      for (i = 0; i < quit; i++)
	push_stack_op_let(sc, OP_EVAL_DONE);
    }
}

static s7_pointer g_call_with_exit(s7_scheme *sc, s7_pointer args)
{
  #define H_call_with_exit "(call-with-exit (lambda (exiter) ...)) is call/cc without the ability to jump back into a previous computation."
  #define Q_call_with_exit s7_make_signature(sc, 2, sc->values_symbol, sc->is_procedure_symbol)

  s7_pointer p, x;
  /* (call-with-exit (lambda (return) ...)) */

  p = car(args);
  if (!is_t_procedure(p))                  /* this includes continuations */
    return(method_or_bust_with_type_one_arg(sc, p, sc->call_with_exit_symbol, args, a_procedure_string));

  x = make_goto(sc);
  push_stack(sc, OP_DEACTIVATE_GOTO, x, p); /* this means call-with-exit is not tail-recursive */
  push_stack(sc, OP_APPLY, cons_unchecked(sc, x, sc->nil), p);

  /* if the lambda body calls the argument as a function,
   *   it is applied to its arguments, apply notices that it is a goto, and...
   *
   *      (conceptually...) sc->stack_top = call_exit_goto_loc(sc->code);
   *      s_pop(sc, (is_not_null(sc->args)) ? car(sc->args) : sc->nil);
   *
   *   which jumps to the point of the goto returning car(args).
   *
   * There is one gotcha: we can't jump back in from outside, so if the caller saves the goto
   *   and tries to invoke it outside the call-with-exit block, we have to
   *   make sure it triggers an error.  So, if the escape is called, it then
   *   deactivates itself.  Otherwise the block returns, we pop to OP_DEACTIVATE_GOTO,
   *   and it finds the goto in sc->args.
   * Even worse:
       (let ((cc #f))
         (call-with-exit
           (lambda (c3)
             (call/cc (lambda (ret) (set! cc ret)))
             (c3)))
         (cc))
   * where we jump back into a call-with-exit body via call/cc, the goto has to be re-established.
   *
   * I think call-with-exit could be based on catch, but it's a simpler notion,
   *   and certainly at the source level it is easier to read.
   */
  return(sc->nil);
}

static s7_pointer op_call_with_exit(s7_scheme *sc)
{
  s7_pointer go, args;
  set_current_code(sc, sc->code);
  args = opt2_pair(sc->code);
  go = make_goto(sc);
  push_stack_no_let_no_code(sc, OP_DEACTIVATE_GOTO, go); /* was also pushing code */
  new_frame_with_slot(sc, sc->envir, sc->envir, caar(args), go);
  sc->code = T_Pair(cdr(args));
  return(NULL);
}

static s7_pointer op_call_with_exit_p(s7_scheme *sc)
{
  op_call_with_exit(sc);
  sc->code = car(sc->code);
  return(NULL);
}

static bool op_goto(s7_scheme *sc)
{
  set_opt1_goto(sc->code, lookup_checked(sc, car(sc->code)));
  if (!is_goto(opt1_goto(sc->code))) return(false);
  sc->args = sc->nil;
  sc->code = T_Got(opt1_goto(sc->code));
  call_with_exit(sc);
  return(true);
}

static bool op_goto_a(s7_scheme *sc)
{
  set_opt1_goto(sc->code, lookup_checked(sc, car(sc->code)));
  if (!is_goto(opt1_goto(sc->code))) return(false);
  sc->args = list_1(sc, fx_call(sc, cdr(sc->code)));
  sc->code = T_Got(opt1_goto(sc->code));
  call_with_exit(sc);
  return(true);
}


/* -------------------------------- numbers -------------------------------- */

#if WITH_GMP
  static char *big_number_to_string_with_radix(s7_pointer p, int32_t radix, s7_int width, s7_int *nlen, use_write_t use_write);
  static bool big_numbers_are_eqv(s7_pointer a, s7_pointer b);
  static s7_pointer string_to_either_integer(s7_scheme *sc, const char *str, int32_t radix);
  static s7_pointer string_to_either_ratio(s7_scheme *sc, const char *nstr, const char *dstr, int32_t radix);
  static s7_pointer string_to_either_real(s7_scheme *sc, const char *str, int32_t radix);
  static s7_pointer string_to_either_complex(s7_scheme *sc, char *q, char *slash1, char *ex1, bool has_dec_point1,
					     char *plus, char *slash2, char *ex2, bool has_dec_point2, int32_t radix, int32_t has_plus_or_minus);
  static s7_pointer big_add(s7_scheme *sc, s7_pointer args);
  static s7_pointer big_subtract(s7_scheme *sc, s7_pointer args);
  static s7_pointer big_multiply(s7_scheme *sc, s7_pointer args);
  static s7_pointer big_divide(s7_scheme *sc, s7_pointer args);
  static s7_pointer big_random(s7_scheme *sc, s7_pointer args);
  static s7_pointer s7_int_to_big_integer(s7_scheme *sc, s7_int val);
  static s7_pointer s7_ratio_to_big_ratio(s7_scheme *sc, s7_int num, s7_int den);
  static s7_pointer s7_number_to_big_real(s7_scheme *sc, s7_pointer p);
  static s7_pointer promote_number(s7_scheme *sc, int32_t type, s7_pointer x);
  static s7_pointer big_equal(s7_scheme *sc, s7_pointer args);
  static s7_pointer big_negate(s7_scheme *sc, s7_pointer args);
  static s7_pointer big_invert(s7_scheme *sc, s7_pointer args);
#if (!WITH_PURE_S7)
  static s7_pointer big_inexact_to_exact(s7_scheme *sc, s7_pointer args);
  static s7_pointer big_exact_to_inexact(s7_scheme *sc, s7_pointer args);
#endif
  static s7_pointer mpz_to_big_integer(s7_scheme *sc, mpz_t val);
  static s7_pointer mpq_to_big_ratio(s7_scheme *sc, mpq_t val);
  static s7_pointer mpfr_to_big_real(s7_scheme *sc, mpfr_t val);
  static s7_pointer mpc_to_big_complex(s7_scheme *sc, mpc_t val);
#endif

#ifndef HAVE_OVERFLOW_CHECKS
#if ((defined(__clang__) && (!POINTER_32) && ((__clang_major__ > 3) || (__clang_major__ == 3 && __clang_minor__ >= 4))) || (defined(__GNUC__) && __GNUC__ >= 5))
  #define HAVE_OVERFLOW_CHECKS 1
#else
  #define HAVE_OVERFLOW_CHECKS 0
  #if (!WITH_GMP)
    #warning "no arithmetic overflow checks in this version of s7"
  #endif
#endif
#endif

#if (defined(__clang__) && (!POINTER_32) && ((__clang_major__ > 3) || (__clang_major__ == 3 && __clang_minor__ >= 4)))
  #define subtract_overflow(A, B, C)       __builtin_ssubll_overflow((long long)A, (long long)B, (long long *)C)
  #define add_overflow(A, B, C)            __builtin_saddll_overflow((long long)A, (long long)B, (long long *)C)
  #define multiply_overflow(A, B, C)       __builtin_smulll_overflow((long long)A, (long long)B, (long long *)C)
  /* #define int32_subtract_overflow(A, B, C) __builtin_ssub_overflow(A, B, C) */
  #define int32_add_overflow(A, B, C)      __builtin_sadd_overflow(A, B, C)
  #define int32_multiply_overflow(A, B, C) __builtin_smul_overflow(A, B, C)
#else
#if (defined(__GNUC__) && __GNUC__ >= 5)
  #define subtract_overflow(A, B, C)       __builtin_sub_overflow(A, B, C)
  #define add_overflow(A, B, C)            __builtin_add_overflow(A, B, C)
  #define multiply_overflow(A, B, C)       __builtin_mul_overflow(A, B, C)
  /* #define int32_subtract_overflow(A, B, C) __builtin_sub_overflow(A, B, C) */
  #define int32_add_overflow(A, B, C)      __builtin_add_overflow(A, B, C)
  #define int32_multiply_overflow(A, B, C) __builtin_mul_overflow(A, B, C)
#endif
#endif

#if WITH_GCC
#define s7_int_abs(x) ({s7_int _X_; _X_ = x; _X_ >= 0 ? _X_ : -_X_;})
#else
#define s7_int_abs(x) ((x) >= 0 ? (x) : -(x))
#endif
/* can't use abs even in gcc -- it doesn't work with int64_ts! */

#if (!__NetBSD__)
  #define s7_fabsl(X) fabsl(X)
#else
  static double s7_fabsl(long double x) {if (x < 0.0) return(-x);  return(x);}
#endif


static bool is_NaN(s7_double x) {return(x != x);}
/* callgrind says this is faster than isnan, I think (very confusing data...) */

#if defined(__sun) && defined(__SVR4)
  static bool is_inf(s7_double x) {return((x == x) && (is_NaN(x - x)));} /* there's no isinf in Solaris */
#else
#if (!MS_WINDOWS)

  #if __cplusplus
    #define is_inf(x) std::isinf(x)
  #else
    #define is_inf(x) isinf(x)
  #endif

#else
  static bool is_inf(s7_double x) {return((x == x) && (is_NaN(x - x)));}  /* Another possibility: (x * 0) != 0 */

  /* in MS C, we need to provide inverse hyperbolic trig funcs and cbrt */
  static double asinh(double x) {return(log(x + sqrt(1.0 + x * x)));}
  static double acosh(double x) {return(log(x + sqrt(x * x - 1.0)));}
  /* perhaps less prone to numerical troubles (untested): 2.0 * log(sqrt(0.5 * (x + 1.0)) + sqrt(0.5 * (x - 1.0))) */
  static double atanh(double x) {return(log((1.0 + x) / (1.0 - x)) / 2.0);}
  static double cbrt(double x) {if (x >= 0.0) return(pow(x, 1.0 / 3.0)); return(-pow(-x, 1.0 / 3.0));}
#endif /* windows */
#endif /* sun */


/* for g_log, we also need round. this version is from stackoverflow, see also r5rs_round below */
double s7_round(double number) {return((number < 0.0) ? ceil(number - 0.5) : floor(number + 0.5));}

#if HAVE_COMPLEX_NUMBERS
#if __cplusplus
  #define _Complex_I (complex<s7_double>(0.0, 1.0))
  #define creal(x) Real(x)
  #define cimag(x) Imag(x)
  #define carg(x) arg(x)
  #define cabs(x) abs(x)
  #define csqrt(x) sqrt(x)
  #define cpow(x, y) pow(x, y)
  #define clog(x) log(x)
  #define cexp(x) exp(x)
  #define csin(x) sin(x)
  #define ccos(x) cos(x)
  #define csinh(x) sinh(x)
  #define ccosh(x) cosh(x)
#else
  typedef double complex s7_complex;
#endif


#if (!HAVE_COMPLEX_TRIG)
#if (__cplusplus)

  static s7_complex ctan(s7_complex z)   {return(csin(z) / ccos(z));}
  static s7_complex ctanh(s7_complex z)  {return(csinh(z) / ccosh(z));}
  static s7_complex casin(s7_complex z)  {return(-_Complex_I * clog(_Complex_I * z + csqrt(1.0 - z * z)));}
  static s7_complex cacos(s7_complex z)  {return(-_Complex_I * clog(z + _Complex_I * csqrt(1.0 - z * z)));}
  static s7_complex catan(s7_complex z)  {return(_Complex_I * clog((_Complex_I + z) / (_Complex_I - z)) / 2.0);}
  static s7_complex casinh(s7_complex z) {return(clog(z + csqrt(1.0 + z * z)));}
  static s7_complex cacosh(s7_complex z) {return(clog(z + csqrt(z * z - 1.0)));}
  static s7_complex catanh(s7_complex z) {return(clog((1.0 + z) / (1.0 - z)) / 2.0);}
#else

/* still not in FreeBSD! */
static s7_complex clog(s7_complex z) {return(log(fabs(cabs(z))) + carg(z) * _Complex_I);}
static s7_complex cpow(s7_complex x, s7_complex y)
{
  s7_double r = cabs(x);
  s7_double theta = carg(x);
  s7_double yre = creal(y);
  s7_double yim = cimag(y);
  s7_double nr = exp(yre * log(r) - yim * theta);
  s7_double ntheta = yre * theta + yim * log(r);
  return(nr * cos(ntheta) + (nr * sin(ntheta)) * _Complex_I); /* make-polar */
}

#if (!defined(__FreeBSD__)) || (__FreeBSD__ < 9) /* untested -- this orignally looked at __FreeBSD_version which apparently no longer exists */
  static s7_complex cexp(s7_complex z) {return(exp(creal(z)) * cos(cimag(z)) + (exp(creal(z)) * sin(cimag(z))) * _Complex_I);}
#endif

#if (!defined(__FreeBSD__)) || (__FreeBSD__ < 10)
  static s7_complex csin(s7_complex z)   {return(sin(creal(z)) * cosh(cimag(z)) + (cos(creal(z)) * sinh(cimag(z))) * _Complex_I);}
  static s7_complex ccos(s7_complex z)   {return(cos(creal(z)) * cosh(cimag(z)) + (-sin(creal(z)) * sinh(cimag(z))) * _Complex_I);}
  static s7_complex csinh(s7_complex z)  {return(sinh(creal(z)) * cos(cimag(z)) + (cosh(creal(z)) * sin(cimag(z))) * _Complex_I);}
  static s7_complex ccosh(s7_complex z)  {return(cosh(creal(z)) * cos(cimag(z)) + (sinh(creal(z)) * sin(cimag(z))) * _Complex_I);}
  static s7_complex ctan(s7_complex z)   {return(csin(z) / ccos(z));}
  static s7_complex ctanh(s7_complex z)  {return(csinh(z) / ccosh(z));}
  static s7_complex casin(s7_complex z)  {return(-_Complex_I * clog(_Complex_I * z + csqrt(1.0 - z * z)));}
  static s7_complex cacos(s7_complex z)  {return(-_Complex_I * clog(z + _Complex_I * csqrt(1.0 - z * z)));}
  static s7_complex catan(s7_complex z)  {return(_Complex_I * clog((_Complex_I + z) / (_Complex_I - z)) / 2.0);}
  static s7_complex catanh(s7_complex z) {return(clog((1.0 + z) / (1.0 - z)) / 2.0);}
  static s7_complex casinh(s7_complex z) {return(clog(z + csqrt(1.0 + z * z)));}
  static s7_complex cacosh(s7_complex z) {return(clog(z + csqrt(z * z - 1.0)));}
#endif /* not FreeBSD 10 */
#endif /* not c++ */
#endif /* not HAVE_COMPLEX_TRIG */

#else  /* not HAVE_COMPLEX_NUMBERS */
  typedef double s7_complex;
  #define _Complex_I 1
  #define creal(x) x
  #define cimag(x) x
  #define csin(x) sin(x)
  #define casin(x) x
  #define ccos(x) cos(x)
  #define cacos(x) x
  #define ctan(x) x
  #define catan(x) x
  #define csinh(x) x
  #define casinh(x) x
  #define ccosh(x) x
  #define cacosh(x) x
  #define ctanh(x) x
  #define catanh(x) x
  #define cexp(x) exp(x)
  #define cpow(x, y) pow(x, y)
  #define clog(x) log(x)
  #define csqrt(x) sqrt(x)
  #define conj(x) x
#endif

#ifdef __OpenBSD__
  /* openbsd's builtin versions of these functions are not usable */
  static s7_complex catanh_1(s7_complex z) {return(clog((1.0 + z) / (1.0 - z)) / 2.0);}
  static s7_complex casinh_1(s7_complex z) {return(clog(z + csqrt(1.0 + z * z)));}
  static s7_complex cacosh_1(s7_complex z) {return(clog(z + csqrt(z * z - 1.0)));}
#endif
#ifdef __NetBSD__
  static s7_complex catanh_1(s7_complex z) {return(clog((1.0 + z) / (1.0 - z)) / 2.0);}
  static s7_complex casinh_1(s7_complex z) {return(clog(z + csqrt(1.0 + z * z)));}
#endif


bool s7_is_number(s7_pointer p)
{
#if WITH_GMP
  return((is_number(p)) || (is_big_number(p)));
#else
  return(is_number(p));
#endif
}


bool s7_is_integer(s7_pointer p)
{
#if WITH_GMP
  return((is_t_integer(p)) ||
	 (is_t_big_integer(p)));
#else
  return(is_t_integer(p));
#endif
}

bool s7_is_real(s7_pointer p)
{
#if WITH_GMP
  return((is_real(p)) ||
	 (is_t_big_integer(p)) ||
	 (is_t_big_ratio(p)) ||
	 (is_t_big_real(p)));
#else
  return(is_real(p)); /* in GSL, a NaN or inf is not a real, or perhaps better, finite = not (nan or inf) */
#endif
}


bool s7_is_rational(s7_pointer p)
{
#if WITH_GMP
  return((is_rational(p)) ||
	 (is_t_big_integer(p)) ||
	 (is_t_big_ratio(p)));
#else
  return(is_rational(p));
#endif
}


bool s7_is_ratio(s7_pointer p)
{
#if WITH_GMP
  return((is_t_ratio(p)) || (is_t_big_ratio(p)));
#else
  return(is_t_ratio(p));
#endif
}


bool s7_is_complex(s7_pointer p)
{
#if WITH_GMP
  return((is_number(p)) || (is_big_number(p)));
#else
  return(is_number(p));
#endif
}


static s7_int c_gcd(s7_int u, s7_int v)
{
  s7_int a, b;

  if ((u == s7_int_min) || (v == s7_int_min))
    {
      /* can't take abs of these (below) so do it by hand */
      s7_int divisor = 1;
      if (u == v) return(u);
      while (((u & 1) == 0) && ((v & 1) == 0))
	{
	  u /= 2;
	  v /= 2;
	  divisor *= 2;
	}
      return(divisor);
    }

  a = s7_int_abs(u);
  b = s7_int_abs(v);
  /* there are faster gcd algorithms but does it ever matter? */
  while (b != 0)
    {
      s7_int temp;
      temp = a % b;
      a = b;
      b = temp;
    }
  /* if (a < 0) return(-a); */ /* why this? */
  return(a);
}

static bool c_rationalize(s7_double ux, s7_double error, s7_int *numer, s7_int *denom)
{
  /*
    (define* (rat ux (err 0.0000001))
      ;; translated from CL code in Canny, Donald, Ressler, "A Rational Rotation Method for Robust Geometric Algorithms"
      (let ((x0 (- ux error))
	    (x1 (+ ux error)))
        (let ((i (ceiling x0))
	      (i0 (floor x0))
	      (i1 (ceiling x1))
	      (r 0))
          (if (>= x1 i)
	      i
	      (do ((p0 i0 (+ p1 (* r p0)))
	           (q0 1 (+ q1 (* r q0)))
	           (p1 i1 p0)
	           (q1 1 q0)
	           (e0 (- i1 x0) e1p)
	           (e1 (- x0 i0) (- e0p (* r e1p)))
	           (e0p (- i1 x1) e1)
	           (e1p (- x1 i0) (- e0 (* r e1))))
	          ((<= x0 (/ p0 q0) x1)
	           (/ p0 q0))
	        (set! r (min (floor (/ e0 e1))
			     (ceiling (/ e0p e1p)))))))))
  */

  double x0, x1;
  s7_int i, i0, i1, p0, q0, p1, q1;
  double e0, e1, e0p, e1p;
  int32_t tries = 0;
  /* don't use long double: the loop below will hang */

  /* #e1e19 is a killer -- it's bigger than most-positive-fixnum, but if we ceil(ux) below
   *   it turns into most-negative-fixnum.  1e19 is trouble in many places.
   */
  if ((ux >= s7_int_max) || (ux <= s7_int_min)) /* (rationalize most-positive-fixnum) should not return most-negative-fixnum */
    {
      /* can't return false here because that confuses some of the callers! */
      if (ux > s7_int_min) (*numer) = s7_int_max; else (*numer) = s7_int_min;
      (*denom) = 1;
      return(true);
    }

  if (error < 0.0) error = -error;
  x0 = ux - error;
  x1 = ux + error;
  i = (s7_int)ceil(x0);

  if (error >= 1.0) /* aw good grief! */
    {
      if (x0 < 0)
	{
	  if (x1 < 0)
	    (*numer) = (s7_int)floor(x1);
	  else (*numer) = 0;
	}
      else (*numer) = i;
      (*denom) = 1;
      return(true);
    }

  if (x1 >= i)
    {
      if (i >= 0)
	(*numer) = i;
      else (*numer) = (s7_int)floor(x1);
      (*denom) = 1;
      return(true);
    }

  i0 = (s7_int)floor(x0);
  i1 = (s7_int)ceil(x1);

  p0 = i0;
  q0 = 1;
  p1 = i1;
  q1 = 1;
  e0 = i1 - x0;
  e1 = x0 - i0;
  e0p = i1 - x1;
  e1p = x1 - i0;

  while (true)
    {
      s7_int old_p1, old_q1;
      double old_e0, old_e1, old_e0p, val, r, r1;
      val = (double)p0 / (double)q0;

      if (((x0 <= val) && (val <= x1)) ||
	  (e1 == 0)                    ||
	  (e1p == 0)                   ||
	  (tries > 100))
	{
	  if ((q0 == s7_int_min) && (p0 == 1)) /* (rationalize 1.000000004297917e-12) when error is 1e-12 */
	    {
	      (*numer) = 0;
	      (*denom) = 1;
	    }
	  else
	    {
	      (*numer) = p0;
	      (*denom) = q0;
	    }
	  return(true);
	}
      tries++;

      r = (s7_int)floor(e0 / e1);
      r1 = (s7_int)ceil(e0p / e1p);
      if (r1 < r) r = r1;

      /* do handles all step vars in parallel */
      old_p1 = p1;
      p1 = p0;
      old_q1 = q1;
      q1 = q0;
      old_e0 = e0;
      e0 = e1p;
      old_e0p = e0p;
      e0p = e1;
      old_e1 = e1;

      p0 = old_p1 + r * p0;
      q0 = old_q1 + r * q0;
      e1 = old_e0p - r * e1p;
      /* if the error is set too low, we can get e1 = 0 here: (rationalize (/ pi) 1e-17) */
      e1p = old_e0 - r * old_e1;
    }
  return(false);
}

s7_pointer s7_rationalize(s7_scheme *sc, s7_double x, s7_double error)
{
  s7_int numer = 0, denom = 1;
  if (c_rationalize(x, error, &numer, &denom))
    return(s7_make_ratio(sc, numer, denom));
  return(make_real(sc, x));
}


static s7_int number_to_numerator(s7_pointer n)
{
  if (is_t_ratio(n))
    return(numerator(n));
  return(integer(n));
}

static s7_int number_to_denominator(s7_pointer n)
{
  if (is_t_ratio(n))
    return(denominator(n));
  return(1);
}


s7_pointer s7_make_integer(s7_scheme *sc, s7_int n)
{
  s7_pointer x;
  if (is_small(n))              /* ((n >= 0) && (n < NUM_SMALL_INTS)) is slower */
    return(small_int(n));

  new_cell(sc, x, T_INTEGER);
  integer(x) = n;
  return(x);
}

static s7_pointer make_mutable_integer(s7_scheme *sc, s7_int n)
{
  s7_pointer x;
  new_cell(sc, x, T_INTEGER | T_MUTABLE | T_IMMUTABLE);
  integer(x) = n;
  return(x);
}

static s7_pointer make_permanent_integer(s7_int i)
{
  if (is_small(i)) return(small_int(i));

  if (i == MAX_ARITY) return(max_arity);
  if (i == CLOSURE_ARITY_NOT_SET) return(arity_not_set);
  if (i == -1) return(minus_one);
  if (i == -2) return(minus_two);
  /* a few -3 */

  return(make_permanent_integer_unchecked(i));
}

s7_pointer s7_make_real(s7_scheme *sc, s7_double n)
{
  s7_pointer x;
  new_cell(sc, x, T_REAL);
  set_real(x, n);
  return(x);
}

s7_pointer s7_make_mutable_real(s7_scheme *sc, s7_double n)
{
  s7_pointer x;
  new_cell(sc, x, T_REAL | T_MUTABLE | T_IMMUTABLE);
  set_real(x, n);
  return(x);
}

s7_pointer s7_make_complex(s7_scheme *sc, s7_double a, s7_double b)
{
  s7_pointer x;
  if (b == 0.0)
    {
      new_cell(sc, x, T_REAL);
      set_real(x, a);
    }
  else
    {
      new_cell(sc, x, T_COMPLEX);
      set_real_part(x, a);
      set_imag_part(x, b);
    }
  return(x);
}


s7_pointer s7_make_ratio(s7_scheme *sc, s7_int a, s7_int b)
{
  s7_pointer x;

  if (b == 0)
    return(division_by_zero_error(sc, wrap_string(sc, "make-ratio", 10), set_elist_2(sc, wrap_integer1(sc, a), small_int(0))));
  if (a == 0)
    return(small_int(0));
  if (a == b)
    return(small_int(1));
  if (b == 1)
    return(make_integer(sc, a));

#if (!WITH_GMP)
  if (b == s7_int_min)
    {
      /* we've got a problem... This should not trigger an error during reading -- we might have the
       *   ratio on a switch with-bignums or whatever, so its mere occurrence is just an annoyance.
       */
      if (a & 1)
	return(make_real(sc, (long double)a / (long double)b));
      a /= 2;
      b /= 2;
    }
#endif

  if (b < 0)
    {
      a = -a;
      b = -b;
    }

  if (a == s7_int_min)
    {
      while (((a & 1) == 0) && ((b & 1) == 0))
	{
	  a /= 2;
	  b /= 2;
	}
    }
  else
    {
      s7_int b1, divisor;
      divisor = s7_int_abs(a);
      b1 = b;
      do {
	s7_int temp;
	temp = divisor % b1;
	divisor = b1;
	b1 = temp;
      } while (b1 != 0);
      if (divisor != 1)
	{
	  a /= divisor;
	  b /= divisor;
	}
    }
  if (b == 1)
    return(make_integer(sc, a));

  new_cell(sc, x, T_RATIO);
  numerator(x) = a;
  denominator(x) = b;
  return(x);
}

static inline s7_pointer make_simple_ratio(s7_scheme *sc, s7_int num, s7_int den)
{
  s7_pointer x;
  if (den == 1)
    return(make_integer(sc, num));
  if (den == -1)
    return(make_integer(sc, -num));
  if ((den == s7_int_min) && ((num & 1) != 0))
    return(make_real(sc, (long double)num / (long double)den));
  new_cell(sc, x, T_RATIO);
  if (den < 0)
    {
      numerator(x) = -num;
      denominator(x) = -den;
    }
  else
    {
      numerator(x) = num;
      denominator(x) = den;
    }
  return(x);
}


#define WITH_OVERFLOW_ERROR true
#define WITHOUT_OVERFLOW_ERROR false

#if (!WITH_PURE_S7) && (!WITH_GMP)
static s7_pointer exact_to_inexact(s7_scheme *sc, s7_pointer x)
{
  /* this is tricky because a big int32_t can mess up when turned into a double: (truncate (exact->inexact most-positive-fixnum)) -> -9223372036854775808 */
  switch (type(x))
    {
    case T_INTEGER: return(make_real(sc, (s7_double)(integer(x))));
    case T_RATIO:   return(make_real(sc, (s7_double)(fraction(x))));
    case T_REAL:
    case T_COMPLEX: return(x); /* apparently (exact->inexact 1+i) is not an error */
    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->exact_to_inexact_symbol, list_1(sc, x), a_number_string));
    }
}

static s7_pointer inexact_to_exact(s7_scheme *sc, s7_pointer x, bool with_error)
{
  switch (type(x))
    {
    case T_INTEGER:
    case T_RATIO:
      return(x);

    case T_REAL:
      {
	s7_int numer = 0, denom = 1;
	s7_double val;

	val = real(x); /* no fall through */
	if ((is_inf(val)) || (is_NaN(val)))
	  {
	    if (with_error)
	      return(simple_wrong_type_argument_with_type(sc, sc->inexact_to_exact_symbol, x, a_normal_real_string));
	    return(sc->nil);
	  }

	if ((val > s7_int_max) ||
	    (val < s7_int_min))
	  {
	    if (with_error)
	      return(simple_out_of_range(sc, sc->inexact_to_exact_symbol, x, its_too_large_string));
	    return(sc->nil);
	  }

	if (c_rationalize(val, sc->default_rationalize_error, &numer, &denom))
	  return(s7_make_ratio(sc, numer, denom));
      }

    default:
      if (with_error)
	return(method_or_bust_one_arg(sc, x, sc->inexact_to_exact_symbol, list_1(sc, x), T_REAL));
      return(sc->nil);
    }
  return(x);
}
#endif

/* this is a mess -- it's too late to clean up s7.h (sigh) */
s7_double s7_number_to_real_with_caller(s7_scheme *sc, s7_pointer x, const char *caller)
{
  if (is_t_real(x))
    return(real(x));

  switch (type(x))
    {
    case T_INTEGER:     return((s7_double)integer(x));
    case T_RATIO:       return((s7_double)numerator(x) / (s7_double)denominator(x));
    case T_REAL:        return(real(x));
#if WITH_GMP
    case T_BIG_INTEGER: return((s7_double)big_integer_to_s7_int(big_integer(x)));
    case T_BIG_RATIO:   return((s7_double)((long_double)big_integer_to_s7_int(mpq_numref(big_ratio(x))) /
					   (long_double)big_integer_to_s7_int(mpq_denref(big_ratio(x)))));
    case T_BIG_REAL:    return((s7_double)mpfr_get_d(big_real(x), GMP_RNDN));
#endif
    }
  s7_wrong_type_arg_error(sc, caller, 0, x, "a real number");
  return(0.0);
}

s7_double s7_number_to_real(s7_scheme *sc, s7_pointer x)
{
  return(s7_number_to_real_with_caller(sc, x, "s7_number_to_real"));
}

s7_int s7_number_to_integer_with_caller(s7_scheme *sc, s7_pointer x, const char *caller)
{
  if (is_t_integer(x))
    return(integer(x));

#if WITH_GMP
  if (is_t_big_integer(x))
    return(big_integer_to_s7_int(big_integer(x)));
#endif
  s7_wrong_type_arg_error(sc, caller, 0, x, "an integer");
  return(0);
}

s7_int s7_number_to_integer(s7_scheme *sc, s7_pointer x)
{
  return(s7_number_to_integer_with_caller(sc, x, "s7_number_to_integer"));
}


s7_int s7_numerator(s7_pointer x)
{
  switch (type(x))
    {
    case T_INTEGER:     return(integer(x));
    case T_RATIO:       return(numerator(x));
#if WITH_GMP
    case T_BIG_INTEGER: return(big_integer_to_s7_int(big_integer(x)));
    case T_BIG_RATIO:   return(big_integer_to_s7_int(mpq_numref(big_ratio(x))));
#endif
    }
  return(0);
}


s7_int s7_denominator(s7_pointer x)
{
  switch (type(x))
    {
    case T_RATIO:     return(denominator(x));
#if WITH_GMP
    case T_BIG_RATIO: return(big_integer_to_s7_int(mpq_denref(big_ratio(x))));
#endif
    }
  return(1);
}


s7_int s7_integer(s7_pointer p)
{
  if (is_t_integer(p))
    return(integer(p));

#if WITH_GMP
  if (is_t_big_integer(p))
    return(big_integer_to_s7_int(big_integer(p)));
#endif

  return(0);
}

s7_double s7_real(s7_pointer x)
{
  if (is_t_real(x))
    return(real(x));
  return(s7_number_to_real_with_caller(cur_sc, x, "s7_real"));
}

#if (!WITH_GMP)
static s7_complex s7_to_c_complex(s7_pointer p)
{
#if HAVE_COMPLEX_NUMBERS
  return(CMPLX(s7_real_part(p), s7_imag_part(p)));
#else
  return(0.0);
#endif
}


static s7_pointer s7_from_c_complex(s7_scheme *sc, s7_complex z)
{
  return(s7_make_complex(sc, creal(z), cimag(z)));
}
#endif


#if (!WITH_GMP)
static s7_pointer s7_negate(s7_scheme *sc, s7_pointer p)     /* can't use "negate" because it confuses C++! */
{
  switch (type(p))
    {
    case T_INTEGER:
      if (integer(p) == s7_int_min)
	return(simple_out_of_range(sc, sc->subtract_symbol, p, wrap_string(sc, "most-negative-fixnum can't be negated", 37)));
      return(make_integer(sc, -integer(p)));
    case T_RATIO:   return(make_simple_ratio(sc, -numerator(p), denominator(p)));
    case T_REAL:    return(make_real(sc, -real(p)));
    default:        return(s7_make_complex(sc, -real_part(p), -imag_part(p)));
    }
}
#endif

static s7_pointer complex_invert(s7_scheme *sc, s7_pointer p)
{
  s7_double r2, i2, den;
  r2 = real_part(p);
  i2 = imag_part(p);
  den = (r2 * r2 + i2 * i2);
  return(s7_make_complex(sc, r2 / den, -i2 / den));
}

static s7_pointer s7_invert(s7_scheme *sc, s7_pointer p)      /* s7_ to be consistent... */
{
  switch (type(p))
    {
    case T_INTEGER: return(make_simple_ratio(sc, 1, integer(p)));           /* a already checked, not 0 */
    case T_RATIO:   return(make_simple_ratio(sc, denominator(p), numerator(p)));
    case T_REAL:    return(make_real(sc, 1.0 / real(p)));
    case T_COMPLEX: return(complex_invert(sc, p));
    default:        return(wrong_type_argument_with_type(sc, sc->divide_symbol, 1, p, a_number_string));
    }
}


static s7_pointer subtract_ratios(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  s7_int d1, d2, n1, n2;
  d1 = number_to_denominator(x);
  n1 = number_to_numerator(x);
  d2 = number_to_denominator(y);
  n2 = number_to_numerator(y);

  if (d1 == d2)                                     /* the easy case -- if overflow here, it matches the int32_t case */
    return(s7_make_ratio(sc, n1 - n2, d1));

#if (!WITH_GMP) && HAVE_OVERFLOW_CHECKS
  {
    s7_int n1d2, n2d1, d1d2, dn;
    if ((multiply_overflow(d1, d2, &d1d2)) ||
	(multiply_overflow(n1, d2, &n1d2)) ||
	(multiply_overflow(n2, d1, &n2d1)) ||
	(subtract_overflow(n1d2, n2d1, &dn)))
      return(make_real(sc, ((long_double)n1 / (long_double)d1) - ((long_double)n2 / (long_double)d2)));
    return(s7_make_ratio(sc, dn, d1d2));
  }
#else
  return(s7_make_ratio(sc, n1 * d2 - n2 * d1, d1 * d2));
#endif
}

static bool s7_is_negative(s7_pointer obj)
{
  switch (type(obj))
    {
    case T_INTEGER:     return(integer(obj) < 0);
    case T_RATIO:       return(numerator(obj) < 0);
#if WITH_GMP
    case T_BIG_INTEGER: return(mpz_cmp_ui(big_integer(obj), 0) < 0);
    case T_BIG_RATIO:   return(mpq_cmp_ui(big_ratio(obj), 0, 1) < 0);
    case T_BIG_REAL:    return(mpfr_cmp_ui(big_real(obj), 0) < 0);
#endif
    default:            return(real(obj) < 0);
    }
}

static bool s7_is_positive(s7_pointer x)
{
  switch (type(x))
    {
    case T_INTEGER:     return(integer(x) > 0);
    case T_RATIO:       return(numerator(x) > 0);
#if WITH_GMP
    case T_BIG_INTEGER: return(mpz_cmp_ui(big_integer(x), 0) > 0);
    case T_BIG_RATIO:   return(mpq_cmp_ui(big_ratio(x), 0, 1) > 0);
    case T_BIG_REAL:    return(mpfr_cmp_ui(big_real(x), 0) > 0);
#endif
    default:            return(real(x) > 0.0);
    }
}

static bool s7_is_zero(s7_pointer x)
{
  switch (type(x))
    {
    case T_INTEGER:     return(integer(x) == 0);
    case T_REAL:        return(real(x) == 0.0);
#if WITH_GMP
    case T_BIG_INTEGER: return(mpz_cmp_ui(big_integer(x), 0) == 0);
    case T_BIG_RATIO:   return(mpz_cmp_ui(mpq_numref(big_ratio(x)), 0) == 0);   /* a big_ratio can be zero! */
    case T_BIG_REAL:    return(mpfr_zero_p(big_real(x)));
#endif
    default:            return(false); /* ratios and complex numbers here are already collapsed into integers and reals */
    }
}

static bool s7_is_one(s7_pointer x)
{
    return(((is_t_integer(x)) && (integer(x) == 1)) ||
	   ((is_float(x)) && (real(x) == 1.0)));
}


/* -------- optimize exponents -------- */

#define MAX_POW 64
static double pepow[17][MAX_POW * 2];

static void init_pows(void)
{
  int32_t i, j;
  for (i = 2; i < 17; i++)        /* radix between 2 and 16 */
    for (j = -MAX_POW; j < MAX_POW; j++) /* saved exponent between 0 and +/- MAX_POW */
      pepow[i][j + MAX_POW] = pow((double)i, (double)j);
}

static double ipow(int32_t x, int32_t y)
{
  if ((y >= MAX_POW) || (y < -MAX_POW))
    return(pow((double)x, (double)y));
  return(pepow[x][y + MAX_POW]);
}


/* -------------------------------- number->string -------------------------------- */
#define WITH_DTOA 1
#if WITH_DTOA
/* fpconv, revised to fit the local coding style

   The MIT License

Copyright (c) 2013 Andreas Samoljuk

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#define dtoa_npowers     87
#define dtoa_steppowers  8
#define dtoa_firstpower -348 /* 10 ^ -348 */
#define dtoa_expmax     -32
#define dtoa_expmin     -60

typedef struct dtoa_Fp {uint64_t frac; int exp;} dtoa_Fp;

static dtoa_Fp dtoa_powers_ten[] = {
    { 18054884314459144840U, -1220 }, { 13451937075301367670U, -1193 }, { 10022474136428063862U, -1166 }, { 14934650266808366570U, -1140 },
    { 11127181549972568877U, -1113 }, { 16580792590934885855U, -1087 }, { 12353653155963782858U, -1060 }, { 18408377700990114895U, -1034 },
    { 13715310171984221708U, -1007 }, { 10218702384817765436U, -980 }, { 15227053142812498563U, -954 },  { 11345038669416679861U, -927 },
    { 16905424996341287883U, -901 },  { 12595523146049147757U, -874 }, { 9384396036005875287U,  -847 },  { 13983839803942852151U, -821 },
    { 10418772551374772303U, -794 },  { 15525180923007089351U, -768 }, { 11567161174868858868U, -741 },  { 17236413322193710309U, -715 },
    { 12842128665889583758U, -688 },  { 9568131466127621947U,  -661 }, { 14257626930069360058U, -635 },  { 10622759856335341974U, -608 },
    { 15829145694278690180U, -582 },  { 11793632577567316726U, -555 }, { 17573882009934360870U, -529 },  { 13093562431584567480U, -502 },
    { 9755464219737475723U,  -475 },  { 14536774485912137811U, -449 }, { 10830740992659433045U, -422 },  { 16139061738043178685U, -396 },
    { 12024538023802026127U, -369 },  { 17917957937422433684U, -343 }, { 13349918974505688015U, -316 },  { 9946464728195732843U,  -289 },
    { 14821387422376473014U, -263 },  { 11042794154864902060U, -236 }, { 16455045573212060422U, -210 },  { 12259964326927110867U, -183 },
    { 18268770466636286478U, -157 },  { 13611294676837538539U, -130 }, { 10141204801825835212U, -103 },  { 15111572745182864684U, -77 },
    { 11258999068426240000U, -50 },   { 16777216000000000000U, -24 }, { 12500000000000000000U,   3 },   { 9313225746154785156U,   30 },
    { 13877787807814456755U,  56 },   { 10339757656912845936U,  83 }, { 15407439555097886824U, 109 },   { 11479437019748901445U, 136 },
    { 17105694144590052135U, 162 },   { 12744735289059618216U, 189 }, { 9495567745759798747U,  216 },   { 14149498560666738074U, 242 },
    { 10542197943230523224U, 269 },   { 15709099088952724970U, 295 }, { 11704190886730495818U, 322 },   { 17440603504673385349U, 348 },
    { 12994262207056124023U, 375 },   { 9681479787123295682U,  402 }, { 14426529090290212157U, 428 },   { 10748601772107342003U, 455 },
    { 16016664761464807395U, 481 },   { 11933345169920330789U, 508 }, { 17782069995880619868U, 534 },   { 13248674568444952270U, 561 },
    { 9871031767461413346U,  588 },   { 14708983551653345445U, 614 }, { 10959046745042015199U, 641 },   { 16330252207878254650U, 667 },
    { 12166986024289022870U, 694 },   { 18130221999122236476U, 720 }, { 13508068024458167312U, 747 },   { 10064294952495520794U, 774 },
    { 14996968138956309548U, 800 },   { 11173611982879273257U, 827 }, { 16649979327439178909U, 853 },   { 12405201291620119593U, 880 },
    { 9242595204427927429U,  907 },   { 13772540099066387757U, 933 }, { 10261342003245940623U, 960 },   { 15290591125556738113U, 986 },
    { 11392378155556871081U, 1013 },  { 16975966327722178521U, 1039 },
    { 12648080533535911531U, 1066 }};

static dtoa_Fp dtoa_find_cachedpow10(int exp, int* k)
{
  int approx, idx;
  const double one_log_ten = 0.30102999566398114;

  approx = -(exp + dtoa_npowers) * one_log_ten;
  idx = (approx - dtoa_firstpower) / dtoa_steppowers;
  while (true)
    {
      int current;
      current = exp + dtoa_powers_ten[idx].exp + 64;
      if (current < dtoa_expmin)
	{
	  idx++;
	  continue;
        }
      if (current > dtoa_expmax)
	{
	  idx--;
	  continue;
        }
      *k = (dtoa_firstpower + idx * dtoa_steppowers);
      return(dtoa_powers_ten[idx]);
    }
}

#define dtoa_fracmask  0x000FFFFFFFFFFFFFU
#define dtoa_expmask   0x7FF0000000000000U
#define dtoa_hiddenbit 0x0010000000000000U
#define dtoa_signmask  0x8000000000000000U
#define dtoa_expbias   (1023 + 52)
#define dtoa_absv(n)   ((n) < 0 ? -(n) : (n))
#define dtoa_minv(a, b) ((a) < (b) ? (a) : (b))

static uint64_t dtoa_tens[] =
  { 10000000000000000000U, 1000000000000000000U, 100000000000000000U,
    10000000000000000U, 1000000000000000U, 100000000000000U,
    10000000000000U, 1000000000000U, 100000000000U,
    10000000000U, 1000000000U, 100000000U,
    10000000U, 1000000U, 100000U,
    10000U, 1000U, 100U,
    10U, 1U};

static uint64_t dtoa_get_dbits(double d)
{
  union {double dbl; uint64_t i;} dbl_bits = {d};
  return(dbl_bits.i);
}

static dtoa_Fp dtoa_build_fp(double d)
{
  uint64_t bits;
  dtoa_Fp fp;

  bits = dtoa_get_dbits(d);
  fp.frac = bits & dtoa_fracmask;
  fp.exp = (bits & dtoa_expmask) >> 52;
  if (fp.exp)
    {
      fp.frac += dtoa_hiddenbit;
      fp.exp -= dtoa_expbias;
    }
  else fp.exp = -dtoa_expbias + 1;
  return(fp);
}

static void dtoa_normalize(dtoa_Fp* fp)
{
  int shift;
  while ((fp->frac & dtoa_hiddenbit) == 0)
    {
      fp->frac <<= 1;
      fp->exp--;
    }
  shift = 64 - 52 - 1;
  fp->frac <<= shift;
  fp->exp -= shift;
}

static void dtoa_get_normalized_boundaries(dtoa_Fp* fp, dtoa_Fp* lower, dtoa_Fp* upper)
{
  int u_shift, l_shift;
  upper->frac = (fp->frac << 1) + 1;
  upper->exp  = fp->exp - 1;
  while ((upper->frac & (dtoa_hiddenbit << 1)) == 0)
    {
      upper->frac <<= 1;
      upper->exp--;
    }
  u_shift = 64 - 52 - 2;
  upper->frac <<= u_shift;
  upper->exp = upper->exp - u_shift;
  l_shift = fp->frac == dtoa_hiddenbit ? 2 : 1;
  lower->frac = (fp->frac << l_shift) - 1;
  lower->exp = fp->exp - l_shift;
  lower->frac <<= lower->exp - upper->exp;
  lower->exp = upper->exp;
}

static dtoa_Fp dtoa_multiply(dtoa_Fp* a, dtoa_Fp* b)
{
  dtoa_Fp fp;
  uint64_t ah_bl, al_bh, al_bl, ah_bh, tmp;
  const uint64_t lomask = 0x00000000FFFFFFFF;

  ah_bl = (a->frac >> 32)    * (b->frac & lomask);
  al_bh = (a->frac & lomask) * (b->frac >> 32);
  al_bl = (a->frac & lomask) * (b->frac & lomask);
  ah_bh = (a->frac >> 32)    * (b->frac >> 32);
  tmp = (ah_bl & lomask) + (al_bh & lomask) + (al_bl >> 32);
  /* round up */
  tmp += 1U << 31;
  fp.frac = ah_bh + (ah_bl >> 32) + (al_bh >> 32) + (tmp >> 32);
  fp.exp = a->exp + b->exp + 64;
  return(fp);
}

static void dtoa_round_digit(char* digits, int ndigits, uint64_t delta, uint64_t rem, uint64_t kappa, uint64_t frac)
{
  while ((rem < frac) && (delta - rem >= kappa) &&
	 ((rem + kappa < frac) || (frac - rem > rem + kappa - frac)))
    {
      digits[ndigits - 1]--;
      rem += kappa;
    }
}

static int dtoa_generate_digits(dtoa_Fp* fp, dtoa_Fp* upper, dtoa_Fp* lower, char* digits, int* K)
{
  uint64_t part1, part2, wfrac, delta;
  uint64_t *divp, *unit;
  int idx, kappa;
  dtoa_Fp one;

  wfrac = upper->frac - fp->frac;
  delta = upper->frac - lower->frac;
  one.frac = 1ULL << -upper->exp;
  one.exp  = upper->exp;
  part1 = upper->frac >> -one.exp;
  part2 = upper->frac & (one.frac - 1);
  idx = 0;
  kappa = 10;

  /* 1000000000 */
  for (divp = dtoa_tens + 10; kappa > 0; divp++)
    {
      uint64_t tmp, div;
      unsigned digit;
      div = *divp;
      digit = part1 / div;
      if (digit || idx)
	digits[idx++] = digit + '0';
      part1 -= digit * div;
      kappa--;
      tmp = (part1 << -one.exp) + part2;
      if (tmp <= delta)
	{
	  *K += kappa;
	  dtoa_round_digit(digits, idx, delta, tmp, div << -one.exp, wfrac);
	  return(idx);
        }
    }

  /* 10 */
  unit = dtoa_tens + 18;
  while(true)
    {
      unsigned digit;
      part2 *= 10;
      delta *= 10;
      kappa--;
      digit = part2 >> -one.exp;
      if (digit || idx)
	digits[idx++] = digit + '0';
      part2 &= one.frac - 1;
      if (part2 < delta)
	{
	  *K += kappa;
	  dtoa_round_digit(digits, idx, delta, part2, one.frac, wfrac * *unit);
	  return(idx);
	}
      unit--;
    }
}

static int dtoa_grisu2(double d, char* digits, int* K)
{
  int k;
  dtoa_Fp cp, w, lower, upper;
  w = dtoa_build_fp(d);
  dtoa_get_normalized_boundaries(&w, &lower, &upper);
  dtoa_normalize(&w);
  cp = dtoa_find_cachedpow10(upper.exp, &k);
  w = dtoa_multiply(&w, &cp);
  upper = dtoa_multiply(&upper, &cp);
  lower = dtoa_multiply(&lower, &cp);
  lower.frac++;
  upper.frac--;
  *K = -k;
  return(dtoa_generate_digits(&w, &upper, &lower, digits, K));
}

static int dtoa_emit_digits(char* digits, int ndigits, char* dest, int K, bool neg)
{
  int exp, idx, cent;
  char sign;
  exp = dtoa_absv(K + ndigits - 1);

  /* write plain integer */
  if ((K >= 0) && (exp < (ndigits + 7)))
    {
      memcpy(dest, digits, ndigits);
      memset(dest + ndigits, '0', K);
      dest[ndigits + K] = '.';
      dest[ndigits + K + 1] = '0';
      return(ndigits + K + 2);
    }

  /* write decimal w/o scientific notation */
  if ((K < 0) && (K > -7 || exp < 4))
    {
      int offset;
      offset = ndigits - dtoa_absv(K);
      /* fp < 1.0 -> write leading zero */
      if (offset <= 0)
	{
	  offset = -offset;
	  dest[0] = '0';
	  dest[1] = '.';
	  memset(dest + 2, '0', offset);
	  memcpy(dest + offset + 2, digits, ndigits);
	  return(ndigits + 2 + offset);
	  /* fp > 1.0 */
	}
      else
	{
	  memcpy(dest, digits, offset);
	  dest[offset] = '.';
	  memcpy(dest + offset + 1, digits + offset, ndigits - offset);
	  return(ndigits + 1);
	}
    }

  /* write decimal w/ scientific notation */
  ndigits = dtoa_minv(ndigits, 18 - neg);
  idx = 0;
  dest[idx++] = digits[0];
  if (ndigits > 1)
    {
      dest[idx++] = '.';
      memcpy(dest + idx, digits + 1, ndigits - 1);
      idx += ndigits - 1;
    }
  dest[idx++] = 'e';
  sign = K + ndigits - 1 < 0 ? '-' : '+';
  dest[idx++] = sign;
  cent = 0;
  if (exp > 99)
    {
      cent = exp / 100;
      dest[idx++] = cent + '0';
      exp -= cent * 100;
    }
  if (exp > 9)
    {
      int dec;
      dec = exp / 10;
      dest[idx++] = dec + '0';
      exp -= dec * 10;
    }
  else
    {
      if (cent)
	dest[idx++] = '0';
    }
  dest[idx++] = exp % 10 + '0';
  return(idx);
}

static int dtoa_filter_special(double fp, char* dest, bool neg)
{
  uint64_t bits;
  bool nan;
  if (fp == 0.0)
    {
      dest[0] = '0'; dest[1] = '.'; dest[2] = '0';
      return(3);
    }
  bits = dtoa_get_dbits(fp);
  nan = (bits & dtoa_expmask) == dtoa_expmask;
  if (!nan) return(0);

  if (!neg)
    {
      dest[0] = '+';
      dest++;
    }
  if (bits & dtoa_fracmask)
    {
      dest[0] = 'n'; dest[1] = 'a'; dest[2] = 'n'; dest[3] = '.'; dest[4] = '0';
    }
  else
    {
      dest[0] = 'i'; dest[1] = 'n'; dest[2] = 'f'; dest[3] = '.'; dest[4] = '0';
    }
  return((neg) ? 5 : 6);
}

static inline int fpconv_dtoa(double d, char dest[24])
{
  char digits[18];
  int str_len = 0, spec, K, ndigits;
  bool neg = false;

  if (dtoa_get_dbits(d) & dtoa_signmask)
    {
      dest[0] = '-';
      str_len++;
      neg = true;
    }

  spec = dtoa_filter_special(d, dest + str_len, neg);
  if (spec) return(str_len + spec);
  K = 0;
  ndigits = dtoa_grisu2(d, digits, &K);
  str_len += dtoa_emit_digits(digits, ndigits, dest + str_len, K, neg);
  return(str_len);
}
#endif


/* -------------------------------- number->string -------------------------------- */
static const char dignum[] = "0123456789abcdef";

static size_t integer_to_string_any_base(char *p, s7_int n, int32_t radix)  /* called by number_to_string_with_radix */
{
  s7_int i, len, end;
  bool sign;
  s7_int pown;

  if ((radix < 2) || (radix > 16))
    return(0);

  if (n == s7_int_min) /* can't negate this, so do it by hand */
    {
      static const char *mnfs[17] = {"","",
	"-1000000000000000000000000000000000000000000000000000000000000000", "-2021110011022210012102010021220101220222",
	"-20000000000000000000000000000000", "-1104332401304422434310311213", "-1540241003031030222122212",
	"-22341010611245052052301", "-1000000000000000000000", "-67404283172107811828",	"-9223372036854775808",
	"-1728002635214590698",	"-41a792678515120368", "-10b269549075433c38", "-4340724c6c71dc7a8", "-160e2ad3246366808", "-8000000000000000"};

      len = safe_strlen(mnfs[radix]);
      memcpy((void *)p, (void *)mnfs[radix], len);
      p[len] = '\0';
      return(len);
    }

  sign = (n < 0);
  if (sign) n = -n;

  /* the previous version that counted up to n, rather than dividing down below n, as here,
   *   could be confused by large ints on 64 bit machines
   */
  pown = n;
  for (i = 1; i < 100; i++)
    {
      if (pown < radix)
	break;
      pown /= (s7_int)radix;
    }
  len = i - 1;
  if (sign) len++;
  end = 0;
  if (sign)
    {
      p[0] = '-';
      end++;
    }
  for (i = len; i >= end; i--)
    {
      p[i] = dignum[n % radix];
      n /= radix;
    }
  p[len + 1] = '\0';
  return(len + 1);
}

static char *integer_to_string(s7_scheme *sc, s7_int num, s7_int *nlen) /* do not free the returned string */
{
  char *p, *op;
  bool sign;

  if (num == s7_int_min)
    {
      (*nlen) = 20;
      return((char *)"-9223372036854775808");
    }
  p = (char *)(sc->int_to_str1 + INT_TO_STR_SIZE - 1);
  op = p;
  *p-- = '\0';

  sign = (num < 0);
  if (sign) num = -num;  /* we need a positive index below */
  do {*p-- = "0123456789"[num % 10]; num /= 10;} while (num);
  if (sign)
    {
      *p = '-';
      (*nlen) = op - p;
      return(p);
    }

  (*nlen) = op - p - 1;
  return(++p);
}

static char *integer_to_string_no_length(s7_scheme *sc, s7_int num) /* do not free the returned string */
{
  char *p;
  bool sign;

  if (num == s7_int_min)
    return((char *)"-9223372036854775808");
  p = (char *)(sc->int_to_str2 + INT_TO_STR_SIZE - 1);
  *p-- = '\0';
  sign = (num < 0);
  if (sign) num = -num;
  do {*p-- = "0123456789"[num % 10]; num /= 10;} while (num);
  if (sign)
    {
      *p = '-';
      return(p);
    }
  return(++p);
}

static inline char *floatify(char *str, s7_int *nlen)
{
  if ((!strchr(str, '.')) && (!strchr(str, 'e'))) /* faster than (strcspn(str, ".e") >= (size_t)(*nlen)) */
    {
      s7_int len;
      len = *nlen;
      /* snprintf returns "nan" and "inf" but we (stupidly) want "+nan.0" and "+inf.0"; "-nan" and "-inf" will be handled by the normal case */
      if (len == 3)
	{
	  if (str[0] == 'n')
	    {
	      str[0] = '+'; str[1] = 'n'; str[2] = 'a'; str[3] = 'n';
	      len = 4;
	    }
	  if (str[0] == 'i')
	    {
	      str[0] = '+'; str[1] = 'i'; str[2] = 'n'; str[3] = 'f';
	      len = 4;
	    }
	}
      str[len]='.';
      str[len + 1]='0';
      str[len + 2]='\0';
      (*nlen) = len + 2;
    }
  return(str);
}

static void insert_spaces(s7_scheme *sc, char *src, s7_int width, s7_int len)
{
  s7_int spaces;
  if (width >= sc->num_to_str_size)
    {
      sc->num_to_str_size = width + 1;
      sc->num_to_str = (char *)realloc(sc->num_to_str, sc->num_to_str_size * sizeof(char));
    }
  spaces = width - len;
  sc->num_to_str[width] = '\0';
  memmove((void *)(sc->num_to_str + spaces), (void *)src, len);
  memset((void *)(sc->num_to_str), (int)' ', spaces);
}

static char *number_to_string_base_10(s7_scheme *sc, s7_pointer obj, s7_int width, s7_int precision, char float_choice, s7_int *nlen, use_write_t choice) /* don't free result */
{
  /* called by number_to_string_with_radix g_number_to_string, number_to_string_p_p number_to_port format_number */
  /* the rest of s7 assumes nlen is set to the correct length
   *   a tricky case: (format #f "~f" 1e308) -- tries to print 308 digits! so 256 as default len is too small.
   *   but then even worse: (format #f "~F" 1e308+1e308i)!
   */
  s7_int len;

  if ((width + precision) > 512)
    len = 512 + 2 * (width + precision);
  else len = 1024;

  if (len > sc->num_to_str_size)
    {
      if (!sc->num_to_str)
	sc->num_to_str = (char *)malloc(len * sizeof(char));
      else sc->num_to_str = (char *)realloc(sc->num_to_str, len * sizeof(char));
      sc->num_to_str_size = len;
    }

  /* bignums can't happen here */
  switch (type(obj))
    {
    case T_INTEGER:
      if (width == 0)
	{
	  if (has_print_name(obj))
	    {
	      (*nlen) = print_name_length(obj);
	      return((char *)print_name(obj));
	    }
	  return(integer_to_string(sc, integer(obj), nlen));
	}
      {
	char *p;
	p = integer_to_string(sc, integer(obj), &len);
	if (width > len)
	  {
	    insert_spaces(sc, p, width, len);
	    (*nlen) = width;
	    return(sc->num_to_str);
	  }
	(*nlen) = len;
	return(p);
      }

    case T_RATIO:
      len = catstrs_direct(sc->num_to_str, integer_to_string_no_length(sc, numerator(obj)), "/", pos_int_to_str_direct(sc, denominator(obj)), NULL);
      if (width > len)
	{
	  insert_spaces(sc, sc->num_to_str, width, len);
	  (*nlen) = width;
	}
      else (*nlen) = len;
      return(sc->num_to_str);

    case T_REAL:
      if (width == 0)
	{
#if WITH_DTOA
	  if ((float_choice == 'g') &&
	      (precision == WRITE_REAL_PRECISION))
	    {
	      len = fpconv_dtoa(real(obj), sc->num_to_str);
	      sc->num_to_str[len] = '\0';
	      (*nlen) = len;
	      return(sc->num_to_str);
	    }
#endif
	  len = snprintf(sc->num_to_str, sc->num_to_str_size - 4,
			 (float_choice == 'g') ? "%.*g" : ((float_choice == 'f') ? "%.*f" : "%.*e"),
			 (int32_t)precision, real(obj)); /* -4 for floatify */
	}
      else len = snprintf(sc->num_to_str, sc->num_to_str_size - 4,
			  (float_choice == 'g') ? "%*.*g" : ((float_choice == 'f') ? "%*.*f" : "%*.*e"),
			  (int32_t)width, (int32_t)precision, real(obj)); /* -4 for floatify */
      (*nlen) = len;
      floatify(sc->num_to_str, nlen);
      return(sc->num_to_str);

    default:
      {
	char *imag;

	sc->num_to_str[0] = '\0';
 	real(sc->real_wrapper4) = imag_part(obj);
	imag = copy_string(number_to_string_base_10(sc, sc->real_wrapper4, 0, precision, float_choice, &len, choice));

	sc->num_to_str[0] = '\0';
 	real(sc->real_wrapper3) = real_part(obj);
	number_to_string_base_10(sc, sc->real_wrapper3, 0, precision, float_choice, &len, choice);

	sc->num_to_str[len] = '\0';
	len = catstrs(sc->num_to_str, sc->num_to_str_size, ((imag[0] == '+') || (imag[0] == '-')) ? "" : "+", imag, "i", NULL);
	free(imag);

	if (width > len)  /* (format #f "~20g" 1+i) */
	  {
	    insert_spaces(sc, sc->num_to_str, width, len); /* this checks sc->num_to_str_size */
	    (*nlen) = width;
	  }
	else (*nlen) = len;
      }
      break;
    }
  return(sc->num_to_str);
}

static char *number_to_string_with_radix(s7_scheme *sc, s7_pointer obj, int32_t radix, s7_int width, s7_int precision, char float_choice, s7_int *nlen)
{ /* called by s7_number_to_string (char*), g_number_to_string (strp), number_to_string_p_pp (strp), format_number (strp basically) */
  /* the rest of s7 assumes nlen is set to the correct length */
  char *p;
  s7_int len, str_len;

#if WITH_GMP
  if (s7_is_bignum(obj))
    return(big_number_to_string_with_radix(obj, radix, width, nlen, P_WRITE));
  /* this ignores precision because it's way too hard to get the mpfr string to look like
   *   C's output -- we either have to call mpfr_get_str twice (the first time just to
   *   find out what the exponent is and how long the string actually is), or we have
   *   to do messy string manipulations.  So (format #f "",3F" pi) ignores the "3" and
   *   prints the full string.
   */
#endif

  if (radix == 10)
    {
      p = number_to_string_base_10(sc, obj, width, precision, float_choice, nlen, P_WRITE);
      return(copy_string_with_length(p, *nlen));
    }

  switch (type(obj))
    {
    case T_INTEGER:
      {
	size_t len1;
	p = (char *)malloc((128 + width) * sizeof(char));
	len1 = integer_to_string_any_base(p, integer(obj), radix);
	if ((size_t)width > len1)
	  {
	    size_t start;
	    start = width - len1;
	    memmove((void *)(p + start), (void *)p, len1);
	    memset((void *)p, (int)' ', start);
	    p[width] = '\0';
	    *nlen = width;
	  }
	else *nlen = len1;
	return(p);
      }
    case T_RATIO:
      {
	size_t len1, len2;
	str_len = 256 + width;
	p = (char *)malloc(str_len * sizeof(char));
	len1 = integer_to_string_any_base(p, numerator(obj), radix);
	p[len1] = '/';
	len2 = integer_to_string_any_base((char *)(p + len1 + 1), denominator(obj), radix);
        len = len1 + 1 + len2;
        p[len] = '\0';
      }
      break;

    case T_REAL:
      {
	int32_t i;
	s7_int int_part;
	s7_double x, frac_part, min_frac, base;
	bool sign = false;
	char n[128], d[256];

	x = real(obj);

	if (is_NaN(x))
	  return(copy_string_with_length("+nan.0", *nlen = 6));
	if (is_inf(x))
	  {
	    if (x < 0.0)
	      return(copy_string_with_length("-inf.0", *nlen = 6));
	    return(copy_string_with_length("+inf.0", *nlen = 6));
	  }

	if (x < 0.0)
	  {
	    sign = true;
	    x = -x;
	  }

	if (x > 1.0e18) /* i.e. close to or greater than most-positive-fixnum (9.22e18), so the code below is unlikely to work, (format #f "~X" 1e19) */
	  {
	    int32_t ep;
	    char *p1;
	    len = 0;
	    ep = (int32_t)floor(log(x) / log((double)radix));
 	    real(sc->real_wrapper3) = x / pow((double)radix, (double)ep); /* divide it down to one digit, then the fractional part */
	    p1 = number_to_string_with_radix(sc, sc->real_wrapper3, radix, width, precision, float_choice, &len);
	    p = (char *)malloc((len + 8) * sizeof(char));
	    p[0] = '\0';
	    (*nlen) = catstrs(p, len + 8, (sign) ? "-" : "", p1, "e", integer_to_string_no_length(sc, ep), NULL);
	    free(p1);
	    return(p);
	  }

	int_part = (s7_int)floor(x);
	frac_part = x - int_part;
	integer_to_string_any_base(n, int_part, radix);
	min_frac = (s7_double)ipow(radix, -precision);

	/* doesn't this assume precision < 128/256 and that we can fit in 256 digits (1e308)? */
	for (i = 0, base = radix; (i < precision) && (frac_part > min_frac); i++, base *= radix)
	  {
	    s7_int ipart;
	    ipart = (s7_int)(frac_part * base);
	    if (ipart >= radix)         /* rounding confusion */
	      ipart = radix - 1;
	    frac_part -= (ipart / base);
	    if (ipart < 10)
	      d[i] = (char)('0' + ipart);
	    else d[i] = (char)('a' + ipart -  10);
	  }
	if (i == 0)
	  d[i++] = '0';
	d[i] = '\0';
	p = (char *)malloc(256 * sizeof(char));
	p[0] = '\0';
	len = catstrs(p, 256, (sign) ? "-" : "", n, ".", d, NULL);
	str_len = 256;
      }
      break;

    default:
      {
	char *n, *d;
	p = (char *)malloc(512 * sizeof(char));
 	real(sc->real_wrapper3) = real_part(obj);
	n = number_to_string_with_radix(sc, sc->real_wrapper3, radix, 0, precision, float_choice, &len); /* include floatify */
 	real(sc->real_wrapper4) = imag_part(obj);
	d = number_to_string_with_radix(sc, sc->real_wrapper4, radix, 0, precision, float_choice, &len);
	p[0] = '\0';
	len = catstrs(p, 512, n, ((d[0] == '+') || (d[0] == '-')) ? "" : "+", d, "i", NULL);
	str_len = 512;
	free(n);
	free(d);
      }
      break;
    }

  if (width > len)
    {
      s7_int spaces;
      if (width >= str_len)
	{
	  str_len = width + 1;
	  p = (char *)realloc(p, str_len * sizeof(char));
	}
      spaces = width - len;
      p[width] = '\0';
      memmove((void *)(p + spaces), (void *)p, len);
      memset((void *)p, (int)' ', spaces);
      (*nlen) = width;
    }
  else (*nlen) = len;
  return(p);
}

char *s7_number_to_string(s7_scheme *sc, s7_pointer obj, s7_int radix)
{
  s7_int nlen = 0;
  return(number_to_string_with_radix(sc, obj, radix, 0, 20, 'g', &nlen));  /* (log top 10) so we get all the digits in base 10 (??) */
}

static s7_pointer g_number_to_string(s7_scheme *sc, s7_pointer args)
{
  #define H_number_to_string "(number->string num (radix 10)) converts the number num into a string."
  #define Q_number_to_string s7_make_signature(sc, 3, sc->is_string_symbol, sc->is_number_symbol, sc->is_integer_symbol)

  s7_int nlen = 0, radix; /* ignore cppcheck complaint about radix! */
  char *res;
  s7_pointer x;

  x = car(args);
  if (!s7_is_number(x))
    return(method_or_bust_with_type(sc, x, sc->number_to_string_symbol, args, a_number_string, 1));

  if (is_pair(cdr(args)))
    {
      s7_pointer y;
      y = cadr(args);
      if (s7_is_integer(y))
	radix = s7_integer(y);
      else return(method_or_bust(sc, y, sc->number_to_string_symbol, args, T_INTEGER, 2));
      if ((radix < 2) || (radix > 16))
	return(out_of_range(sc, sc->number_to_string_symbol, small_int(2), y, a_valid_radix_string));
#if (WITH_GMP)
      if (!s7_is_bignum(x))
#endif
	{
	  s7_pointer p;
	  res = number_to_string_with_radix(sc, x, radix, 0, sc->float_format_precision, 'g', &nlen);
	  p = make_string_with_length(sc, res, nlen);
	  free(res);
	  return(p);
	}
    }
#if WITH_GMP
  else radix = 10;
  if (s7_is_bignum(x))
    {
      s7_pointer p;
      res = big_number_to_string_with_radix(x, radix, 0, &nlen, P_WRITE);
      p = make_string_with_length(sc, res, nlen);
      free(res);
      return(p);
    }
#endif
  res = number_to_string_base_10(sc, x, 0, sc->float_format_precision, 'g', &nlen, P_WRITE);
  return(make_string_with_length(sc, res, nlen));
}

#if (!WITH_GMP)
static s7_pointer number_to_string_p_p(s7_scheme *sc, s7_pointer p)
{
  s7_int nlen = 0;
  char *res;
  if (!is_number(p))
    return(wrong_type_argument_with_type(sc, sc->number_to_string_symbol, 1, p, a_number_string));
  res = number_to_string_base_10(sc, p, 0, sc->float_format_precision, 'g', &nlen, P_WRITE);
  return(make_string_with_length(sc, res, nlen));
}

static s7_pointer number_to_string_p_i(s7_scheme *sc, s7_int p)
{
  s7_int nlen = 0;
  char *res;
  res = integer_to_string(sc, p, &nlen);
  return(make_string_with_length(sc, res, nlen));
}

static s7_pointer number_to_string_p_d(s7_scheme *sc, s7_double x)
{
  s7_int len;
  if (!sc->num_to_str)
    sc->num_to_str = (char *)malloc(1024 * sizeof(char));
  len = snprintf(sc->num_to_str, sc->num_to_str_size, "%.*g", sc->float_format_precision, x);
  floatify(sc->num_to_str, &len);
  return(make_string_with_length(sc, sc->num_to_str, len));
}
#endif

static s7_pointer number_to_string_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  s7_int nlen = 0, radix;
  char *res;
  s7_pointer p;
  if (!is_number(p1))
    return(wrong_type_argument_with_type(sc, sc->number_to_string_symbol, 1, p1, a_number_string));
  if (!is_t_integer(p2))
    return(wrong_type_argument(sc, sc->number_to_string_symbol, 2, p2, T_INTEGER));
  radix = s7_integer(p2);
  if ((radix < 2) || (radix > 16))
    return(out_of_range(sc, sc->number_to_string_symbol, small_int(2), p2, a_valid_radix_string));
  res = number_to_string_with_radix(sc, p1, radix, 0, sc->float_format_precision, 'g', &nlen);
  p = make_string_with_length(sc, res, nlen);
  free(res);
  return(p);
}


/* -------------------------------------------------------------------------------- */
#define CTABLE_SIZE 256
static bool *exponent_table, *slashify_table, *char_ok_in_a_name, *white_space, *number_table, *symbol_slashify_table;
static int32_t *digits;

static void init_ctables(void)
{
  int32_t i;

  exponent_table = (bool *)calloc(CTABLE_SIZE, sizeof(bool));
  slashify_table = (bool *)calloc(CTABLE_SIZE, sizeof(bool));
  symbol_slashify_table = (bool *)calloc(CTABLE_SIZE, sizeof(bool));
  char_ok_in_a_name = (bool *)calloc(CTABLE_SIZE, sizeof(bool));
  white_space = (bool *)calloc(CTABLE_SIZE + 1, sizeof(bool));
  white_space++;      /* leave white_space[-1] false for white_space[EOF] */
  number_table = (bool *)calloc(CTABLE_SIZE, sizeof(bool));
  digits = (int32_t *)calloc(CTABLE_SIZE, sizeof(int32_t));

  for (i = 0; i < CTABLE_SIZE; i++)
    {
      char_ok_in_a_name[i] = true;
      white_space[i] = false;
      digits[i] = 256;
      number_table[i] = false;
    }

  char_ok_in_a_name[0] = false;
  char_ok_in_a_name[(uint8_t)'('] = false;  /* cast for C++ */
  char_ok_in_a_name[(uint8_t)')'] = false;
  char_ok_in_a_name[(uint8_t)';'] = false;
  char_ok_in_a_name[(uint8_t)'\t'] = false;
  char_ok_in_a_name[(uint8_t)'\n'] = false;
  char_ok_in_a_name[(uint8_t)'\r'] = false;
  char_ok_in_a_name[(uint8_t)' '] = false;
  char_ok_in_a_name[(uint8_t)'"'] = false;

  white_space[(uint8_t)'\t'] = true;
  white_space[(uint8_t)'\n'] = true;
  white_space[(uint8_t)'\r'] = true;
  white_space[(uint8_t)'\f'] = true;
  white_space[(uint8_t)'\v'] = true;
  white_space[(uint8_t)' '] = true;
  white_space[(uint8_t)'\205'] = true; /* 133 */
  white_space[(uint8_t)'\240'] = true; /* 160 */

  /* surely only 'e' is needed... */
  exponent_table[(uint8_t)'e'] = true; exponent_table[(uint8_t)'E'] = true;
  exponent_table[(uint8_t)'@'] = true;
#if WITH_EXTRA_EXPONENT_MARKERS
  exponent_table[(uint8_t)'s'] = true; exponent_table[(uint8_t)'S'] = true;
  exponent_table[(uint8_t)'f'] = true; exponent_table[(uint8_t)'F'] = true;
  exponent_table[(uint8_t)'d'] = true; exponent_table[(uint8_t)'D'] = true;
  exponent_table[(uint8_t)'l'] = true; exponent_table[(uint8_t)'L'] = true;
#endif

  for (i = 0; i < 32; i++)
    slashify_table[i] = true;
  for (i = 127; i < 160; i++)
    slashify_table[i] = true;
  slashify_table[(uint8_t)'\\'] = true;
  slashify_table[(uint8_t)'"'] = true;
  slashify_table[(uint8_t)'\n'] = false;

  for (i = 0; i < CTABLE_SIZE; i++)
    symbol_slashify_table[i] = ((slashify_table[i]) || (!char_ok_in_a_name[i])); /* force use of (symbol ...) for cases like '(ab) as symbol */

  digits[(uint8_t)'0'] = 0; digits[(uint8_t)'1'] = 1; digits[(uint8_t)'2'] = 2; digits[(uint8_t)'3'] = 3; digits[(uint8_t)'4'] = 4;
  digits[(uint8_t)'5'] = 5; digits[(uint8_t)'6'] = 6; digits[(uint8_t)'7'] = 7; digits[(uint8_t)'8'] = 8; digits[(uint8_t)'9'] = 9;
  digits[(uint8_t)'a'] = 10; digits[(uint8_t)'A'] = 10;
  digits[(uint8_t)'b'] = 11; digits[(uint8_t)'B'] = 11;
  digits[(uint8_t)'c'] = 12; digits[(uint8_t)'C'] = 12;
  digits[(uint8_t)'d'] = 13; digits[(uint8_t)'D'] = 13;
  digits[(uint8_t)'e'] = 14; digits[(uint8_t)'E'] = 14;
  digits[(uint8_t)'f'] = 15; digits[(uint8_t)'F'] = 15;

  number_table[(uint8_t)'0'] = true; number_table[(uint8_t)'1'] = true; number_table[(uint8_t)'2'] = true; number_table[(uint8_t)'3'] = true;
  number_table[(uint8_t)'4'] = true; number_table[(uint8_t)'5'] = true; number_table[(uint8_t)'6'] = true; number_table[(uint8_t)'7'] = true;
  number_table[(uint8_t)'8'] = true; number_table[(uint8_t)'9'] = true; number_table[(uint8_t)'.'] = true;
  number_table[(uint8_t)'+'] = true;
  number_table[(uint8_t)'-'] = true;
  number_table[(uint8_t)'#'] = true;
}

#define is_white_space(C) white_space[C]
  /* this is much faster than C's isspace, and does not depend on the current locale.
   * if c == EOF (-1), it indexes into the empty (0) slot we preallocated below white_space
   */

/* -------------------------------- *#readers* -------------------------------- */
static s7_pointer check_sharp_readers(s7_scheme *sc, const char *name)
{
  s7_pointer reader, value, args;
  bool need_loader_port;
  value = sc->F;
  args = sc->F;

  /* *#reader* is assumed to be an alist of (char . proc)
   *    where each proc takes one argument, the string from just beyond the "#" to the next delimiter.
   *    The procedure can call read-char to read ahead in the current-input-port.
   *    If it returns anything other than #f, that is the value of the sharp expression.
   *    Since #f means "nothing found", it is tricky to handle #F:
   *       (cons #\F (lambda (str) (and (string=? str "F") (list 'not #t))))
   * This search happens after #|, #t, and #f (and #nD for multivectors?). #! has a fallback.
   */

  need_loader_port = is_loader_port(sc->input_port);
  if (need_loader_port)
    clear_loader_port(sc->input_port);

  /* normally read* can't read from sc->input_port if it is in use by the loader, but here we are deliberately making that possible. */
  for (reader = slot_value(sc->sharp_readers); is_not_null(reader); reader = cdr(reader))
    if (name[0] == s7_character(caar(reader)))
      {
	if (args == sc->F)
	  args = set_plist_1(sc, s7_make_string_wrapper(sc, name)); /* was list_1(sc, make_string(sc, name)) 16-Nov-18 */
	/* args is GC protected by s7_apply_function?? (placed on the stack) */
	value = s7_apply_function(sc, cdar(reader), args); /* this is much less error-safe than s7_call */
	if (value != sc->F)
	  break;
      }
  if (need_loader_port)
    set_loader_port(sc->input_port);
  return(value);
}

static s7_pointer g_sharp_readers_set(s7_scheme *sc, s7_pointer args)
{
  /* new value must be either () or a proper list of conses (char . func) */
  if (is_null(cadr(args))) return(cadr(args));
  if (is_pair(cadr(args)))
    {
      s7_pointer x;
      for (x = cadr(args); is_pair(x); x = cdr(x))
	if ((!is_pair(car(x))) ||
	    (!s7_is_character(caar(x))) ||
	    (!s7_is_procedure(cdar(x))))
	  return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *#readers* to ~S", 26), cadr(args))));
      if (is_null(x))
	return(cadr(args));
    }
  return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *#readers* to ~S", 26), cadr(args))));
}

static s7_pointer make_unknown(s7_scheme *sc, const char* name)
{
  s7_pointer p;
  char *newstr;
  s7_int len;
  new_cell(sc, p, T_UNDEFINED | T_IMMUTABLE);
  len = safe_strlen(name);
  newstr = (char *)malloc((len + 2) * sizeof(char)); /* this is a non-permanent unknown */
  newstr[0] = '#';
  if (len > 0)
    memcpy((void *)(newstr + 1), (void *)name, len);
  newstr[len + 1] = '\0';
  if (sc->undefined_constant_warnings)
    s7_warn(sc, len + 32, "%s is undefined\n", newstr);
  unique_name_length(p) = len + 1;
  unknown_name(p) = newstr;
  add_unknown(sc, p);
  return(p);
}

static s7_pointer unknown_sharp_constant(s7_scheme *sc, char *name)
{
  if (hook_has_functions(sc->read_error_hook))  /* check *read-error-hook* */
    {
      s7_pointer result;
      /* see sc->error_hook for a more robust way to handle this */
      result = s7_call(sc, sc->read_error_hook, list_2(sc, sc->T, s7_make_string_wrapper(sc, name)));
      if (result != sc->unspecified)
	return(result);
    }
  return(make_unknown(sc, name));
}

#define SYMBOL_OK true
#define NO_SYMBOLS false
static s7_pointer *chars;

static s7_pointer make_sharp_constant(s7_scheme *sc, char *name, bool with_error)
{
  /* name is the stuff after the '#', return sc->nil if not a recognized #... entity */

  if ((name[0] == 't') &&
      ((name[1] == '\0') || (strings_are_equal(name, "true"))))
    return(sc->T);

  if ((name[0] == 'f') &&
      ((name[1] == '\0') || (strings_are_equal(name, "false"))))
    return(sc->F);

  if (is_not_null(slot_value(sc->sharp_readers)))
    {
      s7_pointer x;
      x = check_sharp_readers(sc, name);
      if (x != sc->F)
	return(x);
    }

  if ((name[0] == '\0') || name[1] == '\0')
    return(unknown_sharp_constant(sc, name));

  switch (name[0])
    {
      /* -------- #< ... > -------- */
    case '<':
      if (strings_are_equal(name, "<unspecified>"))
	return(sc->unspecified);

      if (strings_are_equal(name, "<undefined>"))
	return(sc->undefined);

      if (strings_are_equal(name, "<eof>"))
	return(eof_object);

      return(unknown_sharp_constant(sc, name));

      /* -------- #o #x #b -------- */
    case 'o':   /* #o (octal) */
    case 'x':   /* #x (hex) */
    case 'b':   /* #b (binary) */
      return(make_atom(sc, (char *)(name + 1), (name[0] == 'o') ? 8 : ((name[0] == 'x') ? 16 : 2), NO_SYMBOLS, with_error));

      /* -------- #_... -------- */
    case '_':
      {
	s7_pointer sym;
	sym = make_symbol(sc, (char *)(name + 1));
	if ((!is_gensym(sym)) && (is_slot(initial_slot(sym))))
	  return(slot_value(initial_slot(sym)));

	/* here we should not necessarily raise an error that *_... is undefined.  reader-cond, for example, needs to
	 *    read undefined #_ vals that it will eventually discard.
	 */
	return(make_unknown(sc, name));    /* (define x (with-input-from-string "(#_asdf 1 2)" read)) (type-of (car x)) -> undefined? */
      }

      /* -------- #\... -------- */
    case '\\':
      if (name[2] == 0)                             /* the most common case: #\a */
	return(chars[(uint8_t)(name[1])]);
      /* not uint32_t here!  (uint32_t)255 (as a char) returns -1!! */
      switch (name[1])
	{
	case 'n':
	  if ((strings_are_equal(name + 1, "null")) ||
	      (strings_are_equal(name + 1, "nul")))
	    return(chars[0]);

	  if (strings_are_equal(name + 1, "newline"))
	    return(chars[(uint8_t)'\n']);
	  break;

	case 's': if (strings_are_equal(name + 1, "space"))     return(chars[(uint8_t)' ']);  break;
	case 'r': if (strings_are_equal(name + 1, "return"))    return(chars[(uint8_t)'\r']); break;
	case 'l': if (strings_are_equal(name + 1, "linefeed"))  return(chars[(uint8_t)'\n']); break;
	case 't': if (strings_are_equal(name + 1, "tab"))       return(chars[(uint8_t)'\t']); break;
	case 'a': if (strings_are_equal(name + 1, "alarm"))     return(chars[7]);             break;
	case 'b': if (strings_are_equal(name + 1, "backspace")) return(chars[8]);             break;
	case 'e': if (strings_are_equal(name + 1, "escape"))    return(chars[0x1b]);          break;
	case 'd': if (strings_are_equal(name + 1, "delete"))    return(chars[0x7f]);          break;

	case 'x':
	  /* #\x is just x, but apparently #\x<num> is int->char? #\x65 -> #\e, and #\xcebb is lambda? */
	  {
	    /* sscanf here misses errors like #\x1.4, but make_atom misses #\x6/3,
	     *   #\x#b0, #\x#e0.0, #\x-0, #\x#e0e100 etc, so we have to do it at an even lower level.
	     * another problem: #\xbdca2cbec overflows so lval is -593310740 -> segfault unless caught
	     */
	    bool happy = true;
	    char *tmp;
	    int32_t lval = 0;

	    tmp = (char *)(name + 2);
	    while ((*tmp) && (happy) && (lval >= 0) && (lval < 256))
	      {
		int32_t dig;
		dig = digits[(int32_t)(*tmp++)];
		if (dig < 16)
		  lval = dig + (lval * 16);
		else happy = false;
	      }
	    if ((happy) &&
		(lval < 256) &&
		(lval >= 0))
	      return(chars[lval]);
	  }
	  break;
	}
    }
  return(unknown_sharp_constant(sc, name));
}

static s7_int string_to_integer(const char *str, int32_t radix, bool *overflow)
{
  bool negative = false;
  s7_int lval = 0;
  int32_t dig;
  char *tmp = (char *)str;
#if WITH_GMP
  char *tmp1;
#endif

  if (str[0] == '+')
    tmp++;
  else
    {
      if (str[0] == '-')
	{
	  negative = true;
	  tmp++;
	}
    }
  while (*tmp == '0') {tmp++;};
#if WITH_GMP
  tmp1 = tmp;
#endif

 if (radix == 10)
    {
      while (true)
	{
	  dig = digits[(uint8_t)(*tmp++)];
	  if (dig > 9) break;
#if HAVE_OVERFLOW_CHECKS
	  if ((multiply_overflow(lval, (s7_int)10, &lval)) ||
	      (add_overflow(lval, (s7_int)dig, &lval)))
	    {
	      if ((lval == s7_int_min) && (digits[(uint8_t)(*tmp++)] > 9))
		return(lval);
	      *overflow = true;
	      break;
	    }
#else
	  lval = dig + (lval * 10);
	  dig = digits[(uint8_t)(*tmp++)];
	  if (dig > 9) break;
	  lval = dig + (lval * 10);
#endif
	}
    }
  else
    {
      while (true)
	{
	  dig = digits[(uint8_t)(*tmp++)];
	  if (dig >= radix) break;
#if HAVE_OVERFLOW_CHECKS && (!WITH_GMP)
	  {
	    s7_int oval = 0;
	    if (multiply_overflow(lval, (s7_int)radix, &oval))
	      {
		/* maybe a bad idea!  #xffffffffffffffff -> -1??? this is needed for 64-bit number hacks (see s7test.scm bit-reverse) */
		if ((radix == 16) &&
		    (digits[(uint8_t)(*tmp)] >= radix))
		  {
		    lval -= 576460752303423488LL; /* turn off sign bit */
		    lval *= radix;
		    lval += dig;
		    lval -= 9223372036854775807LL;
		    return(lval - 1);
		  }
		lval = oval; /* old case */
		if ((lval == s7_int_min)  && (digits[(uint8_t)(*tmp++)] > 9))
		  return(lval);
		*overflow = true;
		break;
	      }
	    else lval = oval;
	    if (add_overflow(lval, (s7_int)dig, &lval))
	      {
		if (lval == s7_int_min) return(lval);
		*overflow = true;
		break;
	      }
	  }
#else
	  lval = dig + (lval * radix);
	  dig = digits[(uint8_t)(*tmp++)];
	  if (dig >= radix) break;
	  lval = dig + (lval * radix);
#endif
	}
    }

#if WITH_GMP
  (*overflow) = ((lval > s7_int32_max) ||
		 ((tmp - tmp1) > s7_int_digits_by_radix[radix]));
  /* this tells the string->number readers to create a bignum.  We need to be very
   *    conservative here to catch contexts such as (/ 1/524288 19073486328125)
   */
#endif

  if (negative) return(-lval);
  return(lval);
}

/*  9223372036854775807                9223372036854775807
 * -9223372036854775808               -9223372036854775808
 * 0000000000000000000000000001.0     1.0
 * 1.0000000000000000000000000000     1.0
 * 1000000000000000000000000000.0e-40 1.0e-12
 * 0.0000000000000000000000000001e40  1.0e12
 * 1.0e00000000000000000001           10.0
 */

#if WITH_GMP
static s7_double string_to_double_with_radix(const char *ur_str, int32_t radix, bool *overflow)
#else
#define string_to_double_with_radix(Str, Rad, Over) string_to_double_with_radix_1(Str, Rad)
static s7_double string_to_double_with_radix_1(const char *ur_str, int32_t radix)
#endif
{
  /* strtod follows LANG which is not what we want (only "." is decimal point in Scheme).
   *   To overcome LANG in strtod would require screwing around with setlocale which never works.
   *   So we use our own code -- according to valgrind, this function is much faster than strtod.
   * comma as decimal point causes ambiguities: `(+ ,1 2) etc
   */

  int32_t i, sign = 1, frac_len, int_len, dig, max_len, exponent = 0;
  int64_t int_part = 0, frac_part = 0;
  char *str;
  char *ipart, *fpart;
  s7_double dval = 0.0;

  /* there's an ambiguity in number notation here if we allow "1e1" or "1.e1" in base 16 (or 15) -- is e a digit or an exponent marker?
   *   but 1e+1, for example disambiguates it -- kind of messy! -- the scheme spec says "e" can only occur in base 10.
   * '@' can now be used as the exponent marker (26-Mar-12).
   * Another slight ambiguity: 1+1/2i is parsed as 1 + 0.5i, not 1+1/(2i), or (1+1)/(2i) or (1+1/2)i etc
   */

  max_len = s7_int_digits_by_radix[radix];
  str = (char *)ur_str;

  if (*str == '+')
    str++;
  else
    {
      if (*str == '-')
	{
	  str++;
	  sign = -1;
	}
    }
  while (*str == '0') {str++;};

  ipart = str;
  while (digits[(int32_t)(*str)] < radix) str++;
  int_len = str - ipart;

  if (*str == '.') str++;
  fpart = str;
  while (digits[(int32_t)(*str)] < radix) str++;
  frac_len = str - fpart;

  if ((*str) && (exponent_table[(uint8_t)(*str)]))
    {
      int32_t exp_negative = false;
      str++;
      if (*str == '+')
	str++;
      else
	{
	  if (*str == '-')
	    {
	      str++;
	      exp_negative = true;
	    }
	}
      while ((dig = digits[(int32_t)(*str++)]) < 10) /* exponent itself is always base 10 */
	{
#if HAVE_OVERFLOW_CHECKS
	  if ((int32_multiply_overflow(exponent, 10, &exponent)) ||
	      (int32_add_overflow(exponent, dig, &exponent)))
	    {
	      exponent = 1000000; /* see below */
	      break;
	    }
#else
	  exponent = dig + (exponent * 10);
#endif
	}
#if (!defined(__GNUC__)) || (__GNUC__ < 5)
      if (exponent < 0)         /* we overflowed, so make sure we notice it below (need to check for 0.0e... first) (Brian Damgaard) */
	exponent = 1000000;     /*   see below for examples -- this number needs to be very big but not too big for add */
#endif
      if (exp_negative)
	exponent = -exponent;

      /*           2e12341234123123123123213123123123 -> 0.0
       * but exp len is not the decider: 2e00000000000000000000000000000000000000001 -> 20.0
       * first zero: 2e123412341231231231231
       * then:     2e12341234123123123123123123 -> inf
       * then:     2e123412341231231231231231231231231231 -> 0.0
       *           2e-123412341231231231231 -> inf
       * but:      0e123412341231231231231231231231231231
       */
    }

#if WITH_GMP
  /* 9007199254740995.0 */
  if (int_len + frac_len >= max_len)
    {
      (*overflow) = true;
      return(0.0);
    }
#endif

  str = ipart;
  if ((int_len + exponent) > max_len)
    {
      /*  12341234.56789e12                   12341234567889999872.0              1.234123456789e+19
       * -1234567890123456789.0              -1234567890123456768.0              -1.2345678901235e+18
       *  12345678901234567890.0              12345678901234567168.0              1.2345678901235e+19
       *  123.456e30                          123456000000000012741097792995328.0 1.23456e+32
       *  12345678901234567890.0e12           12345678901234569054409354903552.0  1.2345678901235e+31
       *  1.234567890123456789012e30          1234567890123456849145940148224.0   1.2345678901235e+30
       *  1e20                                100000000000000000000.0             1e+20
       *  1234567890123456789.0               1234567890123456768.0               1.2345678901235e+18
       *  123.456e16                          1234560000000000000.0               1.23456e+18
       *  98765432101234567890987654321.0e-5  987654321012345728401408.0          9.8765432101235e+23
       *  98765432101234567890987654321.0e-10 9876543210123456512.0               9.8765432101235e+18
       *  0.00000000000000001234e20           1234.0
       *  0.000000000000000000000000001234e30 1234.0
       *  0.0000000000000000000000000000000000001234e40 1234.0
       *  0.000000000012345678909876543210e15 12345.678909877
       *  0e1000                              0.0
       */

      for (i = 0; i < max_len; i++)
	{
	  dig = digits[(int32_t)(*str++)];
	  if (dig < radix)
	    int_part = dig + (int_part * radix);
	  else break;
	}

      /* if the exponent is huge, check for 0 int_part and frac_part before complaining (0e1000 or 0.0e1000)
       */
      if ((int_part == 0) &&
	  (exponent > max_len))
	{
	  /* if frac_part is also 0, return 0.0 */
	  if (frac_len == 0)
	    return(0.0);

	  str = fpart;
	  while ((dig = digits[(int32_t)(*str++)]) < radix)
	    frac_part = dig + (frac_part * radix);
	  if (frac_part == 0)
	    return(0.0);

#if WITH_GMP
	  (*overflow) = true;
#endif
	}

#if WITH_GMP
      (*overflow) = ((int_part > 0) || (exponent > 20));    /* .1e310 is a tricky case */
#endif

      if (int_part != 0) /* 0.<310 zeros here>1e310 for example --
			  *   pow (via ipow) thinks it has to be too big, returns Nan,
			  *   then Nan * 0 -> Nan and the NaN propagates
			  */
	{
	  if (int_len <= max_len)
	    dval = int_part * ipow(radix, exponent);
	  else dval = int_part * ipow(radix, exponent + int_len - max_len);
	}
      else dval = 0.0;

      /* shift by exponent, but if int_len > max_len then we assumed (see below) int_len - max_len 0's on the left */
      /*   using int_to_int or table lookups here instead of pow did not make any difference in speed */

      if (int_len < max_len)
	{
	  int32_t k, flen;
	  str = fpart;

	  for (k = 0; (frac_len > 0) && (k < exponent); k += max_len)
	    {
	      if (frac_len > max_len) flen = max_len; else flen = frac_len;
	      frac_len -= max_len;

	      frac_part = 0;
	      for (i = 0; i < flen; i++)
		frac_part = digits[(int32_t)(*str++)] + (frac_part * radix);

	      if (frac_part != 0)                                /* same pow->NaN problem as above can occur here */
		dval += frac_part * ipow(radix, exponent - flen - k);
	    }
	}
      else
	{
	  /* some of the fraction is in the integer part before the negative exponent shifts it over */
	  if (int_len > max_len)
	    {
	      int32_t ilen;
	      /* str should be at the last digit we read */
	      ilen = int_len - max_len;                          /* we read these above */
	      if (ilen > max_len)
		ilen = max_len;

	      for (i = 0; i < ilen; i++)
		frac_part = digits[(int32_t)(*str++)] + (frac_part * radix);

	      dval += frac_part * ipow(radix, exponent - ilen);
	    }
	}

      return(sign * dval);
    }

  /* int_len + exponent <= max_len */

  if (int_len <= max_len)
    {
      int32_t int_exponent;

      /* a better algorithm (since the inaccuracies are in the radix^exponent portion):
       *   strip off leading zeros and possible sign,
       *   strip off digits beyond max_len, then remove any trailing zeros.
       *     (maybe fiddle with the lowest order digit here for rounding, but I doubt it matters)
       *   read digits until end of number or max_len reached, ignoring the decimal point
       *   get exponent and use it and decimal point location to position the current result integer
       * this always combines the same integer and the same exponent no matter how the number is expressed.
       */

      int_exponent = exponent;
      if (int_len > 0)
	{
	  char *iend;
	  iend = (char *)(str + int_len - 1);
	  while ((*iend == '0') && (iend != str)) {iend--; int_exponent++;}

	  while (str <= iend)
	    int_part = digits[(int32_t)(*str++)] + (int_part * radix);
	}
      if (int_exponent != 0)
	dval = int_part * ipow(radix, int_exponent);
      else dval = (s7_double)int_part;
    }
  else
    {
      int32_t len, flen;
      int64_t frpart = 0;

      /* 98765432101234567890987654321.0e-20    987654321.012346
       * 98765432101234567890987654321.0e-29    0.98765432101235
       * 98765432101234567890987654321.0e-30    0.098765432101235
       * 98765432101234567890987654321.0e-28    9.8765432101235
       */

      len = int_len + exponent;
      for (i = 0; i < len; i++)
	int_part = digits[(int32_t)(*str++)] + (int_part * radix);

      flen = -exponent;
      if (flen > max_len)
	flen = max_len;

      for (i = 0; i < flen; i++)
	frpart = digits[(int32_t)(*str++)] + (frpart * radix);

      if (len <= 0)
	dval = int_part + frpart * ipow(radix, len - flen);
      else dval = int_part + frpart * ipow(radix, -flen);
    }

  if (frac_len > 0)
    {
      str = fpart;
      if (frac_len <= max_len)
	{
	  /* splitting out base 10 case saves very little here */
	  /* this ignores trailing zeros, so that 0.3 equals 0.300 */
	  char *fend;

	  fend = (char *)(str + frac_len - 1);
	  while ((*fend == '0') && (fend != str)) {fend--; frac_len--;} /* (= .6 0.6000) */

	  if ((frac_len & 1) == 0)
	    {
	      while (str <= fend)
		{
		  frac_part = digits[(int32_t)(*str++)] + (frac_part * radix);
		  frac_part = digits[(int32_t)(*str++)] + (frac_part * radix);
		}
	    }
	  else
	    {
	      while (str <= fend)
		frac_part = digits[(int32_t)(*str++)] + (frac_part * radix);
	    }
	  dval += frac_part * ipow(radix, exponent - frac_len);

	  /* 0.6:    frac:    6, exp: 0.10000000000000000555, val: 0.60000000000000008882
	   * 0.60:   frac:   60, exp: 0.01000000000000000021, val: 0.59999999999999997780
	   * 0.6000: frac: 6000, exp: 0.00010000000000000000, val: 0.59999999999999997780
	   * (= 0.6 0.60): #f
	   * (= #i3/5 0.6): #f
	   * so (string->number (number->string num)) == num only if both num's are the same text (or you get lucky)
	   * (= 0.6 6e-1): #t ; but not 60e-2
	   * to fix the 0.60 case, we need to ignore trailing post-dot zeros.
	   */
	}
      else
	{
	  if (exponent <= 0)
	    {
	      for (i = 0; i < max_len; i++)
		frac_part = digits[(int32_t)(*str++)] + (frac_part * radix);

	      dval += frac_part * ipow(radix, exponent - max_len);
	    }
	  else
	    {
	      /* 1.0123456789876543210e1         10.12345678987654373771
	       * 1.0123456789876543210e10        10123456789.87654304504394531250
	       * 0.000000010000000000000000e10   100.0
	       * 0.000000010000000000000000000000000000000000000e10 100.0
	       * 0.000000012222222222222222222222222222222222222e10 122.22222222222222
	       * 0.000000012222222222222222222222222222222222222e17 1222222222.222222
	       */

	      int_part = 0;
	      for (i = 0; i < exponent; i++)
		int_part = digits[(int32_t)(*str++)] + (int_part * radix);

	      frac_len -= exponent;
	      if (frac_len > max_len)
		frac_len = max_len;

	      for (i = 0; i < frac_len; i++)
		frac_part = digits[(int32_t)(*str++)] + (frac_part * radix);

	      dval += int_part + frac_part * ipow(radix, -frac_len);
	    }
	}
    }

#if WITH_GMP
  if ((int_part == 0) &&
      (frac_part == 0))
    return(0.0);
  (*overflow) = ((frac_len - exponent) > max_len);
#endif

  return(sign * dval);
}

static s7_pointer nan1_or_bust(s7_scheme *sc, s7_double x, char *p, char *q, int32_t radix, bool want_symbol)
{
  s7_int len;
  len = safe_strlen(p);
  if (p[len - 1] == 'i')        /* +nan.0[+/-]...i */
    {
      char *ip;
      s7_pointer imag;
      if (len == 6)            /* +nan.0+i */
	return(make_complex(sc, x, (p[4] == '+') ? 1.0 : -1.0));
      ip = copy_string_with_length((const char *)(p + 4), len - 5);
      imag = make_atom(sc, ip, radix, false, false);
      free(ip);
      if (s7_is_real(imag))
	return(make_complex(sc, x, real_to_double(sc, imag, __func__))); /* +nan.0+2/3i etc */
    }
  return((want_symbol) ? make_symbol(sc, q) : sc->F);
}

static s7_pointer nan2_or_bust(s7_scheme *sc, s7_double x, char *p, char *q, int32_t radix, bool want_symbol)
{
  char *ip;
  s7_pointer rl;
  s7_int len;
  len = safe_strlen(q);
  ip = copy_string_with_length((const char *)q, len - 7);
  rl = make_atom(sc, ip, radix, false, false);
  free(ip);
  if (s7_is_real(rl))
    return(make_complex(sc, real_to_double(sc, rl, __func__), x));
  return((want_symbol) ? make_symbol(sc, q) : sc->F);
}

static s7_pointer make_atom(s7_scheme *sc, char *q, int32_t radix, bool want_symbol, bool with_error)
{
  /* make symbol or number from string */
  #define IS_DIGIT(Chr, Rad) (digits[(uint8_t)Chr] < Rad)

  char c, *p;
  bool has_dec_point1 = false;

  p = q;
  c = *p++;

  /* a number starts with + - . or digit, but so does 1+ for example (and there's also nan.0 and inf.0) */

  switch (c)
    {
    case '#':
      return(make_sharp_constant(sc, p, with_error)); /* make_sharp_constant expects the '#' to be removed */

    case '+':
    case '-':
      c = *p++;
      if (c == '.')
	{
	  has_dec_point1 = true;
	  c = *p++;
	}
      if (!c)
	return((want_symbol) ? make_symbol(sc, q) : sc->F);
      if (!IS_DIGIT(c, radix))
	{
	  if (has_dec_point1)
	    return((want_symbol) ? make_symbol(sc, q) : sc->F);
	  if (c == 'n')
	    {
	      if (local_strcmp(p, "an.0"))      /* +nan.0 */
		return(real_NaN);
	      if ((local_strncmp(p, "an.0", 4)) &&
		  ((p[4] == '+') || (p[4] == '-')))
		return(nan1_or_bust(sc, NAN, p, q, radix, want_symbol));
	    }
	  if (c == 'i')
	    {
	      if (local_strcmp(p, "nf.0"))  /* +inf.0 */
		return((q[0] == '+') ? real_infinity : real_minus_infinity);
	      if ((local_strncmp(p, "nf.0", 4)) &&
		  ((p[4] == '+') || (p[4] == '-')))
		return(nan1_or_bust(sc, (q[0] == '-') ? -INFINITY : INFINITY, p, q, radix, want_symbol));
	    }
	  return((want_symbol) ? make_symbol(sc, q) : sc->F);
	}
      break;

    case '.':
      has_dec_point1 = true;
      c = *p++;

      if ((!c) || (!IS_DIGIT(c, radix)))
	return((want_symbol) ? make_symbol(sc, q) : sc->F);
      break;

    case 'n':
      if (local_strcmp(p, "an.0"))      /* nan.0 */
	return(real_NaN);
      return((want_symbol) ? make_symbol(sc, q) : sc->F);

    case 'i':
      if (local_strcmp(p, "nf.0"))      /* inf.0 */
	return(real_infinity);
      return((want_symbol) ? make_symbol(sc, q) : sc->F);

    case '0':        /* these two are always digits */
    case '1':
      break;

    default:
      if (!IS_DIGIT(c, radix))
	return((want_symbol) ? make_symbol(sc, q) : sc->F);
      break;
    }

  /* now it's possibly a number -- the first character(s) could be part of a number in the current radix */
  {
    char *slash1 = NULL, *slash2 = NULL, *plus = NULL, *ex1 = NULL, *ex2 = NULL;
    bool has_i = false, has_dec_point2 = false;
    int32_t has_plus_or_minus = 0, current_radix;
#if (!WITH_GMP)
    bool overflow = false; /* for string_to_integer */
#endif
    current_radix = radix;  /* current_radix is 10 for the exponent portions, but radix for all the rest */

    for ( ; (c = *p) != 0; ++p)
      {
	/* what about embedded null? (string->number (string #\1 (integer->char 0) #\0))
	 *   currently we stop and return 1, but Guile returns #f
	 */
	if (!IS_DIGIT(c, current_radix))         /* moving this inside the switch statement was much slower */
	  {
	    current_radix = radix;

	    switch (c)
	      {
		/* -------- decimal point -------- */
	      case '.':
		if ((!IS_DIGIT(p[1], current_radix)) &&
		    (!IS_DIGIT(p[-1], current_radix)))
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		if (has_plus_or_minus == 0)
		  {
		    if ((has_dec_point1) || (slash1))
		      return((want_symbol) ? make_symbol(sc, q) : sc->F);
		    has_dec_point1 = true;
		  }
		else
		  {
		    if ((has_dec_point2) || (slash2))
		      return((want_symbol) ? make_symbol(sc, q) : sc->F);
		    has_dec_point2 = true;
		  }
		continue;

		/* -------- exponent marker -------- */
#if WITH_EXTRA_EXPONENT_MARKERS
		/* 1st 3d-perspective 0.0f 128.0f 3d 1s -- in 2 million lines of public scheme code, not one actual use! */
	      case 's': case 'S':
	      case 'd': case 'D':
	      case 'f': case 'F':
	      case 'l': case 'L':
#endif
	      case 'e': case 'E':
		if (current_radix > 10) /* see above */
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);
		/* fall through -- if '@' used, radices>10 are ok */

	      case '@':
		current_radix = 10;

		if (((ex1) ||
		     (slash1)) &&
		    (has_plus_or_minus == 0)) /* ee */
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		if (((ex2) ||
		     (slash2)) &&
		    (has_plus_or_minus != 0)) /* 1+1.0ee */
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		if ((!IS_DIGIT(p[-1], radix)) && /* was current_radix but that's always 10! */
		    (p[-1] != '.'))
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		if (has_plus_or_minus == 0)
		  {
		    ex1 = p;
		    has_dec_point1 = true; /* decimal point illegal from now on */
		  }
		else
		  {
		    ex2 = p;
		    has_dec_point2 = true;
		  }
		p++;
		if ((*p == '-') || (*p == '+')) p++;
		if (IS_DIGIT(*p, current_radix))
		  continue;
		break;

		/* -------- internal + or - -------- */
	      case '+':
	      case '-':
		if (has_plus_or_minus != 0) /* already have the separator */
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		if (c == '+') has_plus_or_minus = 1; else has_plus_or_minus = -1;
		plus = (char *)(p + 1);
		/* now check for nan/inf as imaginary part */

		if ((plus[0] == 'n') &&
		    (local_strcmp(plus, "nan.0i")))
		  return(nan2_or_bust(sc, NAN, p, q, radix, want_symbol));
		if ((plus[0] == 'i') &&
		    (local_strcmp(plus, "inf.0i")))
		  return(nan2_or_bust(sc, (c == '+') ? INFINITY : -INFINITY, p, q, radix, want_symbol));
		continue;

		/* ratio marker */
	      case '/':
		if ((has_plus_or_minus == 0) &&
		    ((ex1) ||
		     (slash1) ||
		     (has_dec_point1)))
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		if ((has_plus_or_minus != 0) &&
		    ((ex2) ||
		     (slash2) ||
		     (has_dec_point2)))
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		if (has_plus_or_minus == 0)
		  slash1 = (char *)(p + 1);
		else slash2 = (char *)(p + 1);

		if ((!IS_DIGIT(p[1], current_radix)) ||
		    (!IS_DIGIT(p[-1], current_radix)))
		  return((want_symbol) ? make_symbol(sc, q) : sc->F);

		continue;

		/* -------- i for the imaginary part -------- */
	      case 'i':
		if ((has_plus_or_minus != 0) &&
		    (!has_i))
		  {
		    has_i = true;
		    continue;
		  }
		break;

	      default:
		break;
	      }
	    return((want_symbol) ? make_symbol(sc, q) : sc->F);
	  }
      }

    if ((has_plus_or_minus != 0) &&        /* that is, we have an internal + or - */
	(!has_i))                          /*   but no i for the imaginary part */
      return((want_symbol) ? make_symbol(sc, q) : sc->F);

    if (has_i)
      {
#if (!WITH_GMP)
	s7_double rl = 0.0, im = 0.0;
#else
	char e1 = 0, e2 = 0;
#endif
	s7_pointer result;
	s7_int len;
	char ql1, pl1;

	len = safe_strlen(q);

	if (q[len - 1] != 'i')
	  return((want_symbol) ? make_symbol(sc, q) : sc->F);

	/* save original string */
	ql1 = q[len - 1];
	pl1 = (*(plus - 1));
#if WITH_GMP
	if (ex1) {e1 = *ex1; (*ex1) = '@';} /* for mpfr */
	if (ex2) {e2 = *ex2; (*ex2) = '@';}
#endif

	/* look for cases like 1+i */
	if ((q[len - 2] == '+') || (q[len - 2] == '-'))
	  q[len - 1] = '1';
	else q[len - 1] = '\0'; /* remove 'i' */

	(*((char *)(plus - 1))) = '\0';

#if (!WITH_GMP)
	if ((has_dec_point1) ||
	    (ex1))
	  {
	    /* (string->number "1100.1+0.11i" 2) -- need to split into 2 honest reals before passing to non-base-10 str->dbl */
	    rl = string_to_double_with_radix(q, radix, ignored);
	  }
	else
	  {
	    if (slash1)
	      {
		/* here the overflow could be innocuous if it's in the denominator and the numerator is 0
		 *    0/100000000000000000000000000000000000000-0i
		 */
		s7_int num, den;
		num = string_to_integer(q, radix, &overflow);
		den = string_to_integer(slash1, radix, &overflow);
		if (den == 0)
		  rl = NAN;
		else
		  {
		    if (num == 0)
		      {
			rl = 0.0;
			overflow = false;
		      }
		    else rl = (s7_double)num / (s7_double)den;
		  }
	      }
	    else rl = (s7_double)string_to_integer(q, radix, &overflow);
	    if (overflow) return(real_NaN);
	  }
	if (rl == -0.0) rl = 0.0;

	if ((has_dec_point2) ||
	    (ex2))
	  im = string_to_double_with_radix(plus, radix, ignored);
	else
	  {
	    if (slash2)
	      {
		/* same as above: 0-0/100000000000000000000000000000000000000i */
		s7_int num, den;
		num = string_to_integer(plus, radix, &overflow);
		den = string_to_integer(slash2, radix, &overflow);
		if (den == 0)
		  im = NAN;
		else
		  {
		    if (num == 0)
		      {
			im = 0.0;
			overflow = false;
		      }
		    else im = (s7_double)num / (s7_double)den;
		  }
	      }
	    else im = (s7_double)string_to_integer(plus, radix, &overflow);
	    if (overflow) return(real_NaN);
	  }
	if ((has_plus_or_minus == -1) &&
	    (im != 0.0))
	  im = -im;
	result = s7_make_complex(sc, rl, im);
#else
	result = string_to_either_complex(sc, q, slash1, ex1, has_dec_point1, plus, slash2, ex2, has_dec_point2, radix, has_plus_or_minus);
#endif

	/* restore original string */
	q[len - 1] = ql1;
	(*((char *)(plus - 1))) = pl1;
#if WITH_GMP
	if (ex1) (*ex1) = e1;
	if (ex2) (*ex2) = e2;
#endif
	return(result);
      }

    /* not complex */
    if ((has_dec_point1) ||
	(ex1))
      {
	s7_pointer result;

	if (slash1)  /* not complex, so slash and "." is not a number */
	  return((want_symbol) ? make_symbol(sc, q) : sc->F);

#if (!WITH_GMP)
	result = make_real(sc, string_to_double_with_radix(q, radix, ignored));
#else
	{
	  char old_e = 0;
	  if (ex1)
	    {
	      old_e = (*ex1);
	      (*ex1) = '@';
	    }
	  result = string_to_either_real(sc, q, radix);
	  if (ex1)
	    (*ex1) = old_e;
	}
#endif
	return(result);
      }

    /* not real */
    if (slash1)
#if (!WITH_GMP)
      {
	s7_int n, d;

	n = string_to_integer(q, radix, &overflow);
	d = string_to_integer(slash1, radix, &overflow);

	if ((n == 0) && (d != 0))                        /* 0/100000000000000000000000000000000000000 */
	  return(small_int(0));
	if ((d == 0) || (overflow))
	  return(real_NaN);
	/* it would be neat to return 1 from 10000000000000000000000000000/10000000000000000000000000000
	 *   but q is the entire number ('/' included) and slash1 is the stuff after the '/', and every
	 *   big number comes through here, so there's no clean and safe way to check that q == slash1.
	 */
	return(s7_make_ratio(sc, n, d));
      }
#else
    return(string_to_either_ratio(sc, q, slash1, radix));
#endif

    /* integer */
#if (!WITH_GMP)
    {
      s7_int x;
      x = string_to_integer(q, radix, &overflow);
      if (overflow)
	return((q[0] == '-') ? real_minus_infinity : real_infinity);
      return(make_integer(sc, x));
    }
#else
    return(string_to_either_integer(sc, q, radix));
#endif
  }
}


/* -------------------------------- string->number -------------------------------- */

static s7_pointer string_to_number(s7_scheme *sc, char *str, int32_t radix)
{
  s7_pointer x;
  x = make_atom(sc, str, radix, NO_SYMBOLS, WITHOUT_OVERFLOW_ERROR);
  if (s7_is_number(x))  /* only needed because str might start with '#' and not be a number (#t for example) */
    return(x);
  return(sc->F);
}

#if (!WITH_GMP)
static s7_pointer string_to_number_p_pp(s7_scheme *sc, s7_pointer str1, s7_pointer radix1)
{
  s7_int radix;
  char *str;

  if (!is_string(str1))
    return(wrong_type_argument(sc, sc->string_to_number_symbol, 1, str1, T_STRING));

  if (!is_t_integer(radix1))
    return(wrong_type_argument(sc, sc->string_to_number_symbol, 2, radix1, T_INTEGER));
  radix = s7_integer(radix1);
  if ((radix < 2) || (radix > 16))
    return(out_of_range(sc, sc->string_to_number_symbol, small_int(2), radix1, a_valid_radix_string));

  str = (char *)string_value(str1);
  if ((!str) || (!(*str)))
    return(sc->F);

  return(string_to_number(sc, str, radix));
}
#endif

static s7_pointer g_string_to_number_1(s7_scheme *sc, s7_pointer args, s7_pointer caller)
{
  s7_int radix;
  char *str;

  if (!is_string(car(args)))
    return(method_or_bust(sc, car(args), caller, args, T_STRING, 1));

  if (is_pair(cdr(args)))
    {
      s7_pointer rad;
      rad = cadr(args);
      if (!s7_is_integer(rad))
	return(method_or_bust(sc, rad, caller, args, T_INTEGER, 2));
      radix = s7_integer(rad);
      if ((radix < 2) || (radix > 16)) 
	return(out_of_range(sc, caller, small_int(2), rad, a_valid_radix_string));
    }
  else radix = 10;
  str = (char *)string_value(car(args));
  if ((!str) || (!(*str)))
    return(sc->F);

  return(string_to_number(sc, str, radix));
}

static s7_pointer g_string_to_number(s7_scheme *sc, s7_pointer args)
{
  #define H_string_to_number "(string->number str (radix 10)) converts str into a number. \
If str does not represent a number, string->number returns #f.  If 'str' has an embedded radix, \
the optional 'radix' argument is ignored: (string->number \"#x11\" 2) -> 17 not 3."
  #define Q_string_to_number s7_make_signature(sc, 3, s7_make_signature(sc, 2, sc->is_number_symbol, sc->not_symbol), sc->is_string_symbol, sc->is_integer_symbol)

  return(g_string_to_number_1(sc, args, sc->string_to_number_symbol));
}


/* -------------------------------- abs -------------------------------- */
static bool is_rational_via_method(s7_scheme *sc, s7_pointer p) /* used in gmp as well as below */
{
  if (s7_is_rational(p))
    return(true);
  if (has_active_methods(sc, p))
    {
      s7_pointer f;
      f = find_method(sc, find_let(sc, p), sc->is_rational_symbol);
      if (f != sc->undefined)
	return(is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil))));
    }
  return(false);
}

#if (!WITH_GMP)
static s7_pointer g_abs(s7_scheme *sc, s7_pointer args)
{
  #define H_abs "(abs x) returns the absolute value of the real number x"
  #define Q_abs s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_real_symbol)

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) < 0)
	{
	  if (integer(x) == s7_int_min)
	    return(make_integer(sc, s7_int_max));
	  return(make_integer(sc, -integer(x)));
	}
      return(x);

    case T_RATIO:
      if (numerator(x) < 0)
	{
	  if (numerator(x) == s7_int_min)
	    return(s7_make_ratio(sc, s7_int_max, denominator(x)));
	  return(make_simple_ratio(sc, -numerator(x), denominator(x)));
	}
      return(x);

    case T_REAL:
      if (is_NaN(real(x)))                  /* (abs -nan.0) -> +nan.0, not -nan.0 */
	return(real_NaN);
      if (real(x) < 0.0)
	return(make_real(sc, -real(x)));
      return(x);

    default:
      return(method_or_bust_one_arg(sc, x, sc->abs_symbol, args, T_REAL));
    }
}

static s7_double abs_d_d(s7_double x) {return((x < 0.0) ? (-x) : x);}
static s7_int abs_i_i(s7_int x) {return((x < 0.0) ? (-x) : x);}


/* -------------------------------- magnitude -------------------------------- */

static double my_hypot(double x, double y)
{
  /* according to callgrind, this is much faster than libc's hypot */
  if (x == 0.0) return(fabs(y));
  if (y == 0.0) return(fabs(x));
  if (x == y) return(1.414213562373095 * fabs(x));
  if ((is_NaN(x)) || (is_NaN(y))) return(NAN);
  return(sqrt(x * x + y * y));
}

static s7_pointer g_magnitude(s7_scheme *sc, s7_pointer args)
{
  #define H_magnitude "(magnitude z) returns the magnitude of z"
  #define Q_magnitude s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_number_symbol)
  s7_pointer x;
  x = car(args);

  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == s7_int_min)
	return(make_integer(sc, s7_int_max));
      /* (magnitude -9223372036854775808) -> -9223372036854775808
       *   same thing happens in abs, lcm and gcd: (gcd -9223372036854775808) -> -9223372036854775808
       */
      if (integer(x) < 0)
        return(make_integer(sc, -integer(x)));
      return(x);

    case T_RATIO:
      if (numerator(x) < 0)
	return(make_simple_ratio(sc, -numerator(x), denominator(x)));
      return(x);

    case T_REAL:
      if (is_NaN(real(x)))                 /* (magnitude -nan.0) -> +nan.0, not -nan.0 */
	return(real_NaN);
      if (real(x) < 0.0)
	return(make_real(sc, -real(x)));
      return(x);

    case T_COMPLEX:
      return(make_real(sc, my_hypot(imag_part(x), real_part(x))));

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->magnitude_symbol, args, a_number_string));
    }
}


/* -------------------------------- rationalize -------------------------------- */
static s7_pointer g_rationalize(s7_scheme *sc, s7_pointer args)
{
  #define H_rationalize "(rationalize x err) returns the ratio with smallest denominator within err of x"
  #define Q_rationalize s7_make_signature(sc, 3, sc->is_rational_symbol, sc->is_real_symbol, sc->is_real_symbol)
  /* I can't find a case where this returns a non-rational result */

  s7_double err;
  s7_pointer x;

  x = car(args);
  if (!s7_is_real(x))
    return(method_or_bust(sc, x, sc->rationalize_symbol, args, T_REAL, 1));

  if (is_not_null(cdr(args)))
    {
      s7_pointer ex;
      ex = cadr(args);
      if (!s7_is_real(ex))
	return(method_or_bust(sc, ex, sc->rationalize_symbol, args, T_REAL, 2));

      err = real_to_double(sc, ex, "rationalize");
      if (is_NaN(err))
	return(out_of_range(sc, sc->rationalize_symbol, small_int(2), cadr(args), its_nan_string));
      if (err < 0.0) err = -err;
    }
  else err = sc->default_rationalize_error;

  switch (type(x))
    {
    case T_INTEGER:
      {
	s7_int a, b, pa;
	if (err < 1.0) return(x);
	a = s7_integer(x);
	if (a < 0) pa = -a; else pa = a;
	if (err >= pa) return(small_int(0));
	b = (s7_int)err;
	pa -= b;
	if (a < 0)
	  return(make_integer(sc, -pa));
	return(make_integer(sc, pa));
      }

    case T_RATIO:
      if (err == 0.0)
	return(x);

    case T_REAL:
      {
	s7_double rat;
	s7_int numer = 0, denom = 1;

	rat = s7_real(x); /* possible fall through from above */
	if ((is_NaN(rat)) || (is_inf(rat)))
	  return(out_of_range(sc, sc->rationalize_symbol, small_int(1), x, a_normal_real_string));

	if (err >= fabs(rat))
	  return(small_int(0));

	if ((rat > 9.2233720368548e+18) || (rat < -9.2233720368548e+18))
	  return(out_of_range(sc, sc->rationalize_symbol, small_int(1), x, its_too_large_string));

	if ((fabs(rat) + fabs(err)) < 1.0e-18)
	  err = 1.0e-18;
	/* (/ 1.0 most-positive-fixnum) is 1.0842021e-19, so if we let err be less than that,
	 * (rationalize 1e-19 1e-20) hangs, but this only affects the initial ceiling, I believe.
	 */

	if (fabs(rat) < fabs(err))
	  return(small_int(0));

	if (c_rationalize(rat, err, &numer, &denom))
	  return(s7_make_ratio(sc, numer, denom));
#if S7_DEBUGGING
	fprintf(stderr, "rationalize %s -> #f\n", DISPLAY(args));
#endif
	return(sc->F);
      }
    }
#if S7_DEBUGGING
  fprintf(stderr, "(at end) rationalize %s -> #f\n", DISPLAY(args));
#endif
  return(sc->F); /* make compiler happy */
}

s7_pointer rationalize_p_d(s7_scheme *sc, s7_double x)
{
  if ((is_NaN(x)) || (is_inf(x)))
    return(out_of_range(sc, sc->rationalize_symbol, small_int(1), make_real(sc, x), a_normal_real_string));
  if ((x > 9.2233720368548e+18) || (x < -9.2233720368548e+18))
    return(out_of_range(sc, sc->rationalize_symbol, small_int(1), make_real(sc, x), its_too_large_string));
  return(s7_rationalize(sc, x, sc->default_rationalize_error));
}


/* -------------------------------- angle -------------------------------- */
static s7_pointer g_angle(s7_scheme *sc, s7_pointer args)
{
  #define H_angle "(angle z) returns the angle of z"
  #define Q_angle s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_number_symbol)
  s7_pointer x;
  /* (angle inf+infi) -> 0.78539816339745 ?
   *   I think this should be -pi < ang <= pi
   */

  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) < 0)
	return(real_pi);
      return(small_int(0));

    case T_RATIO:
      if (numerator(x) < 0)
	return(real_pi);
      return(small_int(0));

    case T_REAL:
      if (is_NaN(real(x))) return(x);
      if (real(x) < 0.0)
	return(real_pi);
      return(real_zero);

    case T_COMPLEX:
      return(make_real(sc, atan2(imag_part(x), real_part(x))));

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->angle_symbol, args, a_number_string));
    }
}


/* -------------------------------- make-polar -------------------------------- */
#if (!WITH_PURE_S7)
static s7_pointer g_make_polar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, y;
  s7_double ang, mag;
  #define H_make_polar "(make-polar mag ang) returns a complex number with magnitude mag and angle ang"
  #define Q_make_polar s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_real_symbol, sc->is_real_symbol)

  x = car(args);
  y = cadr(args);

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(x) == 0) return(x);            /* (make-polar 0 1) -> 0 */
	  if (integer(y) == 0) return(x);            /* (make-polar 1 0) -> 1 */
	  mag = (s7_double)integer(x);
	  ang = (s7_double)integer(y);
	  break;

	case T_RATIO:
	  if (integer(x) == 0) return(x);
	  mag = (s7_double)integer(x);
	  ang = (s7_double)fraction(y);
	  break;

	case T_REAL:
	  ang = real(y);
	  if (ang == 0.0) return(x);
	  if (is_NaN(ang)) return(y);
	  if (is_inf(ang)) return(real_NaN);
	  if ((ang == M_PI) || (ang == -M_PI)) return(make_integer(sc, -integer(x)));
	  mag = (s7_double)integer(x);
	  break;

	default:
	  return(method_or_bust(sc, y, sc->make_polar_symbol, args, T_REAL, 2));
	}
      break;

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(y) == 0) return(x);
	  mag = (s7_double)fraction(x);
	  ang = (s7_double)integer(y);
	  break;

	case T_RATIO:
	  mag = (s7_double)fraction(x);
	  ang = (s7_double)fraction(y);
	  break;

	case T_REAL:
	  ang = real(y);
	  if (ang == 0.0) return(x);
	  if (is_NaN(ang)) return(y);
	  if (is_inf(ang)) return(real_NaN);
	  if ((ang == M_PI) || (ang == -M_PI)) return(make_simple_ratio(sc, -numerator(x), denominator(x)));
	  mag = (s7_double)fraction(x);
	  break;

	default:
	  return(method_or_bust(sc, y, sc->make_polar_symbol, args, T_REAL, 2));
	}
      break;

    case T_REAL:
      mag = real(x);
      switch (type(y))
	{
	case T_INTEGER:
	  if (is_NaN(mag)) return(x);
	  if (integer(y) == 0) return(x);
	  ang = (s7_double)integer(y);
	  break;

	case T_RATIO:
	  if (is_NaN(mag)) return(x);
	  ang = (s7_double)fraction(y);
	  break;

	case T_REAL:
	  if (is_NaN(mag)) return(x);
	  ang = real(y);
	  if (ang == 0.0) return(x);
	  if (is_NaN(ang)) return(y);
	  if (is_inf(ang)) return(real_NaN);
	  break;

	default:
	  return(method_or_bust(sc, y, sc->make_polar_symbol, args, T_REAL, 2));
	}
      break;

    default:
      return(method_or_bust(sc, x, sc->make_polar_symbol, args, T_REAL, 1));
    }

  return(s7_make_complex(sc, mag * cos(ang), mag * sin(ang)));

  /* since sin is inaccurate for large arguments, so is make-polar:
   *    (make-polar 1.0 1e40) -> -0.76267273202438+0.64678458842683i, not 8.218988919070239214448025364432557517335E-1-5.696334009536363273080341815735687231337E-1i
   */
}
#endif


/* -------------------------------- complex -------------------------------- */

static s7_pointer c_complex(s7_scheme *sc, s7_double rl, s7_double im)
{
  /* same as s7_make_complex, but assumes im is not 0.0 */
  s7_pointer x;
  new_cell(sc, x, T_COMPLEX);
  set_real_part(x, rl);
  set_imag_part(x, im);
  return(x);
}

static s7_pointer g_complex(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, y;
  #define H_complex "(complex x1 x2) returns a complex number with real-part x1 and imaginary-part x2"
  #define Q_complex s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_real_symbol, sc->is_real_symbol)

  x = car(args);
  y = cadr(args);

  switch (type(y))
    {
    case T_INTEGER:
      switch (type(x))
	{
	case T_INTEGER:
	  if (integer(y) == 0) return(x);
	  return(c_complex(sc, (s7_double)integer(x), (s7_double)integer(y)));

	case T_RATIO:
	  if (integer(y) == 0) return(x);
	  return(c_complex(sc, (s7_double)fraction(x), (s7_double)integer(y)));

	case T_REAL:
	  if (integer(y) == 0) return(x);
	  return(c_complex(sc, real(x), (s7_double)integer(y)));

	default:
	  return(method_or_bust(sc, x, sc->complex_symbol, args, T_REAL, 1));
	}

    case T_RATIO:
      switch (type(x))
	{
	case T_INTEGER: return(c_complex(sc, (s7_double)integer(x), (s7_double)fraction(y)));
	case T_RATIO:   return(c_complex(sc, (s7_double)fraction(x), (s7_double)fraction(y)));
	case T_REAL:    return(c_complex(sc, real(x), (s7_double)fraction(y)));
	default:
	  return(method_or_bust(sc, x, sc->complex_symbol, args, T_REAL, 1));
	}

    case T_REAL:
      switch (type(x))
	{
	case T_INTEGER:
	  if (real(y) == 0.0) return(x);
	  return(c_complex(sc, (s7_double)integer(x), real(y)));

	case T_RATIO:
	  if (real(y) == 0.0) return(x);
	  return(c_complex(sc, (s7_double)fraction(x), real(y)));

	case T_REAL:
	  if (real(y) == 0.0) return(x);
	  return(c_complex(sc, real(x), real(y)));

	default:
	  return(method_or_bust(sc, x, sc->complex_symbol, args, T_REAL, 1));
	}

    default:
      return(method_or_bust(sc, (is_let(x)) ? x : y, sc->complex_symbol, args, T_REAL, 2));
    }
}

static s7_pointer complex_p_ii(s7_scheme *sc, s7_int x, s7_int y)
{
  if (y == 0)
    return(make_integer(sc, x));
  return(c_complex(sc, (s7_double)x, (s7_double)y));
}

static s7_pointer complex_p_dd(s7_scheme *sc, s7_double x, s7_double y)
{
  if (y == 0)
    return(make_real(sc, x));
  return(c_complex(sc, x, y));
}


/* -------------------------------- exp -------------------------------- */
#if (!HAVE_COMPLEX_NUMBERS)
  static s7_pointer no_complex_numbers_string;
#endif

static s7_pointer g_exp(s7_scheme *sc, s7_pointer args)
{
  #define H_exp "(exp z) returns e^z, (exp 1) is 2.718281828459"
  #define Q_exp sc->pcl_n

  s7_pointer x;

  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == 0) return(small_int(1));                       /* (exp 0) -> 1 */
      return(make_real(sc, exp((s7_double)(integer(x)))));

    case T_RATIO:
      return(make_real(sc, exp((s7_double)fraction(x))));

    case T_REAL:
      return(make_real(sc, exp(real(x))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      return(s7_from_c_complex(sc, cexp(as_c_complex(x))));
      /* this is inaccurate for large arguments:
       *   (exp 0+1e20i) -> -0.66491178990701-0.74692189125949i, not 7.639704044417283004001468027378811228331E-1-6.45251285265780844205811711312523007406E-1i
       */
#else
      return(out_of_range(sc, sc->exp_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->exp_symbol, args, a_number_string));
    }
}

static s7_double exp_d_d(s7_double x) {return(exp(x));}


/* -------------------------------- log -------------------------------- */

#if __cplusplus
#define LOG_2 1.4426950408889634074
#else
#define LOG_2 1.4426950408889634073599246810018921L /* (/ (log 2.0)) */
#endif

static s7_pointer g_log(s7_scheme *sc, s7_pointer args)
{
  #define H_log "(log z1 (z2 e)) returns log(z1) / log(z2) where z2 (the base) defaults to e: (log 8 2) = 3"
  #define Q_log sc->pcl_n

  s7_pointer x;
  x = car(args);
  if (!s7_is_number(x))
    return(method_or_bust_with_type(sc, x, sc->log_symbol, args, a_number_string, 1));

  if (is_pair(cdr(args)))
    {
      s7_pointer y;

      y = cadr(args);
      if (!(s7_is_number(y)))
	return(method_or_bust_with_type(sc, y, sc->log_symbol, args, a_number_string, 2));

      if (y == small_int(2))
	{
	  /* (define (2^n? x) (and (not (zero? x)) (zero? (logand x (- x 1))))) */
	  if (is_t_integer(x))
	    {
	      s7_int ix;
	      ix = s7_integer(x);
	      if (ix > 0)
		{
		  s7_double fx;
#if (__ANDROID__) || (MS_WINDOWS) || ((__GNUC__) && ((__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ <= 4))))
		  /* just a guess -- log2 gets a warning in gcc 4.3.2, but not in 4.4.4 */
		  fx = log((double)ix) / log(2.0);
#else
		  fx = log2((double)ix);
#endif
		  /* (s7_int)fx rounds (log 8 2) to 2 in FreeBSD! */
#if ((__GNUC__) && ((__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ < 4))))
		  return(make_real(sc, fx));
#else
		  if ((ix & (ix - 1)) == 0)
		    return(make_integer(sc, (s7_int)s7_round(fx)));
		  return(make_real(sc, fx));
#endif
		}
	    }
	  if ((s7_is_real(x)) &&
	      (s7_is_positive(x)))
	    return(make_real(sc, log(s7_real(x)) * LOG_2));
	  return(s7_from_c_complex(sc, clog(s7_to_c_complex(x)) * LOG_2));
	}

      if ((x == small_int(1)) && (y == small_int(1)))  /* (log 1 1) -> 0 (this is NaN in the bignum case) */
	return(small_int(0));

      /* (log 1 0) must be 0 since everyone says (expt 0 0) is 1 */
      if (s7_is_zero(y))
	{
	  if ((y == small_int(0)) &&
	      (x == small_int(1)))
	    return(y);
	  return(out_of_range(sc, sc->log_symbol, small_int(2), y, wrap_string(sc, "can't be 0", 10)));
	}

      if (s7_is_one(y))          /* this used to raise an error, but the bignum case is simpler if we return inf */
	{
	  if (s7_is_one(x))      /* but (log 1.0 1.0) -> 0.0 */
	    return(real_zero);
	  return(real_infinity); /* currently (log 1/0 1) is inf? */
	}

      if ((s7_is_real(x)) &&
	  (s7_is_real(y)) &&
	  (s7_is_positive(x)) &&
	  (s7_is_positive(y)))
	{
	  if ((s7_is_rational(x)) &&
	      (s7_is_rational(y)))
	    {
	      s7_double res;
	      s7_int ires;
	      res = log(rational_to_double(sc, x)) / log(rational_to_double(sc, y));
	      ires = (s7_int)res;
	      if (res - ires == 0.0)
		return(make_integer(sc, ires));   /* (log 8 2) -> 3 or (log 1/8 2) -> -3 */
	      return(make_real(sc, res));         /* perhaps use rationalize here? (log 2 8) -> 1/3 */
	    }
	  return(make_real(sc, log(s7_real(x)) / log(s7_real(y))));
	}
      return(s7_from_c_complex(sc, clog(s7_to_c_complex(x)) / clog(s7_to_c_complex(y))));
    }

  if (s7_is_real(x))
    {
      if (s7_is_positive(x))
	return(make_real(sc, log(s7_real(x))));
      return(s7_make_complex(sc, log(-s7_real(x)), M_PI));
    }
  return(s7_from_c_complex(sc, clog(s7_to_c_complex(x))));
}


/* -------------------------------- sin -------------------------------- */
static s7_pointer g_sin(s7_scheme *sc, s7_pointer args)
{
  #define H_sin "(sin z) returns sin(z)"
  #define Q_sin sc->pcl_n

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_REAL:
      return(make_real(sc, sin(real(x))));

    case T_INTEGER:
      if (integer(x) == 0) return(small_int(0));                      /* (sin 0) -> 0 */
      return(make_real(sc, sin((s7_double)integer(x))));

    case T_RATIO:
      return(make_real(sc, sin((s7_double)(fraction(x)))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      return(s7_from_c_complex(sc, csin(as_c_complex(x))));
#else
      return(out_of_range(sc, sc->sin_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->sin_symbol, args, a_number_string));
    }

  /* sin is totally inaccurate over about 1e18.  There's a way to get true results,
   *   but it involves fancy "range reduction" techniques.
   *   This means that lots of things are inaccurate:
   * (sin (remainder 1e22 (* 2 pi))) -> -0.57876806033477
   * but it should be -8.522008497671888065747423101326159661908E-1
   * ---
   * (remainder 1e22 (* 2 pi)) -> 1.0057952155665e+22 !!
   *   it should be 5.263007914620499494429139986095833592117E0
   */
}

static s7_double sin_d_d(s7_double x) {return(sin(x));}
static s7_pointer sin_p_d(s7_scheme *sc, s7_double x) {return(make_real(sc, sin(x)));}


/* -------------------------------- cos -------------------------------- */
static s7_pointer g_cos(s7_scheme *sc, s7_pointer args)
{
  #define H_cos "(cos z) returns cos(z)"
  #define Q_cos sc->pcl_n

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_REAL:
      return(make_real(sc, cos(real(x))));

    case T_INTEGER:
      if (integer(x) == 0) return(small_int(1));                     /* (cos 0) -> 1 */
      return(make_real(sc, cos((s7_double)integer(x))));

    case T_RATIO:
      return(make_real(sc, cos((s7_double)(fraction(x)))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      return(s7_from_c_complex(sc, ccos(as_c_complex(x))));
#else
      return(out_of_range(sc, sc->cos_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->cos_symbol, args, a_number_string));
    }
}

static s7_double cos_d_d(s7_double x) {return(cos(x));}
static s7_pointer cos_p_d(s7_scheme *sc, s7_double x) {return(make_real(sc, cos(x)));}


/* -------------------------------- tan -------------------------------- */
static s7_pointer g_tan(s7_scheme *sc, s7_pointer args)
{
  #define H_tan "(tan z) returns tan(z)"
  #define Q_tan sc->pcl_n

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_REAL:
      return(make_real(sc, tan(real(x))));

    case T_INTEGER:
      if (integer(x) == 0) return(small_int(0));                      /* (tan 0) -> 0 */
      return(make_real(sc, tan((s7_double)(integer(x)))));

    case T_RATIO:
      return(make_real(sc, tan((s7_double)(fraction(x)))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      if (imag_part(x) > 350.0)
	return(c_complex(sc, 0.0, 1.0));
      if (imag_part(x) < -350.0)
	return(c_complex(sc, 0.0, -1.0));
      return(s7_from_c_complex(sc, ctan(as_c_complex(x))));
#else
      return(out_of_range(sc, sc->tan_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->tan_symbol, args, a_number_string));
    }
}

static s7_double tan_d_d(s7_double x) {return(tan(x));}


/* -------------------------------- asin -------------------------------- */
static s7_pointer c_asin(s7_scheme *sc, s7_double x)
{
  s7_double absx, recip;
  s7_complex result;

  absx = fabs(x);
  if (absx <= 1.0)
    return(make_real(sc, asin(x)));

  /* otherwise use maxima code: */
  recip = 1.0 / absx;
  result = (M_PI / 2.0) - (_Complex_I * clog(absx * (1.0 + (sqrt(1.0 + recip) * csqrt(1.0 - recip)))));
  if (x < 0.0)
    return(s7_from_c_complex(sc, -result));
  return(s7_from_c_complex(sc, result));
}


static s7_pointer g_asin(s7_scheme *sc, s7_pointer args)
{
  #define H_asin "(asin z) returns asin(z); (sin (asin x)) = x"
  #define Q_asin sc->pcl_n
  s7_pointer n;

  n = car(args);
  switch (type(n))
    {
    case T_INTEGER:
      if (integer(n) == 0) return(small_int(0));                    /* (asin 0) -> 0 */
      /* in netBSD, (asin 2) returns 0.25383842987008+0.25383842987008i according to Peter Bex */
      return(c_asin(sc, (s7_double)integer(n)));

    case T_RATIO:
      return(c_asin(sc, (s7_double)numerator(n) / (s7_double)denominator(n)));

    case T_REAL:
      return(c_asin(sc, real(n)));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      /* if either real or imag part is very large, use explicit formula, not casin */
      /*   this code taken from sbcl's src/code/irrat.lisp; break is around x+70000000i */
      if ((fabs(real_part(n)) > 1.0e7) ||
	  (fabs(imag_part(n)) > 1.0e7))
	{
	  s7_complex sq1mz, sq1pz, z;
	  z = as_c_complex(n);
	  sq1mz = csqrt(1.0 - z);
	  sq1pz = csqrt(1.0 + z);
	  return(s7_make_complex(sc, atan(real_part(n) / creal(sq1mz * sq1pz)), asinh(cimag(sq1pz * conj(sq1mz)))));
	}
      return(s7_from_c_complex(sc, casin(as_c_complex(n))));
#else
      return(out_of_range(sc, sc->asin_symbol, small_int(1), n, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, n, sc->asin_symbol, list_1(sc, n), a_number_string));
    }
}


/* -------------------------------- acos -------------------------------- */
static s7_pointer c_acos(s7_scheme *sc, s7_double x)
{
  s7_double absx, recip;
  s7_complex result;

  absx = fabs(x);
  if (absx <= 1.0)
    return(make_real(sc, acos(x)));

  /* else follow maxima again: */
  recip = 1.0 / absx;
  if (x > 0.0)
    result = _Complex_I * clog(absx * (1.0 + (sqrt(1.0 + recip) * csqrt(1.0 - recip))));
  else result = M_PI - _Complex_I * clog(absx * (1.0 + (sqrt(1.0 + recip) * csqrt(1.0 - recip))));
  return(s7_from_c_complex(sc, result));
}

static s7_pointer g_acos(s7_scheme *sc, s7_pointer args)
{
  #define H_acos "(acos z) returns acos(z); (cos (acos 1)) = 1"
  #define Q_acos sc->pcl_n
  s7_pointer n;

  n = car(args);
  switch (type(n))
    {
    case T_INTEGER:
      if (integer(n) == 1) return(small_int(0));
      return(c_acos(sc, (s7_double)integer(n)));

    case T_RATIO:
      return(c_acos(sc, (s7_double)numerator(n) / (s7_double)denominator(n)));

    case T_REAL:
      return(c_acos(sc, real(n)));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      /* if either real or imag part is very large, use explicit formula, not cacos */
      /*   this code taken from sbcl's src/code/irrat.lisp */

      if ((fabs(real_part(n)) > 1.0e7) ||
	  (fabs(imag_part(n)) > 1.0e7))
	{
	  s7_complex sq1mz, sq1pz, z;
	  z = as_c_complex(n);
	  sq1mz = csqrt(1.0 - z);
	  sq1pz = csqrt(1.0 + z);	  /* creal(sq1pz) can be 0.0 */
	  if (creal(sq1pz) == 0.0)        /* so the atan arg will be inf, so the real part will be pi/2(?) */
	    return(s7_make_complex(sc, M_PI / 2.0, asinh(cimag(sq1mz * conj(sq1pz)))));
	  return(s7_make_complex(sc, 2.0 * atan(creal(sq1mz) / creal(sq1pz)), asinh(cimag(sq1mz * conj(sq1pz)))));
	}
      return(s7_from_c_complex(sc, cacos(s7_to_c_complex(n))));
#else
      return(out_of_range(sc, sc->acos_symbol, small_int(1), n, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, n, sc->acos_symbol, list_1(sc, n), a_number_string));
    }
}


/* -------------------------------- atan -------------------------------- */

static s7_pointer g_atan(s7_scheme *sc, s7_pointer args)
{
  #define H_atan "(atan z) returns atan(z), (atan y x) returns atan(y/x)"
  #define Q_atan s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_number_symbol, sc->is_real_symbol)
  /* actually if there are two args, both should be real, but how to express that in the signature? */
  s7_pointer x, y;
  s7_double x1, x2;

  /* currently (atan inf.0 inf.0) -> 0.78539816339745, and (atan inf.0 -inf.0) -> 2.3561944901923 (etc) */

  x = car(args);
  if (!is_pair(cdr(args)))
    {
      switch (type(x))
	{
	case T_INTEGER:
	  if (integer(x) == 0) return(small_int(0));                /* (atan 0) -> 0 */

	case T_RATIO:
	case T_REAL:
	  return(make_real(sc, atan(s7_real(x))));

	case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
	  return(s7_from_c_complex(sc, catan(as_c_complex(x))));
#else
	  return(out_of_range(sc, sc->atan_symbol, small_int(1), x, no_complex_numbers_string));
#endif

	default:
	  return(method_or_bust_with_type_one_arg(sc, x, sc->atan_symbol, args, a_number_string));
	}
    }

  if (!s7_is_real(x))
    return(method_or_bust(sc, x, sc->atan_symbol, args, T_REAL, 1));

  y = cadr(args);
  if (!s7_is_real(y))
    return(method_or_bust(sc, y, sc->atan_symbol, args, T_REAL, 2));

  x1 = s7_real(x);
  x2 = s7_real(y);
  return(make_real(sc, atan2(x1, x2)));
}

static s7_double atan_d_dd(s7_double x, s7_double y) {return(atan2(x, y));}


/* -------------------------------- sinh -------------------------------- */
static s7_pointer g_sinh(s7_scheme *sc, s7_pointer args)
{
  #define H_sinh "(sinh z) returns sinh(z)"
  #define Q_sinh sc->pcl_n

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == 0) return(small_int(0));                    /* (sinh 0) -> 0 */

    case T_REAL:
    case T_RATIO:
      return(make_real(sc, sinh(s7_real(x))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      return(s7_from_c_complex(sc, csinh(as_c_complex(x))));
#else
      return(out_of_range(sc, sc->sinh_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->sinh_symbol, args, a_number_string));
    }
}

static s7_double sinh_d_d(s7_double x) {return(sinh(x));}


/* -------------------------------- cosh -------------------------------- */
static s7_pointer g_cosh(s7_scheme *sc, s7_pointer args)
{
  #define H_cosh "(cosh z) returns cosh(z)"
  #define Q_cosh sc->pcl_n

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == 0) return(small_int(1));                   /* (cosh 0) -> 1 */

    case T_REAL:
    case T_RATIO:
      return(make_real(sc, cosh(s7_real(x))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      return(s7_from_c_complex(sc, ccosh(as_c_complex(x))));
#else
      return(out_of_range(sc, sc->cosh_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->cosh_symbol, args, a_number_string));
    }
}

static s7_double cosh_d_d(s7_double x) {return(cosh(x));}


/* -------------------------------- tanh -------------------------------- */
static s7_pointer g_tanh(s7_scheme *sc, s7_pointer args)
{
  #define H_tanh "(tanh z) returns tanh(z)"
  #define Q_tanh sc->pcl_n

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == 0) return(small_int(0));  /* (tanh 0) -> 0 */

    case T_REAL:
    case T_RATIO:
      return(make_real(sc, tanh(s7_real(x))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
      if (real_part(x) > 350.0)
	return(real_one);                         /* closer than 0.0 which is what ctanh is about to return! */
      if (real_part(x) < -350.0)
	return(make_real(sc, -1.0));              /* closer than ctanh's -0.0 */
      return(s7_from_c_complex(sc, ctanh(as_c_complex(x))));
#else
      return(out_of_range(sc, sc->tanh_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->tanh_symbol, args, a_number_string));
    }
}

static s7_double tanh_d_d(s7_double x) {return(tanh(x));}


/* -------------------------------- asinh -------------------------------- */

static s7_pointer g_asinh(s7_scheme *sc, s7_pointer args)
{
  #define H_asinh "(asinh z) returns asinh(z)"
  #define Q_asinh sc->pcl_n
  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == 0) return(small_int(0));
      return(make_real(sc, asinh((s7_double)integer(x))));

    case T_RATIO:
      return(make_real(sc, asinh((s7_double)numerator(x) / (s7_double)denominator(x))));

    case T_REAL:
      return(make_real(sc, asinh(real(x))));

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
  #if (defined(__OpenBSD__)) || (defined(__NetBSD__))
      return(s7_from_c_complex(sc, casinh_1(as_c_complex(x))));
  #else
      return(s7_from_c_complex(sc, casinh(as_c_complex(x))));
  #endif
#else
      return(out_of_range(sc, sc->asinh_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->asinh_symbol, list_1(sc, x), a_number_string));
    }
}


/* -------------------------------- acosh -------------------------------- */

static s7_pointer g_acosh(s7_scheme *sc, s7_pointer args)
{
  #define H_acosh "(acosh z) returns acosh(z)"
  #define Q_acosh sc->pcl_n
  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == 1) return(small_int(0));

    case T_REAL:
    case T_RATIO:
      {
	double x1;
	x1 = s7_real(x);
	if (x1 >= 1.0)
	  return(make_real(sc, acosh(x1)));
      }

    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
  #ifdef __OpenBSD__
      return(s7_from_c_complex(sc, cacosh_1(s7_to_c_complex(x))));
  #else
      return(s7_from_c_complex(sc, cacosh(s7_to_c_complex(x)))); /* not as_c_complex because x might not be complex */
  #endif
#else
      /* since we can fall through to this branch, we need a better error message than "must be a number, not 0.0" */
      return(out_of_range(sc, sc->acosh_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->acosh_symbol, list_1(sc, x), a_number_string));
    }
}


/* -------------------------------- atanh -------------------------------- */

static s7_pointer g_atanh(s7_scheme *sc, s7_pointer args)
{
  #define H_atanh "(atanh z) returns atanh(z)"
  #define Q_atanh sc->pcl_n
  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      if (integer(x) == 0) return(small_int(0));                    /* (atanh 0) -> 0 */

    case T_REAL:
    case T_RATIO:
      {
	double x1;
	x1 = s7_real(x);
	if (fabs(x1) < 1.0)
	  return(make_real(sc, atanh(x1)));
      }

      /* if we can't distinguish x from 1.0 even with long doubles, we'll get inf.0:
       *    (atanh 9223372036854775/9223372036854776) -> 18.714973875119
       *    (atanh 92233720368547758/92233720368547757) -> inf.0
       */
    case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
  #if (defined(__OpenBSD__)) || (defined(__NetBSD__))
      return(s7_from_c_complex(sc, catanh_1(s7_to_c_complex(x))));
  #else
      return(s7_from_c_complex(sc, catanh(s7_to_c_complex(x))));
  #endif
#else
      return(out_of_range(sc, sc->atanh_symbol, small_int(1), x, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->atanh_symbol, list_1(sc, x), a_number_string));
    }
}


/* -------------------------------- sqrt -------------------------------- */
static s7_pointer g_sqrt(s7_scheme *sc, s7_pointer args)
{
  #define H_sqrt "(sqrt z) returns the square root of z"
  #define Q_sqrt sc->pcl_n

  s7_pointer n;
  s7_double sqx;

  n = car(args);
  switch (type(n))
    {
    case T_INTEGER:
      if (integer(n) >= 0)
	{
	  s7_int ix;
	  sqx = sqrt((s7_double)integer(n));
	  ix = (s7_int)sqx;
	  if ((ix * ix) == integer(n))
	    return(make_integer(sc, ix));
	  return(make_real(sc, sqx));
	  /* Mark Weaver notes that
	   *     (zero? (- (sqrt 9007199136250226) 94906265.0)) -> #t
	   * but (* 94906265 94906265) -> 9007199136250225 -- oops
	   * at least we return a real here, not an incorrect integer and
	   *     (sqrt 9007199136250225) -> 94906265
	   */
	}
      sqx = (s7_double)integer(n); /* we're trying to protect against (sqrt -9223372036854775808) where we can't negate the integer argument */
      return(s7_make_complex(sc, 0.0, sqrt((s7_double)(-sqx))));

    case T_RATIO:
      sqx = (s7_double)fraction(n);
      if (sqx > 0.0) /* else it's complex, so it can't be a ratio */
	{
	  s7_int nm = 0, dn = 1;
	  if (c_rationalize(sqx, 1.0e-16, &nm, &dn)) /* 1e-16 so that (sqrt 1/1099511627776) returns 1/1048576 */
	    {
#if HAVE_OVERFLOW_CHECKS
	      s7_int nm2, dn2;
	      if ((multiply_overflow(nm, nm, &nm2)) ||
		  (multiply_overflow(dn, dn, &dn2)))
		return(make_real(sc, sqrt(sqx)));
	      if ((nm2 == numerator(n)) &&
		  (dn2 == denominator(n)))
		return(s7_make_ratio(sc, nm, dn));
#else
	      if ((nm * nm == numerator(n)) &&
		  (dn * dn == denominator(n)))
		return(s7_make_ratio(sc, nm, dn));
#endif
	    }
	  return(make_real(sc, sqrt(sqx)));
	}
      return(s7_make_complex(sc, 0.0, sqrt(-sqx)));

    case T_REAL:
      if (is_NaN(real(n)))
	return(real_NaN);
      if (real(n) >= 0.0)
	return(make_real(sc, sqrt(real(n))));
      return(s7_make_complex(sc, 0.0, sqrt(-real(n))));

    case T_COMPLEX:
      /* (* inf.0 (sqrt -1)) -> -nan+infi, but (sqrt -inf.0) -> 0+infi */
#if HAVE_COMPLEX_NUMBERS
      return(s7_from_c_complex(sc, csqrt(as_c_complex(n))));
#else
      return(out_of_range(sc, sc->sqrt_symbol, small_int(1), n, no_complex_numbers_string));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, n, sc->sqrt_symbol, args, a_number_string));
    }
}


/* -------------------------------- expt -------------------------------- */

static s7_int int_to_int(s7_int x, s7_int n)
{
  /* from GSL */
  s7_int value = 1;
  do {
    if (n & 1) value *= x;
    n >>= 1;
#if HAVE_OVERFLOW_CHECKS
    if (multiply_overflow(x, x, &x))
      break;
#else
    x *= x;
#endif
  } while (n);
  return(value);
}


static const int64_t nth_roots[63] = {
  S7_LLONG_MAX, S7_LLONG_MAX, 3037000499LL, 2097151, 55108, 6208, 1448, 511, 234, 127, 78, 52, 38, 28, 22,
  18, 15, 13, 11, 9, 8, 7, 7, 6, 6, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,
  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};

static const int64_t int_nth_roots[31] = {
  S7_LONG_MAX, S7_LONG_MAX, 46340, 1290, 215, 73, 35, 21, 14, 10, 8, 7, 5, 5, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2};

static bool int_pow_ok(s7_int x, s7_int y)
{
  if (s7_int_bits > 31)
    return((y < 63) &&
	   (nth_roots[y] >= s7_int_abs(x)));
  return((y < 31) &&
	 (int_nth_roots[y] >= s7_int_abs(x)));
}

static s7_pointer g_expt(s7_scheme *sc, s7_pointer args)
{
  #define H_expt "(expt z1 z2) returns z1^z2"
  #define Q_expt sc->pcl_n
  s7_pointer n, pw;

  n = car(args);
  if (!s7_is_number(n))
    return(method_or_bust_with_type(sc, n, sc->expt_symbol, args, a_number_string, 1));

  pw = cadr(args);
  if (!s7_is_number(pw))
    return(method_or_bust_with_type(sc, pw, sc->expt_symbol, args, a_number_string, 2));

  /* this provides more than 2 args to expt:
   *  if (is_not_null(cddr(args)))
   *    return(g_expt(sc, list_2(sc, car(args), g_expt(sc, cdr(args)))));
   * but it's unusual in scheme to process args in reverse order, and the
   * syntax by itself is ambiguous (does (expt 2 2 3) = 256 or 64?)
   */

  if (s7_is_zero(n))
    {
      if (s7_is_zero(pw))
	{
	  if ((s7_is_integer(n)) && (s7_is_integer(pw)))       /* (expt 0 0) -> 1 */
	    return(small_int(1));
	  return(real_zero);                                   /* (expt 0.0 0) -> 0.0 */
	}

      if (s7_is_real(pw))
	{
	  if (s7_is_negative(pw))                              /* (expt 0 -1) */
	    return(division_by_zero_error(sc, sc->expt_symbol, args));
	  /* (Clisp gives divide-by-zero error here, Guile returns inf.0) */

	  if ((!s7_is_rational(pw)) &&                         /* (expt 0 most-positive-fixnum) */
	      (is_NaN(s7_real(pw))))                           /* (expt 0 +nan.0) */
	    return(pw);
	}
      else
	{                                                      /* (expt 0 a+bi) */
	  if (real_part(pw) < 0.0)                             /* (expt 0 -1+i) */
	    return(division_by_zero_error(sc, sc->expt_symbol, args));
	  if ((is_NaN(real_part(pw))) ||                       /* (expt 0 0+1/0i) */
	      (is_NaN(imag_part(pw))))
	    return(real_NaN);
	}

      if ((s7_is_integer(n)) && (s7_is_integer(pw)))           /* pw != 0, (expt 0 2312) */
	return(small_int(0));
      return(real_zero);                                       /* (expt 0.0 123123) */
    }

  if (s7_is_one(pw))
    {
      if (s7_is_integer(pw))                                   /* (expt x 1) */
	return(n);
      if (is_rational(n))                                      /* (expt ratio 1.0) */
	return(make_real(sc, rational_to_double(sc, n)));
      return(n);
    }

  if (is_t_integer(pw))
    {
      s7_int y;
      y = integer(pw);
      if (y == 0)
	{
	  if (is_rational(n))                                 /* (expt 3 0) */
	    return(small_int(1));
	  if ((is_NaN(s7_real_part(n))) ||                    /* (expt 1/0 0) -> NaN */
	      (is_NaN(s7_imag_part(n))))                      /* (expt (complex 0 1/0) 0) -> NaN */
	    return(n);
	  return(real_one);                                   /* (expt 3.0 0) */
	}

      switch (type(n))
	{
	case T_INTEGER:
	  {
	    s7_int x;
	    x = s7_integer(n);
	    if (x == 1)                                       /* (expt 1 y) */
	      return(n);

	    if (x == -1)
	      {
		if (y == s7_int_min)                        /* (expt -1 most-negative-fixnum) */
		  return(small_int(1));

		if (s7_int_abs(y) & 1)                        /* (expt -1 odd-int) */
		  return(n);
		return(small_int(1));                         /* (expt -1 even-int) */
	      }

	    if (y == s7_int_min)                            /* (expt x most-negative-fixnum) */
	      return(small_int(0));
	    if (x == s7_int_min)                            /* (expt most-negative-fixnum y) */
	      return(make_real(sc, pow((double)x, (double)y)));

	    if (int_pow_ok(x, s7_int_abs(y)))
	      {
		if (y > 0)
		  return(make_integer(sc, int_to_int(x, y)));
		return(s7_make_ratio(sc, 1, int_to_int(x, -y)));
	      }
	  }
	  break;

	case T_RATIO:
	  {
	    s7_int nm, dn;

	    nm = numerator(n);
	    dn = denominator(n);

	    if (y == s7_int_min)
	      {
		if (s7_int_abs(nm) > dn)
		  return(small_int(0));              /* (expt 4/3 most-negative-fixnum) -> 0? */
		return(real_infinity);               /* (expt 3/4 most-negative-fixnum) -> inf? */
	      }

	    if ((int_pow_ok(nm, s7_int_abs(y))) &&
		(int_pow_ok(dn, s7_int_abs(y))))
	      {
		if (y > 0)
		  return(s7_make_ratio(sc, int_to_int(nm, y), int_to_int(dn, y)));
		return(s7_make_ratio(sc, int_to_int(dn, -y), int_to_int(nm, -y)));
	      }
	  }
	  break;
	  /* occasionally int^rat can be int32_t but it happens so infrequently it's probably not worth checking
	   *  one possibly easy case: (expt 1 1/2) -> 1 (-1?) etc
	   */

	case T_REAL:
	  /* (expt -1.0 most-positive-fixnum) should be -1.0
	   * (expt -1.0 (+ (expt 2 53) 1)) -> -1.0
	   * (expt -1.0 (- 1 (expt 2 54))) -> -1.0
	   */
	  if (real(n) == -1.0)
	    {
	      if (y == s7_int_min)
		return(real_one);

	      if (s7_int_abs(y) & 1)
		return(n);
	      return(real_one);
	    }
	  break;

	case T_COMPLEX:
#if HAVE_COMPLEX_NUMBERS
	  if ((s7_real_part(n) == 0.0) &&
	      ((s7_imag_part(n) == 1.0) ||
	       (s7_imag_part(n) == -1.0)))
	    {
	      bool yp, np;
	      yp = (y > 0);
	      np = (s7_imag_part(n) > 0.0);
	      switch (s7_int_abs(y) % 4)
		{
		case 0: return(real_one);
		case 1: return(s7_make_complex(sc, 0.0, (yp == np) ? 1.0 : -1.0));
		case 2: return(make_real(sc, -1.0));
		case 3: return(s7_make_complex(sc, 0.0, (yp == np) ? -1.0 : 1.0));
		}
	    }
#else
	  return(out_of_range(sc, sc->expt_symbol, small_int(2), n, no_complex_numbers_string));
#endif
	  break;
	}
    }

  if ((s7_is_real(n)) &&
      (s7_is_real(pw)))
    {
      s7_double x, y;

      if ((is_t_ratio(pw)) &&
	  (numerator(pw) == 1))
	{
	  if (denominator(pw) == 2)
	    return(g_sqrt(sc, args));
	  if (denominator(pw) == 3)
	    return(make_real(sc, cbrt(s7_real(n)))); /* (expt 27 1/3) should be 3, not 3.0... */

	  /* but: (expt 512/729 1/3) -> 0.88888888888889, and 4 -> sqrt(sqrt...) etc? */
	}

      x = s7_real(n);
      y = s7_real(pw);

      if (is_NaN(x)) return(n);
      if (is_NaN(y)) return(pw);
      if (y == 0.0) return(real_one);

      if (x > 0.0)
	return(make_real(sc, pow(x, y)));      /* tricky cases abound here: (expt -1 1/9223372036854775807) */
    }

  /* (expt 0+i 1e+16) = 0.98156860153485-0.19111012657867i ?
   * (expt 0+i 1+1/0i) = 0.0 ??
   */
  return(s7_from_c_complex(sc, cpow(s7_to_c_complex(n), s7_to_c_complex(pw))));
}


/* -------------------------------- lcm -------------------------------- */
static s7_pointer g_lcm(s7_scheme *sc, s7_pointer args)
{
  /* (/ (* m n) (gcd m n)), (lcm a b c) -> (lcm a (lcm b c)) */
  #define H_lcm "(lcm ...) returns the least common multiple of its rational arguments"
  #define Q_lcm sc->pcl_f

  s7_int n = 1, d = 0;
  s7_pointer p;

  if (!is_pair(args))
    return(small_int(1));

  if (!is_pair(cdr(args)))
    {
      if (!is_rational(car(args)))
	return(method_or_bust_with_type(sc, car(args), sc->lcm_symbol, args, a_rational_string, 1));
      return(g_abs(sc, args));
    }

  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer x;
      s7_int b;
      x = car(p);
      switch (type(x))
	{
	case T_INTEGER:
	  if (integer(x) == 0)
	    n = 0;
	  else
	    {
	      b = integer(x);
	      if (b < 0) b = -b;
#if HAVE_OVERFLOW_CHECKS
	      if (multiply_overflow(n / c_gcd(n, b), b, &n))
		return(simple_out_of_range(sc, sc->lcm_symbol, args, result_is_too_large_string));
#else
	      n = (n / c_gcd(n, b)) * b;
#endif
	    }
	  if (d != 0) d = 1;
	  break;

	case T_RATIO:
	  b = numerator(x);
	  if (b < 0) b = -b;
	  n = (n / c_gcd(n, b)) * b;
	  if (d == 0)
	    {
	      if (p == args)
		d = s7_denominator(x);
	      else d = 1;
	    }
	  else d = c_gcd(d, s7_denominator(x));
	  break;

	default:
	  return(method_or_bust_with_type(sc, x, sc->lcm_symbol, cons(sc, (d <= 1) ? make_integer(sc, n) : s7_make_ratio(sc, n, d), p),
					  a_rational_string, position_of(p, args)));
	}
      if (n < 0) return(simple_out_of_range(sc, sc->lcm_symbol, args, result_is_too_large_string));
      if (n == 0)
	{
	  for (p = cdr(p); is_pair(p); p = cdr(p))
	    if (!is_rational_via_method(sc, car(p)))
	      return(wrong_type_argument_with_type(sc, sc->lcm_symbol, position_of(p, args), x, a_rational_string));
	  return(small_int(0));
	}
    }

  if (d <= 1)
    return(make_integer(sc, n));
  return(make_simple_ratio(sc, n, d));
}


/* -------------------------------- gcd -------------------------------- */
static s7_pointer g_gcd(s7_scheme *sc, s7_pointer args)
{
  #define H_gcd "(gcd ...) returns the greatest common divisor of its rational arguments"
  #define Q_gcd sc->pcl_f
  s7_int n = 0, d = 1;
  s7_pointer p;

  if (!is_pair(args))
    return(small_int(0));

  if (!is_pair(cdr(args)))
    {
      if (!is_rational(car(args)))
	return(method_or_bust_with_type(sc, car(args), sc->gcd_symbol, args, a_rational_string, 1));
      return(g_abs(sc, args));
    }

  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer x;
      s7_int b;
      x = car(p);
      switch (type(x))
	{
	case T_INTEGER:
	  n = c_gcd(n, integer(x));
	  break;

	case T_RATIO:
	  n = c_gcd(n, s7_numerator(x));
	  b = s7_denominator(x);
	  if (b < 0) b = -b;
	  d = (d / c_gcd(d, b)) * b;
	  if (d < 0) return(simple_out_of_range(sc, sc->gcd_symbol, args, result_is_too_large_string));
	  break;

	default:
	  return(method_or_bust_with_type(sc, x, sc->gcd_symbol, cons(sc, (d <= 1) ? make_integer(sc, n) : s7_make_ratio(sc, n, d), p),
					  a_rational_string, position_of(p, args)));
	}
      if (n < 0) return(simple_out_of_range(sc, sc->gcd_symbol, args, result_is_too_large_string));
    }

  if (d <= 1)
    return(make_integer(sc, n));
  return(make_simple_ratio(sc, n, d));
}


/* -------------------------------- quotient -------------------------------- */
static s7_pointer s7_truncate(s7_scheme *sc, s7_pointer caller, s7_double xf)   /* can't use "truncate" -- it's in unistd.h */
{
  if ((xf > s7_int_max) ||
      (xf < s7_int_min))
    return(simple_out_of_range(sc, caller, wrap_real(sc, xf), its_too_large_string));

  if (xf > 0.0)
    return(make_integer(sc, (s7_int)floor(xf)));
  return(make_integer(sc, (s7_int)ceil(xf)));
}

static inline s7_int c_quo_int(s7_scheme *sc, s7_int x, s7_int y)
{
  if (y == 0)
    division_by_zero_error(sc, sc->quotient_symbol, set_elist_2(sc, wrap_integer1(sc, x), wrap_integer2(sc, y)));
  if ((y == -1) && (x == s7_int_min))   /* (quotient most-negative-fixnum -1) */
    simple_out_of_range(sc, sc->quotient_symbol, set_elist_2(sc, wrap_integer1(sc, x), wrap_integer2(sc, y)), its_too_large_string);
  return(x / y);
}

static s7_double c_quo_dbl(s7_scheme *sc, s7_double x, s7_double y)
{
  s7_double xf;

  if (y == 0.0)
    division_by_zero_error(sc, sc->quotient_symbol, set_elist_2(sc, wrap_real(sc, x), wrap_real2(sc, y)));
  if ((is_inf(y)) || (is_NaN(y)))
    wrong_type_argument_with_type(sc, sc->quotient_symbol, 2, wrap_real(sc, y), a_normal_real_string);

  xf = x / y;
  if ((xf > s7_int_max) ||
      (xf < s7_int_min))
    simple_out_of_range(sc, sc->quotient_symbol, wrap_real(sc, xf), its_too_large_string);

  if (xf > 0.0)
    return(floor(xf));
  return(ceil(xf));
}

static s7_int quotient_i_7ii(s7_scheme *sc, s7_int i1, s7_int i2) {return(c_quo_int(sc, i1, i2));}
static s7_int quotient_i_ii_direct(s7_int i1, s7_int i2) {return(i1 / i2);} /* i2 > 0 */

static s7_double quotient_d_7dd(s7_scheme *sc, s7_double x1, s7_double x2)
{
  if ((is_inf(x1)) || (is_NaN(x1)))
    wrong_type_argument_with_type(sc, sc->quotient_symbol, 1, wrap_real(sc, x1), a_normal_real_string);
  return(c_quo_dbl(sc, x1, x2));
}

static s7_pointer g_quotient(s7_scheme *sc, s7_pointer args)
{
  #define H_quotient "(quotient x1 x2) returns the integer quotient of x1 and x2; (quotient 4 3) = 1"
  #define Q_quotient sc->pcl_r
  /* (define (quo x1 x2) (truncate (/ x1 x2))) ; slib */
  s7_pointer x, y;
  s7_int d1, d2, n1, n2;

  x = car(args);
  y = cadr(args);

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  return(make_integer(sc, c_quo_int(sc, integer(x), integer(y))));

	case T_RATIO:
	  n1 = integer(x);
	  d1 = 1;
	  n2 = numerator(y);
	  d2 = denominator(y);
	  /* (quotient -9223372036854775808 -1/9223372036854775807): arithmetic exception in the no-overflow-checks case */
	  goto RATIO_QUO_RATIO;

	case T_REAL:
	  if (real(y) == 0.0)
	    return(division_by_zero_error(sc, sc->quotient_symbol, args));
	  if ((is_inf(real(y))) || (is_NaN(real(y))))
	    return(wrong_type_argument_with_type(sc, sc->quotient_symbol, 2, y, a_normal_real_string));
	  return(s7_truncate(sc, sc->quotient_symbol, (s7_double)integer(x) / real(y)));

	default:
	  return(method_or_bust(sc, y, sc->quotient_symbol, args, T_REAL, 2));
	}

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(y) == 0)
	    return(division_by_zero_error(sc, sc->quotient_symbol, args));
	  n1 = numerator(x);
	  d1 = denominator(x);
	  n2 = integer(y);
	  d2 = 1;
	  goto RATIO_QUO_RATIO;
	  /* this can lose:
	   *   (quotient 1 2305843009213693952/4611686018427387903) -> 2, not 1
	   *   (quotient 21053343141/6701487259 3587785776203/1142027682075) -> 1, not 0
	   */

	case T_RATIO:
	  n1 = numerator(x);
	  d1 = denominator(x);
	  n2 = numerator(y);
	  d2 = denominator(y);
	RATIO_QUO_RATIO:
	  if (d1 == d2)
	    return(make_integer(sc, n1 / n2));              /* (quotient 3/9223372036854775807 1/9223372036854775807) */
	  if (n1 == n2)
	    return(make_integer(sc, d2 / d1));              /* (quotient 9223372036854775807/2 9223372036854775807/8) */
#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int n1d2, n2d1;
	    if ((multiply_overflow(n1, d2, &n1d2)) ||
		(multiply_overflow(n2, d1, &n2d1)))
	      return(s7_truncate(sc, sc->quotient_symbol, ((long_double)n1 / (long_double)n2) * ((long_double)d2 / (long_double)d1)));
	    return(make_integer(sc, n1d2 / n2d1));
	  }
#else
	  return(make_integer(sc, (n1 * d2) / (n2 * d1)));
#endif

	case T_REAL:
	  if (real(y) == 0.0)
	    return(division_by_zero_error(sc, sc->quotient_symbol, args));
	  if ((is_inf(real(y))) || (is_NaN(real(y))))
	    return(wrong_type_argument_with_type(sc, sc->quotient_symbol, 2, y, a_normal_real_string));
	  return(s7_truncate(sc, sc->quotient_symbol, (s7_double)fraction(x) / real(y)));

	default:
	  return(method_or_bust(sc, y, sc->quotient_symbol, args, T_REAL, 2));
	}

    case T_REAL:
      if ((is_inf(real(x))) || (is_NaN(real(x))))
	return(wrong_type_argument_with_type(sc, sc->quotient_symbol, 1, x, a_normal_real_string));

      /* if infs allowed we need to return infs/nans, else:
       *    (quotient inf.0 1e-309) -> -9223372036854775808
       *    (quotient inf.0 inf.0) -> -9223372036854775808
       */

      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(y) == 0)
	    return(division_by_zero_error(sc, sc->quotient_symbol, args));
	  return(s7_truncate(sc, sc->quotient_symbol, real(x) / (s7_double)integer(y)));

	case T_RATIO:
	  return(s7_truncate(sc, sc->quotient_symbol, real(x) / (s7_double)fraction(y)));

	case T_REAL:
	  return(make_real(sc, c_quo_dbl(sc, real(x), real(y))));

	default:
	  return(method_or_bust(sc, y, sc->quotient_symbol, args, T_REAL, 2));
	}

    default:
      return(method_or_bust(sc, x, sc->quotient_symbol, args, T_REAL, 2));
    }
}


/* -------------------------------- remainder -------------------------------- */
static inline s7_int c_rem_int(s7_scheme *sc, s7_int x, s7_int y)
{
  if (y == 0)
    division_by_zero_error(sc, sc->remainder_symbol, set_elist_2(sc, wrap_integer1(sc, x), wrap_integer2(sc, y)));
  if ((y == 1) || (y == -1))   /* (remainder most-negative-fixnum -1) will segfault with arithmetic exception */
    return(0);
  return(x % y);
}

static s7_double c_rem_dbl(s7_scheme *sc, s7_double x, s7_double y)
{
  s7_int quo;
  s7_double pre_quo;
  if (y == 0.0)
    division_by_zero_error(sc, sc->remainder_symbol, set_elist_2(sc, wrap_real(sc, x), wrap_real2(sc, y)));
  if ((is_inf(y)) || (is_NaN(y)))
    wrong_type_argument_with_type(sc, sc->remainder_symbol, 2, set_elist_1(sc, wrap_real(sc, y)), a_normal_real_string);

  pre_quo = x / y;
  if ((pre_quo > s7_int_max) || (pre_quo < s7_int_min))
    simple_out_of_range(sc, sc->remainder_symbol, set_elist_2(sc, make_real(sc, x), wrap_real(sc, y)), its_too_large_string);
  if (pre_quo > 0.0)
    quo = (s7_int)floor(pre_quo);
  else quo = (s7_int)ceil(pre_quo);
  return(x - (y * quo));
}

static s7_int remainder_i_7ii(s7_scheme *sc, s7_int i1, s7_int i2) {return(c_rem_int(sc, i1, i2));}
static s7_int remainder_i_ii_direct(s7_int i1, s7_int i2) {return(i1 % i2);} /* i2 > 1 */

static s7_double remainder_d_7dd(s7_scheme *sc, s7_double x1, s7_double x2)
{
  if ((is_inf(x1)) || (is_NaN(x1)))
    wrong_type_argument_with_type(sc, sc->remainder_symbol, 1, set_elist_1(sc, wrap_real(sc, x1)), a_normal_real_string);
  return(c_rem_dbl(sc, x1, x2));
}

static s7_pointer g_remainder(s7_scheme *sc, s7_pointer args)
{
  #define H_remainder "(remainder x1 x2) returns the remainder of x1/x2; (remainder 10 3) = 1"
  #define Q_remainder sc->pcl_r
  /* (define (rem x1 x2) (- x1 (* x2 (quo x1 x2)))) ; slib, if x2 is an integer (- x1 (truncate x1 x2)), fractional part: (remainder x 1) */

  s7_pointer x, y;
  s7_int quo, d1, d2, n1, n2;
  s7_double pre_quo;

  x = car(args);
  y = cadr(args);

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  return(make_integer(sc, c_rem_int(sc, integer(x), integer(y))));

	case T_RATIO:
	  n1 = integer(x);
	  d1 = 1;
	  n2 = numerator(y);
	  d2 = denominator(y);
	  goto RATIO_REM_RATIO;

	case T_REAL:
	  if (real(y) == 0.0)
	    return(division_by_zero_error(sc, sc->remainder_symbol, args));
	  if ((is_inf(real(y))) || (is_NaN(real(y))))
	    return(wrong_type_argument_with_type(sc, sc->remainder_symbol, 2, y, a_normal_real_string));

	  pre_quo = (s7_double)integer(x) / real(y);
	  if ((pre_quo > s7_int_max) || (pre_quo < s7_int_min))
	    return(simple_out_of_range(sc, sc->remainder_symbol, args, its_too_large_string));
	  if (pre_quo > 0.0) quo = (s7_int)floor(pre_quo); else quo = (s7_int)ceil(pre_quo);
	  return(make_real(sc, integer(x) - real(y) * quo));

	default:
	  return(method_or_bust(sc, y, sc->remainder_symbol, args, T_REAL, 2));
	}

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	  n2 = integer(y);
 	  if (n2 == 0)
 	    return(division_by_zero_error(sc, sc->remainder_symbol, args));
	  n1 = numerator(x);
	  d1 = denominator(x);
	  d2 = 1;
	  goto RATIO_REM_RATIO;

	case T_RATIO:
	  n1 = numerator(x);
	  d1 = denominator(x);
	  n2 = numerator(y);
	  d2 = denominator(y);
	RATIO_REM_RATIO:
	  if (d1 == d2)
	    quo = (s7_int)(n1 / n2);
	  else
	    {
	      if (n1 == n2)
		quo = (s7_int)(d2 / d1);
	      else
		{
#if HAVE_OVERFLOW_CHECKS
		  s7_int n1d2, n2d1;
		  if ((multiply_overflow(n1, d2, &n1d2)) ||
		      (multiply_overflow(n2, d1, &n2d1)))
		    {
		      pre_quo = ((long_double)n1 / (long_double)n2) * ((long_double)d2 / (long_double)d1);
		      if ((pre_quo > s7_int_max) || (pre_quo < s7_int_min))
			return(simple_out_of_range(sc, sc->remainder_symbol, args, its_too_large_string));
		      if (pre_quo > 0.0) quo = (s7_int)floor(pre_quo); else quo = (s7_int)ceil(pre_quo);
		    }
		  else quo = n1d2 / n2d1;
#else
		  quo = (n1 * d2) / (n2 * d1);
#endif
		}
	    }
	  if (quo == 0)
	    return(x);

#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int dn, nq;
	    if (!multiply_overflow(n2, quo, &nq))
	      {
		if ((d1 == d2) &&
		    (!subtract_overflow(n1, nq, &dn)))
		  return(s7_make_ratio(sc, dn, d1));

		if ((!multiply_overflow(n1, d2, &dn)) &&
		    (!multiply_overflow(nq, d1, &nq)) &&
		    (!subtract_overflow(dn, nq, &nq)) &&
		    (!multiply_overflow(d1, d2, &d1)))
		  return(s7_make_ratio(sc, nq, d1));
	      }
	  }
#else
	  if (d1 == d2)
	    return(s7_make_ratio(sc, n1 - n2 * quo, d1));

	  return(s7_make_ratio(sc, n1 * d2 - n2 * d1 * quo, d1 * d2));
#endif
	  return(simple_out_of_range(sc, sc->remainder_symbol, args, wrap_string(sc, "intermediate (a/b) is too large", 31)));

	case T_REAL:
	  {
	    s7_double frac;
	    if (real(y) == 0.0)
	      return(division_by_zero_error(sc, sc->remainder_symbol, args));
	    if ((is_inf(real(y))) || (is_NaN(real(y))))
	      return(wrong_type_argument_with_type(sc, sc->remainder_symbol, 2, y, a_normal_real_string));
	    frac = (s7_double)fraction(x);
	    pre_quo = frac / real(y);
	    if ((pre_quo > s7_int_max) || (pre_quo < s7_int_min))
	      return(simple_out_of_range(sc, sc->remainder_symbol, args, its_too_large_string));
	    if (pre_quo > 0.0) quo = (s7_int)floor(pre_quo); else quo = (s7_int)ceil(pre_quo);
	    return(make_real(sc, frac - real(y) * quo));
	  }

	default:
	  return(method_or_bust(sc, y, sc->remainder_symbol, args, T_REAL, 2));
	}

    case T_REAL:
      if ((is_inf(real(x))) || (is_NaN(real(x))))
	return(wrong_type_argument_with_type(sc, sc->remainder_symbol, 1, x, a_normal_real_string));

      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(y) == 0)
	    return(division_by_zero_error(sc, sc->remainder_symbol, args));
	  pre_quo = real(x) / (s7_double)integer(y);
	  if ((pre_quo > s7_int_max) || (pre_quo < s7_int_min))
	    return(simple_out_of_range(sc, sc->remainder_symbol, args, its_too_large_string));
	  if (pre_quo > 0.0) quo = (s7_int)floor(pre_quo); else quo = (s7_int)ceil(pre_quo);
	  return(make_real(sc, real(x) - integer(y) * quo));
	  /* but... (remainder 1e+18 9223372036854775807) -> 1e+18 */

	case T_RATIO:
	  {
	    /* bad cases here start around 1e16: (remainder 1e15 3/13) -> 0.0 with loss of digits earlier
	     *   would long double help?
	     */
	    s7_double frac;
	    frac = (s7_double)fraction(y);
	    pre_quo = real(x) / frac;
	    if ((pre_quo > s7_int_max) || (pre_quo < s7_int_min))
	      return(simple_out_of_range(sc, sc->remainder_symbol, args, its_too_large_string));
	    if (pre_quo > 0.0) quo = (s7_int)floor(pre_quo); else quo = (s7_int)ceil(pre_quo);
	    return(make_real(sc, real(x) - frac * quo));
	  }

	case T_REAL:
	  return(make_real(sc, c_rem_dbl(sc, real(x), real(y))));

	  /* see under sin -- this calculation is completely bogus if "a" is large
	   * (quotient 1e22 (* 2 pi)) -> -9223372036854775808 -- should this return arithmetic-overflow?
	   *          but it should be 1591549430918953357688,
	   * (remainder 1e22 (* 2 pi)) -> 1.0057952155665e+22
	   * -- the "remainder" is greater than the original argument!
	   * Clisp gives 0.0 here, as does sbcl
	   * currently s7 throws an error (out-of-range).
	   */

	default:
	  return(method_or_bust(sc, y, sc->remainder_symbol, args, T_REAL, 2));
	}

    default:
      return(method_or_bust(sc, x, sc->remainder_symbol, args, T_REAL, 1));
    }
}


/* -------------------------------- floor -------------------------------- */

#define REAL_TO_INT_LIMIT 9.2233727815085e+18
/* unfortunately, this limit is only a max in a sense: (ceiling 9223372036854770.9) => 9223372036854770
 *    see s7test for more examples
 */

static s7_pointer g_floor(s7_scheme *sc, s7_pointer args)
{
  #define H_floor "(floor x) returns the integer closest to x toward -inf"
  #define Q_floor s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)

  s7_pointer x;

  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      return(x);

    case T_RATIO:
      {
	s7_int val;
	val = numerator(x) / denominator(x);
	/* C "/" truncates? -- C spec says "truncation toward 0" */
	/* we're avoiding "floor" here because the int->double conversion introduces inaccuracies for big numbers */
	if (numerator(x) < 0) /* not "val" because it might be truncated to 0 */
	  return(make_integer(sc, val - 1));
	return(make_integer(sc, val));
      }

    case T_REAL:
      {
	s7_double z;
	z = real(x);
	if (is_NaN(z))
	  return(simple_out_of_range(sc, sc->floor_symbol, x, its_nan_string));
	if (fabs(z) > REAL_TO_INT_LIMIT)
	  return(simple_out_of_range(sc, sc->floor_symbol, x, its_too_large_string));
	return(make_integer(sc, (s7_int)floor(z)));
	/* floor here rounds down, whereas a straight int<=real coercion apparently rounds towards 0 */
      }

    case T_COMPLEX:
    default:
      return(method_or_bust_one_arg(sc, x, sc->floor_symbol, args, T_REAL));
    }
}

static s7_int floor_i_i(s7_int i) {return(i);}

static s7_int floor_i_7d(s7_scheme *sc, s7_double x)
{

  if (is_NaN(x))
    simple_out_of_range(sc, sc->floor_symbol, wrap_real(sc, x), its_nan_string);
  if (fabs(x) > REAL_TO_INT_LIMIT)
    simple_out_of_range(sc, sc->floor_symbol, wrap_real(sc, x), its_too_large_string);
  return((s7_int)floor(x));
}

static s7_int floor_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (is_t_integer(p)) return(s7_integer(p));
  if (is_t_real(p)) return(floor_i_7d(sc, real(p)));
  if (is_t_ratio(p)) return((s7_int)(floor(fraction(p))));
  if (has_active_methods(sc, p))
    return(s7_integer(find_and_apply_method(sc, find_let(sc, p), sc->floor_symbol, list_1(sc, p))));
  s7_wrong_type_arg_error(sc, "floor", 0, p, "a real number");
  return(0);
}


/* -------------------------------- ceiling -------------------------------- */
static s7_pointer g_ceiling(s7_scheme *sc, s7_pointer args)
{
  #define H_ceiling "(ceiling x) returns the integer closest to x toward inf"
  #define Q_ceiling s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)

  s7_pointer x;

  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      return(x);

    case T_RATIO:
      {
	s7_int val;
	val = numerator(x) / denominator(x);
	if (numerator(x) < 0)
	  return(make_integer(sc, val));
	return(make_integer(sc, val + 1));
      }

    case T_REAL:
      {
	s7_double z;
	z = real(x);
	if (is_NaN(z))
	  return(simple_out_of_range(sc, sc->ceiling_symbol, x, its_nan_string));
	if ((is_inf(z)) ||
	    (z > REAL_TO_INT_LIMIT) ||
	    (z < -REAL_TO_INT_LIMIT))
	  return(simple_out_of_range(sc, sc->ceiling_symbol, x, its_too_large_string));
	return(make_integer(sc, (s7_int)ceil(real(x))));
      }

    case T_COMPLEX:
    default:
      return(method_or_bust_one_arg(sc, x, sc->ceiling_symbol, args, T_REAL));
    }
}

static s7_int ceiling_i_i(s7_int i) {return(i);}

static s7_int ceiling_i_7d(s7_scheme *sc, s7_double x)
{
  if (is_NaN(x))
    simple_out_of_range(sc, sc->ceiling_symbol, wrap_real(sc, x), its_nan_string);
  if ((is_inf(x)) ||
      (x > REAL_TO_INT_LIMIT) ||
      (x < -REAL_TO_INT_LIMIT))
    simple_out_of_range(sc, sc->ceiling_symbol, wrap_real(sc, x), its_too_large_string);
  return((s7_int)ceil(x));
}

static s7_int ceiling_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (is_t_integer(p)) return(s7_integer(p));
  if (is_t_real(p)) return(ceiling_i_7d(sc, real(p)));
  if (is_t_ratio(p)) return((s7_int)(ceil(fraction(p))));
  if (has_active_methods(sc, p))
    return(s7_integer(find_and_apply_method(sc, find_let(sc, p), sc->ceiling_symbol, list_1(sc, p))));
  s7_wrong_type_arg_error(sc, "ceiling", 0, p, "a real number");
  return(0);
}


/* -------------------------------- truncate -------------------------------- */
static s7_pointer g_truncate(s7_scheme *sc, s7_pointer args)
{
  #define H_truncate "(truncate x) returns the integer closest to x toward 0"
  #define Q_truncate s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      return(x);

    case T_RATIO:
      return(make_integer(sc, (s7_int)(numerator(x) / denominator(x)))); /* C "/" already truncates */

    case T_REAL:
      {
	s7_double z;
	z = real(x);
	if (is_NaN(z))
	  return(simple_out_of_range(sc, sc->truncate_symbol, x, its_nan_string));
	if (is_inf(z))
	  return(simple_out_of_range(sc, sc->truncate_symbol, x, its_infinite_string));
	return(s7_truncate(sc, sc->truncate_symbol, real(x)));
      }

    case T_COMPLEX:
    default:
      return(method_or_bust_one_arg(sc, x, sc->truncate_symbol, args, T_REAL));
    }
}

static s7_int truncate_i_i(s7_int i) {return(i);}

static s7_int truncate_i_7d(s7_scheme *sc, s7_double x)
{
  if (is_NaN(x))
    simple_out_of_range(sc, sc->truncate_symbol, wrap_real(sc, x), its_nan_string);
  if (is_inf(x))
    simple_out_of_range(sc, sc->truncate_symbol, wrap_real(sc, x), its_infinite_string);
  if (x > 0.0)
    {
      if (x > s7_int_max)
	simple_out_of_range(sc, sc->truncate_symbol, wrap_real(sc, x), its_too_large_string);
      return((s7_int)floor(x));
    }
  if (x < s7_int_min)
    simple_out_of_range(sc, sc->truncate_symbol, wrap_real(sc, x), its_too_large_string);
  return((s7_int)ceil(x));
}


/* -------------------------------- round -------------------------------- */
static s7_double r5rs_round(s7_double x)
{
  s7_double fl, ce, dfl, dce;

  fl = floor(x);
  ce = ceil(x);
  dfl = x - fl;
  dce = ce - x;

  if (dfl > dce) return(ce);
  if (dfl < dce) return(fl);
  if (fmod(fl, 2.0) == 0.0) return(fl);
  return(ce);
}

static s7_pointer g_round(s7_scheme *sc, s7_pointer args)
{
  #define H_round "(round x) returns the integer closest to x"
  #define Q_round s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
      return(x);

    case T_RATIO:
      {
	s7_int truncated, remains;
	long double frac;

	truncated = numerator(x) / denominator(x);
	remains = numerator(x) % denominator(x);
	frac = s7_fabsl((long_double)remains / (long_double)denominator(x));

	if ((frac > 0.5) ||
	    ((frac == 0.5) &&
	     (truncated % 2 != 0)))
	  {
	    if (numerator(x) < 0)
	      return(make_integer(sc, truncated - 1));
	    return(make_integer(sc, truncated + 1));
	  }
	return(make_integer(sc, truncated));
      }

    case T_REAL:
      {
	s7_double z;
	z = real(x);
	if (is_NaN(z))
	  return(simple_out_of_range(sc, sc->round_symbol, x, its_nan_string));
	if ((is_inf(z)) ||
	    (z > REAL_TO_INT_LIMIT) ||
	    (z < -REAL_TO_INT_LIMIT))
	  return(simple_out_of_range(sc, sc->round_symbol, x, its_too_large_string));
	return(make_integer(sc, (s7_int)r5rs_round(z)));
      }

    case T_COMPLEX:
    default:
      return(method_or_bust_one_arg(sc, x, sc->round_symbol, args, T_REAL));
    }
}

static s7_int round_i_i(s7_int i) {return(i);}

static s7_int round_i_7d(s7_scheme *sc, s7_double z)
{
  if (is_NaN(z))
    simple_out_of_range(sc, sc->round_symbol, wrap_real(sc, z), its_nan_string);
  if ((is_inf(z)) ||
      (z > REAL_TO_INT_LIMIT) ||
      (z < -REAL_TO_INT_LIMIT))
    simple_out_of_range(sc, sc->round_symbol, wrap_real(sc, z), its_too_large_string);
  return((s7_int)r5rs_round(z));
}


/* -------------------------------- modulo -------------------------------- */
static s7_int c_mod(s7_int x, s7_int y)
{
  s7_int z;
  if (y == 0) return(x);     /* else arithmetic exception */
  if ((y == 1) || (y == -1)) /* else (modulo most-negative-fixnum -1) will segfault with arithmetic exception */
    return(0);
  z = x % y;
  if (((y < 0) && (z > 0)) ||
      ((y > 0) && (z < 0)))
    return(z + y);
  return(z);
}

static s7_int modulo_i_ii(s7_int i1, s7_int i2) {return(c_mod(i1, i2));}
static s7_int modulo_i_ii_direct(s7_int i1, s7_int i2)
{
  /* i2 > 1 */
  s7_int z;
  z = i1 % i2;
  if (z < 0)
    return(z + i2);
  return(z);
}
static s7_double modulo_d_dd(s7_double x1, s7_double x2) {return(x1 - x2 * (s7_int)floor(x1 / x2));}

static s7_pointer g_modulo(s7_scheme *sc, s7_pointer args)
{
  #define H_modulo "(modulo x1 x2) returns x1 mod x2; (modulo 4 3) = 1.  The arguments can be real numbers."
  #define Q_modulo sc->pcl_r
  /* (define (mod x1 x2) (- x1 (* x2 (floor (/ x1 x2))))) from slib
   * (mod x 0) = x according to "Concrete Mathematics"
   */
  s7_pointer x, y;
  s7_double a, b;
  s7_int n1, n2, d1, d2;

  x = car(args);
  y = cadr(args);

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  return(make_integer(sc, c_mod(integer(x), integer(y))));

	case T_RATIO:
	  n1 = integer(x);
	  d1 = 1;
	  n2 = numerator(y);
	  d2 = denominator(y);
	  goto RATIO_MOD_RATIO;

	case T_REAL:
	  {
	    double c;
	    b = real(y);
	    if (b == 0.0) return(x);
	    if (is_NaN(b)) return(y);
	    if (is_inf(b)) return(real_NaN);
	    a = (s7_double)integer(x);
	    c = a / b;
	    if ((c > 1e19) || (c < -1e19))
	      return(simple_out_of_range(sc, sc->modulo_symbol, y, wrap_string(sc, "intermediate (a/b) is too large", 31)));
	    return(make_real(sc, a - b * (s7_int)floor(c)));
	  }

	default:
	  return(method_or_bust(sc, y, sc->modulo_symbol, args, T_REAL, 2));
	}

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(y) == 0) return(x);
	  n1 = numerator(x);
	  d1 = denominator(x);
	  n2 = integer(y);

	  if ((n2 > 0) && (n1 > 0) && (n2 > n1)) return(x);
	  if ((n2 < 0) && (n1 < 0) && (n2 < n1)) return(x);

	  if (n2 == s7_int_min)
	    return(simple_out_of_range(sc, sc->modulo_symbol, y, wrap_string(sc, "intermediate (a/b) is too large", 31)));
	  /* the problem here is that (modulo 3/2 most-negative-fixnum)
	   * will segfault with signal SIGFPE, Arithmetic exception, so try to trap it.
	   */

	  d2 = 1;
	  goto RATIO_MOD_RATIO;

	case T_RATIO:
	  n1 = numerator(x);
	  d1 = denominator(x);
	  n2 = numerator(y); /* can't be 0 */
	  d2 = denominator(y);
	  if (d1 == d2)
	    return(s7_make_ratio(sc, c_mod(n1, n2), d1));

	RATIO_MOD_RATIO:

	  if ((n1 == n2) &&
	      (d1 > d2))
	    return(x);                 /* signs match so this should be ok */
#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int n2d1, n1d2, d1d2, fl;
	    if (!multiply_overflow(n2, d1, &n2d1))
	      {
		if (n2d1 == 1)
		  return(small_int(0));

		if (!multiply_overflow(n1, d2, &n1d2))
		  {
		    /* can't use "floor" here (int->float ruins everything) */
		    fl = (s7_int)(n1d2 / n2d1);
		    if (((n1 < 0) && (n2 > 0)) ||
			((n1 > 0) && (n2 < 0)))
		      fl -= 1;

		    if (fl == 0)
		      return(x);

		    if ((!multiply_overflow(d1, d2, &d1d2)) &&
			(!multiply_overflow(fl, n2d1, &fl)) &&
			(!subtract_overflow(n1d2, fl, &fl)))
		      return(s7_make_ratio(sc, fl, d1d2));
		  }
	      }
	  }
#else
	  {
	    s7_int n1d2, n2d1, fl;
	    n1d2 = n1 * d2;
	    n2d1 = n2 * d1;

	    if (n2d1 == 1)
	      return(small_int(0));

	    /* can't use "floor" here (int->float ruins everything) */
	    fl = (s7_int)(n1d2 / n2d1);
	    if (((n1 < 0) && (n2 > 0)) ||
		((n1 > 0) && (n2 < 0)))
	      fl -= 1;

	    if (fl == 0)
	      return(x);

	    return(s7_make_ratio(sc, n1d2 - (n2d1 * fl), d1 * d2));
	  }
#endif

	  /* there are cases here we might want to catch:
	   *    (modulo 9223372036 1/9223372036) -> error, not 0?
	   *    (modulo 1 1/9223372036854775807) -> error, not 0?
	   */
	  return(simple_out_of_range(sc, sc->modulo_symbol, x, wrap_string(sc, "intermediate (a/b) is too large", 31)));

	case T_REAL:
	  b = real(y);
	  if (b == 0.0) return(x);
	  if (is_NaN(b)) return(y);
	  if (is_inf(b)) return(real_NaN);
	  a = fraction(x);
	  return(make_real(sc, a - b * (s7_int)floor(a / b)));

	default:
	  return(method_or_bust(sc, y, sc->modulo_symbol, args, T_REAL, 2));
	}

    case T_REAL:
      a = real(x);

      switch (type(y))
	{
	case T_INTEGER:
	  if (is_NaN(a)) return(x);
	  if (is_inf(a)) return(real_NaN);
	  if (integer(y) == 0) return(x);
	  b = (s7_double)integer(y);
	  return(make_real(sc, a - b * (s7_int)floor(a / b)));

	case T_RATIO:
	  if (is_NaN(a)) return(x);
	  if (is_inf(a)) return(real_NaN);
	  b = fraction(y);
	  return(make_real(sc, a - b * (s7_int)floor(a / b)));

	case T_REAL:
	  {
	    s7_double c;
	    if (is_NaN(a)) return(x);
	    if (is_inf(a)) return(real_NaN);
	    b = real(y);
	    if (b == 0.0) return(x);
	    if (is_NaN(b)) return(y);
	    if (is_inf(b)) return(real_NaN);
	    c = a / b;
	    if ((c > 1e19) || (c < -1e19))
	      return(simple_out_of_range(sc, sc->modulo_symbol, y, wrap_string(sc, "intermediate (a/b) is too large", 31)));
	    return(make_real(sc, a - b * (s7_int)floor(c)));
	  }

	default:
	  return(method_or_bust(sc, y, sc->modulo_symbol, args, T_REAL, 2));
	}

    default:
      return(method_or_bust(sc, x, sc->modulo_symbol, args, T_REAL, 1));
    }
}

static s7_pointer g_mod_si(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  s7_int y;

  x = lookup(sc, car(args));
  y = integer(cadr(args));

  if (is_t_integer(x))
    {
      s7_int z;
      /* here we know y is positive */
      z = integer(x) % y;
      if (z < 0)
	return(make_integer(sc, z + y));
      return(make_integer(sc, z));
    }

  if (is_t_real(x))
    {
      s7_double a, b, c;
      a = real(x);
      if (is_NaN(a)) return(x);
      if (is_inf(a)) return(real_NaN);
      b = (s7_double)y;
      c = a / b;
      if ((c > 1e19) || (c < -1e19))
	return(simple_out_of_range(sc, sc->modulo_symbol, make_real(sc, c), wrap_string(sc, "intermediate (a/b) is too large", 31)));
      return(make_real(sc, a - b * (s7_int)floor(c)));
    }

  if (s7_is_ratio(x))
    return(g_modulo(sc, set_plist_2(sc, x, cadr(args))));

  return(method_or_bust(sc, x, sc->modulo_symbol, list_2(sc, x, cadr(args)), T_REAL, 1));
}
#endif
/* !WITH_GMP */


static int32_t reduce_fraction(s7_int *numer, s7_int *denom)
{
  /* we're assuming in several places that we have a normal s7 rational after returning,
   *    so the denominator needs to be positive.
   */
  s7_int divisor;

  if (*numer == 0)
    {
      *denom = 1;
      return(T_INTEGER);
    }
  if (*denom < 0)
    {
      if (*denom == *numer)
	{
	  *denom = 1;
	  *numer = 1;
	  return(T_INTEGER);
	}
      if (*denom == s7_int_min)
	{
	  if (*numer & 1)
	    return(T_RATIO);
	  *denom /= 2;
	  *numer /= 2;
	}
      else
	{
	  if (*numer == s7_int_min)
	    {
	      if (*denom & 1)
		return(T_RATIO);
	      *denom /= 2;
	      *numer /= 2;
	    }
	}
      *denom = -*denom;
      *numer = -*numer;
    }
  divisor = c_gcd(*numer, *denom);
  if (divisor != 1)
    {
      *numer /= divisor;
      *denom /= divisor;
    }
  if (*denom == 1)
    return(T_INTEGER);
  return(T_RATIO);
}


/* ---------------------------------------- add ---------------------------------------- */

static s7_pointer g_add(s7_scheme *sc, s7_pointer args)
{
  #define H_add "(+ ...) adds its arguments"
  #define Q_add sc->pcl_n
  s7_pointer x, p;
  s7_int num_a, den_a, dn;
  s7_double rl_a, im_a;

#if (!WITH_GMP)
  if (is_null(args))
    return(small_int(0));
#endif

  x = car(args);
  p = cdr(args);
  if (is_null(p))
    {
      if (!is_number(x))
	return(method_or_bust_with_type_one_arg(sc, x, sc->add_symbol, args, a_number_string));
      return(x);
    }

  switch (type(x))
    {
    case T_INTEGER:
      num_a = integer(x);

    ADD_INTEGERS:
#if WITH_GMP
      if ((num_a > s7_int32_max) ||
	  (num_a < s7_int32_min))
	return(big_add(sc, cons(sc, s7_int_to_big_integer(sc, num_a), p)));
#endif
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
#if HAVE_OVERFLOW_CHECKS
	  if (add_overflow(num_a, integer(x), &den_a))
	    {
	      rl_a = (s7_double)num_a + (s7_double)integer(x);
	      if (is_null(p)) return(make_real(sc, rl_a));
	      goto ADD_REALS;
	    }
#else
	  den_a = num_a + integer(x);
	  if (den_a < 0)
	    {
	      if ((num_a > 0) && (integer(x) > 0))
		{
		  rl_a = (s7_double)num_a + (s7_double)integer(x);
		  if (is_null(p)) return(make_real(sc, rl_a));
		  goto ADD_REALS;
		}
	    }
	  else
	    {
	      if ((num_a < 0) && (integer(x) < 0))
		{
		  rl_a = (s7_double)num_a + (s7_double)integer(x);
		  if (is_null(p)) return(make_real(sc, rl_a));
		  /* this is not ideal!  piano.scm has its own noise generator that wants integer
		   *    arithmetic to overflow as an integer.  Perhaps 'safety==0 would not check anywhere?
		   */
		  goto ADD_REALS;
		}
	    }
#endif
	  if (is_null(p)) return(make_integer(sc, den_a));
	  num_a = den_a;
	  /* (+ 4611686018427387904 4611686018427387904) -> -9223372036854775808
	   * (+ most-positive-fixnum most-positive-fixnum) -> -2
	   * (+ most-negative-fixnum most-negative-fixnum) -> 0
	   * can't check result - arg: (- 0 most-negative-fixnum) -> most-negative-fixnum
	   */
	  goto ADD_INTEGERS;

	case T_RATIO:
	  den_a = denominator(x);
#if HAVE_OVERFLOW_CHECKS
	  if ((multiply_overflow(den_a, num_a, &dn)) ||
	      (add_overflow(dn, numerator(x), &dn)))
	    {
	      if (is_null(p))
		{
		  if (num_a == 0)                /* (+ 0 1/9223372036854775807) */
		    return(x);
		  return(make_real(sc, num_a + fraction(x)));
		}
	      rl_a = (s7_double)num_a + fraction(x);
	      goto ADD_REALS;
	    }
#else
	  dn = numerator(x) + (num_a * den_a);
#endif
	  if (is_null(p)) return(s7_make_ratio(sc, dn, den_a));
	  num_a = dn;

	  /* overflow examples:
	   *   (+ 100000 1/142857142857140) -> -832205957599110323/28571428571428
	   *   (+ 4611686018427387904 3/4) -> 3/4
	   * see s7test for more
	   */
	  goto ADD_RATIOS;

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, num_a + real(x)));
	  rl_a = (s7_double)num_a + real(x);
	  goto ADD_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, num_a + real_part(x), imag_part(x)));
	  rl_a = (s7_double)num_a + real_part(x);
	  im_a = imag_part(x);
	  goto ADD_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->add_symbol, cons_unchecked(sc, s7_make_integer(sc, num_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_RATIO:
      num_a = numerator(x);
      den_a = denominator(x);
    ADD_RATIOS:
#if WITH_GMP
      if ((num_a > s7_int32_max) ||
	  (den_a > s7_int32_max) ||
	  (num_a < s7_int32_min))
	return(big_add(sc, cons(sc, s7_ratio_to_big_ratio(sc, num_a, den_a), p)));
#endif
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
#if HAVE_OVERFLOW_CHECKS
	  if ((multiply_overflow(den_a, integer(x), &dn)) ||
	      (add_overflow(dn, num_a, &dn)))
	    {
	      /* (+ 3/4 4611686018427387904) -> 3/4
	       * (+ 1/17179869184 1073741824) -> 1/17179869184
	       * (+ 1/8589934592 1073741824) -> -9223372036854775807/8589934592
	       */
	      if (is_null(p))
		return(make_real(sc, (s7_double)integer(x) + ((long_double)num_a / (long_double)den_a)));
	      rl_a = (s7_double)integer(x) + ((long_double)num_a / (long_double)den_a);
	      goto ADD_REALS;
	    }
#else
	  dn = num_a + (integer(x) * den_a);
#endif
	  if (is_null(p)) return(s7_make_ratio(sc, dn, den_a));
	  num_a = dn;
	  if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	    goto ADD_INTEGERS;
	  goto ADD_RATIOS;

	case T_RATIO:
	  {
	    s7_int d1, d2, n1, n2;
	    d1 = den_a;
	    n1 = num_a;
	    d2 = denominator(x);
	    n2 = numerator(x);
	    if (d1 == d2)                                     /* the easy case -- if overflow here, it matches the int32_t case */
	      {
		if (is_null(p))
		  return(s7_make_ratio(sc, n1 + n2, d1));
		num_a += n2;                  /* d1 can't be zero */
	      }
	    else
	      {
#if (!WITH_GMP)
#if HAVE_OVERFLOW_CHECKS
		s7_int n1d2, n2d1;
		if ((multiply_overflow(d1, d2, &den_a)) ||
		    (multiply_overflow(n1, d2, &n1d2)) ||
		    (multiply_overflow(n2, d1, &n2d1)) ||
		    (add_overflow(n1d2, n2d1, &num_a)))
		  {
		    if (is_null(p))
		      return(make_real(sc, ((long_double)n1 / (long_double)d1) + ((long_double)n2 / (long_double)d2)));
		    rl_a = ((long_double)n1 / (long_double)d1) + ((long_double)n2 / (long_double)d2);
		    goto ADD_REALS;
		  }
#else
		num_a = n1 * d2 + n2 * d1;
		den_a = d1 * d2;
#endif
#else
		num_a = n1 * d2 + n2 * d1;
		den_a = d1 * d2;
#endif
		if (is_null(p))
		  return(s7_make_ratio(sc, num_a, den_a));
	      }
	    /* (+ 1/100 99/100 (- most-positive-fixnum 2)) should not be converted to real */
	    if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	    goto ADD_INTEGERS;
	  goto ADD_RATIOS;
	  }

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, ((long_double)num_a / (long_double)den_a) + real(x)));
	  rl_a = ((long_double)num_a / (long_double)den_a) + real(x);
	  goto ADD_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, ((long_double)num_a / (long_double)den_a) + real_part(x), imag_part(x)));
	  rl_a = ((long_double)num_a / (long_double)den_a) + real_part(x);
	  im_a = imag_part(x);
	  goto ADD_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->add_symbol, cons_unchecked(sc, s7_make_ratio(sc, num_a, den_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_REAL:
      rl_a = real(x);

    ADD_REALS:
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
	  if (is_null(p)) return(make_real(sc, rl_a + integer(x)));
	  rl_a += (s7_double)integer(x);
	  goto ADD_REALS;

	case T_RATIO:
	  if (is_null(p)) return(make_real(sc, rl_a + fraction(x)));
	  rl_a += (s7_double)fraction(x);
	  goto ADD_REALS;

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, rl_a + real(x)));
	  rl_a += real(x);
	  goto ADD_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a + real_part(x), imag_part(x)));
	  rl_a += real_part(x);
	  im_a = imag_part(x);
	  goto ADD_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->add_symbol, cons_unchecked(sc, make_real(sc, rl_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_COMPLEX:
      rl_a = real_part(x);
      im_a = imag_part(x);

    ADD_COMPLEX:
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a + integer(x), im_a));
	  rl_a += (s7_double)integer(x);
	  goto ADD_COMPLEX;

	case T_RATIO:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a + fraction(x), im_a));
	  rl_a += (s7_double)fraction(x);
	  goto ADD_COMPLEX;

	case T_REAL:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a + real(x), im_a));
	  rl_a += real(x);
	  goto ADD_COMPLEX;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a + real_part(x), im_a + imag_part(x)));
	  rl_a += real_part(x);
	  im_a += imag_part(x);
	  if (im_a == 0.0)
	    goto ADD_REALS;
	  goto ADD_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->add_symbol, cons_unchecked(sc, s7_make_complex(sc, rl_a, im_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    default:
      return(method_or_bust_with_type(sc, x, sc->add_symbol, args, a_number_string, 1));
    }
  return(NULL); /* make the compiler happy */
}

static s7_pointer add_ratios_1(s7_scheme *sc, s7_int n1, s7_int d1, s7_int n2, s7_int d2)
{
  if (d1 == d2)                                     /* the easy case -- if overflow here, it matches the int case */
    return(s7_make_ratio(sc, n1 + n2, d1));

#if HAVE_OVERFLOW_CHECKS
  {
    s7_int n1d2, n2d1, d1d2, dn;
    if ((multiply_overflow(d1, d2, &d1d2)) ||
	(multiply_overflow(n1, d2, &n1d2)) ||
	(multiply_overflow(n2, d1, &n2d1)) ||
	(add_overflow(n1d2, n2d1, &dn)))
      return(make_real(sc, ((long_double)n1 / (long_double)d1) + ((long_double)n2 / (long_double)d2)));
    return(s7_make_ratio(sc, dn, d1d2));
  }
#else
  return(s7_make_ratio(sc, n1 * d2 + n2 * d1, d1 * d2));
#endif
}

static s7_pointer add_ratios(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  return(add_ratios_1(sc, number_to_numerator(x), number_to_denominator(x), number_to_numerator(y), number_to_denominator(y)));
}

static s7_pointer add_out_x(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, x))
    return(find_and_apply_method(sc, find_let(sc, x), sc->add_symbol, list_2(sc, x, y)));
  return(wrong_type_argument_with_type(sc, sc->add_symbol, 1, x, a_number_string));
}

static s7_pointer add_out_y(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, y))
    return(find_and_apply_method(sc, find_let(sc, y), sc->add_symbol, list_2(sc, x, y)));
  return(wrong_type_argument_with_type(sc, sc->add_symbol, 2, y, a_number_string));
}

static inline s7_pointer add_p_pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (type(x) == type(y))
    {
      if (is_t_real(x))
	return(make_real(sc, real(x) + real(y)));

      switch (type(x))
	{
#if HAVE_OVERFLOW_CHECKS
	case T_INTEGER:
	  {
	    s7_int val;
	    if (add_overflow(integer(x), integer(y), &val))
	      return(make_real(sc, (double)integer(x) + (double)integer(y)));
	    return(make_integer(sc, val));
	  }
#else
	case T_INTEGER: return(make_integer(sc, integer(x) + integer(y)));
#endif
	case T_RATIO:   return(add_ratios(sc, x, y));
	case T_REAL:    return(make_real(sc, real(x) + real(y)));
	case T_COMPLEX: return(make_complex(sc, real_part(x) + real_part(y), imag_part(x) + imag_part(y)));
	default:
	  if (!is_number(x))
	    return(add_out_x(sc, x, y));
	  return(add_out_y(sc, x, y));
	}
    }

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER: return(make_integer(sc, integer(x) + integer(y)));
	case T_RATIO:   return(add_ratios(sc, x, y));
	case T_REAL:    return(make_real(sc, integer(x) + real(y)));
	case T_COMPLEX: return(make_complex(sc, integer(x) + real_part(y), imag_part(y)));
	default:
	  return(add_out_y(sc, x, y));
	}

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	case T_RATIO:   return(add_ratios(sc, x, y));
	case T_REAL:    return(make_real(sc, fraction(x) + real(y)));
	case T_COMPLEX: return(s7_make_complex(sc, fraction(x) + real_part(y), imag_part(y)));
	default:
	  return(add_out_y(sc, x, y));
	}

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER: return(make_real(sc, real(x) + integer(y)));
	case T_RATIO:   return(make_real(sc, real(x) + fraction(y)));
	case T_REAL:    return(make_real(sc, real(x) + real(y)));
	case T_COMPLEX: return(make_complex(sc, real(x) + real_part(y), imag_part(y)));
	default:
	  return(add_out_y(sc, x, y));
	}

    case T_COMPLEX:
      switch (type(y))
	{
	case T_INTEGER: return(s7_make_complex(sc, real_part(x) + integer(y), imag_part(x)));
	case T_RATIO:   return(s7_make_complex(sc, real_part(x) + fraction(y), imag_part(x)));
	case T_REAL:    return(s7_make_complex(sc, real_part(x) + real(y), imag_part(x)));
	case T_COMPLEX: return(make_complex(sc, real_part(x) + real_part(y), imag_part(x) + imag_part(y)));
	default:
	  return(add_out_y(sc, x, y));
	}

    default:
      return(add_out_x(sc, x, y));
    }
  return(x);
}

static s7_pointer g_add_2(s7_scheme *sc, s7_pointer args) {return(add_p_pp(sc, car(args), cadr(args)));}

static s7_pointer g_add_s1_1(s7_scheme *sc, s7_pointer x, s7_pointer args)
{
  switch (type(x))
    {
#if HAVE_OVERFLOW_CHECKS
    case T_INTEGER:
      {
	s7_int val;
	if (add_overflow(integer(x), 1, &val))
	  return(make_real(sc, (double)integer(x) + 1.0));
	return(make_integer(sc, val));
      }
#else
    case T_INTEGER: return(make_integer(sc, integer(x) + 1));
#endif
    case T_RATIO:   return(add_ratios(sc, x, small_int(1)));
    case T_REAL:    return(make_real(sc, real(x) + 1.0));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) + 1.0, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->add_symbol, cons(sc, x, cdr(args)), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_add_s1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  x = car(args);
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + 1));
  return(g_add_s1_1(sc, x, args));
}

static s7_pointer g_add_cs1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  x = lookup(sc, car(args));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + 1));
  return(g_add_s1_1(sc, x, args));
}

static s7_pointer g_add_1s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;

  x = cadr(args);
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + 1));

  switch (type(x))
    {
    case T_INTEGER: return(make_integer(sc, integer(x) + 1));
    case T_RATIO:   return(add_ratios(sc, x, small_int(1)));
    case T_REAL:    return(make_real(sc, real(x) + 1.0));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) + 1.0, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->add_symbol, args, a_number_string, 2));
    }
  return(x);
}

static s7_pointer g_add_sis(s7_scheme *sc, s7_pointer x, s7_int y)
{
  switch (type(x))
    {
    case T_INTEGER:
#if HAVE_OVERFLOW_CHECKS
      {
	s7_int val;
	if (add_overflow(integer(x), y, &val))
	  return(make_real(sc, (double)integer(x) + (double)y));
	return(make_integer(sc, val));
      }
#else
      return(make_integer(sc, integer(x) + y));
#endif
    case T_RATIO:   return(add_ratios_1(sc, numerator(x), denominator(x), y, 1));
    case T_REAL:    return(make_real(sc, real(x) + y));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) + y, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->add_symbol, list_2(sc, x, make_integer(sc, y)), a_number_string, 1));
    }
  return(x);

}

static s7_pointer g_add_si(s7_scheme *sc, s7_pointer args) {return(g_add_sis(sc, lookup(sc, car(args)), integer(cadr(args))));}

static s7_pointer g_add_sfs(s7_scheme *sc, s7_pointer x, s7_double y)
{
  switch (type(x))
    {
    case T_INTEGER: return(make_real(sc, integer(x) + y));
    case T_RATIO:   return(make_real(sc, fraction(x) + y));
    case T_REAL:    return(make_real(sc, real(x) + y));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) + y, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->add_symbol, list_2(sc, x, make_real(sc, y)), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_add_sf(s7_scheme *sc, s7_pointer args) {return(g_add_sfs(sc, lookup(sc, car(args)), real(cadr(args))));}
static s7_pointer g_add_fs(s7_scheme *sc, s7_pointer args) {return(g_add_sfs(sc, lookup(sc, cadr(args)), real(car(args))));}

static s7_pointer g_add_f_sf(s7_scheme *sc, s7_pointer args)
{
  /* (+ x (* s y)) */
  s7_pointer vargs, s;
  s7_double x, y;

  x = real(car(args));
  vargs = cdadr(args);
  s = lookup(sc, car(vargs));
  y = real(cadr(vargs));

  if (is_t_real(s))
    return(make_real(sc, x + (real(s) * y)));

  switch (type(s))
    {
    case T_INTEGER: return(make_real(sc, x + (integer(s) * y)));
    case T_RATIO:   return(make_real(sc, x + (fraction(s) * y)));
    case T_REAL:    return(make_real(sc, x + real(s) * y));
    case T_COMPLEX: return(s7_make_complex(sc, x + (real_part(s) * y), imag_part(s) * y));
    default:
      {
	s7_pointer func;
	if ((func = find_method(sc, find_let(sc, s), sc->multiply_symbol)) != sc->undefined)
	  return(add_p_pp(sc, car(args), s7_apply_function(sc, func, list_2(sc, s, cadr(vargs)))));
	return(wrong_type_argument_with_type(sc, sc->multiply_symbol, 1, s, a_number_string));
      }
    }
  return(s);
}

#if (!WITH_GMP)
static s7_pointer g_add_2_ff(s7_scheme *sc, s7_pointer args) {return(make_real(sc, real(car(args)) + real(cadr(args))));}
static s7_pointer g_add_2_ii(s7_scheme *sc, s7_pointer args)
{
#if HAVE_OVERFLOW_CHECKS
  s7_int val, x, y;
  x = integer(car(args));
  y = integer(cadr(args));
  if (add_overflow(x, y, &val))
    return(make_real(sc, (double)x + (double)y));
  return(make_integer(sc, val));
#else
  return(make_integer(sc, integer(car(args)) + integer(cadr(args))));
#endif
}

static s7_pointer g_add_2_if(s7_scheme *sc, s7_pointer args) {return(make_real(sc, integer(car(args)) + real(cadr(args))));}
static s7_pointer g_add_2_fi(s7_scheme *sc, s7_pointer args) {return(make_real(sc, real(car(args)) + integer(cadr(args))));}

static s7_pointer g_add_2_xi(s7_scheme *sc, s7_pointer args) {return(g_add_sis(sc, car(args), integer(cadr(args))));}
static s7_pointer g_add_2_ix(s7_scheme *sc, s7_pointer args) {return(g_add_sis(sc, cadr(args), integer(car(args))));}
static s7_pointer g_add_2_xf(s7_scheme *sc, s7_pointer args) {return(g_add_sfs(sc, car(args), real(cadr(args))));}
static s7_pointer g_add_2_fx(s7_scheme *sc, s7_pointer args) {return(g_add_sfs(sc, cadr(args), real(car(args))));}

static s7_pointer add_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_real(sc, x1 + x2));}
/* add_p_ii and add_d_id unhittable apparently */
#endif

static s7_double add_d_d(s7_double x) {return(x);}
static s7_double add_d_dd(s7_double x1, s7_double x2) {return(x1 + x2);}
static s7_double add_d_ddd(s7_double x1, s7_double x2, s7_double x3) {return(x1 + x2 + x3);}
static s7_double add_d_dddd(s7_double x1, s7_double x2, s7_double x3, s7_double x4) {return(x1 + x2 + x3 + x4);}

static s7_int add_i_ii(s7_int i1, s7_int i2) {return(i1 + i2);}
static s7_int add_i_iii(s7_int i1, s7_int i2, s7_int i3) {return(i1 + i2 + i3);}


/* ---------------------------------------- subtract ---------------------------------------- */

static s7_pointer g_subtract(s7_scheme *sc, s7_pointer args)
{
  #define H_subtract "(- x1 ...) subtracts its trailing arguments from the first, or negates the first if only one it is given"
  #define Q_subtract sc->pcl_n

  s7_pointer x, p;
  s7_int num_a, den_a;
  s7_double rl_a, im_a;

  x = car(args);
  p = cdr(args);

#if (!WITH_GMP)
  if (is_null(p))
    {
      if (!is_number(x))
	return(method_or_bust_with_type_one_arg(sc, x, sc->subtract_symbol, args, a_number_string));
      return(s7_negate(sc, x));
    }
#endif

  switch (type(x))
    {
    case T_INTEGER:
      num_a = integer(x);

    SUBTRACT_INTEGERS:
#if WITH_GMP
      if ((num_a > s7_int32_max) ||
	  (num_a < s7_int32_min))
	return(big_subtract(sc, cons(sc, s7_int_to_big_integer(sc, num_a), p)));
#endif
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
#if HAVE_OVERFLOW_CHECKS
	  if (subtract_overflow(num_a, integer(x), &den_a))
	    {
	      rl_a = (s7_double)num_a - (s7_double)integer(x);
	      if (is_null(p)) return(make_real(sc, rl_a));
	      goto SUBTRACT_REALS;
	    }
#else
	  den_a = num_a - integer(x);
	  if (den_a < 0)
	    {
	      if ((num_a > 0) && (integer(x) < 0))
		{
		  rl_a = (s7_double)num_a - (s7_double)integer(x);
		  if (is_null(p)) return(make_real(sc, rl_a));
		  goto SUBTRACT_REALS;
		}
	      /* (- most-positive-fixnum most-negative-fixnum) -> -1 (1.8446744073709551615E19) */
	    }
	  else
	    {
	      if ((num_a < 0) && (integer(x) > 0))
		{
		  rl_a = (s7_double)num_a - (s7_double)integer(x);
		  if (is_null(p)) return(make_real(sc, rl_a));
		  goto SUBTRACT_REALS;
		}
	      /* (- most-negative-fixnum most-positive-fixnum) -> 1 (-1.8446744073709551615E19) */
	    }
#endif
	  if (is_null(p)) return(make_integer(sc, den_a));
	  num_a = den_a;
	  goto SUBTRACT_INTEGERS;

	case T_RATIO:
	  {
	    s7_int dn;
	    den_a = denominator(x);
#if HAVE_OVERFLOW_CHECKS
	    if ((multiply_overflow(num_a, den_a, &dn)) ||
		(subtract_overflow(dn, numerator(x), &dn)))
	      {
		if (is_null(p)) return(make_real(sc, num_a - fraction(x)));
		rl_a = (s7_double)num_a - fraction(x);
		goto SUBTRACT_REALS;
	      }
#else
	    dn = (num_a * den_a) - numerator(x);
#endif
	    if (is_null(p)) return(s7_make_ratio(sc, dn, den_a));
	    num_a = dn;
	    if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	      goto SUBTRACT_INTEGERS;
	    goto SUBTRACT_RATIOS;
	  }

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, num_a - real(x)));
	  rl_a = (s7_double)num_a - real(x);
	  goto SUBTRACT_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, num_a - real_part(x), -imag_part(x)));
	  rl_a = (s7_double)num_a - real_part(x);
	  im_a = -imag_part(x);
	  goto SUBTRACT_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->subtract_symbol, cons_unchecked(sc, s7_make_integer(sc, num_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_RATIO:
      num_a = numerator(x);
      den_a = denominator(x);
    SUBTRACT_RATIOS:
#if WITH_GMP
      if ((num_a > s7_int32_max) ||
	  (den_a > s7_int32_max) ||
	  (num_a < s7_int32_min))
	return(big_subtract(sc, cons(sc, s7_ratio_to_big_ratio(sc, num_a, den_a), p)));
#endif
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int di;
	    if ((multiply_overflow(den_a, integer(x), &di)) ||
		(subtract_overflow(num_a, di, &di)))
	      {
		if (is_null(p)) return(make_real(sc, ((long_double)num_a / (long_double)den_a) - integer(x)));
		rl_a = ((long_double)num_a / (long_double)den_a) - integer(x);
		goto SUBTRACT_REALS;
	      }
	    if (is_null(p)) return(s7_make_ratio(sc, di, den_a));
	    num_a = di;
	  }
#else
	  if (is_null(p)) return(s7_make_ratio(sc, num_a - (den_a * integer(x)), den_a));
	  num_a -= (den_a * integer(x));
#endif
	  if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	    goto SUBTRACT_INTEGERS;
	  goto SUBTRACT_RATIOS;

	case T_RATIO:
	  {
	    s7_int d1, d2, n1, n2;
	    d1 = den_a;
	    n1 = num_a;
	    d2 = denominator(x);
	    n2 = numerator(x);
	    if (d1 == d2)                                     /* the easy case -- if overflow here, it matches the int32_t case */
	      {
		if (is_null(p))
		  return(s7_make_ratio(sc, n1 - n2, d1));
		num_a -= n2;                  /* d1 can't be zero */
	      }
	    else
	      {
#if (!WITH_GMP) && HAVE_OVERFLOW_CHECKS
		s7_int n1d2, n2d1;
		if ((multiply_overflow(d1, d2, &den_a)) ||
		    (multiply_overflow(n1, d2, &n1d2)) ||
		    (multiply_overflow(n2, d1, &n2d1)) ||
		    (subtract_overflow(n1d2, n2d1, &num_a)))
		  {
		    if (is_null(p))
		      return(make_real(sc, ((long_double)n1 / (long_double)d1) - ((long_double)n2 / (long_double)d2)));
		    rl_a = ((long_double)n1 / (long_double)d1) - ((long_double)n2 / (long_double)d2);
		    goto SUBTRACT_REALS;
		  }
#else
		num_a = n1 * d2 - n2 * d1;
		den_a = d1 * d2;
#endif
		if (is_null(p))
		  return(s7_make_ratio(sc, num_a, den_a));
	      }
	    if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	    goto SUBTRACT_INTEGERS;
	  goto SUBTRACT_RATIOS;
	  }

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, ((long_double)num_a / (long_double)den_a) - real(x)));
	  rl_a = ((long_double)num_a / (long_double)den_a) - real(x);
	  goto SUBTRACT_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, ((long_double)num_a / (long_double)den_a) - real_part(x), -imag_part(x)));
	  rl_a = ((long_double)num_a / (long_double)den_a) - real_part(x);
	  im_a = -imag_part(x);
	  goto SUBTRACT_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->subtract_symbol, cons_unchecked(sc, s7_make_ratio(sc, num_a, den_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_REAL:
      rl_a = real(x);

    SUBTRACT_REALS:
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
	  if (is_null(p)) return(make_real(sc, rl_a - integer(x)));
	  rl_a -= (s7_double)integer(x);
	  goto SUBTRACT_REALS;

	case T_RATIO:
	  if (is_null(p)) return(make_real(sc, rl_a - fraction(x)));
	  rl_a -= (s7_double)fraction(x);
	  goto SUBTRACT_REALS;

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, rl_a - real(x)));
	  rl_a -= real(x);
	  goto SUBTRACT_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a - real_part(x), -imag_part(x)));
	  rl_a -= real_part(x);
	  im_a = -imag_part(x);
	  goto SUBTRACT_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->subtract_symbol, cons_unchecked(sc, make_real(sc, rl_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_COMPLEX:
      rl_a = real_part(x);
      im_a = imag_part(x);

    SUBTRACT_COMPLEX:
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a - integer(x), im_a));
	  rl_a -= (s7_double)integer(x);
	  goto SUBTRACT_COMPLEX;

	case T_RATIO:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a - fraction(x), im_a));
	  rl_a -= (s7_double)fraction(x);
	  goto SUBTRACT_COMPLEX;

	case T_REAL:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a - real(x), im_a));
	  rl_a -= real(x);
	  goto SUBTRACT_COMPLEX;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a - real_part(x), im_a - imag_part(x)));
	  rl_a -= real_part(x);
	  im_a -= imag_part(x);
	  if (im_a == 0.0)
	    goto SUBTRACT_REALS;
	  goto SUBTRACT_COMPLEX;

	default:
	  return(method_or_bust_with_type(sc, x, sc->subtract_symbol, cons_unchecked(sc, s7_make_complex(sc, rl_a, im_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    default:
      return(method_or_bust_with_type(sc, x, sc->subtract_symbol, args, a_number_string, 1));
    }
  return(NULL); /* make the compiler happy */
}

static s7_pointer g_subtract_1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;

  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:
      if (integer(p) == s7_int_min)
#if WITH_GMP
	return(big_negate(sc, set_plist_1(sc, promote_number(sc, T_BIG_INTEGER, p))));
#else
      return(simple_out_of_range(sc, sc->subtract_symbol, p, wrap_string(sc, "most-negative-fixnum can't be negated", 37)));
#endif
      return(make_integer(sc, -integer(p)));

    case T_RATIO:
      return(make_simple_ratio(sc, -numerator(p), denominator(p)));

    case T_REAL:
      return(make_real(sc, -real(p)));

    case T_COMPLEX:
      return(s7_make_complex(sc, -real_part(p), -imag_part(p)));

    default:
      return(method_or_bust_with_type(sc, p, sc->subtract_symbol, args, a_number_string, 1));
    }
}

static inline s7_pointer subtract_p_pp(s7_scheme *sc, s7_pointer x, s7_pointer y) /* inline here simply trades overheads with subtract_2 et al */
{
  if (type(x) == type(y))
    {
      if (is_t_real(x))
	return(make_real(sc, real(x) - real(y)));
      switch (type(x))
	{
#if HAVE_OVERFLOW_CHECKS
	case T_INTEGER:
	  {
	    s7_int val;
	    if (subtract_overflow(integer(x), integer(y), &val))
	      return(make_real(sc, (double)integer(x) - (double)integer(y)));
	    return(make_integer(sc, val));
	  }
#else
	case T_INTEGER: return(make_integer(sc, integer(x) - integer(y)));
#endif
	case T_RATIO:   return(g_subtract(sc, set_plist_2(sc, x, y)));
	case T_REAL:    return(make_real(sc, real(x) - real(y)));
	case T_COMPLEX: return(make_complex(sc, real_part(x) - real_part(y), imag_part(x) - imag_part(y)));
	default:
	  if (!is_number(x))
	    return(method_or_bust_with_type(sc, x, sc->subtract_symbol, list_2(sc, x, y), a_number_string, 1));
	  return(method_or_bust_with_type(sc, y, sc->subtract_symbol, list_2(sc, x, y), a_number_string, 2));
	}
    }

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER: return(make_integer(sc, integer(x) - integer(y)));
	case T_RATIO:   return(g_subtract(sc, set_plist_2(sc, x, y)));
	case T_REAL:    return(make_real(sc, integer(x) - real(y)));
	case T_COMPLEX: return(make_complex(sc, integer(x) - real_part(y), -imag_part(y)));
	default:
	  return(method_or_bust_with_type(sc, y, sc->subtract_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	case T_RATIO:   return(g_subtract(sc, set_plist_2(sc, x, y)));
	case T_REAL:    return(make_real(sc, fraction(x) - real(y)));
	case T_COMPLEX: return(s7_make_complex(sc, fraction(x) - real_part(y), -imag_part(y)));
	default:
	  return(method_or_bust_with_type(sc, y, sc->subtract_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER: return(make_real(sc, real(x) - integer(y)));
	case T_RATIO:   return(make_real(sc, real(x) - fraction(y)));
	case T_REAL:    return(make_real(sc, real(x) - real(y)));
	case T_COMPLEX: return(make_complex(sc, real(x) - real_part(y), -imag_part(y)));
	default:
	  return(method_or_bust_with_type(sc, y, sc->subtract_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    case T_COMPLEX:
      switch (type(y))
	{
	case T_INTEGER: return(s7_make_complex(sc, real_part(x) - integer(y), imag_part(x)));
	case T_RATIO:   return(s7_make_complex(sc, real_part(x) - fraction(y), imag_part(x)));
	case T_REAL:    return(s7_make_complex(sc, real_part(x) - real(y), imag_part(x)));
	case T_COMPLEX: return(make_complex(sc, real_part(x) - real_part(y), imag_part(x) - imag_part(y)));
	default:
	  return(method_or_bust_with_type(sc, y, sc->subtract_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    default:
      return(method_or_bust_with_type(sc, x, sc->subtract_symbol, list_2(sc, x, y), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_subtract_2(s7_scheme *sc, s7_pointer args)
{
  return(subtract_p_pp(sc, car(args), cadr(args)));
}

static s7_pointer minus_c1(s7_scheme *sc, s7_pointer x)
{
  switch (type(x))
    {
#if HAVE_OVERFLOW_CHECKS
    case T_INTEGER:
      {
	s7_int val;
	if (subtract_overflow(integer(x), 1, &val))
	  return(make_real(sc, (double)integer(x) - 1.0));
	return(make_integer(sc, val));
      }
#else
    case T_INTEGER: return(make_integer(sc, integer(x) - 1));
#endif
    case T_RATIO:   return(subtract_ratios(sc, x, small_int(1)));
    case T_REAL:    return(make_real(sc, real(x) - 1.0));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) - 1.0, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->subtract_symbol, list_2(sc, x, small_int(1)), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_subtract_cs1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  x = lookup(sc, car(args));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) - 1));
  return(minus_c1(sc, x));
}

static s7_pointer g_subtract_s1(s7_scheme *sc, s7_pointer args)
{
  return(minus_c1(sc, car(args)));
}

static s7_pointer g_subtract_csn(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  s7_int n;

  x = lookup(sc, car(args));
  n = s7_integer(cadr(args));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) - n));

  switch (type(x))
    {
#if HAVE_OVERFLOW_CHECKS
    case T_INTEGER:
      {
	s7_int val;
	if (subtract_overflow(integer(x), n, &val))
	  return(make_real(sc, (double)integer(x) - (double)n));
	return(make_integer(sc, val));
      }
#else
    case T_INTEGER: return(make_integer(sc, integer(x) - n));
#endif
    case T_RATIO:   return(subtract_ratios(sc, x, cadr(args)));
    case T_REAL:    return(make_real(sc, real(x) - n));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) - n, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->subtract_symbol, list_2(sc, x, cadr(args)), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_subtract_sf(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  s7_double n;

  x = lookup(sc, car(args));
  n = real(cadr(args));
  switch (type(x))
    {
    case T_INTEGER: return(make_real(sc, integer(x) - n));
    case T_RATIO:   return(make_real(sc, fraction(x) - n));
    case T_REAL:    return(make_real(sc, real(x) - n));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) - n, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->subtract_symbol, list_2(sc, x, cadr(args)), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_subtract_2f(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  s7_double n;

  x = car(args);
  n = real(cadr(args));
  switch (type(x))
    {
    case T_INTEGER: return(make_real(sc, integer(x) - n));
    case T_RATIO:   return(make_real(sc, fraction(x) - n));
    case T_REAL:    return(make_real(sc, real(x) - n));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) - n, imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->subtract_symbol, args, a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_subtract_fs(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  s7_double n;

  x = lookup(sc, cadr(args));
  n = real(car(args));
  switch (type(x))
    {
    case T_INTEGER: return(make_real(sc, n - integer(x)));
    case T_RATIO:   return(make_real(sc, n - fraction(x)));
    case T_REAL:    return(make_real(sc, n - real(x)));
    case T_COMPLEX: return(s7_make_complex(sc, n - real_part(x), -imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->subtract_symbol, list_2(sc, car(args), x), a_number_string, 2));
    }
  return(x);
}

static s7_int subtract_i_ii(s7_int i1, s7_int i2) {return(i1 - i2);}
static s7_int subtract_i_i(s7_int x) {return(-x);}
static s7_int subtract_i_iii(s7_int i1, s7_int i2, s7_int i3) {return(i1 - i2 - i3);}

static s7_double subtract_d_d(s7_double x) {return(-x);}
static s7_double subtract_d_dd(s7_double x1, s7_double x2) {return(x1 - x2);}
static s7_double subtract_d_ddd(s7_double x1, s7_double x2, s7_double x3) {return(x1 - x2 - x3);}
static s7_double subtract_d_dddd(s7_double x1, s7_double x2, s7_double x3, s7_double x4) {return(x1 - x2 - x3 - x4);}

#if (!WITH_GMP)
static s7_pointer sub_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_real(sc, x1 - x2));}
#endif


/* ---------------------------------------- multiply ---------------------------------------- */

static s7_pointer multiply_method_or_bust(s7_scheme *sc, s7_pointer obj, s7_pointer caller, s7_pointer args, s7_pointer typ, int32_t num)
{
  if (has_active_methods(sc, obj))
    return(find_and_apply_method(sc, find_let(sc, obj), sc->multiply_symbol, args));
  if (num == 0)
    return(simple_wrong_type_argument_with_type(sc, caller, obj, typ));
  return(wrong_type_argument_with_type(sc, caller, num, obj, typ));
}

static s7_pointer g_multiply_1(s7_scheme *sc, s7_pointer args, s7_pointer caller)
{
  #define H_multiply "(* ...) multiplies its arguments"
  #define Q_multiply sc->pcl_n

  s7_pointer x, p;
  s7_int num_a, den_a;
  s7_double rl_a, im_a;

#if (!WITH_GMP)
  if (is_null(args))
    return(small_int(1));
#endif

  x = car(args);
  p = cdr(args);
  if (is_null(p))
    {
      if (!is_number(x))
	return(multiply_method_or_bust(sc, x, caller, args, a_number_string, 0));
      return(x);
    }

  switch (type(x))
    {
    case T_INTEGER:
      num_a = integer(x);

    MULTIPLY_INTEGERS:
#if WITH_GMP
      if ((num_a > s7_int32_max) ||
	  (num_a < s7_int32_min))
	return(big_multiply(sc, cons(sc, s7_int_to_big_integer(sc, num_a), p)));
#endif
      x = car(p);
      p = cdr(p);
      switch (type(x))
	{
	case T_INTEGER:
#if WITH_GMP
	  if ((integer(x) > s7_int32_max) ||
	      (integer(x) < s7_int32_min))
	    return(big_multiply(sc, cons(sc, s7_int_to_big_integer(sc, num_a), cons(sc, x, p))));
#endif

#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int dn;
	    if (multiply_overflow(num_a, integer(x), &dn))
	      {
		if (is_null(p)) return(make_real(sc, (s7_double)num_a * (s7_double)integer(x)));
		rl_a = (s7_double)num_a * (s7_double)integer(x);
		goto MULTIPLY_REALS;
	      }
	    num_a = dn;
	  }
#else
	  num_a *= integer(x);
#endif
	  if (is_null(p)) return(make_integer(sc, num_a));
	  goto MULTIPLY_INTEGERS;

	case T_RATIO:
#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int dn;
	    if (multiply_overflow(numerator(x), num_a, &dn))
	      {
		if (is_null(p))
		  return(make_real(sc, (s7_double)num_a * fraction(x)));
		rl_a = (s7_double)num_a * fraction(x);
		goto MULTIPLY_REALS;
	      }
	    num_a = dn;
	  }
#else
	  num_a *= numerator(x);
#endif
	  den_a = denominator(x);
	  if (is_null(p)) return(s7_make_ratio(sc, num_a, den_a));
	  if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	    goto MULTIPLY_INTEGERS;
	  goto MULTIPLY_RATIOS;

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, num_a * real(x)));
	  rl_a = num_a * real(x);
	  goto MULTIPLY_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, num_a * real_part(x), num_a * imag_part(x)));
	  rl_a = num_a * real_part(x);
	  im_a = num_a * imag_part(x);
	  goto MULTIPLY_COMPLEX;

	default:
	  return(multiply_method_or_bust(sc, x, caller, cons_unchecked(sc, s7_make_integer(sc, num_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_RATIO:
      num_a = numerator(x);
      den_a = denominator(x);
    MULTIPLY_RATIOS:
#if WITH_GMP
      if ((num_a > s7_int32_max) ||
	  (den_a > s7_int32_max) ||
	  (num_a < s7_int32_min))
	return(big_multiply(sc, cons(sc, s7_ratio_to_big_ratio(sc, num_a, den_a), p)));
#endif
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
	  /* as in +, this can overflow:
	   *   (* 8 -9223372036854775807 8) -> 64
	   *   (* 3/4 -9223372036854775807 8) -> 6
	   *   (* 8 -9223372036854775808 8) -> 0
	   *   (* -1 9223372036854775806 8) -> 16
	   *   (* -9223372036854775808 8 1e+308) -> 0.0
	   */
#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int dn;
	    if (multiply_overflow(integer(x), num_a, &dn))
	      {
		if (is_null(p))
		  return(make_real(sc, ((s7_double)integer(x) / (s7_double)den_a) * (s7_double)num_a));
		rl_a = ((s7_double)integer(x) / (s7_double)den_a) * (s7_double)num_a;
		goto MULTIPLY_REALS;
	      }
	    num_a = dn;
	  }
#else
	  num_a *= integer(x);
#endif
	  if (is_null(p)) return(s7_make_ratio(sc, num_a, den_a));
	  if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	    goto MULTIPLY_INTEGERS;
	  goto MULTIPLY_RATIOS;

	case T_RATIO:
	  {
#if (!WITH_GMP)
#if HAVE_OVERFLOW_CHECKS
	    s7_int d1, n1;
#endif
#endif
	    s7_int d2, n2;
	    d2 = denominator(x);
	    n2 = numerator(x);
#if (!WITH_GMP)
#if HAVE_OVERFLOW_CHECKS
	    d1 = den_a;
	    n1 = num_a;
	    if ((multiply_overflow(n1, n2, &num_a)) ||
		(multiply_overflow(d1, d2, &den_a)))
	      {
		if (is_null(p))
		  return(make_real(sc, ((long_double)n1 / (long_double)d1) * ((long_double)n2 / (long_double)d2)));
		rl_a = ((long_double)n1 / (long_double)d1) * ((long_double)n2 / (long_double)d2);
		goto MULTIPLY_REALS;
	      }
#else
	    num_a *= n2;
	    den_a *= d2;
#endif
#else
	    num_a *= n2;
	    den_a *= d2;
#endif
	    if (is_null(p)) return(s7_make_ratio(sc, num_a, den_a));
	    if (reduce_fraction(&num_a, &den_a) == T_INTEGER)
	      goto MULTIPLY_INTEGERS;
	    goto MULTIPLY_RATIOS;
	  }

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, ((long_double)num_a / (long_double)den_a) * real(x)));
	  rl_a = ((long_double)num_a / (long_double)den_a) * real(x);
	  goto MULTIPLY_REALS;

	case T_COMPLEX:
	  {
	    s7_double frac;
	    frac = ((long_double)num_a / (long_double)den_a);
	    if (is_null(p)) return(s7_make_complex(sc, frac * real_part(x), frac * imag_part(x)));
	    rl_a = frac * real_part(x);
	    im_a = frac * imag_part(x);
	    goto MULTIPLY_COMPLEX;
	  }

	default:
	  return(multiply_method_or_bust(sc, x, caller, cons_unchecked(sc, s7_make_ratio(sc, num_a, den_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_REAL:
      rl_a = real(x);

    MULTIPLY_REALS:
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
	  if (is_null(p)) return(make_real(sc, rl_a * integer(x)));
	  rl_a *= integer(x);
	  goto MULTIPLY_REALS;

	case T_RATIO:
	  if (is_null(p)) return(make_real(sc, rl_a * fraction(x)));
	  rl_a *= (s7_double)fraction(x);
	  goto MULTIPLY_REALS;

	case T_REAL:
	  if (is_null(p)) return(make_real(sc, rl_a * real(x)));
	  rl_a *= real(x);
	  goto MULTIPLY_REALS;

	case T_COMPLEX:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a * real_part(x), rl_a * imag_part(x)));
	  im_a = rl_a * imag_part(x);
	  rl_a *= real_part(x);
	  goto MULTIPLY_COMPLEX;

	default:
	  return(multiply_method_or_bust(sc, x, caller, cons_unchecked(sc, make_real(sc, rl_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    case T_COMPLEX:
      rl_a = real_part(x);
      im_a = imag_part(x);

    MULTIPLY_COMPLEX:
      x = car(p);
      p = cdr(p);

      switch (type(x))
	{
	case T_INTEGER:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a * integer(x), im_a * integer(x)));
	  rl_a *= integer(x);
	  im_a *= integer(x);
	  goto MULTIPLY_COMPLEX;

	case T_RATIO:
	  {
	    s7_double frac;
	    frac = fraction(x);
	    if (is_null(p)) return(s7_make_complex(sc, rl_a * frac, im_a * frac));
	    rl_a *= frac;
	    im_a *= frac;
	    goto MULTIPLY_COMPLEX;
	  }

	case T_REAL:
	  if (is_null(p)) return(s7_make_complex(sc, rl_a * real(x), im_a * real(x)));
	  rl_a *= real(x);
	  im_a *= real(x);
	  goto MULTIPLY_COMPLEX;

	case T_COMPLEX:
	  {
	    s7_double r1, r2, i1, i2;
	    r1 = rl_a;
	    i1 = im_a;
	    r2 = real_part(x);
	    i2 = imag_part(x);
	    if (is_null(p))
	      return(s7_make_complex(sc, r1 * r2 - i1 * i2, r1 * i2 + r2 * i1));
	    rl_a = r1 * r2 - i1 * i2;
	    im_a = r1 * i2 + r2 * i1;
	    if (im_a == 0.0)
	      goto MULTIPLY_REALS;
	    goto MULTIPLY_COMPLEX;
	  }

	default:
	  return(multiply_method_or_bust(sc, x, caller, cons_unchecked(sc, s7_make_complex(sc, rl_a, im_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	}
      break;

    default:
      return(multiply_method_or_bust(sc, x, caller, args, a_number_string, 1));
    }
  return(NULL); /* make the compiler happy */
}

static s7_pointer g_multiply(s7_scheme *sc, s7_pointer args)
{
  return(g_multiply_1(sc, args, sc->multiply_symbol));
}

#if (!WITH_GMP)
static inline s7_pointer multiply_p_pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (type(x) == type(y))
    {
      if (is_t_real(x))
	return(make_real(sc, real(x) * real(y)));
      switch (type(x))
	{
#if HAVE_OVERFLOW_CHECKS
	case T_INTEGER:
	  {
	    s7_int n;
	    if (multiply_overflow(integer(x), integer(y), &n))
	      return(make_real(sc, ((s7_double)integer(x)) * ((s7_double)integer(y))));
	    return(make_integer(sc, n));
	  }
#else
	case T_INTEGER: return(make_integer(sc, integer(x) * integer(y)));
#endif
	case T_RATIO:   return(g_multiply(sc, list_2(sc, x, y)));
	case T_REAL:    return(make_real(sc, real(x) * real(y)));
	case T_COMPLEX:
	  {
	    s7_double r1, r2, i1, i2;
	    r1 = real_part(x);
	    r2 = real_part(y);
	    i1 = imag_part(x);
	    i2 = imag_part(y);
	    return(s7_make_complex(sc, r1 * r2 - i1 * i2, r1 * i2 + r2 * i1));
	  }
	default:
	  if (!is_number(x))
	    return(method_or_bust_with_type(sc, x, sc->multiply_symbol, list_2(sc, x, y), a_number_string, 1));
	  return(method_or_bust_with_type(sc, y, sc->multiply_symbol, list_2(sc, x, y), a_number_string, 2));
	}
    }

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER: return(make_integer(sc, integer(x) * integer(y)));
	case T_RATIO:   return(g_multiply(sc, list_2(sc, x, y)));
	case T_REAL:    return(make_real(sc, integer(x) * real(y)));
	case T_COMPLEX: return(s7_make_complex(sc, integer(x) * real_part(y), integer(x) * imag_part(y)));
	default:
	  return(method_or_bust_with_type(sc, y, sc->multiply_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	case T_RATIO:    return(g_multiply(sc, list_2(sc, x, y)));
	case T_REAL:     return(make_real(sc, fraction(x) * real(y)));
	case T_COMPLEX:
	  {
	    s7_double frac;
	    frac = fraction(x);
	    return(s7_make_complex(sc, frac * real_part(y), frac * imag_part(y)));
	  }
	default:
	  return(method_or_bust_with_type(sc, y, sc->multiply_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER: return(make_real(sc, real(x) * integer(y)));
	case T_RATIO:   return(make_real(sc, real(x) * fraction(y)));
	case T_REAL:    return(make_real(sc, real(x) * real(y)));
	case T_COMPLEX: return(s7_make_complex(sc, real(x) * real_part(y), real(x) * imag_part(y)));
	default:
	  return(method_or_bust_with_type(sc, y, sc->multiply_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    case T_COMPLEX:
      switch (type(y))
	{
	case T_INTEGER: return(s7_make_complex(sc, real_part(x) * integer(y), imag_part(x) * integer(y)));
	case T_RATIO:
	  {
	    s7_double frac;
	    frac = fraction(y);
	    return(s7_make_complex(sc, real_part(x) * frac, imag_part(x) * frac));
	  }
	case T_REAL:    return(s7_make_complex(sc, real_part(x) * real(y), imag_part(x) * real(y)));
	case T_COMPLEX:
	  {
	    s7_double r1, r2, i1, i2;
	    r1 = real_part(x);
	    r2 = real_part(y);
	    i1 = imag_part(x);
	    i2 = imag_part(y);
	    return(s7_make_complex(sc, r1 * r2 - i1 * i2, r1 * i2 + r2 * i1));
	  }
	default:
	  return(method_or_bust_with_type(sc, y, sc->multiply_symbol, list_2(sc, x, y), a_number_string, 2));
	}

    default:
      return(method_or_bust_with_type(sc, x, sc->multiply_symbol, list_2(sc, x, y), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_multiply_2(s7_scheme *sc, s7_pointer args) {return(multiply_p_pp(sc, car(args), cadr(args)));}

/* all of these mess up if overflows occur
 *  (let () (define (f x) (* x 9223372036854775806)) (f -63)) -> -9223372036854775682, but (* -63 9223372036854775806) -> -5.810724383218509e+20
 *  how to catch this?  (affects * - +)
 */

static s7_pointer g_mul_sis(s7_scheme *sc, s7_pointer x, s7_int n, s7_pointer args)
{
  switch (type(x))
    {
#if HAVE_OVERFLOW_CHECKS
    case T_INTEGER:
      {
	s7_int val;
	if (multiply_overflow(integer(x), n, &val))
	  return(make_real(sc, (double)integer(x) * (double)n));
	return(make_integer(sc, val));
      }
    case T_RATIO:
      {
	s7_int val;
	if (multiply_overflow(numerator(x), n, &val))
	  return(make_real(sc, fraction(x) * (double)n));
	return(s7_make_ratio(sc, val, denominator(x)));
      }
#else
    case T_INTEGER: return(make_integer(sc, integer(x) * n));
    case T_RATIO:   return(s7_make_ratio(sc, numerator(x) * n, denominator(x)));
#endif
    case T_REAL:    return(make_real(sc, real(x) * n));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) * n, imag_part(x) * n));
    default:
      /* we can get here from mul_2_xi for example so the non-integer argument might not be a symbol */
      return(method_or_bust_with_type(sc, x, sc->multiply_symbol,
				      (s7_is_integer(car(args))) ? list_2(sc, car(args), x) : list_2(sc, x, cadr(args)),
				      a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_multiply_si(s7_scheme *sc, s7_pointer args) {return(g_mul_sis(sc, lookup(sc, car(args)), integer(cadr(args)), args));}
static s7_pointer g_multiply_is(s7_scheme *sc, s7_pointer args) {return(g_mul_sis(sc, lookup(sc, cadr(args)), integer(car(args)), args));}

static s7_pointer g_mul_sfs(s7_scheme *sc, s7_pointer x, s7_double y)
{
  switch (type(x))
    {
    case T_INTEGER: return(make_real(sc, integer(x) * y));
    case T_RATIO:   return(make_real(sc, numerator(x) * y / denominator(x)));
    case T_REAL:    return(make_real(sc, real(x) * y));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) * y, imag_part(x) * y));
    default:
      return(method_or_bust_with_type(sc, x, sc->multiply_symbol, list_2(sc, make_real(sc, y), x), a_number_string, 1));
    }
  return(x);
}

static s7_pointer g_multiply_fs(s7_scheme *sc, s7_pointer args) {return(g_mul_sfs(sc, lookup(sc, cadr(args)), real(car(args))));}
static s7_pointer g_multiply_sf(s7_scheme *sc, s7_pointer args) {return(g_mul_sfs(sc, lookup(sc, car(args)), real(cadr(args))));}

static s7_pointer g_mul_2_ff(s7_scheme *sc, s7_pointer args) {return(make_real(sc, real(car(args)) * real(cadr(args))));}
static s7_pointer g_mul_2_ii(s7_scheme *sc, s7_pointer args)
{
#if HAVE_OVERFLOW_CHECKS
  s7_int val, x, y;
  x = integer(car(args));
  y = integer(cadr(args));
  if (multiply_overflow(x, y, &val))
    return(make_real(sc, (double)x * (double)y));
  return(make_integer(sc, val));
#else
  return(make_integer(sc, integer(car(args)) * integer(cadr(args))));
#endif
}
static s7_pointer g_mul_2_if(s7_scheme *sc, s7_pointer args) {return(make_real(sc, integer(car(args)) * real(cadr(args))));}
static s7_pointer g_mul_2_fi(s7_scheme *sc, s7_pointer args) {return(make_real(sc, real(car(args)) * integer(cadr(args))));}
static s7_pointer g_mul_2_xi(s7_scheme *sc, s7_pointer args) {return(g_mul_sis(sc, car(args), integer(cadr(args)), args));}
static s7_pointer g_mul_2_ix(s7_scheme *sc, s7_pointer args) {return(g_mul_sis(sc, cadr(args), integer(car(args)), args));}
static s7_pointer g_mul_2_xf(s7_scheme *sc, s7_pointer args) {return(g_mul_sfs(sc, car(args), real(cadr(args))));}
static s7_pointer g_mul_2_fx(s7_scheme *sc, s7_pointer args) {return(g_mul_sfs(sc, cadr(args), real(car(args))));}

static s7_pointer g_sqr_ss(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  x = lookup(sc, car(args));

  switch (type(x))
    {
#if HAVE_OVERFLOW_CHECKS
    case T_INTEGER:
      {
	s7_int val;
	if (multiply_overflow(integer(x), integer(x), &val))
	  return(make_real(sc, (double)integer(x) * (double)integer(x)));
	return(make_integer(sc, val));
      }
    case T_RATIO:
      {
	s7_int num, den;
	if ((multiply_overflow(numerator(x), numerator(x), &num)) ||
	    (multiply_overflow(denominator(x), denominator(x), &den)))
	  return(make_real(sc, fraction(x) * fraction(x)));
	return(s7_make_ratio(sc, num, den));
      }
#else
    case T_INTEGER: return(s7_make_integer(sc, integer(x) * integer(x)));
    case T_RATIO:   return(s7_make_ratio(sc, numerator(x) * numerator(x), denominator(x) * denominator(x)));
#endif
    case T_REAL:    return(make_real(sc, real(x) * real(x)));
    case T_COMPLEX: return(s7_make_complex(sc, real_part(x) * real_part(x) - imag_part(x) * imag_part(x), 2.0 * real_part(x) * imag_part(x)));
    default:
      return(method_or_bust_with_type(sc, x, sc->multiply_symbol, list_2(sc, x, x), a_number_string, 1));
    }
  return(x);
}
#endif /* with-gmp */

static s7_int multiply_i_ii(s7_int i1, s7_int i2)
{
#if HAVE_OVERFLOW_CHECKS
  s7_int val;
  if (multiply_overflow(i1, i2, &val))
    return(s7_int_max); /* this is inconsistent with other unopt cases where an overflow -> double result */
  /* (let () (define (func) (do ((i 0 (+ i 1))) ((= i 1)) (do ((j 0 (+ j 1))) ((= j 1)) (even? (* (ash 1 43) (ash 1 43)))))) (define (hi) (func)) (hi)) */
  return(val);
#else
  return(i1 * i2);
#endif
}

static s7_int multiply_i_iii(s7_int i1, s7_int i2, s7_int i3)
{
#if HAVE_OVERFLOW_CHECKS
  s7_int val1, val2;
  if (multiply_overflow(i1, i2, &val1))
    return(s7_int_max);
  if (multiply_overflow(val1, i3, &val2))
    return(s7_int_max);
  return(val2);
#else
  return(i1 * i2 * i3);
#endif
}

static s7_double multiply_d_d(s7_double x) {return(x);}
static s7_double multiply_d_dd(s7_double x1, s7_double x2) {return(x1 * x2);}
static s7_double multiply_d_ddd(s7_double x1, s7_double x2, s7_double x3) {return(x1 * x2 * x3);}
static s7_double multiply_d_dddd(s7_double x1, s7_double x2, s7_double x3, s7_double x4) {return(x1 * x2 * x3 * x4);}
#if (!WITH_GMP)
static s7_pointer mul_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_real(sc, x1 * x2));}
#endif


/* ---------------------------------------- divide ---------------------------------------- */

static bool is_number_via_method(s7_scheme *sc, s7_pointer p)
{
  if (s7_is_number(p))
    return(true);
  if (has_active_methods(sc, p))
    {
      s7_pointer f;
      f = find_method(sc, find_let(sc, p), sc->is_number_symbol);
      if (f != sc->undefined)
	return(is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil))));
    }
  return(false);
}

static s7_pointer g_divide(s7_scheme *sc, s7_pointer args)
{
  #define H_divide "(/ x1 ...) divides its first argument by the rest, or inverts the first if there is only one argument"
  #define Q_divide sc->pcl_n

  s7_pointer x, y, p;

  x = car(args);
  p = cdr(args);

  if (is_null(p))            /* (/ x) */
    {
      if (!is_number(x))
	return(method_or_bust_with_type_one_arg(sc, x, sc->divide_symbol, args, a_number_string));
      if (s7_is_zero(x))     /* (/ 0) */
	return(division_by_zero_error(sc, sc->divide_symbol, args));
      return(s7_invert(sc, x));
    }
  if (is_null(cdr(p)))
    y = cadr(args);
  else
    {
      y = g_multiply_1(sc, p, sc->divide_symbol); /* in some schemes (/ 1 0 +nan.0) is not equal to (/ 1 (* 0 +nan.0)), in s7 they're both +nan.0 */
#if WITH_GMP
      if (s7_is_bignum(y))
	return(big_divide(sc, set_plist_2(sc, x, y)));
#endif
    }

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	  /* -------- integer x -------- */
	case T_INTEGER:
	  if (integer(y) == 0)
	    return(division_by_zero_error(sc, sc->divide_symbol, set_elist_2(sc, x, y)));
	  return(s7_make_ratio(sc, integer(x), integer(y)));

	case T_RATIO:
#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int dn;
	    if (multiply_overflow(integer(x), denominator(y), &dn))
	      return(make_real(sc, integer(x) * inverted_fraction(y)));
	    return(s7_make_ratio(sc, dn, numerator(y)));
	  }
#else
	  return(s7_make_ratio(sc, integer(x) * denominator(y), numerator(y)));
#endif

	case T_REAL:
	  if (is_NaN(real(y))) return(real_NaN);
	  if (is_inf(real(y))) return(real_zero);
	  if (real(y) == 0.0)
	    return(division_by_zero_error(sc, sc->divide_symbol, args));
	  return(make_real(sc, (s7_double)(integer(x)) / real(y)));

	case T_COMPLEX:
	  {
	    s7_double r1, i2, r2, den;
	    r1 = (s7_double)integer(x);
	    r2 = real_part(y);
	    i2 = imag_part(y);
	    den = 1.0 / (r2 * r2 + i2 * i2);
	    /* we could avoid the squaring (see Knuth II p613 16), not a big deal: (/ 1.0e308+1.0e308i 2.0e308+2.0e308i) => nan, (gmp case is ok here) */
	    return(s7_make_complex(sc, r1 * r2 * den, -(r1 * i2 * den)));
	  }

	default:
#if WITH_GMP
	  if (s7_is_bignum(y))
	    return(big_divide(sc, list_2(sc, x, y)));
#endif
	  return(method_or_bust_with_type(sc, y, sc->divide_symbol, list_2(sc, x, y), a_number_string, 2));
	}
      break;

      /* -------- ratio x -------- */
    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(y) == 0)
	    return(division_by_zero_error(sc, sc->divide_symbol, set_elist_2(sc, x, y)));
#if HAVE_OVERFLOW_CHECKS
	  {
	    s7_int dn;
	    if (multiply_overflow(denominator(x), integer(y), &dn))
	      return(make_real(sc, (long_double)numerator(x) / ((long_double)denominator(x) * (s7_double)integer(y))));
	    return(s7_make_ratio(sc, numerator(x), dn));
	  }
#else
	  return(s7_make_ratio(sc, numerator(x), denominator(x) * integer(y)));
#endif

	case T_RATIO:
	  {
	    s7_int d1, d2, n1, n2;
	    d1 = denominator(x);
	    n1 = numerator(x);
	    d2 = denominator(y);
	    n2 = numerator(y);
	    if (d1 == d2)
	      return(s7_make_ratio(sc, n1, n2));
#if (!WITH_GMP) && HAVE_OVERFLOW_CHECKS
	    if ((multiply_overflow(n1, d2, &n1)) ||
		(multiply_overflow(n2, d1, &d1)))
	      {
		s7_double r1, r2;
		r1 = fraction(x);
		r2 = inverted_fraction(y);
		return(make_real(sc, r1 * r2));
	      }
	    return(s7_make_ratio(sc, n1, d1));
#else
	    return(s7_make_ratio(sc, n1 * d2, n2 * d1));
#endif
	  }

	case T_REAL:
	  if (real(y) == 0.0)
	    return(division_by_zero_error(sc, sc->divide_symbol, args));
	  return(make_real(sc, fraction(x) / real(y)));

	case T_COMPLEX:
	  {
	    s7_double rx, r2, i2, den;
	    rx = fraction(x);
	    r2 = real_part(y);
	    i2 = imag_part(y);
	    den = 1.0 / (r2 * r2 + i2 * i2);
	    return(s7_make_complex(sc, rx * r2 * den, -rx * i2 * den));
	  }

	default:
	  return(method_or_bust_with_type(sc, y, sc->divide_symbol, list_2(sc, x, y), a_number_string, 2));
	}

      /* -------- real x -------- */
    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(y) == 0)
	    return(division_by_zero_error(sc, sc->divide_symbol, args));
	  if (is_NaN(real(x))) return(real_NaN); /* what is (/ +nan.0 0)? */
	  if (is_inf(real(x))) return((real(x) > 0.0) ? ((integer(y) > 0) ? real_infinity : real_minus_infinity) : ((integer(y) > 0) ? real_minus_infinity : real_infinity));
	  return(make_real(sc, real(x) / (s7_double)integer(y)));

	case T_RATIO:
	  if (is_NaN(real(x))) return(real_NaN);
	  if (is_inf(real(x))) return((real(x) > 0) ? ((numerator(y) > 0) ? real_infinity : real_minus_infinity) : ((numerator(y) > 0) ? real_minus_infinity : real_infinity));
	  return(make_real(sc, real(x) * inverted_fraction(y)));

	case T_REAL:
	  if (is_NaN(real(y))) return(real_NaN);
	  if (real(y) == 0.0)
	    return(division_by_zero_error(sc, sc->divide_symbol, args));
	  if (is_NaN(real(x))) return(real_NaN);
	  if (is_inf(real(y)))
	    {
	      if (is_inf(real(x))) return(real_NaN);
	      return(real_zero);
	    }
	  return(make_real(sc, real(x) / real(y)));

	case T_COMPLEX:
	  {
	    s7_double den, r2, i2;
	    if (is_NaN(real(x))) return(real_NaN);
	    if (is_NaN(real_part(y))) return(real_NaN);
	    if (is_NaN(imag_part(y))) return(real_NaN);
	    if (is_inf(real_part(y))) return(real_zero);
	    r2 = real_part(y);
	    i2 = imag_part(y);
	    den = 1.0 / (r2 * r2 + i2 * i2);
	    return(s7_make_complex(sc, real(x) * r2 * den, -real(x) * i2 * den));
	  }

	default:
	  return(method_or_bust_with_type(sc, y, sc->divide_symbol, list_2(sc, x, y), a_number_string, 2));
	}

      /* -------- complex x -------- */
    case T_COMPLEX:
      switch (type(y))
	{
	case T_INTEGER:
	  {
	    s7_double r1;
	    if (integer(y) == 0)
	      return(division_by_zero_error(sc, sc->divide_symbol, args));
	    r1 = 1.0 / (s7_double)integer(y);
	    return(s7_make_complex(sc, real_part(x) * r1, imag_part(x) * r1));
	  }

	case T_RATIO:
	  {
	    s7_double frac;
	    frac = inverted_fraction(y);
	    return(s7_make_complex(sc, real_part(x) * frac, imag_part(x) * frac));
	  }

	case T_REAL:
	  {
	    s7_double r1;
	    if (real(y) == 0.0)
	      return(division_by_zero_error(sc, sc->divide_symbol, args));
	    r1 = 1.0 / real(y);
	    return(s7_make_complex(sc, real_part(x) * r1, imag_part(x) * r1));
	  }

	case T_COMPLEX:
	  {
	    s7_double r1, r2, i1, i2, den;
	    r1 = real_part(x);
	    if (is_NaN(r1)) return(real_NaN);
	    i1 = imag_part(x);
	    if (is_NaN(i1)) return(real_NaN);
	    r2 = real_part(y);
	    if (is_NaN(r2)) return(real_NaN);
	    i2 = imag_part(y);
	    if (is_NaN(i2)) return(real_NaN);
	    den = 1.0 / (r2 * r2 + i2 * i2);
	    return(s7_make_complex(sc, (r1 * r2 + i1 * i2) * den, (r2 * i1 - r1 * i2) * den));
	  }

	default:
	  return(method_or_bust_with_type(sc, y, sc->divide_symbol, list_2(sc, x, y), a_number_string, 2));
	}

      /* -------- any other type x -------- */
    default:
      return(method_or_bust_with_type(sc, x, sc->divide_symbol, list_2(sc, x, y), a_number_string, 1)); /* not args here! y = apply * to cdr(args) */
      break;
    }

  return(NULL); /* make the compiler happy */
}

#if (!WITH_GMP)
static s7_pointer g_invert_1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:
      if (integer(p) != 0)
	return(s7_make_ratio(sc, 1, integer(p)));      /* a already checked, not 0 */
      return(division_by_zero_error(sc, sc->divide_symbol, args));

    case T_RATIO:
      return(make_simple_ratio(sc, denominator(p), numerator(p)));

    case T_REAL:
      if (real(p) != 0.0)
	return(make_real(sc, 1.0 / real(p)));
      return(division_by_zero_error(sc, sc->divide_symbol, args));

    case T_COMPLEX:
      return(complex_invert(sc, p));

    default:
      return(method_or_bust_with_type(sc, p, sc->divide_symbol, args, a_number_string, 1));
    }
}

static s7_pointer g_divide_1r(s7_scheme *sc, s7_pointer args)
{
  if (s7_is_real(cadr(args)))
    {
      s7_double rl;
      rl = s7_real(cadr(args));
      if (rl == 0.0)
	return(division_by_zero_error(sc, sc->divide_symbol, args));
      return(make_real(sc, 1.0 / rl));
    }
  return(g_divide(sc, args));
}
#endif

static s7_double divide_d_7d(s7_scheme *sc, s7_double x)
{
  if (x == 0.0) division_by_zero_error(sc, sc->divide_symbol, set_elist_1(sc, real_zero));
  return(1.0 / x);
}

static s7_double divide_d_7dd(s7_scheme *sc, s7_double x1, s7_double x2)
{
  if (x2 == 0.0) division_by_zero_error(sc, sc->divide_symbol, set_elist_1(sc, real_zero));
  return(x1 / x2);
}

static s7_pointer divide_p_ii(s7_scheme *sc, s7_int x, s7_int y) {return(s7_make_ratio(sc, x, y));} /* make-ratio checks for y==0 */
static s7_pointer divide_p_i(s7_scheme *sc, s7_int x) {return(s7_make_ratio(sc, 1, x));}


/* ---------------------------------------- max/min ---------------------------------------- */

static bool is_real_via_method_1(s7_scheme *sc, s7_pointer p)
{
  s7_pointer f;
  f = find_method(sc, find_let(sc, p), sc->is_real_symbol);
  if (f != sc->undefined)
    return(is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil))));
  return(false);
}

#define is_real_via_method(sc, p) ((s7_is_real(p)) || ((has_active_methods(sc, p)) && (is_real_via_method_1(sc, p))))

static s7_pointer nan_with_error_check(s7_scheme *sc, s7_pointer y, s7_pointer p, s7_pointer args, s7_pointer caller)
{
  for (; is_not_null(p); p = cdr(p))
    if (!is_real_via_method(sc, car(p)))
      return(wrong_type_argument(sc, sc->max_symbol, position_of(p, args), car(p), T_REAL));
  return(y);
}

static s7_pointer g_max(s7_scheme *sc, s7_pointer args)
{
  #define H_max "(max ...) returns the maximum of its arguments"
  #define Q_max sc->pcl_r

  s7_pointer x, y, p;
  s7_int num_a, num_b, den_a, den_b;

  x = car(args);
  p = cdr(args);

  switch (type(x))
    {
    case T_INTEGER:
    MAX_INTEGERS:
      if (is_null(p)) return(x);
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(x) < integer(y)) x = y;
	  goto MAX_INTEGERS;

	case T_RATIO:
	  num_a = integer(x);
	  den_a = 1;
	  num_b = numerator(y);
	  den_b = denominator(y);
	  goto RATIO_MAX_RATIO;

	case T_REAL:
	  if (is_NaN(real(y)))
	    return(nan_with_error_check(sc, y, p, args, sc->max_symbol));
	  if (integer(x) < real(y))
	    {
	      x = y;
	      goto MAX_REALS;
	    }
	  goto MAX_INTEGERS;

	default:
	  return(method_or_bust(sc, y, sc->max_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_RATIO:
    MAX_RATIOS:
      if (is_null(p)) return(x);
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  num_a = numerator(x);
	  den_a = denominator(x);
	  num_b = integer(y);
	  den_b = 1;
	  goto RATIO_MAX_RATIO;

	case T_RATIO:
	  num_a = numerator(x);
	  den_a = denominator(x);
	  num_b = numerator(y);
	  den_b = denominator(y);

	RATIO_MAX_RATIO:
	  /* there are tricky cases here where long ints outrun doubles:
	   *   (max 92233720368547758/9223372036854775807 92233720368547757/9223372036854775807)
	   * which should be 92233720368547758/9223372036854775807) but first the fraction gets reduced
	   * to 13176245766935394/1317624576693539401, so we fall into the double comparison, and
	   * there we should be comparing
	   *    9.999999999999999992410584792601468961145E-3 and
	   *    9.999999999999999883990367544051025548645E-3
	   * but if using doubles we get
	   *    0.010000000000000000208166817117 and
	   *    0.010000000000000000208166817117
	   * that is, we can't distinguish these two fractions once they're coerced to doubles.
	   * Even long doubles fail in innocuous-looking cases:
	   *     (min 21053343141/6701487259 3587785776203/1142027682075) -> 3587785776203/1142027682075
	   *     (max 21053343141/6701487259 3587785776203/1142027682075) -> 3587785776203/1142027682075
	   */

	  if ((num_a < 0) && (num_b >= 0)) /* x < 0, y >= 0 -> y */
	    x = y;
	  else
	    {
	      if ((num_a < 0) || (num_b >= 0))
		{
		  if (den_a == den_b)
		    {
		      if (num_a < num_b)
			x = y;
		    }
		  else
		    {
		      if (num_a == num_b)
			{
			  if (((num_a >= 0) &&
			       (den_a > den_b)) ||
			      ((num_a < 0) &&
			       (den_a < den_b)))
			    x = y;
			}
		      else
			{
			  s7_int vala, valb;
			  vala = num_a / den_a;
			  valb = num_b / den_b;
			  if (!((vala > valb) ||
				((vala == valb) && (is_t_integer(y)))))
			    {
			      if ((valb > vala) ||
				  ((vala == valb) && (is_t_integer(x))) ||
				  /* sigh -- both are ratios and the int32_t parts are equal */
				  (((long_double)(num_a % den_a) / (long_double)den_a) <= ((long_double)(num_b % den_b) / (long_double)den_b)))
				x = y;
			    }}}}
	    }
	  if (is_t_ratio(x))
	    goto MAX_RATIOS;
	  goto MAX_INTEGERS;

	case T_REAL:
	  /* (max 3/4 +nan.0) should probably return NaN */
	  if (is_NaN(real(y)))
	    return(nan_with_error_check(sc, y, p, args, sc->max_symbol));

	  if (fraction(x) < real(y))
	    {
	      x = y;
	      goto MAX_REALS;
	    }
	  goto MAX_RATIOS;

	default:
	  return(method_or_bust(sc, y, sc->max_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_REAL:
      if (is_NaN(real(x)))
	return(nan_with_error_check(sc, x, p, args, sc->max_symbol));

    MAX_REALS:
      if (is_null(p)) return(x);
      y = car(p);
      p = cdr(p);

      switch (type(y))
	{
	case T_INTEGER:
	  if (real(x) < integer(y))
	    {
	      x = y;
	      goto MAX_INTEGERS;
	    }
	  goto MAX_REALS;

	case T_RATIO:
	  if (real(x) < fraction(y))
	    {
	      x = y;
	      goto MAX_RATIOS;
	    }
	  goto MAX_REALS;

	case T_REAL:
	  if (is_NaN(real(y)))
	    return(nan_with_error_check(sc, y, p, args, sc->max_symbol));
	  if (real(x) < real(y)) x = y;
	  goto MAX_REALS;

	default:
	  return(method_or_bust(sc, y, sc->max_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    default:
      return(method_or_bust(sc, x, sc->max_symbol, cons(sc, x, p), T_REAL, 1));
    }
}

static s7_int max_i_ii(s7_int i1, s7_int i2) {return((i1 > i2) ? i1 : i2);}
static s7_int max_i_iii(s7_int i1, s7_int i2, s7_int i3) {return((i1 > i2) ? ((i1 > i3) ? i1 : i3) : ((i2 > i3) ? i2 : i3));}
static s7_double max_d_dd(s7_double x1, s7_double x2) {if (is_NaN(x1)) return(x1); return((x1 > x2) ? x1 : x2);}
static s7_double max_d_ddd(s7_double x1, s7_double x2, s7_double x3) {return(max_d_dd(x1, max_d_dd(x2, x3)));}
static s7_double max_d_dddd(s7_double x1, s7_double x2, s7_double x3, s7_double x4) {return(max_d_dd(x1, max_d_ddd(x2, x3, x4)));}

static s7_pointer g_min(s7_scheme *sc, s7_pointer args)
{
  #define H_min "(min ...) returns the minimum of its arguments"
  #define Q_min sc->pcl_r

  s7_pointer x, y, p;
  s7_int num_a, num_b, den_a, den_b;

  x = car(args);
  p = cdr(args);

  switch (type(x))
    {
    case T_INTEGER:
    MIN_INTEGERS:
      if (is_null(p)) return(x);
      y = car(p);
      p = cdr(p);

      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(x) > integer(y)) x = y;
	  goto MIN_INTEGERS;

	case T_RATIO:
	  num_a = integer(x);
	  den_a = 1;
	  num_b = numerator(y);
	  den_b = denominator(y);
	  goto RATIO_MIN_RATIO;

	case T_REAL:
	  if (is_NaN(real(y)))
	    return(nan_with_error_check(sc, y, p, args, sc->min_symbol));
	  if (integer(x) > real(y))
	    {
	      x = y;
	      goto MIN_REALS;
	    }
	  goto MIN_INTEGERS;

	default:
	  return(method_or_bust(sc, y, sc->min_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_RATIO:
    MIN_RATIOS:
      if (is_null(p)) return(x);
      y = car(p);
      p = cdr(p);

      switch (type(y))
	{
	case T_INTEGER:
	  num_a = numerator(x);
	  den_a = denominator(x);
	  num_b = integer(y);
	  den_b = 1;
	  goto RATIO_MIN_RATIO;

	case T_RATIO:
	  num_a = numerator(x);
	  den_a = denominator(x);
	  num_b = numerator(y);
	  den_b = denominator(y);

	RATIO_MIN_RATIO:
	  if ((num_a >= 0) && (num_b < 0))
	    x = y;
	  else
	    {
	      if ((num_a >= 0) || (num_b < 0))
		{
		  if (den_a == den_b)
		    {
		      if (num_a > num_b)
			x = y;
		    }
		  else
		    {
		      if (num_a == num_b)
			{
			  if (((num_a >= 0) &&
			       (den_a < den_b)) ||
			      ((num_a < 0) &&
			       (den_a > den_b)))
			    x = y;
			}
		      else
			{
			  s7_int vala, valb;
			  vala = num_a / den_a;
			  valb = num_b / den_b;

			  if (!((vala < valb) ||
				((vala == valb) && (is_t_integer(x)))))
			    {
			      if ((valb < vala) ||
				  ((vala == valb) && (is_t_integer(y))) ||
				  (((long_double)(num_a % den_a) / (long_double)den_a) >= ((long_double)(num_b % den_b) / (long_double)den_b)))
				x = y;
			    }}}}
	    }
	  if (is_t_ratio(x))
	    goto MIN_RATIOS;
	  goto MIN_INTEGERS;

	case T_REAL:
	  /* (min 3/4 +nan.0) should probably return NaN */
	  if (is_NaN(real(y)))
	    return(nan_with_error_check(sc, y, p, args, sc->min_symbol));
	  if (fraction(x) > real(y))
	    {
	      x = y;
	      goto MIN_REALS;
	    }
	  goto MIN_RATIOS;

	default:
	  return(method_or_bust(sc, y, sc->min_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_REAL:
      if (is_NaN(real(x)))
	return(nan_with_error_check(sc, x, p, args, sc->min_symbol));

    MIN_REALS:
      if (is_null(p)) return(x);
      y = car(p);
      p = cdr(p);

      switch (type(y))
	{
	case T_INTEGER:
	  if (real(x) > integer(y))
	    {
	      x = y;
	      goto MIN_INTEGERS;
	    }
	  goto MIN_REALS;

	case T_RATIO:
	  if (real(x) > fraction(y))
	    {
	      x = y;
	      goto MIN_RATIOS;
	    }
	  goto MIN_REALS;

	case T_REAL:
	  if (is_NaN(real(y)))
	    return(nan_with_error_check(sc, y, p, args, sc->min_symbol));
	  if (real(x) > real(y)) x = y;
	  goto MIN_REALS;

	default:
	  return(method_or_bust(sc, y, sc->min_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    default:
      return(method_or_bust(sc, x, sc->min_symbol, cons(sc, x, p), T_REAL, 1));
    }
}

static s7_int min_i_ii(s7_int i1, s7_int i2) {return((i1 < i2) ? i1 : i2);}
static s7_int min_i_iii(s7_int i1, s7_int i2, s7_int i3) {return((i1 < i2) ? ((i1 < i3) ? i1 : i3) : ((i2 < i3) ? i2 : i3));}
static s7_double min_d_dd(s7_double x1, s7_double x2) {if (is_NaN(x1)) return(x1); return((x1 < x2) ? x1 : x2);}
static s7_double min_d_ddd(s7_double x1, s7_double x2, s7_double x3) {return(min_d_dd(x1, min_d_dd(x2, x3)));}
static s7_double min_d_dddd(s7_double x1, s7_double x2, s7_double x3, s7_double x4) {return(min_d_dd(x1, min_d_ddd(x2, x3, x4)));}


/* ---------------------------------------- = > < >= <= ---------------------------------------- */

static s7_pointer g_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_equal "(= z1 ...) returns #t if all its arguments are equal"
  #define Q_equal s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_number_symbol)
  s7_pointer x, p;
  s7_int num_a, den_a;
  s7_double rl_a, im_a;

  x = car(args);
  p = cdr(args);

  switch (type(x))
    {
    case T_INTEGER:
      num_a = integer(x);
      while (true)
	{
	  x = car(p);
	  p = cdr(p);
	  switch (type(x))
	    {
	    case T_INTEGER:
	      if (num_a != integer(x)) goto NOT_EQUAL;
	      break;

	    case T_RATIO:
	    case T_COMPLEX:
	      goto NOT_EQUAL;

	    case T_REAL:
	      if (num_a != real(x)) goto NOT_EQUAL;
	      break;

	    default:
	      return(method_or_bust_with_type(sc, x, sc->eq_symbol, cons_unchecked(sc, make_integer(sc, num_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	    }
	  if (is_null(p))
	    return(sc->T);
	}

    case T_RATIO:
      num_a = numerator(x);
      den_a = denominator(x);
      rl_a = 0.0;
      while (true)
	{
	  x = car(p);
	  p = cdr(p);
	  switch (type(x))
	    {
	    case T_INTEGER:
	    case T_COMPLEX:
	      goto NOT_EQUAL;

	    case T_RATIO:
	      if ((num_a != numerator(x)) || (den_a != denominator(x)))	goto NOT_EQUAL; /* hidden cast here */
	      break;

	    case T_REAL:
	      if (rl_a == 0.0)
		rl_a = ((long_double)num_a) / ((long_double)den_a);
	      if (rl_a != real(x)) goto NOT_EQUAL;
	      break;

	    default:
	      return(method_or_bust_with_type(sc, x, sc->eq_symbol, cons_unchecked(sc, s7_make_ratio(sc, num_a, den_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	    }
	  if (is_null(p))
	    return(sc->T);
	}

    case T_REAL:
      rl_a = real(x);
      while (true)
	{
	  x = car(p);
	  p = cdr(p);
	  switch (type(x))
	    {
	    case T_INTEGER:
	      if (rl_a != integer(x)) goto NOT_EQUAL;
	      break;

	    case T_RATIO:
	      if (rl_a != (double)fraction(x)) goto NOT_EQUAL;
	      /* the cast to double is needed because rl_a is s7_double and we want (= ratio real) to be the same as (= real ratio):
	       *   (= 1.0 9223372036854775807/9223372036854775806)
	       *   (= 9223372036854775807/9223372036854775806 1.0)
	       */
	      break;

	    case T_REAL:
	      if (rl_a != real(x)) goto NOT_EQUAL;
	      break;

	    case T_COMPLEX:
	      goto NOT_EQUAL;

	    default:
	      return(method_or_bust_with_type(sc, x, sc->eq_symbol, cons_unchecked(sc, make_real(sc, rl_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	    }
	  if (is_null(p))
	    return(sc->T);
	}

    case T_COMPLEX:
      rl_a = real_part(x);
      im_a = imag_part(x);
      while (true)
	{
	  x = car(p);
	  p = cdr(p);
	  switch (type(x))
	    {
	    case T_INTEGER:
	    case T_RATIO:
	    case T_REAL:
	      goto NOT_EQUAL;

	    case T_COMPLEX:
	      if ((rl_a != real_part(x)) || (im_a != imag_part(x)))
		goto NOT_EQUAL;
	      break;

	    default:
	      return(method_or_bust_with_type(sc, x, sc->eq_symbol, cons_unchecked(sc, s7_make_complex(sc, rl_a, im_a), cons(sc, x, p)), a_number_string, position_of(p, args) - 1));
	    }
	  if (is_null(p))
	    return(sc->T);
	}

    default:
      return(method_or_bust_with_type(sc, x, sc->eq_symbol, args, a_number_string, 1));
    }

 NOT_EQUAL:
  for (; is_pair(p); p = cdr(p))
    if (!is_number_via_method(sc, car(p)))
      return(wrong_type_argument_with_type(sc, sc->eq_symbol, position_of(p, args), car(p), a_number_string));

  return(sc->F);
}


static s7_int c_object_length_to_int(s7_scheme *sc, s7_pointer obj);

#if (!WITH_GMP)
static s7_pointer g_equal_s_ic(s7_scheme *sc, s7_pointer args)
{
  s7_int y;
  s7_pointer val;

  val = lookup(sc, car(args));
  y = integer(cadr(args));
  if (is_t_integer(val))
    return(make_boolean(sc, integer(val) == y));

  switch (type(val))
    {
    case T_INTEGER: return(make_boolean(sc, integer(val) == y));
    case T_RATIO:   return(sc->F);
    case T_REAL:    return(make_boolean(sc, real(val) == y));
    case T_COMPLEX: return(sc->F);
    default: return(method_or_bust_with_type(sc, val, sc->eq_symbol, list_2(sc, val, cadr(args)), a_number_string, 1)); /* not just args here -- need symbol lookup -> val */
    }
  return(sc->T);
}

static s7_pointer g_equal_length_ic(s7_scheme *sc, s7_pointer args)
{
  /* avoid make_integer (and telescope opts), we get here with car=length expr, cadr=int */
  s7_int ilen;
  s7_pointer val;

  val = lookup(sc, cadar(args));
  ilen = integer(cadr(args));

  switch (type(val))
    {
    case T_PAIR:         return(make_boolean(sc, s7_list_length(sc, val) == ilen));
    case T_NIL:          return(make_boolean(sc, ilen == 0));
    case T_STRING:       return(make_boolean(sc, string_length(val) == ilen));
    case T_HASH_TABLE:   return(make_boolean(sc, (hash_table_mask(val) + 1) == ilen));
    case T_C_OBJECT:     return(make_boolean(sc, c_object_length_to_int(sc, val) == ilen));
    case T_LET:          return(make_boolean(sc, let_length(sc, val) == ilen));

    case T_BYTE_VECTOR:
    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
    case T_VECTOR:       
      return(make_boolean(sc, vector_length(val) == ilen));

    case T_ITERATOR:
      {
	s7_pointer len;
	len = s7_length(sc, iterator_sequence(val));
	return(make_boolean(sc, (is_t_integer(len)) && (integer(len) == ilen)));
      }

    case T_CLOSURE:
    case T_CLOSURE_STAR: 
      if (has_active_methods(sc, val)) 
	return(make_boolean(sc, closure_length(sc, val) == ilen));
      /* fall through */

    default:
      return(simple_wrong_type_argument_with_type(sc, sc->length_symbol, val, a_sequence_string));
      /* here we already lost because we checked for the length above */
    }
  return(sc->F);
}


static bool equal_b_pi(s7_scheme *sc, s7_pointer x, s7_int y)
{
  if (is_t_integer(x))
    return(integer(x) == y);

  switch (type(x))
    {
    case T_INTEGER: return(integer(x) == y);
    case T_RATIO:   return(false);
    case T_REAL:    return(real(x) == y);
    case T_COMPLEX: return(false);
    default:
      simple_wrong_type_argument_with_type(sc, sc->eq_symbol, x, a_number_string);
    }
  return(false);
}

static s7_pointer eq_out_x(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, x))
    return(find_and_apply_method(sc, find_let(sc, x), sc->eq_symbol, list_2(sc, x, y)));
  return(wrong_type_argument_with_type(sc, sc->eq_symbol, 1, x, a_number_string));
}

static s7_pointer eq_out_y(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, y))
    return(find_and_apply_method(sc, find_let(sc, y), sc->eq_symbol, list_2(sc, x, y)));
  return(wrong_type_argument_with_type(sc, sc->eq_symbol, 2, y, a_number_string));
}

static s7_pointer c_equal_2(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
#if (!MS_WINDOWS)
  if (type(x) == type(y))
    {
      if (type(x) == T_INTEGER)
	return(make_boolean(sc, integer(x) == integer(y)));
      if (type(x) == T_REAL)
	return(make_boolean(sc, real(x) == real(y)));
      if (type(x) == T_COMPLEX)
	return(make_boolean(sc, (real_part(x) == real_part(y)) && (imag_part(x) == imag_part(y))));
      if (type(x) == T_RATIO)
	return(make_boolean(sc, (numerator(x) == numerator(y)) && (denominator(x) == denominator(y))));
    }
#endif

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER: return(make_boolean(sc, integer(x) == integer(y)));
	case T_RATIO:   return(sc->F);
	case T_REAL:    return(make_boolean(sc, integer(x) == real(y)));
	case T_COMPLEX: return(sc->F);
	default:
	  return(eq_out_y(sc, x, y));
	}
      break;

    case T_RATIO:
      switch (type(y))
	{
	case T_INTEGER: return(sc->F);
	case T_RATIO:   return(make_boolean(sc, (numerator(x) == numerator(y)) && (denominator(x) == denominator(y))));
	case T_REAL:    return(make_boolean(sc, fraction(x) == real(y)));            /* this could avoid the divide via numerator == denominator * x */
	case T_COMPLEX: return(sc->F);
	default:
	  return(eq_out_y(sc, x, y));
	}
      break;

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER: return(make_boolean(sc, real(x) == integer(y)));
	case T_RATIO:   return(make_boolean(sc, real(x) == fraction(y)));
	case T_REAL:    return(make_boolean(sc, real(x) == real(y)));
	case T_COMPLEX: return(sc->F);
	default:
	  return(eq_out_y(sc, x, y));
	}
      break;

    case T_COMPLEX:
      switch (type(y))
	{
	case T_INTEGER:
	case T_RATIO:
	case T_REAL:
	  return(sc->F);

#if (!MS_WINDOWS)
	case T_COMPLEX:
	  return(make_boolean(sc, (real_part(x) == real_part(y)) && (imag_part(x) == imag_part(y))));
#else
	case T_COMPLEX:
	  if ((real_part(x) == real_part(y)) && (imag_part(x) == imag_part(y))) return(sc->T); else return(sc->F);
#endif
	default:
	  return(eq_out_y(sc, x, y));
	}
      break;

    default:
      return(eq_out_x(sc, x, y));
    }
  return(sc->F);
}

static s7_pointer equal_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(c_equal_2(sc, p1, p2));}
static s7_pointer equal_p_pi(s7_scheme *sc, s7_pointer p1, s7_int p2)
{
  if (is_t_integer(p1))
    return((integer(p1) == p2) ? sc->T : sc->F);
  if (is_t_real(p1))
    return((real(p1) == p2) ? sc->T : sc->F);
  if (is_number(p1))
    return(sc->F);
  return(wrong_type_argument_with_type(sc, sc->eq_symbol, 1, p1, a_number_string));
}

static s7_pointer equal_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_boolean(sc, x1 == x2));}
static s7_pointer gt_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_boolean(sc, x1 > x2));}
static s7_pointer geq_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_boolean(sc, x1 >= x2));}
static s7_pointer lt_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_boolean(sc, x1 < x2));}
static s7_pointer leq_p_dd(s7_scheme *sc, s7_double x1, s7_double x2) {return(make_boolean(sc, x1 <= x2));}
static s7_pointer equal_p_ii(s7_scheme *sc, s7_int x1, s7_int x2) {return(make_boolean(sc, x1 == x2));}
static s7_pointer gt_p_ii(s7_scheme *sc, s7_int x1, s7_int x2) {return(make_boolean(sc, x1 > x2));}
static s7_pointer geq_p_ii(s7_scheme *sc, s7_int x1, s7_int x2) {return(make_boolean(sc, x1 >= x2));}
static s7_pointer lt_p_ii(s7_scheme *sc, s7_int x1, s7_int x2) {return(make_boolean(sc, x1 < x2));}
static s7_pointer leq_p_ii(s7_scheme *sc, s7_int x1, s7_int x2) {return(make_boolean(sc, x1 <= x2));}

static s7_pointer g_equal_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, y;
  x = car(args);
  y = cadr(args);
  if ((type(x) == T_INTEGER) && (type(y) == T_INTEGER)) /* this is by far the most common case (ratios aren't used much, and = with floats is frowned upon) */
    return(make_boolean(sc, integer(x) == integer(y)));
  return(c_equal_2(sc, x, y));
}

static s7_pointer g_equal_2i(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, y;
  x = car(args);
  y = cadr(args);
  if (type(x) == T_INTEGER)
    return(make_boolean(sc, integer(x) == integer(y)));
  if (type(x) == T_REAL)
    return(make_boolean(sc, real(x) == integer(y)));
  if (!is_number(x))
    return(eq_out_x(sc, x, y));
  return(sc->F);
}

static s7_pointer g_less(s7_scheme *sc, s7_pointer args)
{
  #define H_less "(< x1 ...) returns #t if its arguments are in increasing order"
  #define Q_less s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)

  s7_pointer x, y, p;

  x = car(args);
  p = cdr(args);

  switch (type(x))
    {
    case T_INTEGER:
    INTEGER_LESS:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(x) >= integer(y)) goto NOT_LESS;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_LESS;

	case T_RATIO:
	  /* no gmp here, but this can overflow: (< 9223372036 1/9223372036), but conversion to real is also problematic
	   */
	  if ((integer(x) >= 0) && (numerator(y) < 0)) goto NOT_LESS;  /* (< 1 -1/2), ratio numerator can't be 0 */
	  if ((integer(x) <= 0) && (numerator(y) > 0))                 /* (< 0 1/2) */
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto RATIO_LESS;
	    }
	  if ((integer(x) < s7_int32_max) &&
	      (integer(x) > s7_int32_min) &&
	      (denominator(y) < s7_int32_max))
	    {
	      if ((integer(x) * denominator(y)) >= numerator(y)) goto NOT_LESS;
	    }
	  else
	    {
	      if (integer(x) >= fraction(y)) goto NOT_LESS;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_LESS;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_LESS;
	  if (integer(x) >= real(y)) goto NOT_LESS;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_LESS;

	default:
	  return(method_or_bust(sc, y, sc->lt_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_RATIO:
    RATIO_LESS:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if ((numerator(x) > 0) && (integer(y) <= 0)) goto NOT_LESS;
	  if ((numerator(x) < 0) && (integer(y) >= 0))
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto INTEGER_LESS;
	    }
	  if ((integer(y) < s7_int32_max) &&
	      (integer(y) > s7_int32_min) &&
	      (denominator(x) < s7_int32_max))
	    {
	      if (numerator(x) >= (integer(y) * denominator(x))) goto NOT_LESS;
	    }
	  else
	    {
	      if (fraction(x) >= integer(y)) goto NOT_LESS;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_LESS;

	case T_RATIO:
	  /* conversion to real and >= is not safe here (see comment under g_greater) */
	  {
	    s7_int d1, d2, n1, n2;
	    d1 = denominator(x);
	    n1 = numerator(x);
	    d2 = denominator(y);
	    n2 = numerator(y);
	    if (d1 == d2)
	      {
		if (n1 >= n2) goto NOT_LESS;
	      }
	    else
	      {
#if HAVE_OVERFLOW_CHECKS
		if ((multiply_overflow(n1, d2, &n1)) ||
		    (multiply_overflow(n2, d1, &n2)))
		  {
		    if (fraction(x) >= fraction(y)) goto NOT_LESS;
		  }
		else
		  {
		    if (n1 >= n2) goto NOT_LESS;
		  }
#else
		if ((n1 * d2) >=  (n2 * d1)) goto NOT_LESS;
#endif
	      }
	  }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_LESS;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_LESS;
	  if (fraction(x) >= real(y)) goto NOT_LESS;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_LESS;

	default:
	  return(method_or_bust(sc, y, sc->lt_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_REAL:
      if (is_NaN(real(x))) goto NOT_LESS;

    REAL_LESS:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (real(x) >= integer(y)) goto NOT_LESS;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_LESS;

	case T_RATIO:
	  if (real(x) >= fraction(y)) goto NOT_LESS;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_LESS;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_LESS;
	  if (real(x) >= real(y)) goto NOT_LESS;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_LESS;

	default:
	  return(method_or_bust(sc, y, sc->lt_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    default:
      return(method_or_bust(sc, x, sc->lt_symbol, args, T_REAL, 1));
    }

 NOT_LESS:
  for (; is_pair(p); p = cdr(p))
    if (!is_real_via_method(sc, car(p)))
      return(wrong_type_argument(sc, sc->lt_symbol, position_of(p, args), car(p), T_REAL));

  return(sc->F);
}


static s7_pointer g_less_or_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_less_or_equal "(<= x1 ...) returns #t if its arguments are in increasing order"
  #define Q_less_or_equal s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)

  s7_pointer x, y, p;

  x = car(args);
  p = cdr(args);

  switch (type(x))
    {
    case T_INTEGER:
    INTEGER_LEQ:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(x) > integer(y)) goto NOT_LEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_LEQ;

	case T_RATIO:
	  /* no gmp here, but this can overflow: (< 9223372036 1/9223372036), but conversion to real is also problematic
	   */
	  if ((integer(x) >= 0) && (numerator(y) < 0)) goto NOT_LEQ;  /* (< 1 -1/2), ratio numerator can't be 0 */
	  if ((integer(x) <= 0) && (numerator(y) > 0))                 /* (< 0 1/2) */
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto RATIO_LEQ;
	    }
	  if ((integer(x) < s7_int32_max) &&
	      (integer(x) > s7_int32_min) &&
	      (denominator(y) < s7_int32_max))
	    {
	      if ((integer(x) * denominator(y)) > numerator(y)) goto NOT_LEQ;
	    }
	  else
	    {
	      if (integer(x) > fraction(y)) goto NOT_LEQ;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_LEQ;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_LEQ;
	  if (integer(x) > real(y)) goto NOT_LEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_LEQ;

	default:
	  return(method_or_bust(sc, y, sc->leq_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_RATIO:
    RATIO_LEQ:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if ((numerator(x) > 0) && (integer(y) <= 0)) goto NOT_LEQ;
	  if ((numerator(x) < 0) && (integer(y) >= 0))
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto INTEGER_LEQ;
	    }
	  if ((integer(y) < s7_int32_max) &&
	      (integer(y) > s7_int32_min) &&
	      (denominator(x) < s7_int32_max))
	    {
	      if (numerator(x) > (integer(y) * denominator(x))) goto NOT_LEQ;
	    }
	  else
	    {
	      if (fraction(x) > integer(y)) goto NOT_LEQ;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_LEQ;

	case T_RATIO:
	  {
	    s7_int d1, d2, n1, n2;
	    d1 = denominator(x);
	    n1 = numerator(x);
	    d2 = denominator(y);
	    n2 = numerator(y);
	    if (d1 == d2)
	      {
		if (n1 > n2) goto NOT_LEQ;
	      }
	    else
	      {
#if HAVE_OVERFLOW_CHECKS
		if ((multiply_overflow(n1, d2, &n1)) ||
		    (multiply_overflow(n2, d1, &n2)))
		  {
		    if (fraction(x) > fraction(y)) goto NOT_LEQ;
		  }
		else
		  {
		    if (n1 > n2) goto NOT_LEQ;
		  }
#else
		if ((n1 * d2) >  (n2 * d1)) goto NOT_LEQ;
#endif
	      }
	  }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_LEQ;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_LEQ;
	  if (fraction(x) > real(y)) goto NOT_LEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_LEQ;

	default:
	  return(method_or_bust(sc, y, sc->leq_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_REAL:
      if (is_NaN(real(x))) goto NOT_LEQ;

    REAL_LEQ:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (real(x) > integer(y)) goto NOT_LEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_LEQ;

	case T_RATIO:
	  if (real(x) > fraction(y)) goto NOT_LEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_LEQ;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_LEQ;
	  if (real(x) > real(y)) goto NOT_LEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_LEQ;

	default:
	  return(method_or_bust(sc, y, sc->leq_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    default:
      return(method_or_bust(sc, x, sc->leq_symbol, args, T_REAL, 1));
    }

 NOT_LEQ:
  for (; is_pair(p); p = cdr(p))
    if (!is_real_via_method(sc, car(p)))
      return(wrong_type_argument(sc, sc->leq_symbol, position_of(p, args), car(p), T_REAL));

  return(sc->F);
}


static s7_pointer g_greater(s7_scheme *sc, s7_pointer args)
{
  #define H_greater "(> x1 ...) returns #t if its arguments are in decreasing order"
  #define Q_greater s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)

  s7_pointer x, y, p;
  x = car(args);
  p = cdr(args);

  switch (type(x))
    {
    case T_INTEGER:
    INTEGER_GREATER:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(x) <= integer(y)) goto NOT_GREATER;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_GREATER;

	case T_RATIO:
	  /* no gmp here, but this can overflow: (< 9223372036 1/9223372036), but conversion to real is also problematic
	   */
	  if ((integer(x) <= 0) && (numerator(y) > 0)) goto NOT_GREATER;
	  if ((integer(x) >= 0) && (numerator(y) < 0))
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto RATIO_GREATER;
	    }
	  if ((integer(x) < s7_int32_max) &&
	      (integer(x) > s7_int32_min) &&
	      (denominator(y) < s7_int32_max))
	    {
	      if ((integer(x) * denominator(y)) <= numerator(y)) goto NOT_GREATER;
	    }
	  else
	    {
	      if (integer(x) <= fraction(y)) goto NOT_GREATER;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_GREATER;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_GREATER;
	  if (integer(x) <= real(y)) goto NOT_GREATER;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_GREATER;

	default:
	  return(method_or_bust(sc, y, sc->gt_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_RATIO:
    RATIO_GREATER:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if ((numerator(x) < 0) && (integer(y) >= 0)) goto NOT_GREATER;
	  if ((numerator(x) > 0) && (integer(y) <= 0))
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto INTEGER_GREATER;
	    }
	  if ((integer(y) < s7_int32_max) &&
	      (integer(y) > s7_int32_min) &&
	      (denominator(x) < s7_int32_max))
	    {
	      if (numerator(x) <= (integer(y) * denominator(x))) goto NOT_GREATER;
	    }
	  else
	    {
	      if (fraction(x) <= integer(y)) goto NOT_GREATER;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_GREATER;

	case T_RATIO:
	  {
	    s7_int d1, d2, n1, n2;
	    d1 = denominator(x);
	    n1 = numerator(x);
	    d2 = denominator(y);
	    n2 = numerator(y);
	    if (d1 == d2)
	      {
		if (n1 <= n2) goto NOT_GREATER;
	      }
	    else
	      {
#if HAVE_OVERFLOW_CHECKS
		if ((multiply_overflow(n1, d2, &n1)) ||
		    (multiply_overflow(n2, d1, &n2)))
		  {
		    if (fraction(x) <= fraction(y)) goto NOT_GREATER;
		  }
		else
		  {
		    if (n1 <= n2) goto NOT_GREATER;
		  }
#else
		if ((n1 * d2) <=  (n2 * d1)) goto NOT_GREATER;
#endif
	      }
	  }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_GREATER;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_GREATER;
	  if (fraction(x) <= real(y)) goto NOT_GREATER;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_GREATER;

	default:
	  return(method_or_bust(sc, y, sc->gt_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_REAL:
      if (is_NaN(real(x))) goto NOT_GREATER;

    REAL_GREATER:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (real(x) <= integer(y)) goto NOT_GREATER;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_GREATER;

	case T_RATIO:
	  if (real(x) <= fraction(y)) goto NOT_GREATER;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_GREATER;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_GREATER;
	  if (real(x) <= real(y)) goto NOT_GREATER;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_GREATER;

	default:
	  return(method_or_bust(sc, y, sc->gt_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    default:
      return(method_or_bust(sc, x, sc->gt_symbol, args, T_REAL, 1));
    }

 NOT_GREATER:
  for (; is_pair(p); p = cdr(p))
    if (!is_real_via_method(sc, car(p)))
      return(wrong_type_argument(sc, sc->gt_symbol, position_of(p, args), car(p), T_REAL));

  return(sc->F);
}


static s7_pointer g_greater_or_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_greater_or_equal "(>= x1 ...) returns #t if its arguments are in decreasing order"
  #define Q_greater_or_equal s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)
  /* (>= 1+i 1+i) is an error which seems unfortunate */
  s7_pointer x, y, p;

  x = car(args);
  p = cdr(args);

  switch (type(x))
    {
    case T_INTEGER:
    INTEGER_GEQ:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (integer(x) < integer(y)) goto NOT_GEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_GEQ;

	case T_RATIO:
	  /* no gmp here, but this can overflow: (< 9223372036 1/9223372036), but conversion to real is also problematic
	   */
	  if ((integer(x) <= 0) && (numerator(y) > 0)) goto NOT_GEQ;
	  if ((integer(x) >= 0) && (numerator(y) < 0))
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto RATIO_GEQ;
	    }
	  if ((integer(x) < s7_int32_max) &&
	      (integer(x) > s7_int32_min) &&
	      (denominator(y) < s7_int32_max))
	    {
	      if ((integer(x) * denominator(y)) < numerator(y)) goto NOT_GEQ;
	    }
	  else
	    {
	      if (integer(x) < fraction(y)) goto NOT_GEQ;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_GEQ;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_GEQ;
	  if (integer(x) < real(y)) goto NOT_GEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_GEQ;

	default:
	  return(method_or_bust(sc, y, sc->geq_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_RATIO:
    RATIO_GEQ:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if ((numerator(x) < 0) && (integer(y) >= 0)) goto NOT_GEQ;
	  if ((numerator(x) > 0) && (integer(y) <= 0))
	    {
	      if (is_null(p)) return(sc->T);
	      x = y;
	      goto INTEGER_GEQ;
	    }
	  if ((integer(y) < s7_int32_max) &&
	      (integer(y) > s7_int32_min) &&
	      (denominator(x) < s7_int32_max))
	    {
	      if (numerator(x) < (integer(y) * denominator(x))) goto NOT_GEQ;
	    }
	  else
	    {
	      if (fraction(x) < integer(y)) goto NOT_GEQ;
	    }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_GEQ;

	case T_RATIO:
	  {
	    s7_int d1, d2, n1, n2;
	    d1 = denominator(x);
	    n1 = numerator(x);
	    d2 = denominator(y);
	    n2 = numerator(y);
	    if (d1 == d2)
	      {
		if (n1 < n2) goto NOT_GEQ;
	      }
	    else
	      {
#if HAVE_OVERFLOW_CHECKS
		if ((multiply_overflow(n1, d2, &n1)) ||
		    (multiply_overflow(n2, d1, &n2)))
		  {
		    if (fraction(x) < fraction(y)) goto NOT_GEQ;
		  }
		else
		  {
		    if (n1 < n2) goto NOT_GEQ;
		  }
#else
		if ((n1 * d2) <  (n2 * d1)) goto NOT_GEQ;
#endif
	      }
	  }
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_GEQ;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_GEQ;
	  if (fraction(x) < real(y)) goto NOT_GEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_GEQ;

	default:
	  return(method_or_bust(sc, y, sc->geq_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    case T_REAL:
      if (is_NaN(real(x))) goto NOT_GEQ;

    REAL_GEQ:
      y = car(p);
      p = cdr(p);
      switch (type(y))
	{
	case T_INTEGER:
	  if (real(x) < integer(y)) goto NOT_GEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto INTEGER_GEQ;

	case T_RATIO:
	  if (real(x) < fraction(y)) goto NOT_GEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto RATIO_GEQ;

	case T_REAL:
	  if (is_NaN(real(y))) goto NOT_GEQ;
	  if (real(x) < real(y)) goto NOT_GEQ;
	  if (is_null(p)) return(sc->T);
	  x = y;
	  goto REAL_GEQ;

	default:
	  return(method_or_bust(sc, y, sc->geq_symbol, cons_unchecked(sc, x, cons(sc, y, p)), T_REAL, position_of(p, args) - 1));
	}

    default:
      return(method_or_bust(sc, x, sc->geq_symbol, args, T_REAL, 1));
    }

 NOT_GEQ:
  for (; is_pair(p); p = cdr(p))
    if (!is_real_via_method(sc, car(p)))
      return(wrong_type_argument(sc, sc->geq_symbol, position_of(p, args), car(p), T_REAL));

  return(sc->F);

}

static s7_pointer g_less_s0(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  x = car(args);
  if (is_t_integer(x))
    return(make_boolean(sc, integer(x) < 0));
  if (is_real(x))
    return(make_boolean(sc, s7_is_negative(x)));
  return(method_or_bust(sc, x, sc->lt_symbol, args, T_REAL, 1));
}

static bool ratio_lt_pi(s7_pointer x, s7_int y)
{
  if ((y >= 0) && (numerator(x) < 0))
    return(true);
  if ((y <= 0) && (numerator(x) > 0))
    return(false);
  if (denominator(x) < s7_int32_max)
    return(numerator(x) < (y * denominator(x)));
  return(fraction(x) < y);
}

static s7_pointer g_less_s_ic(s7_scheme *sc, s7_pointer args)
{
  s7_int y;
  s7_pointer x;

  x = car(args);
  y = integer(cadr(args));

  if (type(x) == T_INTEGER)
    return(make_boolean(sc, integer(x) < y));
  if (type(x) == T_REAL)
    return(make_boolean(sc, real(x) < y));
  if (type(x) == T_RATIO)
    return(make_boolean(sc, ratio_lt_pi(x, y)));
  return(method_or_bust(sc, x, sc->lt_symbol, args, T_REAL, 1));
}

static s7_pointer g_less_length_ic(s7_scheme *sc, s7_pointer args)
{
  s7_int ilen;
  s7_pointer val;

  val = lookup(sc, cadar(args));
  ilen = integer(cadr(args));

  switch (type(val))
    {
    case T_PAIR:         return(make_boolean(sc, s7_list_length(sc, val) < ilen));
    case T_NIL:          return(make_boolean(sc, ilen > 0));
    case T_STRING:       return(make_boolean(sc, string_length(val) < ilen));
    case T_HASH_TABLE:   return(make_boolean(sc, (hash_table_mask(val) + 1) < ilen)); /* was <=? -- changed 15-Dec-15, then again 6-Jan-17: mask is len-1 */
    case T_C_OBJECT:     return(make_boolean(sc, c_object_length_to_int(sc, val) < ilen));
    case T_LET:          return(make_boolean(sc, let_length(sc, val) < ilen));  /* this works because let_length handles the length method itself! */

    case T_BYTE_VECTOR:
    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
    case T_VECTOR:       
      return(make_boolean(sc, vector_length(val) < ilen));

    case T_ITERATOR:
      {
	s7_pointer len;
	len = s7_length(sc, iterator_sequence(val));
	return(make_boolean(sc, (is_t_integer(len)) && (integer(len) < ilen)));
      }

    case T_CLOSURE:
    case T_CLOSURE_STAR: 
      if (has_active_methods(sc, val)) 
	return(make_boolean(sc, closure_length(sc, val) < ilen));
      /* fall through */

    default:
      return(simple_wrong_type_argument_with_type(sc, sc->length_symbol, val, a_sequence_string)); /* no check method here because we checked above */
    }
  return(sc->F);
}

static bool lt_out_x(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, x))
    return(find_and_apply_method(sc, find_let(sc, x), sc->lt_symbol, list_2(sc, x, y)) != sc->F);
  wrong_type_argument(sc, sc->lt_symbol, 1, x, T_REAL);
  return(false);
}

static bool lt_out_y(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, y))
    return(find_and_apply_method(sc, find_let(sc, y), sc->lt_symbol, list_2(sc, x, y)) != sc->F);
  wrong_type_argument(sc, sc->lt_symbol, 2, y, T_REAL);
  return(false);
}

static inline bool lt_b_7pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (type(x) == type(y))
    {
      if (type(x) == T_INTEGER)
	return(integer(x) < integer(y));
      if (type(x) == T_REAL)
	return(real(x) < real(y));
      if (type(x) == T_RATIO)
	return(fraction(x) < fraction(y));
    }
  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  return(integer(x) < integer(y));

	case T_RATIO:
	  return(g_less(sc, set_plist_2(sc, x, y)) != sc->F);

	case T_REAL:
	  if (is_NaN(real(y))) return(false);
	  return(integer(x) < real(y));

	default:
	  return(lt_out_y(sc, x, y));
	}
      break;

    case T_RATIO:
      return(g_less(sc, set_plist_2(sc, x, y)) != sc->F);

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) < integer(y));

	case T_RATIO:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) < fraction(y));

	case T_REAL:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) < real(y));

	default:
	  return(lt_out_y(sc, x, y));
	}
      break;

    default:
      return(lt_out_x(sc, x, y));
    }
  return(true);
}

static s7_pointer lt_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(make_boolean(sc, lt_b_7pp(sc, p1, p2)));}
static s7_pointer g_less_2(s7_scheme *sc, s7_pointer args) {return(lt_p_pp(sc, car(args), cadr(args)));}

static bool ratio_leq_pi(s7_pointer x, s7_int y)
{
  if ((y >= 0) && (numerator(x) <= 0))
    return(true);
  if ((y <= 0) && (numerator(x) > 0))
    return(false);
  if (denominator(x) < s7_int32_max)
    return(numerator(x) <= (y * denominator(x)));
  return(fraction(x) <= y);
}

static s7_pointer g_leq_s_ic(s7_scheme *sc, s7_pointer args)
{
  s7_int y;
  s7_pointer x;

  x = car(args);
  y = integer(cadr(args));

  if (type(x) == T_INTEGER)
    return(make_boolean(sc, integer(x) <= y));
  if (type(x) == T_REAL)
    return(make_boolean(sc, real(x) <= y));
  if (type(x) == T_RATIO)
    return(make_boolean(sc, ratio_leq_pi(x, y)));
  return(method_or_bust(sc, x, sc->leq_symbol, args, T_REAL, 1));
}


static inline bool leq_b_7pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (type(x) == type(y))
    {
      if (type(x) == T_INTEGER)
	return(integer(x) <= integer(y));
      if (type(x) == T_REAL)
	return(real(x) <= real(y));
      if (type(x) == T_RATIO)
	return(fraction(x) <= fraction(y));
    }

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  return(integer(x) <= integer(y));

	case T_RATIO:
	  return(g_less_or_equal(sc, set_plist_2(sc, x, y)) != sc->F);

	case T_REAL:
	  if (is_NaN(real(y))) return(false);
	  return(integer(x) <= real(y));

	default:
	  return(method_or_bust(sc, y, sc->leq_symbol, list_2(sc, x, y), T_REAL, 2) != sc->F);
	}
      break;

    case T_RATIO:
      return(g_less_or_equal(sc, set_plist_2(sc, x, y)) != sc->F);

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) <= integer(y));

	case T_RATIO:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) <= fraction(y));

	case T_REAL:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) <= real(y));

	default:
	  return(method_or_bust(sc, y, sc->leq_symbol, list_2(sc, x, y), T_REAL, 2) != sc->F);
	}
      break;

    default:
      return(method_or_bust(sc, x, sc->leq_symbol, list_2(sc, x, y), T_REAL, 1) != sc->F);
    }
  return(true);
}

static s7_pointer leq_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(make_boolean(sc, leq_b_7pp(sc, p1, p2)));}
static s7_pointer g_leq_2(s7_scheme *sc, s7_pointer args) {return(make_boolean(sc, leq_b_7pp(sc, car(args), cadr(args))));}

static s7_pointer g_greater_s_ic(s7_scheme *sc, s7_pointer args)
{
  s7_int y;
  s7_pointer x;

  x = car(args);
  y = integer(cadr(args));

  if (type(x) == T_INTEGER)
    return(make_boolean(sc, integer(x) > y));
  if (type(x) == T_REAL)
    return(make_boolean(sc, real(x) > y));
  if (type(x) == T_RATIO)
    return(make_boolean(sc, !ratio_leq_pi(x, y)));
  return(method_or_bust_with_type(sc, x, sc->gt_symbol, args, a_number_string, 1));
}

static s7_pointer g_greater_s_fc(s7_scheme *sc, s7_pointer args)
{
  s7_double y;
  s7_pointer x;

  x = car(args);
  y = real(cadr(args));

  if (is_t_real(x))
    return(make_boolean(sc, real(x) > y));

  switch (type(x))
    {
    case T_INTEGER:
      return(make_boolean(sc, integer(x) > y));

    case T_RATIO:
      /* (> 9223372036854775807/9223372036854775806 1.0) */
      if (denominator(x) < s7_int32_max) /* y range check was handled in greater_chooser */
	return(make_boolean(sc, (numerator(x) > (y * denominator(x)))));
      return(make_boolean(sc, fraction(x) > y));

    case T_REAL:
      return(make_boolean(sc, real(x) > y));

    default:
      return(method_or_bust_with_type(sc, x, sc->gt_symbol, args, a_number_string, 1));
    }
  return(sc->T);
}

static bool gt_out_x(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, x))
    return(find_and_apply_method(sc, find_let(sc, x), sc->gt_symbol, list_2(sc, x, y)) != sc->F);
  wrong_type_argument(sc, sc->gt_symbol, 1, x, T_REAL);
  return(false);
}

static bool gt_out_y(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, y))
    return(find_and_apply_method(sc, find_let(sc, y), sc->gt_symbol, list_2(sc, x, y)) != sc->F);
  wrong_type_argument(sc, sc->gt_symbol, 2, y, T_REAL);
  return(false);
}

static inline bool gt_b_7pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (type(x) == type(y))
    {
      if (type(x) == T_INTEGER)
	return(integer(x) > integer(y));
      if (type(x) == T_REAL)
	return(real(x) > real(y));
      if (type(x) == T_RATIO)
	return(fraction(x) > fraction(y));
    }

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  return(integer(x) > integer(y));

	case T_RATIO:
	  return(g_greater(sc, set_plist_2(sc, x, y)) != sc->F);

	case T_REAL:
	  if (is_NaN(real(y))) return(false);
	  return(integer(x) > real(y));

	default:
	  return(gt_out_y(sc, x, y));
	}
      break;

    case T_RATIO:
      return(g_greater(sc, set_plist_2(sc, x, y)) != sc->F);

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) > integer(y));

	case T_RATIO:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) > fraction(y));

	case T_REAL:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) > real(y));

	default:
	  return(gt_out_y(sc, x, y));
	}
      break;

    default:
      return(gt_out_x(sc, x, y));
    }
  return(true);
}

static s7_pointer gt_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(make_boolean(sc, gt_b_7pp(sc, p1, p2)));}

static s7_pointer g_greater_2(s7_scheme *sc, s7_pointer args)
{
#if 0
  return(gt_p_pp(sc, car(args), cadr(args)));
#else
  /* ridiculous repetition, but overheads are killing this poor thing */
  s7_pointer x, y;
  x = car(args);
  y = cadr(args);
#if (!MS_WINDOWS)
  if (type(x) == type(y))
    {
      if (type(x) == T_INTEGER) return(make_boolean(sc, integer(x) > integer(y)));
      if (type(x) == T_REAL)	return(make_boolean(sc, real(x) > real(y)));
      if (type(x) == T_RATIO)	return(make_boolean(sc, fraction(x) > fraction(y)));
    }
#endif
  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER: return(make_boolean(sc, integer(x) > integer(y)));
	case T_RATIO:   return(g_greater(sc, set_plist_2(sc, x, y)));
	case T_REAL:    if (is_NaN(real(y))) return(sc->F); return(make_boolean(sc, integer(x) > real(y)));
	default:        return(make_boolean(sc, gt_out_y(sc, x, y)));
	}
      break;

    case T_RATIO:       return(g_greater(sc, set_plist_2(sc, x, y)));

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER: if (is_NaN(real(x))) return(sc->F); return(make_boolean(sc, real(x) > integer(y)));
	case T_RATIO:   if (is_NaN(real(x))) return(sc->F); return(make_boolean(sc, real(x) > fraction(y)));
	case T_REAL:    if (is_NaN(real(x))) return(sc->F); return(make_boolean(sc, real(x) > real(y)));
	default:        return(make_boolean(sc, gt_out_y(sc, x, y)));
	}
      break;

    default:            return(make_boolean(sc, gt_out_x(sc, x, y)));
    }
  return(sc->T);
#endif
}

static bool geq_out_x(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, x))
    return(find_and_apply_method(sc, find_let(sc, x), sc->geq_symbol, list_2(sc, x, y)) != sc->F);
  wrong_type_argument(sc, sc->geq_symbol, 1, x, T_REAL);
  return(false);
}

static bool geq_out_y(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (has_active_methods(sc, y))
    return(find_and_apply_method(sc, find_let(sc, y), sc->geq_symbol, list_2(sc, x, y)) != sc->F);
  wrong_type_argument(sc, sc->geq_symbol, 2, y, T_REAL);
  return(false);
}

static inline bool geq_b_7pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (type(x) == type(y))
    {
      if (type(x) == T_INTEGER)
	return(integer(x) >= integer(y));
      if (type(x) == T_REAL)
	return(real(x) >= real(y));
      if (type(x) == T_RATIO)
	return(fraction(x) >= fraction(y));
    }

  switch (type(x))
    {
    case T_INTEGER:
      switch (type(y))
	{
	case T_INTEGER:
	  return(integer(x) >= integer(y));

	case T_RATIO:
	  return(g_greater_or_equal(sc, set_plist_2(sc, x, y)) != sc->F);

	case T_REAL:
	  if (is_NaN(real(y))) return(false);
	  return(integer(x) >= real(y));

	default:
	  return(geq_out_y(sc, x, y));
	}
      break;

    case T_RATIO:
      return(g_greater_or_equal(sc, set_plist_2(sc, x, y)) != sc->F);

    case T_REAL:
      switch (type(y))
	{
	case T_INTEGER:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) >= integer(y));

	case T_RATIO:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) >= fraction(y));

	case T_REAL:
	  if (is_NaN(real(x))) return(false);
	  return(real(x) >= real(y));

	default:
	  return(geq_out_y(sc, x, y));
	}
      break;

    default:
      return(geq_out_x(sc, x, y));
    }
  return(true);
}

static s7_pointer geq_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(make_boolean(sc, geq_b_7pp(sc, p1, p2)));}
static s7_pointer g_geq_2(s7_scheme *sc, s7_pointer args) {return(make_boolean(sc, geq_b_7pp(sc, car(args), cadr(args))));}

static s7_pointer g_geq_s_fc(s7_scheme *sc, s7_pointer args)
{
  s7_double y;
  s7_pointer x;

  x = car(args);
  y = real(cadr(args));

  if (is_t_real(x))
    return(make_boolean(sc, real(x) >= y));
  return(g_geq_2(sc, args));
}

static s7_pointer g_geq_s_ic(s7_scheme *sc, s7_pointer args)
{
  s7_int y;
  s7_pointer x;

  x = car(args);
  y = integer(cadr(args));

  if (type(x) == T_INTEGER)
    return(make_boolean(sc, integer(x) >= y));
  if (type(x) == T_REAL)
    return(make_boolean(sc, real(x) >= y));
  if (type(x) == T_RATIO)
    return(make_boolean(sc, !ratio_lt_pi(x, y)));
  return(method_or_bust(sc, x, sc->geq_symbol, args, T_REAL, 1));
}


static bool req_b_7pp(s7_scheme *sc, s7_pointer x, s7_pointer y) {return(c_equal_2(sc, x, y) != sc->F);}

static bool lt_b_pi(s7_scheme *sc, s7_pointer p1, s7_int p2)
{
  if (is_t_integer(p1)) return(integer(p1) < p2);
  if (is_t_real(p1))  return(real(p1) < p2);
  if (is_t_ratio(p1)) return(ratio_lt_pi(p1, p2));
  simple_wrong_type_argument(sc, sc->lt_symbol, p1, T_REAL);
  return(false);
}

static s7_pointer lt_p_pi(s7_scheme *sc, s7_pointer p1, s7_int p2) {return(make_boolean(sc, lt_b_pi(sc, p1, p2)));}

static bool leq_b_pi(s7_scheme *sc, s7_pointer p1, s7_int p2)
{
  if (is_t_integer(p1)) return(integer(p1) <= p2);
  if (is_t_real(p1))  return(real(p1) <= p2);
  if (is_t_ratio(p1)) return(ratio_leq_pi(p1, p2));
  simple_wrong_type_argument(sc, sc->leq_symbol, p1, T_REAL);
  return(false);
}

static s7_pointer leq_p_pi(s7_scheme *sc, s7_pointer p1, s7_int p2) {return(make_boolean(sc, leq_b_pi(sc, p1, p2)));}

static bool gt_b_pi(s7_scheme *sc, s7_pointer p1, s7_int p2)
{
  if (is_t_integer(p1)) return(integer(p1) > p2);
  if (is_t_real(p1))  return(real(p1) > p2);
  if (is_t_ratio(p1)) return(!ratio_leq_pi(p1, p2));
  simple_wrong_type_argument(sc, sc->gt_symbol, p1, T_REAL);
  return(false);
}

static s7_pointer gt_p_pi(s7_scheme *sc, s7_pointer p1, s7_int p2) {return(make_boolean(sc, gt_b_pi(sc, p1, p2)));}

static bool geq_b_pi(s7_scheme *sc, s7_pointer p1, s7_int p2)
{
  if (is_t_integer(p1)) return(integer(p1) >= p2);
  if (is_t_real(p1))  return(real(p1) >= p2);
  if (is_t_ratio(p1)) return(!ratio_lt_pi(p1, p2));
  simple_wrong_type_argument(sc, sc->geq_symbol, p1, T_REAL);
  return(false);
}

static s7_pointer geq_p_pi(s7_scheme *sc, s7_pointer p1, s7_int p2) {return(make_boolean(sc, geq_b_pi(sc, p1, p2)));}
#else
static s7_pointer big_less(s7_scheme *sc, s7_pointer args);
static bool lt_b_7pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  return(big_less(sc, set_plist_2(sc, x, y)) != sc->F);
}
#endif
/* end (!WITH_GMP) */

static bool req_b_ii(s7_int i1, s7_int i2) {return(i1 == i2);}
static bool lt_b_ii(s7_int i1, s7_int i2) {return(i1 < i2);}
static bool leq_b_ii(s7_int i1, s7_int i2) {return(i1 <= i2);}
static bool gt_b_ii(s7_int i1, s7_int i2) {return(i1 > i2);}
static bool geq_b_ii(s7_int i1, s7_int i2) {return(i1 >= i2);}
static bool req_b_dd(s7_double i1, s7_double i2) {return(i1 == i2);}
static bool lt_b_dd(s7_double i1, s7_double i2) {return(i1 < i2);}
static bool leq_b_dd(s7_double i1, s7_double i2) {return(i1 <= i2);}
static bool gt_b_dd(s7_double i1, s7_double i2) {return(i1 > i2);}
static bool geq_b_dd(s7_double i1, s7_double i2) {return(i1 >= i2);}


/* ---------------------------------------- real-part imag-part ---------------------------------------- */

s7_double s7_real_part(s7_pointer x)
{
  switch(type(x))
    {
    case T_INTEGER:     return((s7_double)integer(x));
    case T_RATIO:       return(fraction(x));
    case T_REAL:        return(real(x));
    case T_COMPLEX:     return(real_part(x));
#if WITH_GMP
    case T_BIG_INTEGER: return((s7_double)big_integer_to_s7_int(big_integer(x)));
    case T_BIG_RATIO:   return((s7_double)((long_double)big_integer_to_s7_int(mpq_numref(big_ratio(x))) / (long_double)big_integer_to_s7_int(mpq_denref(big_ratio(x)))));
    case T_BIG_REAL:    return((s7_double)mpfr_get_d(big_real(x), GMP_RNDN));
    case T_BIG_COMPLEX: return((s7_double)mpfr_get_d(mpc_realref(big_complex(x)), GMP_RNDN));
#endif
    }
  return(0.0);
}

s7_double s7_imag_part(s7_pointer x)
{
  switch (type(x))
    {
    case T_COMPLEX:     return(imag_part(x));
#if WITH_GMP
    case T_BIG_COMPLEX: return((s7_double)mpfr_get_d(mpc_imagref(big_complex(x)), GMP_RNDN));
#endif
    }
  return(0.0);
}

static s7_pointer g_real_part(s7_scheme *sc, s7_pointer args)
{
  #define H_real_part "(real-part num) returns the real part of num"
  #define Q_real_part s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_number_symbol)

  s7_pointer p;
  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:
    case T_RATIO:
    case T_REAL:
      return(p);

    case T_COMPLEX:
      return(make_real(sc, real_part(p)));

#if WITH_GMP
    case T_BIG_INTEGER:
    case T_BIG_RATIO:
    case T_BIG_REAL:
      return(p);

    case T_BIG_COMPLEX:
      {
	s7_pointer x;

	new_cell(sc, x, T_BIG_REAL);
	add_big_real(sc, x);
	mpfr_init(big_real(x));
	mpc_real(big_real(x), big_complex(p), GMP_RNDN);

	return(x);
      }
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, p, sc->real_part_symbol, args, a_number_string));
    }
}

static s7_pointer g_imag_part(s7_scheme *sc, s7_pointer args)
{
  #define H_imag_part "(imag-part num) returns the imaginary part of num"
  #define Q_imag_part s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_number_symbol)
  s7_pointer p;
  /* currently (imag-part +nan.0) -> 0.0 ? it's true but maybe confusing */

  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:
    case T_RATIO:
      return(small_int(0));

    case T_REAL:
      return(real_zero);

    case T_COMPLEX:
      return(make_real(sc, imag_part(p)));

#if WITH_GMP
    case T_BIG_INTEGER:
    case T_BIG_RATIO:
      return(small_int(0));

    case T_BIG_REAL:
      return(real_zero);

    case T_BIG_COMPLEX:
      {
	s7_pointer x;
	new_cell(sc, x, T_BIG_REAL);
	add_big_real(sc, x);
	mpfr_init(big_real(x));
	mpc_imag(big_real(x), big_complex(p), GMP_RNDN);

	return(x);
      }
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, p, sc->imag_part_symbol, args, a_number_string));
    }
}


/* ---------------------------------------- numerator denominator ---------------------------------------- */

static s7_pointer g_numerator(s7_scheme *sc, s7_pointer args)
{
  #define H_numerator "(numerator rat) returns the numerator of the rational number rat"
  #define Q_numerator s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_rational_symbol)

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_RATIO:       return(make_integer(sc, numerator(x)));
    case T_INTEGER:     return(x);
#if WITH_GMP
    case T_BIG_INTEGER: return(x);
    case T_BIG_RATIO:   return(mpz_to_big_integer(sc, mpq_numref(big_ratio(x))));
#endif
    default:            return(method_or_bust_with_type_one_arg(sc, x, sc->numerator_symbol, args, a_rational_string));
    }
}

#if (!WITH_GMP)
static s7_int numerator_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_rational(p))
    return(integer(method_or_bust_with_type_one_arg(sc, p, sc->numerator_symbol, list_1(sc, p), a_rational_string)));
  /* it is documented somewhere that if a method shadows a built-in, that method's signature (including return type) must match the built-in's */
  return(numerator(p));
}
#endif

static s7_pointer g_denominator(s7_scheme *sc, s7_pointer args)
{
  #define H_denominator "(denominator rat) returns the denominator of the rational number rat"
  #define Q_denominator s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_rational_symbol)

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_RATIO:       return(make_integer(sc, denominator(x)));
    case T_INTEGER:     return(small_int(1));
#if WITH_GMP
    case T_BIG_INTEGER: return(small_int(1));
    case T_BIG_RATIO:   return(mpz_to_big_integer(sc, mpq_denref(big_ratio(x))));
#endif
    default:            return(method_or_bust_with_type_one_arg(sc, x, sc->denominator_symbol, args, a_rational_string));
    }
}

#if (!WITH_GMP)
static s7_int denominator_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_rational(p))
    return(integer(method_or_bust_with_type_one_arg(sc, p, sc->denominator_symbol, list_1(sc, p), a_rational_string)));
  if (is_t_integer(p))
    return(1);
  return(denominator(p));
}
#endif


/* ---------------------------------------- nan? infinite? ---------------------------------------- */

static s7_pointer g_is_nan(s7_scheme *sc, s7_pointer args)
{
  #define H_is_nan "(nan? obj) returns #t if obj is a NaN"
  #define Q_is_nan sc->pl_bn

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
    case T_RATIO:
      return(sc->F);

    case T_REAL:
      return(make_boolean(sc, is_NaN(real(x))));

    case T_COMPLEX:
      return(make_boolean(sc, (is_NaN(real_part(x))) || (is_NaN(imag_part(x)))));

#if WITH_GMP
    case T_BIG_INTEGER:
    case T_BIG_RATIO:
      return(sc->F);

    case T_BIG_REAL:
      return(make_boolean(sc, is_NaN(s7_real_part(x))));

    case T_BIG_COMPLEX:
      return(make_boolean(sc, (is_NaN(s7_real_part(x))) || (is_NaN(s7_imag_part(x)))));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->is_nan_symbol, list_1(sc, x), a_number_string));
    }
}

static bool is_nan_b_7p(s7_scheme *sc, s7_pointer p) {return(g_is_nan(sc, set_plist_1(sc, p)) != sc->F);}


static s7_pointer g_is_infinite(s7_scheme *sc, s7_pointer args)
{
  #define H_is_infinite "(infinite? obj) returns #t if obj is an infinite real"
  #define Q_is_infinite sc->pl_bn

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
    case T_RATIO:
      return(sc->F);

    case T_REAL:
      return(make_boolean(sc, is_inf(real(x))));

    case T_COMPLEX:
      return(make_boolean(sc, (is_inf(real_part(x))) || (is_inf(imag_part(x)))));

#if WITH_GMP
    case T_BIG_INTEGER:
    case T_BIG_RATIO:
      return(sc->F);

    case T_BIG_REAL:
      return(make_boolean(sc, mpfr_inf_p(big_real(x)) != 0));

    case T_BIG_COMPLEX:
      return(make_boolean(sc,
			  (mpfr_inf_p(big_real(g_real_part(sc, list_1(sc, x)))) != 0) ||
			  (mpfr_inf_p(big_real(g_imag_part(sc, list_1(sc, x)))) != 0)));
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->is_infinite_symbol, list_1(sc, x), a_number_string));
    }
}

static bool is_infinite_b_7p(s7_scheme *sc, s7_pointer p) {return(g_is_infinite(sc, set_plist_1(sc, p)) != sc->F);}


/* ---------------------------------------- number? complex? integer? byte? rational? real?  ---------------------------------------- */

static s7_pointer g_is_number(s7_scheme *sc, s7_pointer args)
{
  #define H_is_number "(number? obj) returns #t if obj is a number"
  #define Q_is_number sc->pl_bt
  check_boolean_method(sc, s7_is_number, sc->is_number_symbol, args); /* we need the s7_* versions here for the GMP case */
}

static s7_pointer g_is_integer(s7_scheme *sc, s7_pointer args)
{
  #define H_is_integer "(integer? obj) returns #t if obj is an integer"
  #define Q_is_integer sc->pl_bt
  check_boolean_method(sc, s7_is_integer, sc->is_integer_symbol, args);
}

static bool is_byte(s7_pointer p) {return((s7_is_integer(p)) && (s7_integer(p) >= 0) && (s7_integer(p) < 256));}
static s7_pointer g_is_byte(s7_scheme *sc, s7_pointer args)
{
  #define H_is_byte "(byte? obj) returns #t if obj is a byte (an integer between 0 and 255)"
  #define Q_is_byte sc->pl_bt
  check_boolean_method(sc, is_byte, sc->is_byte_symbol, args);
}

static s7_pointer g_is_real(s7_scheme *sc, s7_pointer args)
{
  #define H_is_real "(real? obj) returns #t if obj is a real number"
  #define Q_is_real sc->pl_bt
  check_boolean_method(sc, s7_is_real, sc->is_real_symbol, args);
}

static s7_pointer g_is_complex(s7_scheme *sc, s7_pointer args)
{
  #define H_is_complex "(complex? obj) returns #t if obj is a number"
  #define Q_is_complex sc->pl_bt
  check_boolean_method(sc, s7_is_number, sc->is_complex_symbol, args);
}

static s7_pointer g_is_rational(s7_scheme *sc, s7_pointer args)
{
  #define H_is_rational "(rational? obj) returns #t if obj is a rational number (either an integer or a ratio)"
  #define Q_is_rational sc->pl_bt
  check_boolean_method(sc, s7_is_rational, sc->is_rational_symbol, args);
  /* in the non-gmp case, (rational? 455702434782048082459/86885567283849955830) -> #f, not #t, and similarly for exact? etc. */
}

static s7_pointer g_is_float(s7_scheme *sc, s7_pointer args)
{
  #define H_is_float "(float? x) returns #t is x is real and not rational."
  #define Q_is_float sc->pl_bt
  s7_pointer p;
  p = car(args);
  return(make_boolean(sc, is_float(p)));
}

static bool is_float_b(s7_pointer p) {return(is_float(p));}


/* ---------------------------------------- even? odd?---------------------------------------- */

static s7_pointer g_is_even(s7_scheme *sc, s7_pointer args)
{
  #define H_is_even "(even? int) returns #t if the integer int32_t is even"
  #define Q_is_even s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_integer_symbol)

  s7_pointer p;
  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:     return(make_boolean(sc, ((integer(p) & 1) == 0)));
#if WITH_GMP
    case T_BIG_INTEGER: return(make_boolean(sc, mpz_even_p(big_integer(p))));
#endif
    default:            return(method_or_bust_one_arg(sc, p, sc->is_even_symbol, list_1(sc, p), T_INTEGER));
    }
}

static bool is_even_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!s7_is_integer(p))
    simple_wrong_type_argument(sc, sc->is_even_symbol, p, T_INTEGER);
  return((integer(p) & 1) == 0);
}

static bool is_even_i(s7_int i1) {return((i1 & 1) == 0);}

static s7_pointer g_is_odd(s7_scheme *sc, s7_pointer args)
{
  #define H_is_odd "(odd? int) returns #t if the integer int32_t is odd"
  #define Q_is_odd s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_integer_symbol)

  s7_pointer p;
  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:     return(make_boolean(sc, ((integer(p) & 1) == 1)));
#if WITH_GMP
    case T_BIG_INTEGER: return(make_boolean(sc, mpz_odd_p(big_integer(p))));
#endif
    default:            return(method_or_bust_one_arg(sc, p, sc->is_odd_symbol, list_1(sc, p), T_INTEGER));
    }
}

static bool is_odd_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!s7_is_integer(p))
    simple_wrong_type_argument(sc, sc->is_odd_symbol, p, T_INTEGER);
  return((integer(p) & 1) == 1);
}

static bool is_odd_i(s7_int i1) {return((i1 & 1) == 1);}


/* ---------------------------------------- zero? ---------------------------------------- */

static s7_pointer g_is_zero(s7_scheme *sc, s7_pointer args)
{
  #define H_is_zero "(zero? num) returns #t if the number num is zero"
  #define Q_is_zero sc->pl_bn
  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:     return(make_boolean(sc, integer(x) == 0));
    case T_REAL:        return(make_boolean(sc, real(x) == 0.0));
    case T_RATIO:
    case T_COMPLEX:     return(sc->F);      /* ratios and complex numbers are already collapsed into integers and reals */
#if WITH_GMP
    case T_BIG_INTEGER: return(make_boolean(sc, mpz_cmp_ui(big_integer(x), 0) == 0));
    case T_BIG_REAL:    return(make_boolean(sc, mpfr_zero_p(big_real(x))));
    case T_BIG_RATIO:
    case T_BIG_COMPLEX: return(sc->F);
#endif
    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->is_zero_symbol, list_1(sc, x), a_number_string));
    }
}

static bool is_zero_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_number(p))
    simple_wrong_type_argument_with_type(sc, sc->is_zero_symbol, p, a_number_string);
  if (is_t_integer(p))
    return(integer(p) == 0);
  if (is_t_real(p))
    return(real(p) == 0.0);
  return(false);
}

static bool is_zero_i(s7_int p) {return(p == 0);}
static bool is_zero_d(s7_double p) {return(p == 0.0);}


/* -------------------------------- positive? -------------------------------- */

static s7_pointer g_is_positive(s7_scheme *sc, s7_pointer args)
{
  #define H_is_positive "(positive? num) returns #t if the real number num is positive (greater than 0)"
  #define Q_is_positive s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_real_symbol)
  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:     return(make_boolean(sc, integer(x) > 0));
    case T_RATIO:       return(make_boolean(sc, numerator(x) > 0));
    case T_REAL:        return(make_boolean(sc, real(x) > 0.0));
#if WITH_GMP
    case T_BIG_INTEGER: return(make_boolean(sc, (mpz_cmp_ui(big_integer(x), 0) > 0)));
    case T_BIG_RATIO:   return(make_boolean(sc, (mpq_cmp_ui(big_ratio(x), 0, 1) > 0)));
    case T_BIG_REAL:    return(make_boolean(sc, (mpfr_cmp_ui(big_real(x), 0) > 0)));
#endif
    default:
      return(method_or_bust_one_arg(sc, x, sc->is_positive_symbol, list_1(sc, x), T_REAL));
    }
}

static bool is_positive_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_real(p))
    simple_wrong_type_argument(sc, sc->is_positive_symbol, p, T_REAL);
  if (is_t_integer(p))
    return(integer(p) > 0);
  if (is_t_real(p))
    return(real(p) > 0.0);
  return(numerator(p) > 0);
}

static bool is_positive_i(s7_int p) {return(p > 0);}
static bool is_positive_d(s7_double p) {return(p > 0.0);}


/* -------------------------------- negative? -------------------------------- */

static s7_pointer is_negative_p_p(s7_scheme *sc, s7_pointer x)
{
  switch (type(x))
    {
    case T_INTEGER:     return(make_boolean(sc, integer(x) < 0));
    case T_RATIO:       return(make_boolean(sc, numerator(x) < 0));
    case T_REAL:        return(make_boolean(sc, real(x) < 0.0));
#if WITH_GMP
    case T_BIG_INTEGER: return(make_boolean(sc, (mpz_cmp_ui(big_integer(x), 0) < 0)));
    case T_BIG_RATIO:   return(make_boolean(sc, (mpq_cmp_ui(big_ratio(x), 0, 1) < 0)));
    case T_BIG_REAL:    return(make_boolean(sc, (mpfr_cmp_ui(big_real(x), 0) < 0)));
#endif
    default:
      return(method_or_bust_one_arg(sc, x, sc->is_negative_symbol, list_1(sc, x), T_REAL));
    }
}

static s7_pointer g_is_negative(s7_scheme *sc, s7_pointer args)
{
  #define H_is_negative "(negative? num) returns #t if the real number num is negative (less than 0)"
  #define Q_is_negative s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_real_symbol)
  return(is_negative_p_p(sc, car(args)));
}

static bool is_negative_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_real(p))
    simple_wrong_type_argument(sc, sc->is_negative_symbol, p, T_REAL);
  if (is_t_integer(p))
    return(integer(p) < 0);
  if (is_t_real(p))
    return(real(p) < 0.0);
  return(numerator(p) < 0);
}

static bool is_negative_i(s7_int p) {return(p < 0);}
static bool is_negative_d(s7_double p) {return(p < 0.0);}


#if (!WITH_PURE_S7)
#if (!WITH_GMP)
/* ---------------------------------------- exact<->inexact exact? inexact? ---------------------------------------- */

static s7_pointer g_exact_to_inexact(s7_scheme *sc, s7_pointer args)
{
  #define H_exact_to_inexact "(exact->inexact num) converts num to an inexact number; (exact->inexact 3/2) = 1.5"
  #define Q_exact_to_inexact s7_make_signature(sc, 2, sc->is_number_symbol, sc->is_number_symbol)
  /* arg can be complex -> itself! */
  return(exact_to_inexact(sc, car(args)));
}

static s7_pointer g_inexact_to_exact(s7_scheme *sc, s7_pointer args)
{
  #define H_inexact_to_exact "(inexact->exact num) converts num to an exact number; (inexact->exact 1.5) = 3/2"
  #define Q_inexact_to_exact s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_real_symbol)
  return(inexact_to_exact(sc, car(args), WITH_OVERFLOW_ERROR));
}
#endif
/* (!WITH_GMP) */


static s7_pointer g_is_exact(s7_scheme *sc, s7_pointer args)
{
  #define H_is_exact "(exact? num) returns #t if num is exact (an integer or a ratio)"
  #define Q_is_exact sc->pl_bn

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
    case T_RATIO:       return(sc->T);
    case T_REAL:
    case T_COMPLEX:     return(sc->F);
#if WITH_GMP
    case T_BIG_INTEGER:
    case T_BIG_RATIO:   return(sc->T);
    case T_BIG_REAL:
    case T_BIG_COMPLEX: return(sc->F);
#endif
    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->is_exact_symbol, args, a_number_string));
    }
}

static bool is_exact_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_number(p))
    simple_wrong_type_argument_with_type(sc, sc->is_exact_symbol, p, a_number_string);
  return(is_rational(p));
}


static s7_pointer g_is_inexact(s7_scheme *sc, s7_pointer args)
{
  #define H_is_inexact "(inexact? num) returns #t if num is inexact (neither an integer nor a ratio)"
  #define Q_is_inexact sc->pl_bn

  s7_pointer x;
  x = car(args);
  switch (type(x))
    {
    case T_INTEGER:
    case T_RATIO:       return(sc->F);
    case T_REAL:
    case T_COMPLEX:     return(sc->T);
#if WITH_GMP
    case T_BIG_INTEGER:
    case T_BIG_RATIO:   return(sc->F);
    case T_BIG_REAL:
    case T_BIG_COMPLEX: return(sc->T);
#endif
    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->is_inexact_symbol, args, a_number_string));
    }
}

static bool is_inexact_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_number(p))
    simple_wrong_type_argument_with_type(sc, sc->is_inexact_symbol, p, a_number_string);
  return(!is_rational(p));
}


/* ---------------------------------------- integer-length, integer-decode-float ---------------------------------------- */

static int32_t integer_length(s7_int a)
{
  #define I_8 256LL
  #define I_16 65536LL
  #define I_24 16777216LL
  #define I_32 4294967296LL
  #define I_40 1099511627776LL
  #define I_48 281474976710656LL
  #define I_56 72057594037927936LL

  /* a might be most-negative-fixnum! in Clisp: (integer-length -9223372036854775808) -> 63
   */
  if (a < 0)
    {
      if (a == s7_int_min) return(63);
      a = -a;
    }
  if (a < I_8) return(bits[a]);
  if (a < I_16) return(8 + bits[a >> 8]);
  if (a < I_24) return(16 + bits[a >> 16]);
  if (a < I_32) return(24 + bits[a >> 24]);
  if (a < I_40) return(32 + bits[a >> 32]);
  if (a < I_48) return(40 + bits[a >> 40]);
  if (a < I_56) return(48 + bits[a >> 48]);
  return(56 + bits[a >> 56]);
}

static s7_pointer g_integer_length(s7_scheme *sc, s7_pointer args)
{
  #define H_integer_length "(integer-length arg) returns the number of bits required to represent the integer 'arg': (ceiling (log (abs arg) 2))"
  #define Q_integer_length sc->pcl_i

  s7_int x;
  s7_pointer p;

  p = car(args);
  if (!s7_is_integer(p))
    return(method_or_bust_one_arg(sc, p, sc->integer_length_symbol, args, T_INTEGER));

  x = s7_integer(p);
  if (x < 0)
    return(make_integer(sc, integer_length(-(x + 1))));
  return(make_integer(sc, integer_length(x)));
}

static s7_int integer_length_i_i(s7_int x)
{
  if (x < 0)
    return(integer_length(-(x + 1)));
  return(integer_length(x));
}
#endif /* !pure s7 */

static s7_pointer g_integer_decode_float(s7_scheme *sc, s7_pointer args)
{
  #define H_integer_decode_float "(integer-decode-float x) returns a list containing the significand, exponent, and \
sign of 'x' (1 = positive, -1 = negative).  (integer-decode-float 0.0): (0 0 1)"
  #define Q_integer_decode_float s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_float_symbol)

  /* no matter what s7_double is, integer-decode-float acts as if x is a C double */

  typedef union {
    int64_t ix;
    double fx;
  } decode_float_t;

  decode_float_t num;
  s7_pointer x;
  x = car(args);

  switch (type(x))
    {
    case T_REAL:
      num.fx = (double)real(x);
      break;

#if WITH_GMP
    case T_BIG_REAL:
      num.fx = (double)s7_real(x);
      break;
#endif

    default:
      return(method_or_bust_with_type_one_arg(sc, x, sc->integer_decode_float_symbol, args, wrap_string(sc, "a non-rational real", 19)));
    }

  if (num.fx == 0.0)
    return(list_3(sc, small_int(0), small_int(0), small_int(1)));

  return(list_3(sc,
		make_integer(sc, (s7_int)((num.ix & 0xfffffffffffffLL) | 0x10000000000000LL)),
		make_integer(sc, (s7_int)(((num.ix & 0x7fffffffffffffffLL) >> 52) - 1023 - 52)),
		make_integer(sc, ((num.ix & 0x8000000000000000LL) != 0) ? -1 : 1)));
}


/* -------------------------------- logior -------------------------------- */
static s7_pointer g_logior(s7_scheme *sc, s7_pointer args)
{
  #define H_logior "(logior int32_t ...) returns the OR of its integer arguments (the bits that are on in any of the arguments)"
  #define Q_logior sc->pcl_i
  s7_int result = 0;
  s7_pointer x;

  for (x = args; is_not_null(x); x = cdr(x))
    {
      if (!s7_is_integer(car(x)))
	return(method_or_bust(sc, car(x), sc->logior_symbol, (result == 0) ? x : cons(sc, make_integer(sc, result), x), T_INTEGER, position_of(x, args)));
      result |= s7_integer(car(x));
    }
  return(make_integer(sc, result));
}

static s7_int logior_i_ii(s7_int i1, s7_int i2) {return(i1 | i2);}
static s7_int logior_i_iii(s7_int i1, s7_int i2, s7_int i3) {return(i1 | i2 | i3);}


/* -------------------------------- logxor -------------------------------- */
static s7_pointer g_logxor(s7_scheme *sc, s7_pointer args)
{
  #define H_logxor "(logxor int32_t ...) returns the XOR of its integer arguments (the bits that are on in an odd number of the arguments)"
  #define Q_logxor sc->pcl_i
  s7_int result = 0;
  s7_pointer x;

  for (x = args; is_not_null(x); x = cdr(x))
    {
      if (!s7_is_integer(car(x)))
	return(method_or_bust(sc, car(x), sc->logxor_symbol, (result == 0) ? x : cons(sc, make_integer(sc, result), x), T_INTEGER, position_of(x, args)));
      result ^= s7_integer(car(x));
    }
  return(make_integer(sc, result));
}

static s7_int logxor_i_ii(s7_int i1, s7_int i2) {return(i1 ^ i2);}
static s7_int logxor_i_iii(s7_int i1, s7_int i2, s7_int i3) {return(i1 ^ i2 ^ i3);}


/* -------------------------------- logand -------------------------------- */
static s7_pointer g_logand(s7_scheme *sc, s7_pointer args)
{
  #define H_logand "(logand int32_t ...) returns the AND of its integer arguments (the bits that are on in every argument)"
  #define Q_logand sc->pcl_i
  s7_int result = -1;
  s7_pointer x;

  for (x = args; is_not_null(x); x = cdr(x))
    {
      if (!s7_is_integer(car(x)))
	return(method_or_bust(sc, car(x), sc->logand_symbol, (result == -1) ? x : cons(sc, make_integer(sc, result), x), T_INTEGER, position_of(x, args)));
      result &= s7_integer(car(x));
    }
  return(make_integer(sc, result));
}

static s7_int logand_i_ii(s7_int i1, s7_int i2) {return(i1 & i2);}
static s7_int logand_i_iii(s7_int i1, s7_int i2, s7_int i3) {return(i1 & i2 & i3);}


/* -------------------------------- lognot -------------------------------- */

static s7_pointer g_lognot(s7_scheme *sc, s7_pointer args)
{
  #define H_lognot "(lognot num) returns the negation of num (its complement, the bits that are not on): (lognot 0) -> -1"
  #define Q_lognot sc->pcl_i
  if (!s7_is_integer(car(args)))
    return(method_or_bust_one_arg(sc, car(args), sc->lognot_symbol, args, T_INTEGER));
  return(make_integer(sc, ~s7_integer(car(args))));
}

static s7_int lognot_i_i(s7_int i1) {return(~i1);}


/* -------------------------------- logbit? -------------------------------- */
/* logbit?  CL is (logbitp index int) using 2^index, but that order strikes me as backwards
 *   at least gmp got the arg order right!
 */

static s7_pointer g_logbit(s7_scheme *sc, s7_pointer args)
{
  #define H_logbit "(logbit? int index) returns #t if the index-th bit is on in int, otherwise #f. The argument \
order here follows gmp, and is the opposite of the CL convention.  (logbit? int bit) is the same as (not (zero? (logand int (ash 1 bit))))."
  #define Q_logbit s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_integer_symbol)

  s7_pointer x, y;
  s7_int index;      /* index in gmp is mp_bitcnt which is an unsigned long int */

  x = car(args);
  y = cadr(args);

  if (!s7_is_integer(x))
    return(method_or_bust(sc, x, sc->logbit_symbol, args, T_INTEGER, 1));
  if (!s7_is_integer(y))
    return(method_or_bust(sc, y, sc->logbit_symbol, args, T_INTEGER, 2));

  index = s7_integer(y);
  if (index < 0)
    return(out_of_range(sc, sc->logbit_symbol, small_int(2), y, its_negative_string));

#if WITH_GMP
  if (is_t_big_integer(x))
    return(make_boolean(sc, (mpz_tstbit(big_integer(x), index) != 0)));
#endif

  if (index >= s7_int_bits)           /* not sure about the >: (logbit? -1 64) ?? */
    return(make_boolean(sc, integer(x) < 0));

  /* (zero? (logand most-positive-fixnum (ash 1 63))) -> ash argument 2, 63, is out of range (shift is too large)
   *   so logbit? has a wider range than the logand/ash shuffle above.
   */

  /* all these int64_ts are necessary, else C turns it into an int, gets confused about signs etc */
  return(make_boolean(sc, ((((int64_t)(1LL << (int64_t)index)) & (int64_t)integer(x)) != 0)));
}

static bool logbit_b_ii(s7_int i1, s7_int i2)
{
  if (i2 < 0)
    {
      /* no b_7ii_t so fallback on cur_sc, etc -- kinda ugly */
      out_of_range(cur_sc, cur_sc->logbit_symbol, small_int(2), make_integer(cur_sc, i1), its_negative_string);
      return(false);
    }
  if (i2 >= s7_int_bits)
    return(i1 < 0);
  return((((int64_t)(1LL << (int64_t)i2)) & (int64_t)i1) != 0);
}

#if (!WITH_GMP)
static bool logbit_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  if (is_t_integer(p1))
    {
      if (is_t_integer(p2))
	return(logbit_b_ii(integer(p1), integer(p2)));
      simple_wrong_type_argument(sc, sc->logbit_symbol, p2, T_INTEGER);
    }
  simple_wrong_type_argument(sc, sc->logbit_symbol, p1, T_INTEGER);
  return(false);
}
#endif


/* -------------------------------- ash -------------------------------- */
static s7_int c_ash(s7_scheme *sc, s7_int arg1, s7_int arg2)
{
  if (arg1 == 0) return(0);

  if (arg2 >= s7_int_bits)
    {
      if ((arg1 == -1) && (arg2 == 63))   /* (ash -1 63): most-negative-fixnum */
	return(s7_int_min);
      out_of_range(sc, sc->ash_symbol, small_int(2), wrap_integer1(sc, arg2), its_too_large_string);
    }

  if (arg2 < -s7_int_bits)
    {
      if (arg1 < 0)                      /* (ash -31 -100) */
	return(-1);
      return(0);
    }

  /* I can't see any point in protecting this: (ash 9223372036854775807 1) -> -2, but anyone using ash must know something about bits */
  if (arg2 >= 0)
    {
      if (arg1 < 0)
	{
	  uint64_t z;
	  z = (uint64_t)arg1;
	  return((s7_int)(z << arg2));
	}
      return(arg1 << arg2);
    }
  return(arg1 >> -arg2);
}

static s7_pointer g_ash(s7_scheme *sc, s7_pointer args)
{
  #define H_ash "(ash i1 i2) returns i1 shifted right or left i2 times, i1 << i2, (ash 1 3) -> 8, (ash 8 -3) -> 1"
  #define Q_ash sc->pcl_i
  s7_pointer x, y;

  x = car(args);
  if (!s7_is_integer(x))
    return(method_or_bust(sc, x, sc->ash_symbol, args, T_INTEGER, 1));

  y = cadr(args);
  if (!s7_is_integer(y))
    return(method_or_bust(sc, y, sc->ash_symbol, args, T_INTEGER, 2));

  return(make_integer(sc, c_ash(sc, s7_integer(x), s7_integer(y))));
}

static s7_int ash_i_7ii(s7_scheme *sc, s7_int i1, s7_int i2) {return(c_ash(sc, i1, i2));}
#if (!WITH_GMP)
static s7_int rsh_i_ii_direct(s7_int i1, s7_int i2) {return(i1 >> (-i2));}
static s7_int lsh_i_ii_direct(s7_int i1, s7_int i2) {return(i1 << i2);}
static s7_int rsh_i_i2_direct(s7_int i1, s7_int i2) {return(i1 >> 1);}
#endif


/* random numbers.  The simple version used in clm.c is probably adequate,
 *   but here I'll use Marsaglia's MWC algorithm.
 *     (random num) -> a number (0..num), if num == 0 return 0, use global default state
 *     (random num state) -> same but use this state
 *     (random-state seed) -> make a new state
 *   to save the current seed, use copy
 *   to save it across load, random-state->list and list->random-state.
 *   random-state? returns #t if its arg is one of these guys
 */

#if (!WITH_GMP)
/* -------------------------------- random-state -------------------------------- */
s7_pointer s7_random_state(s7_scheme *sc, s7_pointer args)
{
  #define H_random_state "(random-state seed (carry plausible-default)) returns a new random number state initialized with 'seed'. \
Pass this as the second argument to 'random' to get a repeatable random number sequence:\n\
    (let ((seed (random-state 1234))) (random 1.0 seed))"
  #define Q_random_state s7_make_circular_signature(sc, 1, 2, sc->is_random_state_symbol, sc->is_integer_symbol)

  s7_pointer r1, r2, p;
  s7_int i1, i2;

  r1 = car(args);
  if (!s7_is_integer(r1))
    return(method_or_bust(sc, r1, sc->random_state_symbol, args, T_INTEGER, 1));
  i1 = integer(r1);
  if (i1 < 0)
    return(out_of_range(sc, sc->random_state_symbol, small_int(1), r1, its_negative_string));

  if (is_null(cdr(args)))
    {
      new_cell(sc, p, T_RANDOM_STATE);
      random_seed(p) = (uint64_t)i1;
      random_carry(p) = 1675393560;                          /* should this be dependent on the seed? */
      return(p);
    }

  r2 = cadr(args);
  if (!s7_is_integer(r2))
    return(method_or_bust(sc, r2, sc->random_state_symbol, args, T_INTEGER, 2));
  i2 = integer(r2);
  if (i2 < 0)
    return(out_of_range(sc, sc->random_state_symbol, small_int(2), r2, its_negative_string));

  new_cell(sc, p, T_RANDOM_STATE);
  random_seed(p) = (uint64_t)i1;
  random_carry(p) = (uint64_t)i2;
  return(p);
}

#define g_random_state s7_random_state
#endif

static s7_pointer rng_copy(s7_scheme *sc, s7_pointer args)
{
#if WITH_GMP
  return(sc->F); /* I can't find a way to copy a gmp random generator */
#else
  s7_pointer obj;
  obj = car(args);
  if (is_random_state(obj))
    {
      s7_pointer new_r;
      new_cell(sc, new_r, T_RANDOM_STATE);
      random_seed(new_r) = random_seed(obj);
      random_carry(new_r) = random_carry(obj);
      return(new_r);
    }
  return(sc->F);
#endif
}


/* -------------------------------- random-state? -------------------------------- */
static s7_pointer g_is_random_state(s7_scheme *sc, s7_pointer args)
{
  #define H_is_random_state "(random-state? obj) returns #t if obj is a random-state object (from random-state)."
  #define Q_is_random_state sc->pl_bt
  check_boolean_method(sc, is_random_state, sc->is_random_state_symbol, args);
}

static bool is_random_state_b(s7_pointer p) {return(type(p) == T_RANDOM_STATE);}


/* -------------------------------- random-state->list -------------------------------- */
s7_pointer s7_random_state_to_list(s7_scheme *sc, s7_pointer args)
{
  #define H_random_state_to_list "(random-state->list r) returns the random state object as a list.\
You can later apply random-state to this list to continue a random number sequence from any point."
  #define Q_random_state_to_list s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_random_state_symbol)

#if WITH_GMP
  if ((is_pair(args)) &&
      (!is_random_state(car(args))))
    return(method_or_bust_with_type(sc, car(args), sc->random_state_to_list_symbol, args, a_random_state_object_string, 1));
  return(sc->nil);
#else
  s7_pointer r;
  if (is_null(args))
    r = sc->default_rng;
  else
    {
      r = car(args);
      if (!is_random_state(r))
	return(method_or_bust_with_type(sc, r, sc->random_state_to_list_symbol, args, a_random_state_object_string, 1));
    }
  return(list_2(sc, make_integer(sc, random_seed(r)), make_integer(sc, random_carry(r))));
#endif
}

#define g_random_state_to_list s7_random_state_to_list

void s7_set_default_random_state(s7_scheme *sc, s7_int seed, s7_int carry)
{
#if (!WITH_GMP)
  s7_pointer p;
  new_cell(sc, p, T_RANDOM_STATE);
  random_seed(p) = (uint64_t)seed;
  random_carry(p) = (uint64_t)carry;
  sc->default_rng = p;
#endif
}

#if (!WITH_GMP)
/* -------------------------------- random -------------------------------- */

static double next_random(s7_pointer r)
{
  /* The multiply-with-carry generator for 32-bit integers:
   *        x(n)=a*x(n-1) + carry mod 2^32
   * Choose multiplier a from this list:
   *   1791398085 1929682203 1683268614 1965537969 1675393560
   *   1967773755 1517746329 1447497129 1655692410 1606218150
   *   2051013963 1075433238 1557985959 1781943330 1893513180
   *   1631296680 2131995753 2083801278 1873196400 1554115554
   * ( or any 'a' for which both a*2^32-1 and a*2^31-1 are prime)
   */
  double result;
  uint64_t temp;
  #define RAN_MULT 2131995753UL

  temp = random_seed(r) * RAN_MULT + random_carry(r);
  random_seed(r) = (temp & 0xffffffffUL);
  random_carry(r) = (temp >> 32);
  result = (double)((uint32_t)(random_seed(r))) / 4294967295.5;
  /* divisor was 2^32-1 = 4294967295.0, but somehow this can round up once in a billion tries?
   *   do we want the double just less than 2^32?
   */

  /* (let ((mx 0) (mn 1000)) (do ((i 0 (+ i 1))) ((= i 10000)) (let ((val (random 123))) (set! mx (max mx val)) (set! mn (min mn val)))) (list mn mx)) */
  return(result);
}

s7_double s7_random(s7_scheme *sc, s7_pointer state)
{
  if (!state)
    return(next_random(sc->default_rng));
  return(next_random(state));
}

static s7_pointer g_random(s7_scheme *sc, s7_pointer args)
{
  #define H_random "(random num (state #f)) returns a random number between 0 and num (0 if num=0)."
  #define Q_random s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_number_symbol, sc->is_random_state_symbol)
  s7_pointer r, num;

  if (is_not_null(cdr(args)))
    {
      r = cadr(args);
      if (!is_random_state(r))
	return(method_or_bust_with_type(sc, r, sc->random_symbol, args, a_random_state_object_string, 2));
    }
  else r = sc->default_rng;
  num = car(args);

  switch (type(num))
    {
    case T_INTEGER:
      return(make_integer(sc, (s7_int)(integer(num) * next_random(r))));

    case T_RATIO:
      {
	s7_double x, error;
	s7_int numer = 0, denom = 1;
	/* the error here needs to take the size of the fraction into account.  Otherwise, if
	 *    error is (say) 1e-6 and the fraction is (say) 9000000/9223372036854775807,
	 *    c_rationalize will always return 0.  But even that isn't foolproof:
	 *    (random 1/562949953421312) -> 1/376367230475000
	 */
	x = fraction(num);
	if ((x < 1.0e-10) && (x > -1.0e-10))
	  {
	    /* 1e-12 is not tight enough:
	     *    (random 1/2251799813685248) -> 1/2250240579436280
	     *    (random -1/4503599627370496) -> -1/4492889778435526
	     *    (random 1/140737488355328) -> 1/140730223985746
	     *    (random -1/35184372088832) -> -1/35183145492420
	     *    (random -1/70368744177664) -> -1/70366866392738
	     *    (random 1/4398046511104) -> 1/4398033095756
	     *    (random 1/137438953472) -> 1/137438941127
	     */
	    if (numerator(num) < -10)
	      numer = -(s7_int)(floor(-numerator(num) * next_random(r)));
	    else
	      {
		if (numerator(num) > 10)
		  numer = (s7_int)floor(numerator(num) * next_random(r));
		else
		  {
		    int64_t diff;
		    numer = numerator(num);
		    diff = s7_int_max - denominator(num);
		    if (diff < 100)
		      return(s7_make_ratio(sc, numer, denominator(num)));
		    denom = denominator(num) + (s7_int)floor(diff * next_random(r));
		    return(s7_make_ratio(sc, numer, denom));
		  }
	      }
	    return(s7_make_ratio(sc, numer, denominator(num)));
	  }
	if ((x < 1e-6) && (x > -1e-6))
	  error = 1e-18;
	else error = 1e-12;
	c_rationalize(x * next_random(r), error, &numer, &denom);
	return(s7_make_ratio(sc, numer, denom));
      }

    case T_REAL:
      return(make_real(sc, real(num) * next_random(r)));

    case T_COMPLEX:
      return(s7_make_complex(sc, real_part(num) * next_random(r), imag_part(num) * next_random(r)));

    default:
      return(method_or_bust_with_type(sc, num, sc->random_symbol, args, a_number_string, 1));
    }
  return(sc->F);
}

static s7_double random_d_7d(s7_scheme *sc, s7_double x)
{
  return(x * next_random(sc->default_rng));
}

static s7_int random_i_7i(s7_scheme *sc, s7_int i)
{
  return((s7_int)(i * next_random(sc->default_rng)));
}

static s7_pointer random_p_p(s7_scheme *sc, s7_pointer p)
{
  return(g_random(sc, set_plist_1(sc, p)));
}

static s7_pointer g_random_ic(s7_scheme *sc, s7_pointer args)
{
  return(make_integer(sc, (s7_int)(integer(car(args)) * next_random(sc->default_rng))));
}

static s7_pointer g_random_rc(s7_scheme *sc, s7_pointer args)
{
  return(make_real(sc, real(car(args)) * next_random(sc->default_rng)));
}

static s7_pointer g_random_1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer r, num;
  num = car(args);
  r = sc->default_rng;
  if (is_t_integer(num))
    return(make_integer(sc, (s7_int)(integer(num) * next_random(r))));
  if (is_t_real(num))
    return(make_real(sc, real(num) * next_random(r)));
  return(g_random(sc, args));
}

static s7_pointer random_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if (args == 1)
    {
      s7_pointer arg1;
      arg1 = cadr(expr);
      if (s7_is_integer(arg1))
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->random_ic);
	}
      if (is_float(arg1))
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->random_rc);
	}
      return(sc->random_1);
    }
  return(f);
}
#endif /* gmp */


/* -------------------------------- characters -------------------------------- */

#define NUM_CHARS 256

/* -------------------------------- char<->integer -------------------------------- */
static s7_pointer g_char_to_integer(s7_scheme *sc, s7_pointer args)
{
  #define H_char_to_integer "(char->integer c) converts the character c to an integer"
  #define Q_char_to_integer s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_char_symbol)

  if (!s7_is_character(car(args)))
    return(method_or_bust_one_arg(sc, car(args), sc->char_to_integer_symbol, args, T_CHARACTER));
  return(small_int(character(car(args))));
}

static s7_int char_to_integer_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (!s7_is_character(p))
    return(integer(method_or_bust_one_arg(sc, p, sc->char_to_integer_symbol, list_1(sc, p), T_CHARACTER)));
  return(character(p));
}

static s7_pointer integer_to_char_p_p(s7_scheme *sc, s7_pointer x)
{
  s7_int ind;
  if (!s7_is_integer(x))
    return(method_or_bust_one_arg(sc, x, sc->integer_to_char_symbol, list_1(sc, x), T_INTEGER));
  ind = s7_integer(x);
  if ((ind >= 0) && (ind < NUM_CHARS))
    return(s7_make_character(sc, (uint8_t)ind));
  return(s7_out_of_range_error(sc, "integer->char", 1, x, "it doen't fit in an unsigned byte"));
}

static s7_pointer g_integer_to_char(s7_scheme *sc, s7_pointer args)
{
  #define H_integer_to_char "(integer->char i) converts the non-negative integer i to a character"
  #define Q_integer_to_char s7_make_signature(sc, 2, sc->is_char_symbol, sc->is_integer_symbol)
  return(integer_to_char_p_p(sc, car(args)));
}

static s7_pointer integer_to_char_p_i(s7_scheme *sc, s7_int ind)
{
  if ((ind >= 0) && (ind < NUM_CHARS))
    return(s7_make_character(sc, (uint8_t)ind));
  return(s7_out_of_range_error(sc, "integer->char", 1, make_integer(sc, ind), "it doen't fit in an unsigned byte"));
}


static uint8_t uppers[256], lowers[256];
static void init_uppers(void)
{
  int32_t i;
  for (i = 0; i < 256; i++)
    {
      uppers[i] = (uint8_t)toupper(i);
      lowers[i] = (uint8_t)tolower(i);
    }
}

static void init_chars(void)
{
  s7_cell *cells;
  int32_t i;

  chars = (s7_pointer *)malloc((NUM_CHARS + 1) * sizeof(s7_pointer)); /* chars is declared far above */
  cells = (s7_cell *)calloc(NUM_CHARS + 1, sizeof(s7_cell));

  chars[0] = &cells[0];
  eof_object = chars[0];
  set_type(eof_object, T_EOF_OBJECT | T_IMMUTABLE | T_UNHEAP);
  unique_name_length(eof_object) = 6;
  unique_name(eof_object) = "#<eof>";
  chars++;                    /* now chars[EOF] == chars[-1] == eof_object */
  cells++;

  for (i = 0; i < NUM_CHARS; i++)
    {
      s7_pointer cp;
      uint8_t c;

      c = (uint8_t)i;
      cp = &cells[i];
      set_type_bit(cp, T_IMMUTABLE | T_CHARACTER | T_UNHEAP);
      character(cp) = c;
      upper_character(cp) = (uint8_t)toupper(i);
      is_char_alphabetic(cp) = (bool)isalpha(i);
      is_char_numeric(cp) = (bool)isdigit(i);
      is_char_whitespace(cp) = white_space[i];
      is_char_uppercase(cp) = (((bool)isupper(i)) || ((i >= 192) && (i < 208)));
      is_char_lowercase(cp) = (bool)islower(i);
      chars[i] = cp;

      #define make_character_name(S) memcpy((void *)(&(character_name(cp))), (const void *)(S), character_name_length(cp) = strlen(S))
      switch (c)
	{
	case ' ':	 make_character_name("#\\space");     break;
	case '\n':       make_character_name("#\\newline");   break;
	case '\r':       make_character_name("#\\return");    break;
	case '\t':       make_character_name("#\\tab");       break;
	case '\0':       make_character_name("#\\null");      break;
	case (char)0x1b: make_character_name("#\\escape");    break;
	case (char)0x7f: make_character_name("#\\delete");    break;
	case (char)7:    make_character_name("#\\alarm");     break;
	case (char)8:    make_character_name("#\\backspace"); break;
	default:
	  {
            #define P_SIZE 12
	    int32_t len;
	    if ((c < 32) || (c >= 127))
	      len = snprintf((char *)(&(character_name(cp))), P_SIZE, "#\\x%x", c);
	    else len = snprintf((char *)(&(character_name(cp))), P_SIZE, "#\\%c", c);
	    character_name_length(cp) = len;
	    break;
          }}}
}


/* -------------------------------- char-upcase, char-downcase ----------------------- */
static s7_pointer g_char_upcase(s7_scheme *sc, s7_pointer args)
{
  #define H_char_upcase "(char-upcase c) converts the character c to upper case"
  #define Q_char_upcase sc->pcl_c
  if (!s7_is_character(car(args)))
    return(method_or_bust_one_arg(sc, car(args), sc->char_upcase_symbol, args, T_CHARACTER));
  return(s7_make_character(sc, upper_character(car(args))));
}

static s7_pointer g_char_downcase(s7_scheme *sc, s7_pointer args)
{
  #define H_char_downcase "(char-downcase c) converts the character c to lower case"
  #define Q_char_downcase sc->pcl_c
  if (!s7_is_character(car(args)))
    return(method_or_bust_one_arg(sc, car(args), sc->char_downcase_symbol, args, T_CHARACTER));
  return(s7_make_character(sc, lowers[character(car(args))]));
}


/* -------------------------------- char-alphabetic? char-numeric? char-whitespace? -------------------------------- */
static s7_pointer g_is_char_alphabetic(s7_scheme *sc, s7_pointer args)
{
  #define H_is_char_alphabetic "(char-alphabetic? c) returns #t if the character c is alphabetic"
  #define Q_is_char_alphabetic sc->pl_bc
  if (!s7_is_character(car(args)))
    return(method_or_bust_one_arg(sc, car(args), sc->is_char_alphabetic_symbol, args, T_CHARACTER));
  return(make_boolean(sc, is_char_alphabetic(car(args))));

  /* isalpha returns #t for (integer->char 226) and others in that range */
}

static bool is_char_alphabetic_b_7p(s7_scheme *sc, s7_pointer c)
{
  if (!s7_is_character(c))
    simple_wrong_type_argument(sc, sc->is_char_alphabetic_symbol, c, T_CHARACTER);
  return(is_char_alphabetic(c));
}
static bool is_char_alphabetic_c(s7_pointer c) {return(is_char_alphabetic(c));}
static s7_pointer is_char_alphabetic_p_p(s7_scheme *sc, s7_pointer c)
{
  if (!s7_is_character(c))
    simple_wrong_type_argument(sc, sc->is_char_alphabetic_symbol, c, T_CHARACTER);
  return(make_boolean(sc, is_char_alphabetic(c)));
}

static s7_pointer g_is_char_numeric(s7_scheme *sc, s7_pointer args)
{
  s7_pointer arg;
  #define H_is_char_numeric "(char-numeric? c) returns #t if the character c is a digit"
  #define Q_is_char_numeric sc->pl_bc

  arg = car(args);
  if (!s7_is_character(arg))
    return(method_or_bust_one_arg(sc, arg, sc->is_char_numeric_symbol, args, T_CHARACTER));
  return(make_boolean(sc, is_char_numeric(arg)));
}

static bool is_char_numeric_b_7p(s7_scheme *sc, s7_pointer c)
{
  if (!s7_is_character(c))
    simple_wrong_type_argument(sc, sc->is_char_numeric_symbol, c, T_CHARACTER);
  return(is_char_numeric(c));
}
static bool is_char_numeric_c(s7_pointer c) {return(is_char_numeric(c));}


static s7_pointer g_is_char_whitespace(s7_scheme *sc, s7_pointer args)
{
  s7_pointer arg;
  #define H_is_char_whitespace "(char-whitespace? c) returns #t if the character c is non-printing character"
  #define Q_is_char_whitespace sc->pl_bc

  arg = car(args);
  if (!s7_is_character(arg))
    return(method_or_bust_one_arg(sc, arg, sc->is_char_whitespace_symbol, args, T_CHARACTER));
  return(make_boolean(sc, is_char_whitespace(arg)));
}

static bool is_char_whitespace_b_7p(s7_scheme *sc, s7_pointer c)
{
  if (s7_is_character(c))
    return(is_char_whitespace(c));
  if (has_active_methods(sc, c))
    {
      s7_pointer f;
      f = find_method(sc, find_let(sc, c), sc->is_char_whitespace_symbol);
      if (f != sc->undefined)
	return(is_true(sc, s7_apply_function(sc, f, cons(sc, c, sc->nil))));
    }
  simple_wrong_type_argument(sc, sc->is_char_whitespace_symbol, c, T_CHARACTER);
  return(false);
}
static bool is_char_whitespace_c(s7_pointer c) {return(is_char_whitespace(c));}
static s7_pointer is_char_whitespace_p_p(s7_scheme *sc, s7_pointer c)
{
  if (!s7_is_character(c))
    simple_wrong_type_argument(sc, sc->is_char_whitespace_symbol, c, T_CHARACTER);
  return(make_boolean(sc, is_char_whitespace(c)));
}


/* -------------------------------- char-upper-case? char-lower-case? -------------------------------- */
static s7_pointer g_is_char_upper_case(s7_scheme *sc, s7_pointer args)
{
  s7_pointer arg;
  #define H_is_char_upper_case "(char-upper-case? c) returns #t if the character c is in upper case"
  #define Q_is_char_upper_case sc->pl_bc

  arg = car(args);
  if (!s7_is_character(arg))
    return(method_or_bust_one_arg(sc, arg, sc->is_char_upper_case_symbol, args, T_CHARACTER));
  return(make_boolean(sc, is_char_uppercase(arg)));
}

static bool is_char_upper_case_b_7p(s7_scheme *sc, s7_pointer c)
{
  if (!s7_is_character(c))
    simple_wrong_type_argument(sc, sc->is_char_upper_case_symbol, c, T_CHARACTER);
  return(is_char_uppercase(c));
}

static bool is_char_upper_case_c(s7_pointer c) {return(is_char_uppercase(c));}

static s7_pointer g_is_char_lower_case(s7_scheme *sc, s7_pointer args)
{
  s7_pointer arg;
  #define H_is_char_lower_case "(char-lower-case? c) returns #t if the character c is in lower case"
  #define Q_is_char_lower_case sc->pl_bc

  arg = car(args);
  if (!s7_is_character(arg))
    return(method_or_bust_one_arg(sc, arg, sc->is_char_lower_case_symbol, args, T_CHARACTER));
  return(make_boolean(sc, is_char_lowercase(arg)));
}

static bool is_char_lower_case_b_7p(s7_scheme *sc, s7_pointer c)
{
  if (!s7_is_character(c))
    simple_wrong_type_argument(sc, sc->is_char_lower_case_symbol, c, T_CHARACTER);
  return(is_char_lowercase(c));
}

static bool is_char_lower_case_c(s7_pointer c) {return(is_char_lowercase(c));}


/* -------------------------------- char? -------------------------------- */
static s7_pointer g_is_char(s7_scheme *sc, s7_pointer args)
{
  #define H_is_char "(char? obj) returns #t if obj is a character"
  #define Q_is_char sc->pl_bt
  check_boolean_method(sc, s7_is_character, sc->is_char_symbol, args);
}


s7_pointer s7_make_character(s7_scheme *sc, uint8_t c)
{
  return(chars[c]);
}

bool s7_is_character(s7_pointer p)
{
  return(type(p) == T_CHARACTER);
}

uint8_t s7_character(s7_pointer p)
{
  return(character(p));
}


/* -------------------------------- char<? char<=? char>? char>=? char=? -------------------------------- */
static int32_t charcmp(uint8_t c1, uint8_t c2)
{
  return((c1 == c2) ? 0 : (c1 < c2) ? -1 : 1);
  /* not tolower here -- the single case is apparently supposed to be upper case
   *   this matters in a case like (char-ci<? #\_ #\e) which Guile and Gauche say is #f
   *   although (char<? #\_ #\e) is #t -- the spec does not say how to interpret this!
   */
}

static bool is_character_via_method(s7_scheme *sc, s7_pointer p)
{
  if (s7_is_character(p))
    return(true);
  if (has_active_methods(sc, p))
    {
      s7_pointer f;
      f = find_method(sc, find_let(sc, p), sc->is_char_symbol);
      if (f != sc->undefined)
	return(is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil))));
    }
  return(false);
}

static s7_pointer char_with_error_check(s7_scheme *sc, s7_pointer x, s7_pointer args, s7_pointer caller)
{
  s7_pointer y;
  for (y = cdr(x); is_pair(y); y = cdr(y)) /* before returning #f, check for bad trailing arguments */
    if (!is_character_via_method(sc, car(y)))
      return(wrong_type_argument(sc, caller, position_of(y, args), car(y), T_CHARACTER));
  return(sc->F);
}

static s7_pointer g_char_cmp(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!s7_is_character(y))
    return(method_or_bust(sc, y, sym, args, T_CHARACTER, 1));

  for (x = cdr(args); is_pair(x); x = cdr(x))
    {
      if (!s7_is_character(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_CHARACTER, position_of(x, args)));
      if (charcmp(character(y), character(car(x))) != val)
	return(char_with_error_check(sc, x, args, sym));
      y = car(x);
    }
  return(sc->T);
}

static s7_pointer g_char_cmp_not(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!s7_is_character(y))
    return(method_or_bust(sc, y, sym, args, T_CHARACTER, 1));

  for (x = cdr(args); is_pair(x); x = cdr(x))
    {
      if (!s7_is_character(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_CHARACTER, position_of(x, args)));
      if (charcmp(character(y), character(car(x))) == val)
	return(char_with_error_check(sc, x, args, sym));
      y = car(x);
    }
  return(sc->T);
}

static s7_pointer g_chars_are_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_equal "(char=? char ...) returns #t if all the character arguments are equal"
  #define Q_chars_are_equal sc->pcl_bc

  s7_pointer x, y;

  y = car(args);
  if (!s7_is_character(y))
    return(method_or_bust(sc, y, sc->char_eq_symbol, args, T_CHARACTER, 1));

  for (x = cdr(args); is_pair(x); x = cdr(x))
    {
      if (!s7_is_character(car(x)))
	return(method_or_bust(sc, car(x), sc->char_eq_symbol, cons(sc, y, x), T_CHARACTER, position_of(x, args)));
      if (car(x) != y)
	return(char_with_error_check(sc, x, args, sc->char_eq_symbol));
    }
  return(sc->T);
}


static s7_pointer g_chars_are_less(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_less "(char<? char ...) returns #t if all the character arguments are increasing"
  #define Q_chars_are_less sc->pcl_bc

  return(g_char_cmp(sc, args, -1, sc->char_lt_symbol));
}

static s7_pointer g_chars_are_greater(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_greater "(char>? char ...) returns #t if all the character arguments are decreasing"
  #define Q_chars_are_greater sc->pcl_bc

  return(g_char_cmp(sc, args, 1, sc->char_gt_symbol));
}

static s7_pointer g_chars_are_geq(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_geq "(char>=? char ...) returns #t if all the character arguments are equal or decreasing"
  #define Q_chars_are_geq sc->pcl_bc

  return(g_char_cmp_not(sc, args, -1, sc->char_geq_symbol));
}

static s7_pointer g_chars_are_leq(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_leq "(char<=? char ...) returns #t if all the character arguments are equal or increasing"
  #define Q_chars_are_leq sc->pcl_bc

  return(g_char_cmp_not(sc, args, 1, sc->char_leq_symbol));
}

static s7_pointer g_simple_char_eq(s7_scheme *sc, s7_pointer args)
{
  return(make_boolean(sc, character(car(args)) == character(cadr(args))));
}


static inline void check_char2_args(s7_scheme *sc, s7_pointer caller, s7_pointer p1, s7_pointer p2)
{
  if (!s7_is_character(p1))
    simple_wrong_type_argument(sc, caller, p1, T_CHARACTER);
  if (!s7_is_character(p2))
    simple_wrong_type_argument(sc, caller, p2, T_CHARACTER);
}

static bool char_lt_b_direct(s7_pointer p1, s7_pointer p2) {return(character(p1) < character(p2));}
static bool char_lt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_lt_symbol, p1, p2);
  return(character(p1) < character(p2));
}

static bool char_leq_b_direct(s7_pointer p1, s7_pointer p2) {return(character(p1) <= character(p2));}
static bool char_leq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_leq_symbol, p1, p2);
  return(character(p1) <= character(p2));
}

static bool char_gt_b_direct(s7_pointer p1, s7_pointer p2) {return(character(p1) > character(p2));}
static bool char_gt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_gt_symbol, p1, p2);
  return(character(p1) > character(p2));
}

static bool char_geq_b_direct(s7_pointer p1, s7_pointer p2) {return(character(p1) >= character(p2));}
static bool char_geq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_geq_symbol, p1, p2);
  return(character(p1) >= character(p2));
}

static bool char_eq_b_direct(s7_pointer p1, s7_pointer p2) {return(character(p1) == character(p2));}
static bool char_eq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_eq_symbol, p1, p2);
  return(character(p1) == character(p2));
}


/* -------------------------------- char-ci<? char-ci<=? char-ci>? char-ci>=? char-ci=? -------------------------------- */
static s7_pointer g_char_equal_s_ic(s7_scheme *sc, s7_pointer args)
{
  s7_pointer c;
  c = lookup(sc, car(args));
  if (c == cadr(args))
    return(sc->T);
  if (s7_is_character(c))
    return(sc->F);
  return(method_or_bust(sc, c, sc->char_eq_symbol, list_2(sc, c, cadr(args)), T_CHARACTER, 1));
}

static s7_pointer g_char_equal_2(s7_scheme *sc, s7_pointer args)
{
  if (!s7_is_character(car(args)))
    return(method_or_bust(sc, car(args), sc->char_eq_symbol, args, T_CHARACTER, 1));
  if (car(args) == cadr(args))
    return(sc->T);
  if (!s7_is_character(cadr(args)))
    return(method_or_bust(sc, cadr(args), sc->char_eq_symbol, args, T_CHARACTER, 2));
  return(sc->F);
}

static s7_pointer g_char_less_2(s7_scheme *sc, s7_pointer args)
{
  if (!s7_is_character(car(args)))
    return(method_or_bust(sc, car(args), sc->char_lt_symbol, args, T_CHARACTER, 1));
  if (!s7_is_character(cadr(args)))
    return(method_or_bust(sc, cadr(args), sc->char_lt_symbol, args, T_CHARACTER, 2));
  return(make_boolean(sc, character(car(args)) < character(cadr(args))));
}


static s7_pointer g_char_greater_2(s7_scheme *sc, s7_pointer args)
{
  if (!s7_is_character(car(args)))
    return(method_or_bust(sc, car(args), sc->char_gt_symbol, args, T_CHARACTER, 1));
  if (!s7_is_character(cadr(args)))
    return(method_or_bust(sc, cadr(args), sc->char_gt_symbol, args, T_CHARACTER, 2));
  return(make_boolean(sc, character(car(args)) > character(cadr(args))));
}

#if (!WITH_PURE_S7)
static s7_pointer g_char_cmp_ci(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!s7_is_character(y))
    return(method_or_bust(sc, y, sym, args, T_CHARACTER, 1));

  for (x = cdr(args); is_pair(x); x = cdr(x))
    {
      if (!s7_is_character(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_CHARACTER, position_of(x, args)));
      if (charcmp(upper_character(y), upper_character(car(x))) != val)
	return(char_with_error_check(sc, x, args, sym));
      y = car(x);
    }
  return(sc->T);
}

static s7_pointer g_char_cmp_ci_not(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!s7_is_character(y))
    return(method_or_bust(sc, y, sym, args, T_CHARACTER, 1));
  for (x = cdr(args); is_pair(x); x = cdr(x))
    {
      if (!s7_is_character(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_CHARACTER, position_of(x, args)));
      if (charcmp(upper_character(y), upper_character(car(x))) == val)
	return(char_with_error_check(sc, x, args, sym));
      y = car(x);
    }
  return(sc->T);
}

static s7_pointer g_chars_are_ci_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_ci_equal "(char-ci=? char ...) returns #t if all the character arguments are equal, ignoring case"
  #define Q_chars_are_ci_equal sc->pcl_bc

  return(g_char_cmp_ci(sc, args, 0, sc->char_ci_eq_symbol));
}

static s7_pointer g_chars_are_ci_less(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_ci_less "(char-ci<? char ...) returns #t if all the character arguments are increasing, ignoring case"
  #define Q_chars_are_ci_less sc->pcl_bc

  return(g_char_cmp_ci(sc, args, -1, sc->char_ci_lt_symbol));
}

static s7_pointer g_chars_are_ci_greater(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_ci_greater "(char-ci>? char ...) returns #t if all the character arguments are decreasing, ignoring case"
  #define Q_chars_are_ci_greater sc->pcl_bc

  return(g_char_cmp_ci(sc, args, 1, sc->char_ci_gt_symbol));
}

static s7_pointer g_chars_are_ci_geq(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_ci_geq "(char-ci>=? char ...) returns #t if all the character arguments are equal or decreasing, ignoring case"
  #define Q_chars_are_ci_geq sc->pcl_bc

  return(g_char_cmp_ci_not(sc, args, -1, sc->char_ci_geq_symbol));
}

static s7_pointer g_chars_are_ci_leq(s7_scheme *sc, s7_pointer args)
{
  #define H_chars_are_ci_leq "(char-ci<=? char ...) returns #t if all the character arguments are equal or increasing, ignoring case"
  #define Q_chars_are_ci_leq sc->pcl_bc

  return(g_char_cmp_ci_not(sc, args, 1, sc->char_ci_leq_symbol));
}


static bool char_ci_lt_b_direct(s7_pointer p1, s7_pointer p2) {return(upper_character(p1) < upper_character(p2));}
static bool char_ci_lt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_ci_lt_symbol, p1, p2);
  return(upper_character(p1) < upper_character(p2));
}

static bool char_ci_leq_b_direct(s7_pointer p1, s7_pointer p2) {return(upper_character(p1) <= upper_character(p2));}
static bool char_ci_leq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_ci_leq_symbol, p1, p2);
  return(upper_character(p1) <= upper_character(p2));
}

static bool char_ci_gt_b_direct(s7_pointer p1, s7_pointer p2) {return(upper_character(p1) > upper_character(p2));}
static bool char_ci_gt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_ci_gt_symbol, p1, p2);
  return(upper_character(p1) > upper_character(p2));
}

static bool char_ci_geq_b_direct(s7_pointer p1, s7_pointer p2) {return(upper_character(p1) >= upper_character(p2));}
static bool char_ci_geq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_ci_geq_symbol, p1, p2);
  return(upper_character(p1) >= upper_character(p2));
}

static bool char_ci_eq_b_direct(s7_pointer p1, s7_pointer p2) {return(upper_character(p1) == upper_character(p2));}
static bool char_ci_eq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_char2_args(sc, sc->char_ci_eq_symbol, p1, p2);
  return(upper_character(p1) == upper_character(p2));
}

#endif /* not pure s7 */


/* -------------------------------- char-position -------------------------------- */
static s7_pointer g_char_position(s7_scheme *sc, s7_pointer args)
{
  #define H_char_position "(char-position char-or-str str (start 0)) returns the position of the first occurrence of char in str, or #f"
  #define Q_char_position s7_make_signature(sc, 4, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->not_symbol), s7_make_signature(sc, 2, sc->is_char_symbol, sc->is_string_symbol), sc->is_string_symbol, sc->is_integer_symbol)

  const char *porig, *pset;
  s7_int start, pos, len; /* not "int" because start arg might be most-negative-fixnum */
  s7_pointer arg1, arg2;

  arg1 = car(args);
  if ((!s7_is_character(arg1)) &&
      (!is_string(arg1)))
    return(method_or_bust(sc, arg1, sc->char_position_symbol, args, T_CHARACTER, 1));

  arg2 = cadr(args);
  if (!is_string(arg2))
    return(method_or_bust(sc, arg2, sc->char_position_symbol, args, T_STRING, 2));

  if (is_pair(cddr(args)))
    {
      s7_pointer arg3;
      arg3 = caddr(args);
      if (!s7_is_integer(arg3))
	return(method_or_bust(sc, arg3, sc->char_position_symbol, args, T_INTEGER, 3));
      start = s7_integer(arg3);
      if (start < 0)
	return(wrong_type_argument_with_type(sc, sc->char_position_symbol, 3, arg3, a_non_negative_integer_string));
    }
  else start = 0;

  porig = string_value(arg2);
  len = string_length(arg2);
  if (start >= len) return(sc->F);

  if (s7_is_character(arg1))
    {
      char c;
      const char *p;
      c = character(arg1);
      p = strchr((const char *)(porig + start), (int)c); /* use strchrnul in Gnu C to catch embedded null case */
      if (p)
	return(make_integer(sc, p - porig));
      return(sc->F);
    }

  if (string_length(arg1) == 0)
    return(sc->F);
  pset = string_value(arg1);

  pos = strcspn((const char *)(porig + start), (const char *)pset);
  if ((pos + start) < len)
    return(make_integer(sc, pos + start));

  /* if the string has an embedded null, we can get erroneous results here --
   *   perhaps check for null at pos+start?  What about a searched-for string that also has embedded nulls?
   */
  return(sc->F);
}

static s7_pointer char_position_p_ppi(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_int start)
{
  /* p1 is char, p2 is string, p3 is int32_t */
  if (is_string(p2))
    {
      if (start >= 0)
	{
	  const char *porig, *p;
	  s7_int len;
	  char c;
	  c = character(p1);
	  len = string_length(p2);
	  porig = string_value(p2);
	  if (start >= len) return(sc->F);
	  p = strchr((const char *)(porig + start), (int)c);
	  if (p) return(make_integer(sc, p - porig));
	}
      else wrong_type_argument_with_type(sc, sc->char_position_symbol, 3, s7_make_integer(sc, start), a_non_negative_integer_string);
    }
  else simple_wrong_type_argument(sc, sc->char_position_symbol, p2, T_STRING);
  return(sc->F);
}

static s7_pointer g_char_position_csi(s7_scheme *sc, s7_pointer args)
{
  /* assume char arg1, no end */
  const char *porig, *p;
  char c;
  s7_pointer arg2;
  s7_int start, len;

  c = character(car(args));
  arg2 = cadr(args);

  if (!is_string(arg2))
    return(g_char_position(sc, args));

  len = string_length(arg2); /* can't return #f here if len==0 -- need start error check first */
  porig = string_value(arg2);

  if (is_pair(cddr(args)))
    {
      s7_pointer arg3;
      arg3 = caddr(args);
      if (!s7_is_integer(arg3))
	return(g_char_position(sc, args));
      start = s7_integer(arg3);
      if (start < 0)
	return(wrong_type_argument_with_type(sc, sc->char_position_symbol, 3, arg3, a_non_negative_integer_string));
      if (start >= len) return(sc->F);
    }
  else start = 0;

  if (len == 0) return(sc->F);
  p = strchr((const char *)(porig + start), (int)c);
  if (p)
    return(make_integer(sc, p - porig));
  return(sc->F);
}


/* -------------------------------- string-position -------------------------------- */
static s7_pointer g_string_position(s7_scheme *sc, s7_pointer args)
{
  #define H_string_position "(string-position str1 str2 (start 0)) returns the starting position of str1 in str2 or #f"
  #define Q_string_position s7_make_signature(sc, 4, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->not_symbol), sc->is_string_symbol, sc->is_string_symbol, sc->is_integer_symbol)
  const char *s1, *s2, *p2;
  s7_int start = 0;
  s7_pointer s1p, s2p;

  s1p = car(args);
  if (!is_string(s1p))
    return(method_or_bust(sc, s1p, sc->string_position_symbol, args, T_STRING, 1));

  s2p = cadr(args);
  if (!is_string(s2p))
    return(method_or_bust(sc, s2p, sc->string_position_symbol, args, T_STRING, 2));

  if (is_pair(cddr(args)))
    {
      s7_pointer arg3;
      arg3 = caddr(args);
      if (!s7_is_integer(arg3))
	return(method_or_bust(sc, arg3, sc->string_position_symbol, args, T_INTEGER, 3));
      start = s7_integer(arg3);
      if (start < 0)
	return(wrong_type_argument_with_type(sc, sc->string_position_symbol, 3, caddr(args), a_non_negative_integer_string));
    }

  if (string_length(s1p) == 0)
    return(sc->F);
  s1 = string_value(s1p);
  s2 = string_value(s2p);
  if (start >= string_length(s2p))
    return(sc->F);

  p2 = strstr((const char *)(s2 + start), s1);
  if (!p2) return(sc->F);
  return(make_integer(sc, p2 - s2));
}


/* -------------------------------- strings -------------------------------- */

/* prebuilding sc->empty_string and using it wherever len==0 did not produce more than about %.2 speedup
 *   (in index.scm where 11% of the strings are empty).  s7test max 4% empty, elsewhere much less.
 */
bool s7_is_string(s7_pointer p)
{
  return(is_string(p));
}

const char *s7_string(s7_pointer p)
{
  return(string_value(p));
}

s7_int s7_string_length(s7_pointer str)
{
  return(string_length(str));
}

s7_pointer s7_make_string_with_length(s7_scheme *sc, const char *str, s7_int len)
{
  return(make_string_with_length(sc, str, len));
}

#define NUM_STRING_WRAPPERS 8 /* should be a power of 2 */

#if S7_DEBUGGING
/* #define wrap_string(Sc, Str, Len) wrap_string_1(Sc, Str, Len, __func__, __LINE__) */
static s7_pointer wrap_string_1(s7_scheme *sc, const char *str, s7_int len, const char *func, int line)
#else
static s7_pointer wrap_string(s7_scheme *sc, const char *str, s7_int len)
#endif
{
  s7_pointer x;
  x = sc->string_wrappers[sc->string_wrapper_pos];
  sc->string_wrapper_pos = (sc->string_wrapper_pos + 1) & (NUM_STRING_WRAPPERS - 1); /* i.e. next is pos+1 modulo len */
  string_value(x) = (char *)str;
  string_length(x) = len;
  return(x);
}

s7_pointer s7_make_string_wrapper(s7_scheme *sc, const char *str)
{
  return(wrap_string(sc, str, safe_strlen(str)));
}

static s7_pointer block_to_string(s7_scheme *sc, block_t *block, s7_int len)
{
  s7_pointer x;
  new_cell(sc, x, T_STRING | T_SAFE_PROCEDURE);
  string_block(x) = block;
  string_value(x) = (char *)block_data(block);
  string_length(x) = len;
  string_value(x)[len] = '\0';
  string_hash(x) = 0;
  add_string(sc, x);
  return(x);
}

static s7_pointer make_empty_string(s7_scheme *sc, s7_int len, char fill)
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_STRING);
  b = mallocate(sc, len + 1);                   /* terminated_string_read_white_space needs the second #\null (is this still the case?) */
  string_block(x) = b;
  string_value(x) = (char *)block_data(b);
  if ((fill != '\0') && (len > 0))
    local_memset((void *)(string_value(x)), fill, len);
  string_value(x)[len] = 0;
  string_hash(x) = 0;
  string_length(x) = len;
  add_string(sc, x);
  return(x);
}

s7_pointer s7_make_string(s7_scheme *sc, const char *str)
{
  if (str)
    return(make_string_with_length(sc, str, safe_strlen(str)));
  return(make_empty_string(sc, 0, 0));
}

static char *make_permanent_c_string(s7_scheme *sc, const char *str)
{
  char *x;
  s7_int len;
  len = safe_strlen(str);
  x = (char *)alloc_permanent_string(sc, (len + 1) * sizeof(char));
  memcpy((void *)x, (void *)str, len);
  x[len] = 0;
  return(x);
}

#if S7_DEBUGGING
static s7_int permanent_strings = 0;
#endif

s7_pointer s7_make_permanent_string(s7_scheme *sc, const char *str)
{
  /* for the symbol table which is never GC'd */
  s7_pointer x;
  x = alloc_pointer(sc);
#if S7_DEBUGGING
  permanent_strings++;
#endif
  set_type(x, T_STRING | T_IMMUTABLE | T_UNHEAP);
  if (str)
    {
      s7_int len;
      len = safe_strlen(str);
      string_length(x) = len;
      /* string_block(x) = mallocate_block(); */
      string_block(x) = NULL;
      string_value(x) = (char *)alloc_permanent_string(sc, (len + 1) * sizeof(char));
      memcpy((void *)string_value(x), (void *)str, len);
      string_value(x)[len] = 0;
    }
  else
    {
      string_value(x) = NULL;
      string_length(x) = 0;
    }
  string_hash(x) = 0;
  return(x);
}

static s7_pointer g_is_string(s7_scheme *sc, s7_pointer args)
{
  #define H_is_string "(string? obj) returns #t if obj is a string"
  #define Q_is_string sc->pl_bt

  check_boolean_method(sc, is_string, sc->is_string_symbol, args);
}

static s7_pointer make_permanent_string(const char *str)
{
  s7_pointer x;
  s7_int len;

  x = (s7_pointer)calloc(1, sizeof(s7_cell));
  set_type(x, T_STRING | T_IMMUTABLE | T_UNHEAP);
  len = safe_strlen(str);
  string_length(x) = len;
  string_block(x) = NULL;
  string_value(x) = (char *)str;
  string_hash(x) = 0;
  return(x);
}

static void init_strings(void)
{
  car_a_list_string = make_permanent_string("a list whose car is also a list");
  cdr_a_list_string = make_permanent_string("a list whose cdr is also a list");

  caar_a_list_string = make_permanent_string("a list whose caar is also a list");
  cadr_a_list_string = make_permanent_string("a list whose cadr is also a list");
  cdar_a_list_string = make_permanent_string("a list whose cdar is also a list");
  cddr_a_list_string = make_permanent_string("a list whose cddr is also a list");

  caaar_a_list_string = make_permanent_string("a list whose caaar is also a list");
  caadr_a_list_string = make_permanent_string("a list whose caadr is also a list");
  cadar_a_list_string = make_permanent_string("a list whose cadar is also a list");
  caddr_a_list_string = make_permanent_string("a list whose caddr is also a list");
  cdaar_a_list_string = make_permanent_string("a list whose cdaar is also a list");
  cdadr_a_list_string = make_permanent_string("a list whose cdadr is also a list");
  cddar_a_list_string = make_permanent_string("a list whose cddar is also a list");
  cdddr_a_list_string = make_permanent_string("a list whose cdddr is also a list");

  a_list_string =                 make_permanent_string("a list");
  an_eq_func_string =             make_permanent_string("a procedure that can take 2 arguments");
  an_association_list_string =    make_permanent_string("an association list");
  a_normal_real_string =          make_permanent_string("a normal real");
  a_rational_string =             make_permanent_string("an integer or a ratio");
  a_number_string =               make_permanent_string("a number");
  a_procedure_string =            make_permanent_string("a procedure");
  a_normal_procedure_string =     make_permanent_string("a normal procedure (not a continuation)");
  a_let_string =                  make_permanent_string("a let (environment)");
  a_proper_list_string =          make_permanent_string("a proper list");
  a_boolean_string =              make_permanent_string("a boolean");
  a_byte_vector_string =          make_permanent_string("a byte-vector");
  an_input_port_string =          make_permanent_string("an input port");
  an_open_port_string =           make_permanent_string("an open port");
  an_output_port_string =         make_permanent_string("an output port");
  an_input_string_port_string =   make_permanent_string("an input string port");
  an_input_file_port_string =     make_permanent_string("an input file port");
  an_output_string_port_string =  make_permanent_string("an output string port");
  an_output_file_port_string =    make_permanent_string("an output file port");
  a_thunk_string =                make_permanent_string("a thunk");
  a_symbol_string =               make_permanent_string("a symbol");
  a_non_negative_integer_string = make_permanent_string("a non-negative integer");
  an_unsigned_byte_string =       make_permanent_string("an unsigned byte");
  something_applicable_string =   make_permanent_string("a procedure or something applicable");
  a_random_state_object_string =  make_permanent_string("a random-state object");
  a_format_port_string =          make_permanent_string("#f, #t, (), or an open output port");
  a_non_constant_symbol_string =  make_permanent_string("a non-constant symbol");
  a_sequence_string =             make_permanent_string("a sequence");
  a_valid_radix_string =          make_permanent_string("should be between 2 and 16");
  result_is_too_large_string =    make_permanent_string("result is too large");
  its_too_large_string =          make_permanent_string("it is too large");
  its_too_small_string =          make_permanent_string("it is less than the start position");
  its_negative_string =           make_permanent_string("it is negative");
  its_nan_string =                make_permanent_string("NaN usually indicates a numerical error");
  its_infinite_string =           make_permanent_string("it is infinite");
  too_many_indices_string =       make_permanent_string("too many indices");
  value_is_missing_string =       make_permanent_string("~A argument '~A's value is missing");
  parameter_set_twice_string =    make_permanent_string("parameter set twice, ~S in ~S");
  immutable_error_string =        make_permanent_string("can't ~S ~S (it is immutable)");
#if (!HAVE_COMPLEX_NUMBERS)
  no_complex_numbers_string =     make_permanent_string("this version of s7 does not support complex numbers");
#endif

  format_string_1 = make_permanent_string("format: ~S ~{~S~^ ~}: ~A");
  format_string_2 = make_permanent_string("format: ~S: ~A");
  format_string_3 = make_permanent_string("format: ~S ~{~S~^ ~}~&~NT^: ~A");
  format_string_4 = make_permanent_string("format: ~S~&~NT^: ~A");

  too_many_arguments_string = make_permanent_string("~A: too many arguments: ~A");
  not_enough_arguments_string = make_permanent_string("~A: not enough arguments: ~A");
  missing_method_string = make_permanent_string("missing ~S method in ~S");
}


/* -------------------------------- make-string -------------------------------- */
static s7_pointer g_make_string(s7_scheme *sc, s7_pointer args)
{
  #define H_make_string "(make-string len (val #\\space)) makes a string of length len filled with the character val (default: space)"
  #define Q_make_string s7_make_signature(sc, 3, sc->is_string_symbol, sc->is_integer_symbol, sc->is_char_symbol)

  s7_pointer n;
  s7_int len;

  n = car(args);
  if (!s7_is_integer(n))
    {
      check_method(sc, n, sc->make_string_symbol, args);
      return(wrong_type_argument(sc, sc->make_string_symbol, 1, n, T_INTEGER));
    }

  len = s7_integer(n);
#if WITH_GMP
  if ((len == 0) && (!s7_is_zero(n)))
    return(s7_out_of_range_error(sc, "make-string", 1, n, "big integer is too big for s7_int"));
#endif
  if ((len < 0) || (len > sc->max_string_length))
    return(out_of_range(sc, sc->make_string_symbol, small_int(1), n, (len < 0) ? its_negative_string : its_too_large_string));

  if (is_not_null(cdr(args)))
    {
      char fill;
      if (!s7_is_character(cadr(args)))
	return(method_or_bust(sc, cadr(args), sc->make_string_symbol, args, T_CHARACTER, 2));
      fill = s7_character(cadr(args));
      n = make_empty_string(sc, len, fill);
      if ((fill == '\0') && (len > 0))
	memclr((void *)string_value(n), (size_t)len);
      return(n);
    }
  return(make_empty_string(sc, len, '\0')); /* #\null here means "don't fill/clear" */
}

static s7_pointer make_string_p_i(s7_scheme *sc, s7_int len)
{
  if ((len < 0) || (len > sc->max_string_length))
    return(out_of_range(sc, sc->make_string_symbol, small_int(1), make_integer(sc, len), (len < 0) ? its_negative_string : its_too_large_string));
  return(make_empty_string(sc, len, '\0'));
}


#if (!WITH_PURE_S7)
/* -------------------------------- string-length -------------------------------- */
static s7_pointer g_string_length(s7_scheme *sc, s7_pointer args)
{
  #define H_string_length "(string-length str) returns the length of the string str"
  #define Q_string_length s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_string_symbol)
  s7_pointer p;
  p = car(args);
  if (!is_string(p))
    return(method_or_bust_one_arg(sc, p, sc->string_length_symbol, args, T_STRING));
  return(make_integer(sc, string_length(p)));
}

static s7_int string_length_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_string(p))
    return(integer(method_or_bust_one_arg(sc, p, sc->string_length_symbol, list_1(sc, p), T_STRING)));
  return(string_length(p));
}
#endif


/* -------------------------------- string-up|downcase -------------------------------- */
static s7_pointer g_string_downcase(s7_scheme *sc, s7_pointer args)
{
  #define H_string_downcase "(string-downcase str) returns the lower case version of str."
  #define Q_string_downcase sc->pcl_s

  s7_pointer p, newstr;
  s7_int i, len;
  uint8_t *nstr, *ostr;

  p = car(args);
  if (!is_string(p))
    return(method_or_bust_one_arg(sc, p, sc->string_downcase_symbol, list_1(sc, p), T_STRING));
  len = string_length(p);
  newstr = make_empty_string(sc, len, 0);

  ostr = (uint8_t *)string_value(p);
  nstr = (uint8_t *)string_value(newstr);

  if (len >= 128)
    {
      i = len - 1;
      while (i >= 8)
	LOOP_8(nstr[i] = lowers[(uint8_t)ostr[i]]; i--);
      while (i >= 0) {nstr[i] = lowers[(uint8_t)ostr[i]]; i--;}
    }
  else
    {
      for (i = 0; i < len; i++)
	nstr[i] = lowers[(uint8_t)ostr[i]];
    }
  return(newstr);
}

static s7_pointer g_string_upcase(s7_scheme *sc, s7_pointer args)
{
  #define H_string_upcase "(string-upcase str) returns the upper case version of str."
  #define Q_string_upcase sc->pcl_s

  s7_pointer p, newstr;
  s7_int i, len;
  uint8_t *nstr, *ostr;

  p = car(args);
  if (!is_string(p))
    return(method_or_bust_one_arg(sc, p, sc->string_upcase_symbol, list_1(sc, p), T_STRING));
  len = string_length(p);
  newstr = make_empty_string(sc, len, 0);

  ostr = (uint8_t *)string_value(p);
  nstr = (uint8_t *)string_value(newstr);

  if (len >= 128)
    {
      i = len - 1;
      while (i >= 8)
	LOOP_8(nstr[i] = uppers[(uint8_t)ostr[i]]; i--);
      while (i >= 0) {nstr[i] = uppers[(uint8_t)ostr[i]]; i--;}
    }
  else
    {
      for (i = 0; i < len; i++)
	nstr[i] = uppers[(uint8_t)ostr[i]];
    }
  return(newstr);
}


/* -------------------------------- string-ref -------------------------------- */
static s7_pointer string_ref_1(s7_scheme *sc, s7_pointer strng, s7_pointer index)
{
  char *str;
  s7_int ind;

  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->string_ref_symbol, list_2(sc, strng, index), T_INTEGER, 2));
  ind = s7_integer(index);
  if (ind < 0)
    return(wrong_type_argument_with_type(sc, sc->string_ref_symbol, 2, index, a_non_negative_integer_string));
  if (ind >= string_length(strng))
    return(out_of_range(sc, sc->string_ref_symbol, small_int(2), index, its_too_large_string));

  str = string_value(strng);
  return(s7_make_character(sc, ((uint8_t *)str)[ind]));
}

static s7_pointer g_string_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_string_ref "(string-ref str index) returns the character at the index-th element of the string str"
  #define Q_string_ref s7_make_signature(sc, 3, sc->is_char_symbol, sc->is_string_symbol, sc->is_integer_symbol)

  s7_pointer strng;
  strng = car(args);
  if (!is_string(strng))
    return(method_or_bust(sc, strng, sc->string_ref_symbol, args, T_STRING, 1));
  return(string_ref_1(sc, strng, cadr(args)));
}

static s7_pointer string_ref_p_pi(s7_scheme *sc, s7_pointer p1, s7_int i1)
{
  if (!is_string(p1))
    simple_wrong_type_argument(sc, sc->string_ref_symbol, p1, T_STRING);
  if ((i1 >= 0) && (i1 < string_length(p1)))
    return(chars[((uint8_t *)string_value(p1))[i1]]);
  out_of_range(sc, sc->string_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(p1);
}

static s7_pointer string_ref_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer i1)
{
  if (!is_string(p1))
    return(method_or_bust(sc, p1, sc->string_ref_symbol, set_plist_2(sc, p1, i1), T_STRING, 1));
  return(string_ref_1(sc, p1, i1));
}

static s7_pointer string_ref_p_pi_direct(s7_scheme *sc, s7_pointer p1, s7_int i1)
{
  if ((i1 >= 0) && (i1 < string_length(p1)))
    return(chars[((uint8_t *)string_value(p1))[i1]]);
  out_of_range(sc, sc->string_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(p1);
}

static s7_pointer string_ref_unchecked(s7_scheme *sc, s7_pointer p1, s7_int i1) {return(chars[((uint8_t *)string_value(p1))[i1]]);}


/* -------------------------------- string-set! -------------------------------- */
static s7_pointer g_string_set(s7_scheme *sc, s7_pointer args)
{
  #define H_string_set "(string-set! str index chr) sets the index-th element of the string str to the character chr"
  #define Q_string_set s7_make_signature(sc, 4, sc->is_char_symbol, sc->is_string_symbol, sc->is_integer_symbol, sc->is_char_symbol)

  s7_pointer strng, c, index;
  char *str;
  s7_int ind;

  strng = car(args);
  if (!is_mutable_string(strng))
    return(mutable_method_or_bust(sc, strng, sc->string_set_symbol, args, T_STRING, 1));

  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->string_set_symbol, args, T_INTEGER, 2));
  ind = s7_integer(index);
  if (ind < 0)
    return(wrong_type_argument_with_type(sc, sc->string_set_symbol, 2, index, a_non_negative_integer_string));
  if (ind >= string_length(strng))
    return(out_of_range(sc, sc->string_set_symbol, small_int(2), index, its_too_large_string));

  str = string_value(strng);
  c = caddr(args);
  if (!s7_is_character(c))
    return(method_or_bust(sc, c, sc->string_set_symbol, args, T_CHARACTER, 3));

  str[ind] = (char)s7_character(c);
  return(c);
}

static s7_pointer string_set_p_pip(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2)
{
  if (!is_string(p1))
    simple_wrong_type_argument(sc, sc->string_set_symbol, p1, T_STRING);
  if (!s7_is_character(p2))
    simple_wrong_type_argument(sc, sc->string_set_symbol, p2, T_CHARACTER);
  if ((i1 >= 0) && (i1 < string_length(p1)))
    string_value(p1)[i1] = s7_character(p2);
  else out_of_range(sc, sc->string_set_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(p2);
}

static s7_pointer string_set_p_pip_direct(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2)
{
  if ((i1 >= 0) && (i1 < string_length(p1)))
    string_value(p1)[i1] = s7_character(p2);
  else out_of_range(sc, sc->string_set_symbol, small_int(2),make_integer(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(p2);
}

static s7_pointer string_set_unchecked(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2) {string_value(p1)[i1] = s7_character(p2); return(p2);}


/* -------------------------------- string-append -------------------------------- */
#if S7_DEBUGGING
#define unstack(sc) unstack_1(sc, __func__, __LINE__)
static void unstack_1(s7_scheme *sc, const char *func, int line)
{
  sc->stack_end -= 4;
  if (((opcode_t)sc->stack_end[3]) != OP_GC_PROTECT)
    {
      fprintf(stderr, "%s%s[%d]: popped %s?%s\n", BOLD_TEXT, func, line, op_names[(opcode_t)sc->stack_end[3]], UNBOLD_TEXT);
      fprintf(stderr, "    code: %s, args: %s\n", DISPLAY(sc->code), DISPLAY(sc->args));
    }
}
#else
#define unstack(sc) sc->stack_end -= 4
#endif

static s7_pointer g_string_append_1(s7_scheme *sc, s7_pointer args, s7_pointer caller)
{
  #define H_string_append "(string-append str1 ...) appends all its string arguments into one string"
  #define Q_string_append sc->pcl_s

  s7_int len = 0;
  s7_pointer x, newstr;
  char *pos;

  if (is_null(args))
    return(make_string_with_length(sc, "", 0));

  push_stack_no_let_no_code(sc, OP_GC_PROTECT, args);
  /* get length for new string */
  for (x = args; is_not_null(x); x = cdr(x))
    {
      s7_pointer p;
      p = car(x);
      if (!is_string(p))
	{
	  /* look for string-append and if found, cobble up a plausible intermediate call */
	  if (has_active_methods(sc, p))
	    {
	      s7_pointer func;
	      func = find_method(sc, find_let(sc, p), caller);
	      if (func != sc->undefined)
		{
		  s7_pointer y;
		  if (len == 0)
		    return(s7_apply_function(sc, func, x)); /* not args (string-append "" "" ...) */
		  newstr = make_empty_string(sc, len, 0);
		  for (pos = string_value(newstr), y = args; y != x; pos += string_length(car(y)), y = cdr(y))
		    memcpy(pos, string_value(car(y)), string_length(car(y)));
		  return(s7_apply_function(sc, func, cons(sc, newstr, x)));
		}
	    }
	  return(wrong_type_argument(sc, caller, position_of(x, args), p, T_STRING));
	}
      len += string_length(p);
    }

  if (len == 0) return(car(args));

  if (len > sc->max_string_length)
    return(s7_error(sc, sc->out_of_range_symbol,
		    set_elist_4(sc, wrap_string(sc, "~S new string length, ~D, is larger than (*s7* 'max-string-length): ~D", 70),
				caller,
				wrap_integer1(sc, len),
				wrap_integer2(sc, sc->max_string_length))));

  newstr = make_empty_string(sc, len, 0);
  for (pos = string_value(newstr), x = args; is_not_null(x); pos += string_length(car(x)), x = cdr(x))
    if (string_length(car(x)) > 0)
      memcpy(pos, string_value(car(x)), string_length(car(x)));
  unstack(sc);
  return(newstr);
}

static s7_pointer g_string_append(s7_scheme *sc, s7_pointer args)
{
  return(g_string_append_1(sc, args, sc->string_append_symbol));
}

#if (!WITH_PURE_S7)
/* -------------------------------- string-copy -------------------------------- */
static s7_pointer g_string_copy(s7_scheme *sc, s7_pointer args)
{
  #define H_string_copy "(string-copy str) returns a copy of its string argument"
  #define Q_string_copy s7_make_signature(sc, 2, sc->is_string_symbol, sc->is_string_symbol)
  s7_pointer p;
  p = car(args);
  if (!is_string(p))
    return(method_or_bust(sc, p, sc->string_copy_symbol, args, T_STRING, 1));
  return(make_string_with_length(sc, string_value(p), string_length(p)));
}
#endif


/* -------------------------------- substring -------------------------------- */
static s7_pointer start_and_end(s7_scheme *sc, s7_pointer caller, s7_pointer args, int32_t position, s7_int *start, s7_int *end)
{
  /* we assume that *start=0 and *end=length, that end is "exclusive", return true if the start/end points are not changed */
  s7_pointer pstart, index_args;
  s7_int i, index;

  for (i = 0, index_args = args; (i < (position - 1)) && (is_pair(index_args)); i++, index_args = cdr(index_args)) {}

  pstart = car(index_args);
  if (!s7_is_integer(pstart))
    return(method_or_bust(sc, pstart, caller, args, T_INTEGER, position));
  index = s7_integer(pstart);
  if ((index < 0) ||
      (index > *end)) /* *end == length here */
    return(out_of_range(sc, caller, small_int(position), pstart, (index < 0) ? its_negative_string : its_too_large_string));
  *start = index;

  if (is_pair(cdr(index_args)))
    {
      s7_pointer pend;
      pend = cadr(index_args);
      if (!s7_is_integer(pend))
	return(method_or_bust(sc, pend, caller, args, T_INTEGER, position + 1));
      index = s7_integer(pend);
      if ((index < *start) ||
	  (index > *end))
	return(out_of_range(sc, caller, small_int(position + 1), pend, (index < *start) ? its_too_small_string : its_too_large_string));
      *end = index;
    }
  return(sc->unused);
}

static s7_pointer g_substring(s7_scheme *sc, s7_pointer args)
{
  #define H_substring "(substring str start (end (length str))) returns the portion of the string str between start and \
end: (substring \"01234\" 1 2) -> \"1\""
  #define Q_substring s7_make_circular_signature(sc, 2, 3, sc->is_string_symbol, sc->is_string_symbol, sc->is_integer_symbol)

  s7_pointer x, str;
  s7_int start = 0, end, len;
  char *s;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->substring_symbol, args, T_STRING, 1));

  end = string_length(str);
  if (!is_null(cdr(args)))
    {
      x = start_and_end(sc, sc->substring_symbol, args, 2, &start, &end);
      if (x != sc->unused) return(x);
    }
  s = string_value(str);
  len = end - start;
  x = make_string_with_length(sc, (char *)(s + start), len);
  string_value(x)[len] = 0;
  return(x);
}

static s7_pointer g_substring_to_temp(s7_scheme *sc, s7_pointer args)
{
  s7_pointer str;
  s7_int start = 0, end;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->substring_symbol, args, T_STRING, 1));

  end = string_length(str);
  if (!is_null(cdr(args)))
    {
      s7_pointer x;
      x = start_and_end(sc, sc->substring_symbol, args, 2, &start, &end);
      if (x != sc->unused) return(x);
    }
  return(wrap_string(sc, (char *)(string_value(str) + start), end - start));
}


/* -------------------------------- string comparisons -------------------------------- */
static int32_t scheme_strcmp(s7_pointer s1, s7_pointer s2)
{
  /* tricky here because str[i] must be treated as unsigned: (string<? (string (integer->char #xf0)) (string (integer->char #x70)))
   *   and null or lack thereof does not say anything about the string end
   */
  size_t i, len, len1, len2;
  char *str1, *str2;

  len1 = (size_t)string_length(s1);
  len2 = (size_t)string_length(s2);
  if (len1 > len2)
    len = len2;
  else len = len1;

  str1 = string_value(s1);
  str2 = string_value(s2);

  if (len < sizeof(size_t))
    {
      for (i = 0; i < len; i++)
	{
	  if ((uint8_t)(str1[i]) < (uint8_t )(str2[i]))
	    return(-1);
	  if ((uint8_t)(str1[i]) > (uint8_t)(str2[i]))
	    return(1);
	}
    }
  else
    {
      /* this algorithm from stackoverflow(?), with various changes (original did not work for large strings, etc) */
      size_t last, pos;
      size_t *ptr1, *ptr2;

      last = len / sizeof(size_t);
      for (ptr1 = (size_t *)str1, ptr2 = (size_t *)str2, i = 0; i < last; i++)
	if (ptr1[i] ^ ptr2[i])
	  break;

      for (pos = i * sizeof(size_t); pos < len; pos++)
	{
	  if ((uint8_t)str1[pos] < (uint8_t)str2[pos])
	    return(-1);
	  if ((uint8_t)str1[pos] > (uint8_t)str2[pos])
	    return(1);
	}
    }

  if (len1 < len2)
    return(-1);
  if (len1 > len2)
    return(1);
  return(0);
}

static bool is_string_via_method(s7_scheme *sc, s7_pointer p)
{
  if (s7_is_string(p))
    return(true);
  if (has_active_methods(sc, p))
    {
      s7_pointer f;
      f = find_method(sc, find_let(sc, p), sc->is_string_symbol);
      if (f != sc->undefined)
	return(is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil))));
    }
  return(false);
}

static s7_pointer g_string_cmp(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!is_string(y))
    return(method_or_bust(sc, y, sym, args, T_STRING, 1));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!is_string(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_STRING, position_of(x, args)));
      if (scheme_strcmp(y, car(x)) != val)
	{
	  for (y = cdr(x); is_pair(y); y = cdr(y))
	    if (!is_string_via_method(sc, car(y)))
	      return(wrong_type_argument(sc, sym, position_of(y, args), car(y), T_STRING));
	  return(sc->F);
	}
      y = car(x);
    }
  return(sc->T);
}

static s7_pointer g_string_cmp_not(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!is_string(y))
    return(method_or_bust(sc, y, sym, args, T_STRING, 1));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!is_string(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_STRING, position_of(x, args)));
      if (scheme_strcmp(y, car(x)) == val)
	{
	  for (y = cdr(x); is_pair(y); y = cdr(y))
	    if (!is_string_via_method(sc, car(y)))
	      return(wrong_type_argument(sc, sym, position_of(y, args), car(y), T_STRING));
	  return(sc->F);
	}
      y = car(x);
    }
  return(sc->T);
}

static bool scheme_strings_are_equal(s7_pointer x, s7_pointer y)
{
  return((string_length(x) == string_length(y)) &&
	 (strings_are_equal_with_length(string_value(x), string_value(y), string_length(x))));
}

static s7_pointer g_strings_are_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_equal "(string=? str ...) returns #t if all the string arguments are equal"
  #define Q_strings_are_equal sc->pcl_bs

  /* C-based check stops at null, but we can have embedded nulls.
   *   (let ((s1 "1234") (s2 "1245")) (string-set! s1 1 #\null) (string-set! s2 1 #\null) (string=? s1 s2))
   */
  s7_pointer x, y;
  bool happy = true;

  y = car(args);
  if (!is_string(y))
    return(method_or_bust(sc, y, sc->string_eq_symbol, args, T_STRING, 1));

  for (x = cdr(args); is_pair(x); x = cdr(x))
    {
      s7_pointer p;
      p = car(x);
      if (y != p)
	{
	  if (!is_string(p))
	    return(method_or_bust(sc, p, sc->string_eq_symbol, cons(sc, y, x), T_STRING, position_of(x, args)));
	  if (happy)
	    happy = scheme_strings_are_equal(p, y);
	}
    }
  if (!happy)
    return(sc->F);
  return(sc->T);
}

static s7_pointer g_strings_are_less(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_less "(string<? str ...) returns #t if all the string arguments are increasing"
  #define Q_strings_are_less sc->pcl_bs

  return(g_string_cmp(sc, args, -1, sc->string_lt_symbol));
}

static s7_pointer g_strings_are_greater(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_greater "(string>? str ...) returns #t if all the string arguments are decreasing"
  #define Q_strings_are_greater sc->pcl_bs

  return(g_string_cmp(sc, args, 1, sc->string_gt_symbol));
}

static s7_pointer g_strings_are_geq(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_geq "(string>=? str ...) returns #t if all the string arguments are equal or decreasing"
  #define Q_strings_are_geq sc->pcl_bs

  return(g_string_cmp_not(sc, args, -1, sc->string_geq_symbol));
}

static s7_pointer g_strings_are_leq(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_leq "(string<=? str ...) returns #t if all the string arguments are equal or increasing"
  #define Q_strings_are_leq sc->pcl_bs

  return(g_string_cmp_not(sc, args, 1, sc->string_leq_symbol));
}

static s7_pointer g_string_equal_2(s7_scheme *sc, s7_pointer args)
{
  if (!is_string(car(args)))
    return(method_or_bust(sc, car(args), sc->string_eq_symbol, args, T_STRING, 1));
  if (!is_string(cadr(args)))
    return(method_or_bust(sc, cadr(args), sc->string_eq_symbol, args, T_STRING, 2));
  return(make_boolean(sc, scheme_strings_are_equal(car(args), cadr(args))));
}

static s7_pointer g_string_less_2(s7_scheme *sc, s7_pointer args)
{
  if (!is_string(car(args)))
    return(method_or_bust(sc, car(args), sc->string_lt_symbol, args, T_STRING, 1));
  if (!is_string(cadr(args)))
    return(method_or_bust(sc, cadr(args), sc->string_lt_symbol, args, T_STRING, 2));
  return(make_boolean(sc, scheme_strcmp(car(args), cadr(args)) == -1));
}

static s7_pointer g_string_greater_2(s7_scheme *sc, s7_pointer args)
{
  if (!is_string(car(args)))
    return(method_or_bust(sc, car(args), sc->string_gt_symbol, args, T_STRING, 1));
  if (!is_string(cadr(args)))
    return(method_or_bust(sc, cadr(args), sc->string_gt_symbol, args, T_STRING, 2));
  return(make_boolean(sc, scheme_strcmp(car(args), cadr(args)) == 1));
}

static inline void check_string2_args(s7_scheme *sc, s7_pointer caller, s7_pointer p1, s7_pointer p2)
{
  if (!is_string(p1))
    simple_wrong_type_argument(sc, caller, p1, T_STRING);
  if (!s7_is_string(p2))
    simple_wrong_type_argument(sc, caller, p2, T_STRING);
}

static bool string_lt_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcmp(p1, p2) == -1);}
static bool string_lt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_lt_symbol, p1, p2);
  return(scheme_strcmp(p1, p2) == -1);
}

static bool string_leq_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcmp(p1, p2) != 1);}
static bool string_leq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_leq_symbol, p1, p2);
  return(scheme_strcmp(p1, p2) != 1);
}

static bool string_gt_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcmp(p1, p2) == 1);}
static bool string_gt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_gt_symbol, p1, p2);
  return(scheme_strcmp(p1, p2) == 1);
}

static bool string_geq_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcmp(p1, p2) != -1);}
static bool string_geq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_geq_symbol, p1, p2);
  return(scheme_strcmp(p1, p2) != -1);
}

static bool string_eq_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strings_are_equal(p1, p2));}
static bool string_eq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_eq_symbol, p1, p2);
  return(scheme_strings_are_equal(p1, p2));
}


#if (!WITH_PURE_S7)
static int32_t scheme_strcasecmp(s7_pointer s1, s7_pointer s2)
{
  /* same as scheme_strcmp -- watch out for unwanted sign! and lack of trailing null (length sets string end).
   */
  s7_int i, len, len1, len2;
  uint8_t *str1, *str2;

  len1 = string_length(s1);
  len2 = string_length(s2);
  if (len1 > len2)
    len = len2;
  else len = len1;

  str1 = (uint8_t *)string_value(s1);
  str2 = (uint8_t *)string_value(s2);

  for (i = 0; i < len; i++)
    {
      if (uppers[(int32_t)str1[i]] < uppers[(int32_t)str2[i]])
	return(-1);
      if (uppers[(int32_t)str1[i]] > uppers[(int32_t)str2[i]])
	return(1);
    }

  if (len1 < len2)
    return(-1);
  if (len1 > len2)
    return(1);
  return(0);
}

static bool scheme_strequal_ci(s7_pointer s1, s7_pointer s2)
{
  /* same as scheme_strcmp -- watch out for unwanted sign! */
  s7_int i, len, len2;
  uint8_t *str1, *str2;

  len = string_length(s1);
  len2 = string_length(s2);
  if (len != len2)
    return(false);

  str1 = (uint8_t *)string_value(s1);
  str2 = (uint8_t *)string_value(s2);

  for (i = 0; i < len; i++)
    if (uppers[(int32_t)str1[i]] != uppers[(int32_t)str2[i]])
      return(false);
  return(true);
}

static s7_pointer string_check_method(s7_scheme *sc, s7_pointer sym, s7_pointer x, s7_pointer y, s7_pointer args)
{
  for (y = cdr(x); is_pair(y); y = cdr(y))
    if (!is_string_via_method(sc, car(y)))
      return(wrong_type_argument(sc, sym, position_of(y, args), car(y), T_STRING));
  return(sc->F);
}

static s7_pointer g_string_ci_cmp(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!is_string(y))
    return(method_or_bust(sc, y, sym, args, T_STRING, 1));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!is_string(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_STRING, position_of(x, args)));
      if (val == 0)
	{
	  if (!scheme_strequal_ci(y, car(x)))
	    return(string_check_method(sc, sym, x, y, args));
	}
      else
	{
	  if (scheme_strcasecmp(y, car(x)) != val)
	    return(string_check_method(sc, sym, x, y, args));
	}
      y = car(x);
    }
  return(sc->T);
}

static s7_pointer g_string_ci_cmp_not(s7_scheme *sc, s7_pointer args, int32_t val, s7_pointer sym)
{
  s7_pointer x, y;

  y = car(args);
  if (!is_string(y))
    return(method_or_bust(sc, y, sym, args, T_STRING, 1));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!is_string(car(x)))
	return(method_or_bust(sc, car(x), sym, cons(sc, y, x), T_STRING, position_of(x, args)));
      if (scheme_strcasecmp(y, car(x)) == val)
	return(string_check_method(sc, sym, x, y, args));
      y = car(x);
    }
  return(sc->T);
}

static s7_pointer g_strings_are_ci_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_ci_equal "(string-ci=? str ...) returns #t if all the string arguments are equal, ignoring case"
  #define Q_strings_are_ci_equal sc->pcl_bs
  return(g_string_ci_cmp(sc, args, 0, sc->string_ci_eq_symbol));
}

static s7_pointer g_strings_are_ci_less(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_ci_less "(string-ci<? str ...) returns #t if all the string arguments are increasing, ignoring case"
  #define Q_strings_are_ci_less sc->pcl_bs
  return(g_string_ci_cmp(sc, args, -1, sc->string_ci_lt_symbol));
}

static s7_pointer g_strings_are_ci_greater(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_ci_greater "(string-ci>? str ...) returns #t if all the string arguments are decreasing, ignoring case"
  #define Q_strings_are_ci_greater sc->pcl_bs
  return(g_string_ci_cmp(sc, args, 1, sc->string_ci_gt_symbol));
}

static s7_pointer g_strings_are_ci_geq(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_ci_geq "(string-ci>=? str ...) returns #t if all the string arguments are equal or decreasing, ignoring case"
  #define Q_strings_are_ci_geq sc->pcl_bs
  return(g_string_ci_cmp_not(sc, args, -1, sc->string_ci_geq_symbol));
}

static s7_pointer g_strings_are_ci_leq(s7_scheme *sc, s7_pointer args)
{
  #define H_strings_are_ci_leq "(string-ci<=? str ...) returns #t if all the string arguments are equal or increasing, ignoring case"
  #define Q_strings_are_ci_leq sc->pcl_bs
  return(g_string_ci_cmp_not(sc, args, 1, sc->string_ci_leq_symbol));
}

static bool string_ci_lt_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcasecmp(p1, p2) == -1);}
static bool string_ci_lt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_ci_lt_symbol, p1, p2);
  return(scheme_strcasecmp(p1, p2) == -1);
}

static bool string_ci_leq_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcasecmp(p1, p2) != 1);}
static bool string_ci_leq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_ci_leq_symbol, p1, p2);
  return(scheme_strcasecmp(p1, p2) != 1);
}

static bool string_ci_gt_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcasecmp(p1, p2) == 1);}
static bool string_ci_gt_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_ci_gt_symbol, p1, p2);
  return(scheme_strcasecmp(p1, p2) == 1);
}

static bool string_ci_geq_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcasecmp(p1, p2) != -1);}
static bool string_ci_geq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_ci_geq_symbol, p1, p2);
  return(scheme_strcasecmp(p1, p2) != -1);
}

static bool string_ci_eq_b_direct(s7_pointer p1, s7_pointer p2) {return(scheme_strcasecmp(p1, p2) == 0);}
static bool string_ci_eq_b_7pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  check_string2_args(sc, sc->string_ci_eq_symbol, p1, p2);
  return(scheme_strcasecmp(p1, p2) == 0);
}
#endif /* pure s7 */

static s7_pointer g_string_fill_1(s7_scheme *sc, s7_pointer caller, s7_pointer args)
{
  s7_pointer x, chr;
  s7_int start = 0, end;
  x = car(args);

  if (!is_string(x))
    return(method_or_bust(sc, x, caller, args, T_STRING, 1)); /* not two methods here */
  if (is_immutable_string(x))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, caller, x)));

  chr = cadr(args);
  if (!s7_is_character(chr))
    return(method_or_bust(sc, chr, caller, args, T_CHARACTER, 2));

  end = string_length(x);
  if (!is_null(cddr(args)))
    {
      s7_pointer p;
      p = start_and_end(sc, caller, args, 3, &start, &end);
      if (p != sc->unused)
	return(p);
      if (start == end) return(chr);
    }
  if (end == 0) return(chr);

  if ((int)(character(chr)) == 0)
    memclr((void *)(string_value(x) + start), end - start);
  else local_memset((void *)(string_value(x) + start), (int32_t)character(chr), end - start);

  return(chr);
}

#if (!WITH_PURE_S7)
/* -------------------------------- string-fill! -------------------------------- */
static s7_pointer g_string_fill(s7_scheme *sc, s7_pointer args)
{
  #define H_string_fill "(string-fill! str chr start end) fills the string str with the character chr"
  #define Q_string_fill s7_make_signature(sc, 5, s7_make_signature(sc, 2, sc->is_char_symbol, sc->is_integer_symbol), sc->is_string_symbol, sc->is_char_symbol, sc->is_integer_symbol, sc->is_integer_symbol)
  return(g_string_fill_1(sc, sc->string_fill_symbol, args));
}
#endif

static s7_pointer g_string_1(s7_scheme *sc, s7_pointer args, s7_pointer sym)
{
  int32_t i, len;
  s7_pointer x, newstr;
  char *str;

  /* get length for new string and check arg types */
  for (len = 0, x = args; is_not_null(x); len++, x = cdr(x))
    {
      s7_pointer p;
      p = car(x);
      if (!s7_is_character(p))
	{
	  if (has_active_methods(sc, p))
	    {
	      s7_pointer func;
	      func = find_method(sc, find_let(sc, p), sym);
	      if (func != sc->undefined)
		{
		  s7_pointer y;
		  if (len == 0)
		    return(s7_apply_function(sc, func, args));
		  newstr = make_empty_string(sc, len, 0);
		  str = string_value(newstr);
		  for (i = 0, y = args; y != x; i++, y = cdr(y))
		    str[i] = character(car(y));
		  return(g_string_append_1(sc, set_plist_2(sc, newstr, s7_apply_function(sc, func, x)), sym));
		}
	    }
	  return(wrong_type_argument(sc, sym, len + 1, car(x), T_CHARACTER));
	}
    }
  newstr = make_empty_string(sc, len, 0);
  str = string_value(newstr);
  for (i = 0, x = args; is_not_null(x); i++, x = cdr(x))
    str[i] = character(car(x));

  return(newstr);
}


/* -------------------------------- string -------------------------------- */
static s7_pointer g_string(s7_scheme *sc, s7_pointer args)
{
  #define H_string "(string chr...) appends all its character arguments into one string"
  #define Q_string s7_make_circular_signature(sc, 1, 2, sc->is_string_symbol, sc->is_char_symbol)

  if (is_null(args))
    return(make_string_with_length(sc, "", 0));
  return(g_string_1(sc, args, sc->string_symbol));
}


/* -------------------------------- list->string -------------------------------- */
#if (!WITH_PURE_S7)
static s7_pointer g_list_to_string(s7_scheme *sc, s7_pointer args)
{
  #define H_list_to_string "(list->string lst) appends all the list's characters into one string; (apply string lst)"
  #define Q_list_to_string s7_make_signature(sc, 2, sc->is_string_symbol, sc->is_proper_list_symbol)

  if (is_null(car(args)))
    return(make_string_with_length(sc, "", 0));

  if (!s7_is_proper_list(sc, car(args)))
    return(method_or_bust_with_type_one_arg(sc, car(args), sc->list_to_string_symbol, args,
				     wrap_string(sc, "a (proper, non-circular) list of characters", 43)));
  return(g_string_1(sc, car(args), sc->list_to_string_symbol));
}
#endif


/* -------------------------------- string->list -------------------------------- */
static s7_pointer s7_string_to_list(s7_scheme *sc, const char *str, s7_int len)
{
  s7_int i;
  s7_pointer result;
  if (len == 0)
    return(sc->nil);
  check_heap_size(sc, len);
  sc->v = sc->nil;
  for (i = len - 1; i >= 0; i--)
    sc->v = cons_unchecked(sc, s7_make_character(sc, ((uint8_t)str[i])), sc->v);
  result = sc->v;
  sc->v = sc->nil;
  return(result);
}

#if (!WITH_PURE_S7)
static s7_pointer g_string_to_list(s7_scheme *sc, s7_pointer args)
{
  #define H_string_to_list "(string->list str start end) returns the elements of the string str in a list; (map values str)"
  #define Q_string_to_list s7_make_circular_signature(sc, 2, 3, sc->is_proper_list_symbol, sc->is_string_symbol, sc->is_integer_symbol)

  s7_int i, start = 0, end;
  s7_pointer p, str;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust_one_arg(sc, str, sc->string_to_list_symbol, args, T_STRING));

  end = string_length(str);
  if (!is_null(cdr(args)))
    {
      p = start_and_end(sc, sc->string_to_list_symbol, args, 2, &start, &end);
      if (p != sc->unused) return(p);
      if (start == end) return(sc->nil);
    }
  else
    {
      if (end == 0) return(sc->nil);
    }
  if ((end - start) > sc->max_list_length)
    return(out_of_range(sc, sc->string_to_list_symbol, small_int(1), car(args), its_too_large_string));

  if ((start == 0) && (end == string_length(str)))
    return(s7_string_to_list(sc, string_value(str), string_length(str)));

  sc->w = sc->nil;
  for (i = end - 1; i >= start; i--)
    sc->w = cons(sc, s7_make_character(sc, ((uint8_t)string_value(str)[i])), sc->w);

  p = sc->w;
  sc->w = sc->nil;
  return(p);
}
#endif


/* -------------------------------- port-closed? -------------------------------- */
static s7_pointer g_is_port_closed(s7_scheme *sc, s7_pointer args)
{
  #define H_is_port_closed "(port-closed? p) returns #t if the port p is closed."
  #define Q_is_port_closed s7_make_signature(sc, 2, sc->is_boolean_symbol, s7_make_signature(sc, 3, sc->is_input_port_symbol, sc->is_output_port_symbol, sc->not_symbol))
  s7_pointer x;

  x = car(args);
  if ((is_input_port(x)) || (is_output_port(x)))
    return(make_boolean(sc, port_is_closed(x)));
  if ((x == sc->output_port) && (x == sc->F))
    return(sc->F);
  return(method_or_bust_with_type_one_arg(sc, x, sc->is_port_closed_symbol, args, wrap_string(sc, "a port", 6)));
}

static bool is_port_closed_b_7p(s7_scheme *sc, s7_pointer x)
{
  if ((is_input_port(x)) || (is_output_port(x)))
    return(port_is_closed(x));
  if ((x == sc->output_port) && (x == sc->F))
    return(false);
  simple_wrong_type_argument_with_type(sc, sc->is_port_closed_symbol, x, wrap_string(sc, "a port", 6));
  return(false);
}


/* -------------------------------- port-position -------------------------------- */

static s7_pointer g_port_position(s7_scheme *sc, s7_pointer args)
{
  #define H_port_position "(port-position input-port) returns the current location (in bytes) in the port's data where the next read will take place."
  #define Q_port_position s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_input_port_symbol)
  s7_pointer port;

  port = car(args);
  if (!(is_input_port(port)))
    return(simple_wrong_type_argument(sc, sc->port_position_symbol, port, T_INPUT_PORT));
  if (port_is_closed(port))
    return(s7_wrong_type_arg_error(sc, "port-position", 0, port, "an open input port"));
  if (is_string_port(port))
    return(make_integer(sc, port_position(port)));
#if (!MS_WINDOWS)
  if (is_file_port(port))
    return(make_integer(sc, ftell(port_file(port))));
#endif
  return(small_int(0));
}

static s7_pointer g_set_port_position(s7_scheme *sc, s7_pointer args)
{
  s7_pointer port, pos;
  s7_int position;

  port = car(args);
  if (!(is_input_port(port)))
    return(s7_wrong_type_arg_error(sc, "set! port-position", 1, port, "an input port"));
  if (port_is_closed(port))
    return(s7_wrong_type_arg_error(sc, "set! port-position", 1, port, "an open input port"));

  pos = cadr(args);
  if (!is_t_integer(pos))
    return(s7_wrong_type_arg_error(sc, "set! port-position", 2, pos, "an integer"));
  position = s7_integer(pos);
  if (position < 0)
    return(out_of_range(sc, sc->port_position_symbol, small_int(2), pos, its_negative_string));
    
  if (is_string_port(port))
    port_position(port) = position;
#if (!MS_WINDOWS)
  else
    {
      if (is_file_port(port))
	{
	  rewind(port_file(port));
	  fseek(port_file(port), (long)position, SEEK_SET);
	}
    }
#endif
  return(pos);
}


/* -------------------------------- port-file -------------------------------- */

static s7_pointer g_port_file(s7_scheme *sc, s7_pointer args)
{
  #define H_port_file "(port-file port) returns the FILE* pointer associated with the port wrapped in a c-pointer object"
  #define Q_port_file s7_make_signature(sc, 2, sc->is_c_pointer_symbol, s7_make_signature(sc, 2, sc->is_input_port_symbol, sc->is_output_port_symbol))
  s7_pointer port;

  port = car(args);
  if ((!is_input_port(port)) &&
      (!is_output_port(port)))
    return(s7_wrong_type_arg_error(sc, "port-file", 0, port, "a port"));
  if (port_is_closed(port))
    return(s7_wrong_type_arg_error(sc, "port-file", 0, port, "an open port"));
#if (!MS_WINDOWS)
  if (is_file_port(port))
    return(s7_make_c_pointer_with_type(sc, (void *)(port_file(port)), s7_make_symbol(sc, "FILE*"), sc->F));
#endif
  return(s7_make_c_pointer(sc, NULL));
}


/* -------------------------------- port-line-number -------------------------------- */
static s7_pointer c_port_line_number(s7_scheme *sc, s7_pointer x)
{
  if ((!(is_input_port(x))) ||
      (port_is_closed(x)))
    return(method_or_bust_with_type_one_arg(sc, x, sc->port_line_number_symbol, list_1(sc, x), an_input_port_string));
  return(make_integer(sc, port_line_number(x)));
}

static s7_pointer g_port_line_number(s7_scheme *sc, s7_pointer args)
{
  #define H_port_line_number "(port-line-number input-file-port) returns the current read line number of port"
  #define Q_port_line_number s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_input_port_symbol)
  return(c_port_line_number(sc, (is_null(args)) ? sc->input_port : car(args)));
}

s7_int s7_port_line_number(s7_scheme *sc, s7_pointer p)
{
  if (!(is_input_port(p)))
    simple_wrong_type_argument(sc, sc->port_line_number_symbol, p, T_INPUT_PORT);
  return(port_line_number(p));
}

static s7_int port_line_number_i_7p(s7_scheme *sc, s7_pointer p)
{
  return(s7_port_line_number(sc, p));
}

static s7_pointer g_set_port_line_number(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p, line;

  if ((is_null(car(args))) ||
      ((is_null(cdr(args))) && (is_t_integer(car(args)))))
    p = sc->input_port;
  else
    {
      p = car(args);
      if (!(is_input_port(p)))
	return(s7_wrong_type_arg_error(sc, "set! port-line-number", 1, p, "an input port"));
    }

  line = (is_null(cdr(args)) ? car(args) : cadr(args));
  if (!is_t_integer(line))
    return(s7_wrong_type_arg_error(sc, "set! port-line-number", 2, line, "an integer"));
  port_line_number(p) = integer(line);
  return(line);
}


/* -------------------------------- port-filename -------------------------------- */
const char *s7_port_filename(s7_scheme *sc, s7_pointer x)
{
  if (((is_input_port(x)) ||
       (is_output_port(x))) &&
      (!port_is_closed(x)))
    return(port_filename(x));
  return(NULL);
}

static s7_pointer c_port_filename(s7_scheme *sc, s7_pointer x)
{
  if (((is_input_port(x)) ||
       (is_output_port(x))) &&
      (!port_is_closed(x)))
    {
      if (port_filename(x))
	return(make_string_with_length(sc, port_filename(x), port_filename_length(x))); /* not wrapper here! */
      return(make_string_with_length(sc, "", 0));
      /* otherwise (eval-string (port-filename)) and (string->symbol (port-filename)) segfault */
    }
  return(method_or_bust_with_type_one_arg(sc, x, sc->port_filename_symbol, list_1(sc, x), an_open_port_string));
}

static s7_pointer g_port_filename(s7_scheme *sc, s7_pointer args)
{
  #define H_port_filename "(port-filename file-port) returns the filename associated with port"
  #define Q_port_filename s7_make_signature(sc, 2, sc->is_string_symbol, s7_make_signature(sc, 2, sc->is_input_port_symbol, sc->is_output_port_symbol))
  return(c_port_filename(sc, (is_null(args)) ? sc->input_port : car(args)));
}


/* -------------------------------- pair-line-number -------------------------------- */
static s7_pointer g_pair_line_number(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  #define H_pair_line_number "(pair-line-number pair) returns the line number at which it read 'pair', or #f if no such number is available"
  #define Q_pair_line_number s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->not_symbol), sc->is_pair_symbol)

  p = car(args);
  if (!is_pair(p))
    return(method_or_bust_one_arg(sc, p, sc->pair_line_number_symbol, set_plist_1(sc, p), T_PAIR));

  if (has_line_number(p))
    return(make_integer(sc, pair_line(p)));
  return(sc->F); /* was 0 21-Mar-17 */
}

static s7_pointer pair_line_number_p_p(s7_scheme *sc, s7_pointer p)
{
  if (!is_pair(p))
    return(method_or_bust_one_arg(sc, p, sc->pair_line_number_symbol, set_plist_1(sc, p), T_PAIR));
  if (has_line_number(p))
    return(make_integer(sc, pair_line(p)));
  return(sc->F);
}


/* -------------------------------- pair-filename -------------------------------- */
static s7_pointer g_pair_filename(s7_scheme *sc, s7_pointer args)
{
  #define H_pair_filename "(pair-filename pair) returns the name of the file containing 'pair'"
  #define Q_pair_filename s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_string_symbol, sc->not_symbol), sc->is_pair_symbol)
  s7_pointer p;
  p = car(args);

  if (!is_pair(p))
    {
      check_method(sc, p, sc->pair_filename_symbol, args);
      return(simple_wrong_type_argument(sc, sc->pair_filename_symbol, p, T_PAIR));
    }
  if (has_line_number(p))
    return(sc->file_names[pair_file(p)]);
  return(sc->F);
}


/* -------------------------------- input-port? -------------------------------- */
bool s7_is_input_port(s7_scheme *sc, s7_pointer p) {return(is_input_port(p));}
static bool is_input_port_b(s7_pointer p) {return(is_input_port(p));}

static s7_pointer g_is_input_port(s7_scheme *sc, s7_pointer args)
{
  #define H_is_input_port "(input-port? p) returns #t if p is an input port"
  #define Q_is_input_port sc->pl_bt
  check_boolean_method(sc, is_input_port, sc->is_input_port_symbol, args);
}


/* -------------------------------- output-port? -------------------------------- */
bool s7_is_output_port(s7_scheme *sc, s7_pointer p) {return(is_output_port(p));}
static bool is_output_port_b(s7_pointer p) {return(is_output_port(p));}

static s7_pointer g_is_output_port(s7_scheme *sc, s7_pointer args)
{
  #define H_is_output_port "(output-port? p) returns #t if p is an output port"
  #define Q_is_output_port sc->pl_bt
  check_boolean_method(sc, is_output_port, sc->is_output_port_symbol, args);
}


/* -------------------------------- current-input-port -------------------------------- */
s7_pointer s7_current_input_port(s7_scheme *sc) {return(sc->input_port);}

static s7_pointer g_current_input_port(s7_scheme *sc, s7_pointer args)
{
  #define H_current_input_port "(current-input-port) returns the current input port"
  #define Q_current_input_port s7_make_signature(sc, 1, sc->is_input_port_symbol)
  return(sc->input_port);
}

static s7_pointer g_set_current_input_port(s7_scheme *sc, s7_pointer args)
{
  #define H_set_current_input_port "(set-current-input-port port) sets the current-input port to port and returns the previous value of the input port"
  #define Q_set_current_input_port s7_make_signature(sc, 2, sc->is_input_port_symbol, sc->is_input_port_symbol)

  s7_pointer old_port, port;
  old_port = sc->input_port;
  port = car(args);
  if ((is_input_port(port)) &&
      (!port_is_closed(port)))
    sc->input_port = port;
  else
    {
      check_method(sc, port, sc->set_current_input_port_symbol, args);
      return(s7_wrong_type_arg_error(sc, "set-current-input-port", 0, port, "an open input port"));
    }
  return(old_port);
}

s7_pointer s7_set_current_input_port(s7_scheme *sc, s7_pointer port)
{
  s7_pointer old_port;
  old_port = sc->input_port;
  sc->input_port = port;
  return(old_port);
}


/* -------------------------------- current-output-port -------------------------------- */
s7_pointer s7_current_output_port(s7_scheme *sc) {return(sc->output_port);}

s7_pointer s7_set_current_output_port(s7_scheme *sc, s7_pointer port)
{
  s7_pointer old_port;
  old_port = sc->output_port;
  sc->output_port = port;
  return(old_port);
}

static s7_pointer g_current_output_port(s7_scheme *sc, s7_pointer args)
{
  #define H_current_output_port "(current-output-port) returns the current output port"
  #define Q_current_output_port s7_make_signature(sc, 1, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))
  return(sc->output_port);
}

static s7_pointer g_set_current_output_port(s7_scheme *sc, s7_pointer args)
{
  #define H_set_current_output_port "(set-current-output-port port) sets the current-output port to port and returns the previous value of the output port"
  #define Q_set_current_output_port s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol), s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))

  s7_pointer old_port, port;
  old_port = sc->output_port;
  port = car(args);
  if (((is_output_port(port)) &&
       (!port_is_closed(port))) ||
      (port == sc->F))
    sc->output_port = port;
  else
    {
      check_method(sc, port, sc->set_current_output_port_symbol, args);
      return(s7_wrong_type_arg_error(sc, "set-current-output-port", 0, port, "an open output port"));
    }
  return(old_port);
}


/* -------------------------------- current-error-port -------------------------------- */
s7_pointer s7_current_error_port(s7_scheme *sc) {return(sc->error_port);}

s7_pointer s7_set_current_error_port(s7_scheme *sc, s7_pointer port)
{
  s7_pointer old_port;
  old_port = sc->error_port;
  sc->error_port = port;
  return(old_port);
}

static s7_pointer g_current_error_port(s7_scheme *sc, s7_pointer args)
{
  #define H_current_error_port "(current-error-port) returns the current error port"
  #define Q_current_error_port s7_make_signature(sc, 1, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))
  return(sc->error_port);
}

static s7_pointer g_set_current_error_port(s7_scheme *sc, s7_pointer args)
{
  #define H_set_current_error_port "(set-current-error-port port) sets the current-error port to port and returns the previous value of the error port"
  #define Q_set_current_error_port s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol), s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))
  s7_pointer old_port, port;

  old_port = sc->error_port;
  port = car(args);
  if (((is_output_port(port)) &&
       (!port_is_closed(port))) ||
      (port == sc->F))
    sc->error_port = port;
  else
    {
      check_method(sc, port, sc->set_current_error_port_symbol, args);
      return(s7_wrong_type_arg_error(sc, "set-current-error-port", 0, port, "an open output port"));
    }
  return(old_port);
}


/* -------------------------------- char-ready? -------------------------------- */
#if (!WITH_PURE_S7)
static s7_pointer g_is_char_ready(s7_scheme *sc, s7_pointer args)
{
  #define H_is_char_ready "(char-ready? (port (current-input-port))) returns #t if a character is ready for input on the given port"
  #define Q_is_char_ready s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_input_port_symbol)
  if (is_not_null(args))
    {
      s7_pointer pt = car(args);
      if (!is_input_port(pt))
	return(method_or_bust_with_type_one_arg(sc, pt, sc->is_char_ready_symbol, args, an_input_port_string));
      if (port_is_closed(pt))
	return(simple_wrong_type_argument_with_type(sc, sc->is_char_ready_symbol, pt, an_open_port_string));

      if (is_function_port(pt))
	return((*(port_input_function(pt)))(sc, S7_IS_CHAR_READY, pt));
      return(make_boolean(sc, is_string_port(pt)));
    }
  return(make_boolean(sc, (is_input_port(sc->input_port)) && (is_string_port(sc->input_port))));
}
#endif

/* -------- ports -------- */
static int32_t closed_port_read_char(s7_scheme *sc, s7_pointer port);
static s7_pointer closed_port_read_line(s7_scheme *sc, s7_pointer port, bool with_eol, bool copied);
static void closed_port_write_char(s7_scheme *sc, uint8_t c, s7_pointer port);
static void closed_port_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer port);
static void closed_port_display(s7_scheme *sc, const char *s, s7_pointer port);

void s7_close_input_port(s7_scheme *sc, s7_pointer p)
{
  if ((is_immutable_port(p)) ||
      ((is_input_port(p)) && (port_is_closed(p))))
    {
#if S7_DEBUGGING
      if (port_needs_free(p))
	fprintf(stderr, "closed input needs free\n");
#endif
      return;
    }
  if (port_filename(p))
    {
      /* for string ports, this is the original input file name */
      liberate(sc, port_filename_block(p));
      port_filename(p) = NULL;
    }

  if (is_string_port(p))
    {
      if (port_needs_unprotect(p))
	{
	  s7_gc_unprotect_at(sc, port_gc_loc(p));
	  port_needs_unprotect(p) = false;
	}
    }
  else
    {
      if (is_file_port(p))
	{
	  if (port_file(p))
	    {
	      fclose(port_file(p));
	      port_file(p) = NULL;
	    }
	}
    }
  if (port_needs_free(p))
    {
      if (port_data(p))
	{
	  liberate(sc, port_data_block(p));
	  port_data_block(p) = NULL;
	  port_data(p) = NULL;
	  port_data_size(p) = 0;
	}
      port_needs_free(p) = false;
    }

  port_read_character(p) = closed_port_read_char;
  port_read_line(p) = closed_port_read_line;
  port_write_character(p) = closed_port_write_char;
  port_write_string(p) = closed_port_write_string;
  port_display(p) = closed_port_display;
  port_set_closed(p, true);
  port_position(p) = 0;
}


/* -------------------------------- close-input-port -------------------------------- */
static s7_pointer g_close_input_port(s7_scheme *sc, s7_pointer args)
{
  s7_pointer pt;
  #define H_close_input_port "(close-input-port port) closes the port"
  #define Q_close_input_port s7_make_signature(sc, 2, sc->is_unspecified_symbol, sc->is_input_port_symbol)

  pt = car(args);
  if (!is_input_port(pt))
    return(method_or_bust_with_type_one_arg(sc, pt, sc->close_input_port_symbol, set_plist_1(sc, pt), an_input_port_string));
  if ((!is_immutable_port(pt)) &&  /* (close-input-port *stdin*) */
      (!is_loader_port(pt)))       /* top-level unmatched (close-input-port (current-input-port)) should not clobber the loader's input port */
    s7_close_input_port(sc, pt);
  return(sc->unspecified);
}


/* -------------------------------- flush-output-port -------------------------------- */
void s7_flush_output_port(s7_scheme *sc, s7_pointer p)
{
  if ((!is_output_port(p)) ||
      (!is_file_port(p)) ||
      (port_is_closed(p)) ||
      (p == sc->F))
    return;

  if (port_file(p))
    {
      if (port_position(p) > 0)
	{
	  if (fwrite((void *)(port_data(p)), 1, port_position(p), port_file(p)) != (size_t)port_position(p))
	    s7_warn(sc, 64, "fwrite trouble in flush-output-port\n");
	  port_position(p) = 0;
	}
      fflush(port_file(p));
    }
}

static s7_pointer g_flush_output_port(s7_scheme *sc, s7_pointer args)
{
  #define H_flush_output_port "(flush-output-port port) flushes the file port (that is, it writes any accumulated output to the output file)"
  #define Q_flush_output_port s7_make_signature(sc, 2, sc->T, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))
  s7_pointer pt;

  if (is_null(args))
    pt = sc->output_port;
  else pt = car(args);

  if (!is_output_port(pt))
    {
      if (pt == sc->F) return(pt);
      return(method_or_bust_with_type_one_arg(sc, pt, sc->flush_output_port_symbol, args, an_output_port_string));
    }
  s7_flush_output_port(sc, pt);
  return(pt);
}


/* -------------------------------- close-output-port -------------------------------- */
static void close_output_port(s7_scheme *sc, s7_pointer p)
{
  if (is_file_port(p))
    {
      if (port_filename(p)) /* only a file output port has a filename(?) */
	{
	  liberate(sc, port_filename_block(p));
	  port_filename(p) = NULL;
	  port_filename_length(p) = 0;
	}
      if (port_file(p))
	{
	  if (port_position(p) > 0)
	    {
	      if (fwrite((void *)(port_data(p)), 1, port_position(p), port_file(p)) != (size_t)port_position(p))
		s7_warn(sc, 64, "fwrite trouble in close-output-port\n");
	    }
	  fflush(port_file(p));
	  fclose(port_file(p));
	  port_file(p) = NULL;
	}
    }
  else
    {
      if (is_string_port(p))
	{
	  if (port_data(p))
	    {
	      port_data(p) = NULL;
	      port_data_size(p) = 0;
	    }
	}
    }
  port_read_character(p) = closed_port_read_char;
  port_read_line(p) = closed_port_read_line;
  port_write_character(p) = closed_port_write_char;
  port_write_string(p) = closed_port_write_string;
  port_display(p) = closed_port_display;
  port_set_closed(p, true);
  port_position(p) = 0;
}

void s7_close_output_port(s7_scheme *sc, s7_pointer p)
{
  if ((is_immutable_port(p)) ||
      ((is_output_port(p)) && (port_is_closed(p))) ||
      (p == sc->F))
    return;
  close_output_port(sc, p);
}

static s7_pointer g_close_output_port(s7_scheme *sc, s7_pointer args)
{
  s7_pointer pt;
  #define H_close_output_port "(close-output-port port) closes the port"
  #define Q_close_output_port s7_make_signature(sc, 2, sc->is_unspecified_symbol, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))

  pt = car(args);
  if (!is_output_port(pt))
    {
      if (pt == sc->F) return(sc->unspecified);
      return(method_or_bust_with_type_one_arg(sc, pt, sc->close_output_port_symbol, set_plist_1(sc, pt), an_output_port_string));
    }
  if (!(is_immutable_port(pt)))
    s7_close_output_port(sc, pt);
  return(sc->unspecified);
}


/* -------- read character functions -------- */

static int32_t file_read_char(s7_scheme *sc, s7_pointer port)
{
  return(fgetc(port_file(port)));
}

static int32_t function_read_char(s7_scheme *sc, s7_pointer port)
{
  return(character((*(port_input_function(port)))(sc, S7_READ_CHAR, port)));
}

static int32_t string_read_char(s7_scheme *sc, s7_pointer port)
{
  if (port_data_size(port) <= port_position(port)) /* port_string_length is 0 if no port string */
    return(EOF);
  return((uint8_t)port_data(port)[port_position(port)++]);
}

static int32_t output_read_char(s7_scheme *sc, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->read_char_symbol, port, an_input_port_string);
  return(0);
}

static int32_t closed_port_read_char(s7_scheme *sc, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->read_char_symbol, port, an_open_port_string);
  return(0);
}


/* -------- read line functions -------- */

static s7_pointer output_read_line(s7_scheme *sc, s7_pointer port, bool with_eol, bool copied)
{
  return(simple_wrong_type_argument_with_type(sc, sc->read_line_symbol, port, an_input_port_string));
}

static s7_pointer closed_port_read_line(s7_scheme *sc, s7_pointer port, bool with_eol, bool copied)
{
  return(simple_wrong_type_argument_with_type(sc, sc->read_line_symbol, port, an_open_port_string));
}

static s7_pointer function_read_line(s7_scheme *sc, s7_pointer port, bool with_eol, bool copied)
{
  return((*(port_input_function(port)))(sc, S7_READ_LINE, port));
}

static s7_pointer stdin_read_line(s7_scheme *sc, s7_pointer port, bool with_eol, bool copied)
{
  if (!sc->read_line_buf)
    {
      sc->read_line_buf_size = 1024;
      sc->read_line_buf = (char *)malloc(sc->read_line_buf_size * sizeof(char));
    }

  if (fgets(sc->read_line_buf, sc->read_line_buf_size, stdin))
    return(s7_make_string(sc, sc->read_line_buf)); /* fgets adds the trailing '\0' */
  return(make_string_with_length(sc, NULL, 0));
}

static s7_pointer file_read_line(s7_scheme *sc, s7_pointer port, bool with_eol, bool copied)
{
  char *buf;
  s7_int read_size, previous_size = 0;

  if (!sc->read_line_buf)
    {
      sc->read_line_buf_size = 1024;
      sc->read_line_buf = (char *)malloc(sc->read_line_buf_size * sizeof(char));
    }

  buf = sc->read_line_buf;
  read_size = sc->read_line_buf_size;

  while (true)
    {
      char *p, *rtn;
      size_t len;

      p = fgets(buf, read_size, port_file(port));
      if (!p)
	return(eof_object);

      rtn = strchr(buf, (int)'\n');
      if (rtn)
	{
	  port_line_number(port)++;
	  return(make_string_with_length(sc, sc->read_line_buf, (with_eol) ? (previous_size + rtn - p + 1) : (previous_size + rtn - p)));
	}
      /* if no newline, then either at eof or need bigger buffer */
      len = strlen(sc->read_line_buf);

      if ((len + 1) < (size_t)sc->read_line_buf_size)
	return(make_string_with_length(sc, sc->read_line_buf, len));

      previous_size = sc->read_line_buf_size;
      sc->read_line_buf_size *= 2;
      sc->read_line_buf = (char *)realloc(sc->read_line_buf, sc->read_line_buf_size * sizeof(char));
      read_size = previous_size;
      previous_size -= 1;
      buf = (char *)(sc->read_line_buf + previous_size);
    }
  return(eof_object);
}

static s7_pointer string_read_line(s7_scheme *sc, s7_pointer port, bool with_eol, bool copied)
{
  s7_int i, port_start;
  uint8_t *port_str, *cur, *start;

  port_start = port_position(port);
  port_str = port_data(port);
  start = (uint8_t *)(port_str + port_start);

  cur = (uint8_t *)strchr((const char *)start, (int)'\n'); /* this can run off the end making valgrind unhappy, but I think it's innocuous */
  if (cur)
      {
	port_line_number(port)++;
	i = cur - port_str;
	port_position(port) = i + 1;
	if (copied)
	  return(make_string_with_length(sc, (const char *)start, ((with_eol) ? i + 1 : i) - port_start));
	return(wrap_string(sc, (char *)start, ((with_eol) ? i + 1 : i) - port_start));
      }
  i = port_data_size(port);
  port_position(port) = i;
  if (i <= port_start)         /* the < part can happen -- if not caught we try to create a string of length - 1 -> segfault */
    return(eof_object);

  if (copied)
    return(make_string_with_length(sc, (const char *)start, i - port_start));
  return(wrap_string(sc, (char *)start, i - port_start));
}


/* -------- write character functions -------- */

static void resize_port_data(s7_scheme *sc, s7_pointer pt, s7_int new_size)
{
  s7_int loc;
  block_t *nb;

  loc = port_data_size(pt);
  if (new_size < loc) return;

  nb = reallocate(sc, port_data_block(pt), new_size);
  port_data_block(pt) = nb;
  port_data(pt) = (uint8_t *)(block_data(nb));
  port_data_size(pt) = new_size;
}

static void string_write_char_resized(s7_scheme *sc, uint8_t c, s7_pointer pt)
{
  /* this division looks repetitive, but it is much faster */
  resize_port_data(sc, pt, port_data_size(pt) * 2);
  port_data(pt)[port_position(pt)++] = c;
}

static void string_write_char(s7_scheme *sc, uint8_t c, s7_pointer pt)
{
  if (port_position(pt) < port_data_size(pt))
    port_data(pt)[port_position(pt)++] = c;
  else string_write_char_resized(sc, c, pt);
}

static void stdout_write_char(s7_scheme *sc, uint8_t c, s7_pointer port)
{
  fputc(c, stdout);
}

static void stderr_write_char(s7_scheme *sc, uint8_t c, s7_pointer port)
{
  fputc(c, stderr);
}

static void function_write_char(s7_scheme *sc, uint8_t c, s7_pointer port)
{
  (*(port_output_function(port)))(sc, c, port);
}

#define PORT_DATA_SIZE 256
static void file_write_char(s7_scheme *sc, uint8_t c, s7_pointer port)
{
  if (port_position(port) == PORT_DATA_SIZE)
    {
      if (fwrite((void *)(port_data(port)), 1, PORT_DATA_SIZE, port_file(port)) != PORT_DATA_SIZE)
	s7_warn(sc, 64, "fwrite trouble during write-char\n");
      port_position(port) = 0;
    }
  port_data(port)[port_position(port)++] = c;
}

static void input_write_char(s7_scheme *sc, uint8_t c, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->write_char_symbol, port, an_output_port_string);
}

static void closed_port_write_char(s7_scheme *sc, uint8_t c, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->write_char_symbol, port, an_open_port_string);
}


/* -------- write string functions -------- */

static void input_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->write_symbol, port, an_output_port_string);
}

static void closed_port_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->write_symbol, port, an_open_port_string);
}

static void input_display(s7_scheme *sc, const char *s, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->display_symbol, port, an_output_port_string);
}

static void closed_port_display(s7_scheme *sc, const char *s, s7_pointer port)
{
  simple_wrong_type_argument_with_type(sc, sc->display_symbol, port, an_open_port_string);
}

static void stdout_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer port)
{
  if (str[len] == '\0')
    fputs(str, stdout);
  else
    {
      s7_int i;
      for (i = 0; i < len; i++)
	fputc(str[i], stdout);
    }
}

static void stderr_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer port)
{
  if (str[len] == '\0')
    fputs(str, stderr);
  else
    {
      s7_int i;
      for (i = 0; i < len; i++)
	fputc(str[i], stderr);
    }
}

static void string_write_string_resized(s7_scheme *sc, const char *str, s7_int len, s7_pointer pt)
{
  s7_int new_len;  /* len is known to be non-zero, str may not be 0-terminated */
  new_len = port_position(pt) + len;
  resize_port_data(sc, pt, new_len * 2);
  memcpy((void *)(port_data(pt) + port_position(pt)), (void *)str, len);
  port_position(pt) = new_len;
}

static void string_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer pt)
{
#if S7_DEBUGGING
  if (len == 0) {fprintf(stderr, "string_write_string len == 0\n"); abort();}
#endif
  if (port_position(pt) + len < port_data_size(pt))
    {
      memcpy((void *)(port_data(pt) + port_position(pt)), (void *)str, len);
      /* memcpy is much faster than the equivalent while loop, and faster than using the 4-bytes-at-a-time shuffle */
      port_position(pt) += len;
    }
  else string_write_string_resized(sc, str, len, pt);
}

static void file_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer pt)
{
  s7_int new_len;
  new_len = port_position(pt) + len;
  if (new_len >= PORT_DATA_SIZE)
    {
      if (port_position(pt) > 0)
	{
	  if (fwrite((void *)(port_data(pt)), 1, port_position(pt), port_file(pt)) != (size_t)port_position(pt))
	    s7_warn(sc, 64, "fwrite trouble in write-string\n");
	  port_position(pt) = 0;
	}
      if (fwrite((void *)str, 1, len, port_file(pt)) != (size_t)len)
	s7_warn(sc, 64, "fwrite trouble in write-string\n");
    }
  else
    {
      memcpy((void *)(port_data(pt) + port_position(pt)), (void *)str, len);
      port_position(pt) = new_len;
    }
}

static void string_display(s7_scheme *sc, const char *s, s7_pointer port)
{
  if (s)
    string_write_string(sc, s, safe_strlen(s), port);
}

static void file_display(s7_scheme *sc, const char *s, s7_pointer port)
{
  if (s)
    {
      if (port_position(port) > 0)
	{
	  if (fwrite((void *)(port_data(port)), 1, port_position(port), port_file(port)) != (size_t)port_position(port))
	    s7_warn(sc, 64, "fwrite trouble in display\n");
	  port_position(port) = 0;
	}
      if (fputs(s, port_file(port)) == EOF)
	s7_warn(sc, 64, "write to %s: %s\n", port_filename(port), strerror(errno));
    }
}

static void function_display(s7_scheme *sc, const char *s, s7_pointer port)
{
  if (s)
    {
      for (; *s; s++)
	(*(port_output_function(port)))(sc, *s, port);
    }
}

static void function_write_string(s7_scheme *sc, const char *str, s7_int len, s7_pointer pt)
{
  s7_int i;
  for (i = 0; i < len; i++)
    (*(port_output_function(pt)))(sc, str[i], pt);
}

static void stdout_display(s7_scheme *sc, const char *s, s7_pointer port)
{
  if (s) fputs(s, stdout);
}

static void stderr_display(s7_scheme *sc, const char *s, s7_pointer port)
{
  if (s) fputs(s, stderr);
}


/* -------------------------------- write-string -------------------------------- */
static s7_pointer g_write_string(s7_scheme *sc, s7_pointer args)
{
  #define H_write_string "(write-string str port start end) writes str to port."
  #define Q_write_string s7_make_circular_signature(sc, 3, 4, sc->is_string_symbol, sc->is_string_symbol, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol), sc->is_integer_symbol)
  s7_pointer str, port;
  s7_int start = 0, end;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->write_string_symbol, args, T_STRING, 1));

  end = string_length(str);
  if (!is_null(cdr(args)))
    {
      s7_pointer inds;
      port = cadr(args);
      inds = cddr(args);
      if (!is_null(inds))
	{
	  s7_pointer p;
	  p = start_and_end(sc, sc->write_string_symbol, args, 3, &start, &end);
	  if (p != sc->unused) return(p);
	}
    }
  else port = sc->output_port;
  if (!is_output_port(port))
    {
      if (port == sc->F)
	{
	  s7_int len;
	  if ((start == 0) && (end == string_length(str)))
	    return(str);
	  len = (s7_int)(end - start);
	  return(make_string_with_length(sc, (char *)(string_value(str) + start), len));
	}
      return(method_or_bust_with_type(sc, port, sc->write_string_symbol, args, an_output_port_string, 2));
    }
  if (start == end)
    return(str);
  port_write_string(port)(sc, (char *)(string_value(str) + start), (end - start), port);
  return(str);
}


/* -------- skip to newline readers -------- */

static token_t file_read_semicolon(s7_scheme *sc, s7_pointer pt)
{
  int32_t c;
  do (c = fgetc(port_file(pt))); while ((c != '\n') && (c != EOF));
  port_line_number(pt)++;
  if (c == EOF)
    return(TOKEN_EOF);
  return(token(sc));
}

static token_t string_read_semicolon(s7_scheme *sc, s7_pointer pt)
{
  const char *orig_str, *str;
  str = (const char *)(port_data(pt) + port_position(pt));
  orig_str = strchr(str, (int)'\n');
  if (!orig_str)
    {
      port_position(pt) = port_data_size(pt);
      return(TOKEN_EOF);
    }
  port_position(pt) += (orig_str - str + 1); /* + 1 because strchr leaves orig_str pointing at the newline */
  port_line_number(pt)++;
  return(token(sc));
}


/* -------- white space readers -------- */

static int32_t file_read_white_space(s7_scheme *sc, s7_pointer port)
{
  int32_t c;
  while (is_white_space(c = fgetc(port_file(port))))
    if (c == '\n')
      port_line_number(port)++;
  return(c);
}

static int32_t terminated_string_read_white_space(s7_scheme *sc, s7_pointer pt)
{
  const uint8_t *str;
  uint8_t c;
  /* here we know we have null termination and white_space[#\null] is false. */

  str = (const uint8_t *)(port_data(pt) + port_position(pt));

  while (white_space[c = *str++]) /* (let ((a 1)) a) -- 255 is not -1 = EOF */
    if (c == '\n')
      port_line_number(pt)++;
  if (c)
    port_position(pt) = str - port_data(pt);
  else port_position(pt) = port_data_size(pt);
  return((int32_t)c);
}


/* name (alphanumeric token) readers */

static void resize_strbuf(s7_scheme *sc, s7_int needed_size)
{
  s7_int i, old_size;
  old_size = sc->strbuf_size;
  while (sc->strbuf_size <= needed_size) sc->strbuf_size *= 2;
  sc->strbuf = (char *)realloc(sc->strbuf, sc->strbuf_size * sizeof(char));
  for (i = old_size; i < sc->strbuf_size; i++) sc->strbuf[i] = '\0';
}

#define BASE_10 10

static s7_pointer file_read_name_or_sharp(s7_scheme *sc, s7_pointer pt, bool atom_case)
{
  int32_t c;
  s7_int i = 1;
  /* sc->strbuf[0] has the first char of the string we're reading */

  do {
    c = fgetc(port_file(pt)); /* might return EOF */
    if (c == '\n')
      port_line_number(pt)++;

    sc->strbuf[i++] = (unsigned char)c;
    if (i >= sc->strbuf_size)
      resize_strbuf(sc, i);
  } while ((c != EOF) && (char_ok_in_a_name[c]));

  if ((i == 2) &&
      (sc->strbuf[0] == '\\'))
    sc->strbuf[2] = '\0';
  else
    {
      if (c != EOF)
	{
	  if (c == '\n')
	    port_line_number(pt)--;
	  ungetc(c, port_file(pt));
	}
      sc->strbuf[i - 1] = '\0';
    }

  if (atom_case)
    return(make_atom(sc, sc->strbuf, BASE_10, SYMBOL_OK, WITH_OVERFLOW_ERROR));

  return(make_sharp_constant(sc, sc->strbuf, WITH_OVERFLOW_ERROR));
}

static s7_pointer file_read_name(s7_scheme *sc, s7_pointer pt)
{
  return(file_read_name_or_sharp(sc, pt, true));
}

static s7_pointer file_read_sharp(s7_scheme *sc, s7_pointer pt)
{
  return(file_read_name_or_sharp(sc, pt, false));
}

static s7_pointer string_read_name_no_free(s7_scheme *sc, s7_pointer pt)
{
  /* sc->strbuf[0] has the first char of the string we're reading */
  s7_pointer result;
  char *str;

  str = (char *)(port_data(pt) + port_position(pt));

  if (char_ok_in_a_name[(uint8_t)*str])
    {
      s7_int k;
      char *orig_str;

      orig_str = (char *)(str - 1);
      str++;
      while (char_ok_in_a_name[(uint8_t)(*str)]) {str++;}
      k = str - orig_str;
      if (*str != 0)
	port_position(pt) += (k - 1);
      else port_position(pt) = port_data_size(pt);

      /* this is equivalent to:
       *    str = strpbrk(str, "(); \"\t\r\n");
       *    if (!str)
       *      {
       *        k = strlen(orig_str);
       *        str = (char *)(orig_str + k);
       *      }
       *    else k = str - orig_str;
       * but slightly faster.
       */

      if (!number_table[(uint8_t)(*orig_str)])
	return(make_symbol_with_length(sc, orig_str, k));

      /* eval_c_string string is a constant so we can't set and unset the token's end char */
      if ((k + 1) >= sc->strbuf_size)
	resize_strbuf(sc, k + 1);

      memcpy((void *)(sc->strbuf), (void *)orig_str, k);
      sc->strbuf[k] = '\0';
      return(make_atom(sc, sc->strbuf, BASE_10, SYMBOL_OK, WITH_OVERFLOW_ERROR));
    }

  result = sc->singletons[(uint8_t)(sc->strbuf[0])];
  if (!result)
    {
      sc->strbuf[1] = '\0';
      result = make_symbol_with_length(sc, sc->strbuf, 1);
      sc->singletons[(uint8_t)(sc->strbuf[0])] = result;
    }
  return(result);
}

static s7_pointer string_read_sharp(s7_scheme *sc, s7_pointer pt)
{
  /* sc->strbuf[0] has the first char of the string we're reading.
   *   since a *#readers* function might want to get further input, we can't mess with the input even when it is otherwise safe
   */
  char *str;
  str = (char *)(port_data(pt) + port_position(pt));

  if (char_ok_in_a_name[(uint8_t)*str])
    {
      s7_int k;
      char * orig_str;
      orig_str = (char *)(str - 1);
      str++;
      while (char_ok_in_a_name[(uint8_t)(*str)]) {str++;}
      k = str - orig_str;
      if (*str != 0)
	port_position(pt) += (k - 1);
      else port_position(pt) += k;

      if ((k + 1) >= sc->strbuf_size)
	resize_strbuf(sc, k + 1);

      memcpy((void *)(sc->strbuf), (void *)orig_str, k);
      sc->strbuf[k] = '\0';
      return(make_sharp_constant(sc, sc->strbuf, WITH_OVERFLOW_ERROR));
    }
  if (sc->strbuf[0] == 'f')
    return(sc->F);
  if (sc->strbuf[0] == 't')
    return(sc->T);
  if (sc->strbuf[0] == '\\')
    {
      /* must be from #\( and friends -- a character that happens to be not ok-in-a-name */
      sc->strbuf[1] = str[0];
      sc->strbuf[2] = '\0';
      port_position(pt)++;
    }
  else sc->strbuf[1] = '\0';
  return(make_sharp_constant(sc, sc->strbuf, WITH_OVERFLOW_ERROR));
}

static s7_pointer string_read_name(s7_scheme *sc, s7_pointer pt)
{
  /* port_string was allocated (and read from a file) so we can mess with it directly */
  s7_pointer result;
  char *str;

  str = (char *)(port_data(pt) + port_position(pt));
  if (char_ok_in_a_name[(uint8_t)*str])
    {
      s7_int k;
      char endc;
      char *orig_str;
      orig_str = (char *)(str - 1);
      str++;
      while (char_ok_in_a_name[(uint8_t)(*str)]) {str++;}
      k = str - orig_str;
      if (*str != 0)
	port_position(pt) += (k - 1);
      else port_position(pt) = port_data_size(pt);

      if (!number_table[(uint8_t)(*orig_str)])
	return(make_symbol_with_length(sc, orig_str, k));

      endc = (*str);
      (*str) = '\0';
      result = make_atom(sc, orig_str, BASE_10, SYMBOL_OK, WITH_OVERFLOW_ERROR);
      (*str) = endc;
      return(result);
    }
  result = sc->singletons[(uint8_t)(sc->strbuf[0])];
  if (!result)
    {
      sc->strbuf[1] = '\0';
      result = make_symbol_with_length(sc, sc->strbuf, 1);
      sc->singletons[(uint8_t)(sc->strbuf[0])] = result;
    }
  return(result);
}

static inline void port_set_filename(s7_scheme *sc, s7_pointer p, const char *name, size_t len)
{
  block_t *b;
  b = mallocate(sc, len + 1);
  port_filename_block(p) = b;
  port_filename(p) = (char *)block_data(b);
  memcpy((void *)block_data(b), (void *)name, len);
  port_filename(p)[len] = '\0';
}

static block_t *mallocate_port(s7_scheme *sc)
{
  #define PORT_LIST 8 /* sizeof(port_t): 160 */
  block_t *p;
  p = sc->block_lists[PORT_LIST];
  if (p)
    {
      sc->block_lists[PORT_LIST] = (block_t *)block_next(p);
      block_next(p) = NULL;
    }
  else
    { /* this is mallocate without the index calc */
      p = mallocate_block(sc);
      block_data(p) = (void *)alloc_permanent_string(sc, (size_t)(1 << PORT_LIST));
      block_set_index(p, PORT_LIST);
    }
  block_set_size(p, sizeof(port_t));
  return(p);
}

static s7_pointer read_file(s7_scheme *sc, FILE *fp, const char *name, s7_int max_size, const char *caller)
{
  s7_pointer port;
#if (!MS_WINDOWS)
  s7_int size;
#endif
  s7_int port_loc;
  block_t *b;

  new_cell(sc, port, T_INPUT_PORT);
  port_loc = s7_gc_protect_1(sc, port);
  b = mallocate_port(sc);
  port_block(port) = b;
  port_port(port) = (port_t *)block_data(b);
  port_set_closed(port, false);
  port_original_input_string(port) = sc->nil;
  port_write_character(port) = input_write_char;
  port_write_string(port) = input_write_string;

  /* if we're constantly opening files, and each open saves the file name in permanent memory, we gradually core-up. */
  port_filename_length(port) = safe_strlen(name);
  port_set_filename(sc, port, name, port_filename_length(port));
  port_line_number(port) = 1;  /* first line is numbered 1 */
  port_file_number(port) = 0;
  add_input_port(sc, port);

#if (!MS_WINDOWS)
  /* this doesn't work in MS C */
  fseek(fp, 0, SEEK_END);
  size = ftell(fp);
  rewind(fp);

  /* pseudo files (under /proc for example) have size=0, but we can read them, so don't assume a 0 length file is empty */

  if ((size > 0) &&                          /* if (size != 0) we get (open-input-file "/dev/tty") -> (open "/dev/tty") read 0 bytes of an expected -1? */
      ((max_size < 0) || (size < max_size))) /* load uses max_size = -1 */
    {
      size_t bytes;
      block_t *block;
      uint8_t *content;

      block = mallocate(sc, size + 2);
      content = (uint8_t *)(block_data(block));
      bytes = fread(content, sizeof(uint8_t), size, fp);
      if (bytes != (size_t)size)
	{
	  if (sc->output_port != sc->F)
	    {
	      char tmp[256];
	      int32_t len;
	      len = snprintf(tmp, 256, "(%s \"%s\") read %ld bytes of an expected %" print_s7_int "?", caller, name, (long)bytes, size);
	      port_write_string(sc->output_port)(sc, tmp, len, sc->output_port);
	    }
	  size = bytes;
	}
      content[size] = '\0';
      content[size + 1] = '\0';
      fclose(fp);

      port_file(port) = NULL; /* make valgrind happy */
      port_type(port) = STRING_PORT;
      port_data(port) = content;
      port_data_block(port) = block;
      port_data_size(port) = size;
      port_position(port) = 0;
      port_needs_free(port) = true;
      port_needs_unprotect(port) = false;
      port_read_character(port) = string_read_char;
      port_read_line(port) = string_read_line;
      port_display(port) = input_display;
      port_read_semicolon(port) = string_read_semicolon;
      port_read_white_space(port) = terminated_string_read_white_space;
      port_read_name(port) = string_read_name;
      port_read_sharp(port) = string_read_sharp;
    }
  else
    {
      port_file(port) = fp;
      port_type(port) = FILE_PORT;
      port_data(port) = NULL;
      port_data_block(port) = NULL;
      port_data_size(port) = 0;
      port_position(port) = 0;
      port_needs_free(port) = false;
      port_read_character(port) = file_read_char;
      port_read_line(port) = file_read_line;
      port_display(port) = input_display;
      port_read_semicolon(port) = file_read_semicolon;
      port_read_white_space(port) = file_read_white_space;
      port_read_name(port) = file_read_name;
      port_read_sharp(port) = file_read_sharp; /* was string_read_sharp?? */
    }
#else
  /* _stat64 is no better than the fseek/ftell route, and
   *    GetFileSizeEx and friends requires Windows.h which makes hash of everything else.
   *    fread until done takes too long on big files, so use a file port
   */
  port_file(port) = fp;
  port_type(port) = FILE_PORT;
  port_needs_free(port) = false;
  port_data(port) = NULL;
  port_data_block(port) = NULL;
  port_data_size(port) = 0;
  port_position(port) = 0;
  port_read_character(port) = file_read_char;
  port_read_line(port) = file_read_line;
  port_display(port) = input_display;
  port_read_semicolon(port) = file_read_semicolon;
  port_read_white_space(port) = file_read_white_space;
  port_read_name(port) = file_read_name;
  port_read_sharp(port) = file_read_sharp;
#endif

  s7_gc_unprotect_at(sc, port_loc);
  return(port);
}


/* -------------------------------- open-input-file -------------------------------- */
static int32_t remember_file_name(s7_scheme *sc, const char *file)
{
  int32_t i;

  for (i = 0; i <= sc->file_names_top; i++)
    if (safe_strcmp(file, string_value(sc->file_names[i])))
      return(i);

  sc->file_names_top++;
  if (sc->file_names_top >= sc->file_names_size)
    {
      int32_t old_size = 0;
      if (sc->file_names_size == 0)
	{
	  sc->file_names_size = INITIAL_FILE_NAMES_SIZE;
	  sc->file_names = (s7_pointer *)calloc(sc->file_names_size, sizeof(s7_pointer));
	}
      else
	{
	  old_size = sc->file_names_size;
	  sc->file_names_size *= 2;
	  sc->file_names = (s7_pointer *)realloc(sc->file_names, sc->file_names_size * sizeof(s7_pointer));
	}
      for (i = old_size; i < sc->file_names_size; i++)
	sc->file_names[i] = sc->F;
    }
  sc->file_names[sc->file_names_top] = s7_make_permanent_string(sc, file);
  return(sc->file_names_top);
}

static s7_pointer make_input_file(s7_scheme *sc, const char *name, FILE *fp)
{
  #define MAX_SIZE_FOR_STRING_PORT 5000000
  return(read_file(sc, fp, name, MAX_SIZE_FOR_STRING_PORT, "open"));
}

#if (!MS_WINDOWS)
#include <sys/stat.h>
#endif

static bool is_directory(const char *filename)
{
#if (!MS_WINDOWS)
  #ifdef S_ISDIR
    struct stat statbuf;
    return((stat(filename, &statbuf) >= 0) &&
	   (S_ISDIR(statbuf.st_mode)));
  #endif
#endif
  return(false);
}

static s7_pointer open_input_file_1(s7_scheme *sc, const char *name, const char *mode, const char *caller)
{
  FILE *fp;
  /* see if we can open this file before allocating a port */

  if (is_directory(name))
    return(file_error(sc, caller, "file is a directory:", name));

  errno = 0;
  fp = fopen(name, mode);
  if (!fp)
    {
#if (!MS_WINDOWS)
      if (errno == EINVAL)
	return(file_error(sc, caller, "invalid mode", mode));
  #if WITH_GCC
      /* catch one special case, "~/..." */
      if ((name[0] == '~') &&
	  (name[1] == '/'))
	{
	  char *home;
	  home = getenv("HOME");
	  if (home)
	    {
	      block_t *b;
	      char *filename;
	      s7_int len;
	      len = safe_strlen(name) + safe_strlen(home) + 1;
	      b = mallocate(sc, len);
	      filename = (char *)block_data(b);
	      filename[0] = '\0';
	      catstrs(filename, len, home, (char *)(name + 1), NULL);
	      fp = fopen(filename, "r");
	      liberate(sc, b);
	      if (fp)
		return(make_input_file(sc, name, fp));
	    }
	}
  #endif
#endif
      return(file_error(sc, caller, strerror(errno), name));
    }
  return(make_input_file(sc, name, fp));
}

s7_pointer s7_open_input_file(s7_scheme *sc, const char *name, const char *mode)
{
  return(open_input_file_1(sc, name, mode, "open-input-file"));
}

static s7_pointer g_open_input_file(s7_scheme *sc, s7_pointer args)
{
  #define H_open_input_file "(open-input-file filename (mode \"r\")) opens filename for reading"
  #define Q_open_input_file s7_make_signature(sc, 3, sc->is_input_port_symbol, sc->is_string_symbol, sc->is_string_symbol)
  s7_pointer name = car(args);
  /* open-input-file can create a new output file if the file to be opened does not exist, and the "a" mode is given */

  if (!is_string(name))
    return(method_or_bust(sc, name, sc->open_input_file_symbol, args, T_STRING, 1));

  if (is_pair(cdr(args)))
    {
      s7_pointer mode;
      mode = cadr(args);
      if (!is_string(mode))
	return(method_or_bust_with_type(sc, mode, sc->open_input_file_symbol, args,
					wrap_string(sc, "a string (a mode such as \"r\")", 29), 2));
      /* since scheme allows embedded nulls, dumb stuff is accepted here: (open-input-file file "a\x00b") -- should this be an error? */
      return(open_input_file_1(sc, string_value(name), string_value(mode), "open-input-file"));
    }
  return(open_input_file_1(sc, string_value(name), "r", "open-input-file"));
}

#if S7_DEBUGGING
static s7_int permanent_ports = 0;
#endif

static void make_standard_ports(s7_scheme *sc)
{
  s7_pointer x;

  /* standard output */
  x = alloc_pointer(sc);
#if S7_DEBUGGING
  permanent_ports += 3;
#endif
  set_type(x, T_OUTPUT_PORT | T_IMMUTABLE | T_UNHEAP);
  port_port(x) = (port_t *)calloc(1, sizeof(port_t));
  port_type(x) = FILE_PORT;
  port_data(x) = NULL;
  port_data_block(x) = NULL;
  port_set_closed(x, false);
  port_filename_length(x) = 8;
  port_set_filename(sc, x, "*stdout*", 8);
  port_file_number(x) = remember_file_name(sc, port_filename(x)); /* these numbers need to be correct for the evaluator (__FUNC__ data) */
  port_line_number(x) = 0;
  port_file(x) = stdout;
  port_needs_free(x) = false;
  port_read_character(x) = output_read_char;
  port_read_line(x) = output_read_line;
  port_display(x) = stdout_display;
  port_write_character(x) = stdout_write_char;
  port_write_string(x) = stdout_write_string;
  sc->standard_output = x;

  /* standard error */
  x = alloc_pointer(sc);
  set_type(x, T_OUTPUT_PORT | T_IMMUTABLE | T_UNHEAP);
  port_port(x) = (port_t *)calloc(1, sizeof(port_t));
  port_type(x) = FILE_PORT;
  port_data(x) = NULL;
  port_data_block(x) = NULL;
  port_set_closed(x, false);
  port_filename_length(x) = 8;
  port_set_filename(sc, x, "*stderr*", 8);
  port_file_number(x) = remember_file_name(sc, port_filename(x));
  port_line_number(x) = 0;
  port_file(x) = stderr;
  port_needs_free(x) = false;
  port_read_character(x) = output_read_char;
  port_read_line(x) = output_read_line;
  port_display(x) = stderr_display;
  port_write_character(x) = stderr_write_char;
  port_write_string(x) = stderr_write_string;
  sc->standard_error = x;

  /* standard input */
  x = alloc_pointer(sc);
  set_type(x, T_INPUT_PORT | T_IMMUTABLE | T_UNHEAP);
  port_port(x) = (port_t *)calloc(1, sizeof(port_t));
  port_type(x) = FILE_PORT;
  port_set_closed(x, false);
  port_original_input_string(x) = sc->nil;
  port_filename_length(x) = 7;
  port_set_filename(sc, x, "*stdin*", 7);
  port_file_number(x) = remember_file_name(sc, port_filename(x));
  port_line_number(x) = 0;
  port_file(x) = stdin;
  port_data_block(x) = NULL;
  port_needs_free(x) = false;
  port_read_character(x) = file_read_char;
  port_read_line(x) = stdin_read_line;
  port_display(x) = input_display;
  port_read_semicolon(x) = file_read_semicolon;
  port_read_white_space(x) = file_read_white_space;
  port_read_name(x) = file_read_name;
  port_read_sharp(x) = file_read_sharp;
  port_write_character(x) = input_write_char;
  port_write_string(x) = input_write_string;
  sc->standard_input = x;

  s7_define_constant_with_documentation(sc, "*stdin*", sc->standard_input, "*stdin* is the built-in input port, C's stdin");
  s7_define_constant_with_documentation(sc, "*stdout*", sc->standard_output, "*stdout* is the built-in buffered output port, C's stdout");
  s7_define_constant_with_documentation(sc, "*stderr*", sc->standard_error, "*stderr* is the built-in unbuffered output port, C's stderr");

  sc->input_port = sc->standard_input;
  sc->output_port = sc->standard_output;
  sc->error_port = sc->standard_error;
  sc->current_file = NULL;
  sc->current_line = -1;
}


/* -------------------------------- open-output-file -------------------------------- */
s7_pointer s7_open_output_file(s7_scheme *sc, const char *name, const char *mode)
{
  FILE *fp;
  s7_pointer x;
  block_t *block, *b;
  /* see if we can open this file before allocating a port */

  errno = 0;
  fp = fopen(name, mode);
  if (!fp)
    {
#if (!MS_WINDOWS)
      if (errno == EINVAL)
	return(file_error(sc, "open-output-file", "invalid mode", mode));
#endif
      return(file_error(sc, "open-output-file", strerror(errno), name));
    }

  new_cell(sc, x, T_OUTPUT_PORT);
  b = mallocate_port(sc);
  port_block(x) = b;
  port_port(x) = (port_t *)block_data(b);
  port_type(x) = FILE_PORT;
  port_set_closed(x, false);
  port_filename_length(x) = safe_strlen(name);
  port_set_filename(sc, x, name, port_filename_length(x));
  port_line_number(x) = 1;
  port_file_number(x) = 0;
  port_file(x) = fp;
  port_needs_free(x) = true;  /* hmm -- I think these are freed via s7_close_output_port -> close_output_port */
  port_read_character(x) = output_read_char;
  port_read_line(x) = output_read_line;
  port_display(x) = file_display;
  port_write_character(x) = file_write_char;
  port_write_string(x) = file_write_string;
  port_position(x) = 0;
  port_data_size(x) = PORT_DATA_SIZE;
  block = mallocate(sc, PORT_DATA_SIZE);
  port_data_block(x) = block;
  port_data(x) = (uint8_t *)(block_data(block));
  add_output_port(sc, x);
  return(x);
}

static s7_pointer g_open_output_file(s7_scheme *sc, s7_pointer args)
{
  #define H_open_output_file "(open-output-file filename (mode \"w\")) opens filename for writing"
  #define Q_open_output_file s7_make_signature(sc, 3, sc->is_output_port_symbol, sc->is_string_symbol, sc->is_string_symbol)
  s7_pointer name = car(args);

  if (!is_string(name))
    return(method_or_bust(sc, name, sc->open_output_file_symbol, args, T_STRING, 1));

  if (is_pair(cdr(args)))
    {
      if (!is_string(cadr(args)))
	return(method_or_bust_with_type(sc, cadr(args), sc->open_output_file_symbol, args,
				 wrap_string(sc, "a string (a mode such as \"w\")", 29), 2));
      return(s7_open_output_file(sc, string_value(name), string_value(cadr(args))));
    }
  return(s7_open_output_file(sc, string_value(name), "w"));
}


/* -------------------------------- open-input-string -------------------------------- */
static s7_pointer open_input_string(s7_scheme *sc, const char *input_string, s7_int len)
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_INPUT_PORT);
  b = mallocate_port(sc);
  port_block(x) = b;
  port_port(x) = (port_t *)block_data(b);
  port_type(x) = STRING_PORT;
  port_set_closed(x, false);
  port_original_input_string(x) = sc->nil;
  port_data(x) = (uint8_t *)input_string;
  port_data_block(x) = NULL;
  port_data_size(x) = len;
  port_position(x) = 0;
  port_filename_block(x) = NULL;
  port_filename_length(x) = 0;
  port_filename(x) = NULL;
  port_file_number(x) = 0;
  port_line_number(x) = 0;
  port_needs_free(x) = false;
  port_needs_unprotect(x) = false;
  port_read_character(x) = string_read_char;
  port_read_line(x) = string_read_line;
  port_display(x) = input_display;
  port_read_semicolon(x) = string_read_semicolon;
#if S7_DEBUGGING
  if (input_string[len] != '\0')
    {
      fprintf(stderr, "read_white_space string is not terminated: %s", input_string);
      abort();
    }
#endif
  port_read_white_space(x) = terminated_string_read_white_space;
  port_read_name(x) = string_read_name_no_free;
  port_read_sharp(x) = string_read_sharp;
  port_write_character(x) = input_write_char;
  port_write_string(x) = input_write_string;
  add_input_port(sc, x);
  return(x);
}

static s7_pointer open_and_protect_input_string(s7_scheme *sc, s7_pointer str)
{
  s7_pointer p;
  p = open_input_string(sc, string_value(str), string_length(str));
  port_gc_loc(p) = s7_gc_protect_1(sc, str);
  port_needs_unprotect(p) = true;
  return(p);
}

s7_pointer s7_open_input_string(s7_scheme *sc, const char *input_string)
{
  return(open_input_string(sc, input_string, safe_strlen(input_string)));
}


/* -------------------------------- open-output-string -------------------------------- */
static s7_pointer g_open_input_string(s7_scheme *sc, s7_pointer args)
{
  #define H_open_input_string "(open-input-string str) opens an input port reading str"
  #define Q_open_input_string s7_make_signature(sc, 2, sc->is_input_port_symbol, sc->is_string_symbol)
  s7_pointer input_string, port;

  input_string = car(args);
  if (!is_string(input_string))
    return(method_or_bust_one_arg(sc, input_string, sc->open_input_string_symbol, args, T_STRING));
  port = open_and_protect_input_string(sc, input_string);
  return(port);
}

#define FORMAT_PORT_LENGTH 128
/* the large majority (> 99% in my tests) of the output strings have less than 128 chars when the port is finally closed
 *   256 is slightly slower (the calloc time below dominates the realloc time in string_write_string)
 *   64 is much slower (realloc dominates)
 */

static s7_pointer open_output_string(s7_scheme *sc, s7_int len)
{
  s7_pointer x;
  block_t *block, *b;
  new_cell(sc, x, T_OUTPUT_PORT);
  b = mallocate_port(sc);
  port_block(x) = b;
  port_port(x) = (port_t *)block_data(b);
  port_type(x) = STRING_PORT;
  port_set_closed(x, false);
  port_data_size(x) = len;
  block = mallocate(sc, len);
  port_data_block(x) = block;
  port_data(x) = (uint8_t *)(block_data(block));
  port_data(x)[0] = '\0';        /* in case s7_get_output_string before any output */
  port_position(x) = 0;
  port_needs_free(x) = true;
  port_filename_block(x) = NULL;
  port_filename_length(x) = 0;   /* protect against (port-filename (open-output-string)) */
  port_filename(x) = NULL;
  port_read_character(x) = output_read_char;
  port_read_line(x) = output_read_line;
  port_display(x) = string_display;
  port_write_character(x) = string_write_char;
  port_write_string(x) = string_write_string;
  add_output_port(sc, x);
  return(x);
}

s7_pointer s7_open_output_string(s7_scheme *sc) {return(open_output_string(sc, sc->initial_string_port_length));}

static s7_pointer open_output_string_p(s7_scheme *sc) {return(s7_open_output_string(sc));}

static s7_pointer g_open_output_string(s7_scheme *sc, s7_pointer args)
{
  #define H_open_output_string "(open-output-string) opens an output string port"
  #define Q_open_output_string s7_make_signature(sc, 1, sc->is_output_port_symbol)
  return(s7_open_output_string(sc));
}


/* -------------------------------- get-output-string -------------------------------- */
const char *s7_get_output_string(s7_scheme *sc, s7_pointer p)
{
  port_data(p)[port_position(p)] = '\0';
  return((const char *)port_data(p));
}

static s7_pointer g_get_output_string(s7_scheme *sc, s7_pointer args)
{
  #define H_get_output_string "(get-output-string port clear-port) returns the output accumulated in port.  \
If the optional 'clear-port' is #t, the current string is flushed."
  #define Q_get_output_string s7_make_signature(sc, 3, sc->is_string_symbol, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol), sc->is_boolean_symbol)

  s7_pointer p;
  bool clear_port = false;

  if (is_pair(cdr(args)))
    {
      p = cadr(args);
      if (!s7_is_boolean(p))
	return(wrong_type_argument(sc, sc->get_output_string_symbol, 2, p, T_BOOLEAN));
      clear_port = (p == sc->T);
    }
  p = car(args);
  if ((!is_output_port(p)) ||
      (!is_string_port(p)))
    {
      if (p == sc->F) return(make_empty_string(sc, 0, 0));
      return(method_or_bust_with_type_one_arg(sc, p, sc->get_output_string_symbol, args, wrap_string(sc, "an output string port", 21)));
    }
  if (port_is_closed(p))
    return(simple_wrong_type_argument_with_type(sc, sc->get_output_string_symbol, p, wrap_string(sc, "an active (open) string port", 28)));

  if (port_position(p) > sc->max_string_length)
    return(s7_out_of_range_error(sc, "get-output-string", 0, s7_make_integer(sc, port_position(p)),
				 "length is greater than (*s7* 'max-string-length)"));
  if ((clear_port) &&
      (port_position(p) < port_data_size(p)))
    {
      block_t *block;
      s7_pointer result;
      result = block_to_string(sc, port_data_block(p), port_position(p));
      port_data_size(p) = 64;
      block = mallocate(sc, 64);
      port_data_block(p) = block;
      port_data(p) = (uint8_t *)(block_data(block));
      port_position(p) = 0;
      port_data(p)[0] = '\0';
      return(result);
    }
  return(make_string_with_length(sc, (const char *)port_data(p), port_position(p)));
}

static s7_pointer op_get_output_string(s7_scheme *sc)
{
  s7_pointer port;

  port = sc->code;
  if ((!is_output_port(port)) ||
      (port_is_closed(port)))
    simple_wrong_type_argument_with_type(sc, sc->with_output_to_string_symbol, port, wrap_string(sc, "an open string output port", 26));

  if (port_position(port) > sc->max_string_length)
    return(s7_out_of_range_error(sc, "get-output-string", 0, s7_make_integer(sc, port_position(port)),
				 "length is greater than (*s7* 'max-string-length)"));

  if (port_position(port) >= port_data_size(port)) /* can the > part happen? */
    sc->value = block_to_string(sc, reallocate(sc, port_data_block(port), port_position(port) + 1), port_position(port));
  else sc->value = block_to_string(sc, port_data_block(port), port_position(port));

  port_data(port) = NULL;
  port_data_size(port) = 0;
  port_data_block(port) = NULL;
  port_needs_free(port) = false;
  return(NULL);
}


/* -------------------------------- open-input-function -------------------------------- */
s7_pointer s7_open_input_function(s7_scheme *sc, s7_pointer (*function)(s7_scheme *sc, s7_read_t read_choice, s7_pointer port))
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_INPUT_PORT);
  b = mallocate_port(sc);
  port_block(x) = b;
  port_port(x) = (port_t *)block_data(b);
  port_type(x) = FUNCTION_PORT;
  port_set_closed(x, false);
  port_original_input_string(x) = sc->nil;
  port_data_block(x) = NULL;
  port_needs_free(x) = false;
  port_filename_block(x) = NULL;
  port_filename(x) = NULL;
  port_filename_length(x) = 0;
  port_file_number(x) = 0;
  port_line_number(x) = 0;
  port_input_function(x) = function;
  port_read_character(x) = function_read_char;
  port_read_line(x) = function_read_line;
  port_display(x) = input_display;
  port_write_character(x) = input_write_char;
  port_write_string(x) = input_write_string;
  add_input_port(sc, x);
  return(x);
}


/* -------------------------------- open-output-function -------------------------------- */
s7_pointer s7_open_output_function(s7_scheme *sc, void (*function)(s7_scheme *sc, uint8_t c, s7_pointer port))
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_OUTPUT_PORT);
  b = mallocate_port(sc);
  port_block(x) = b;
  port_port(x) = (port_t *)block_data(b);
  port_type(x) = FUNCTION_PORT;
  port_data(x) = NULL;
  port_data_block(x) = NULL;
  port_set_closed(x, false);
  port_needs_free(x) = false;
  port_output_function(x) = function;
  port_read_character(x) = output_read_char;
  port_read_line(x) = output_read_line;
  port_display(x) = function_display;
  port_write_character(x) = function_write_char;
  port_write_string(x) = function_write_string;
  add_output_port(sc, x);
  return(x);
}


static void push_input_port(s7_scheme *sc, s7_pointer new_port)
{
#if S7_DEBUGGING
  if (!is_input_port(new_port)) fprintf(stderr, "push %s\n", DISPLAY(new_port));
#endif
  sc->input_port_stack = cons(sc, sc->input_port, sc->input_port_stack);
  sc->input_port = new_port;
}

static void pop_input_port(s7_scheme *sc)
{
  if (is_pair(sc->input_port_stack))
    {
      s7_pointer nxt;
      sc->input_port = car(sc->input_port_stack);
      nxt = cdr(sc->input_port_stack);
      /* is this safe? */
      free_cell(sc, sc->input_port_stack);
      sc->input_port_stack = nxt;
    }
  else sc->input_port = sc->standard_input;
}

static int32_t inchar(s7_pointer pt)
{
  int32_t c;
  if (is_file_port(pt))
    c = fgetc(port_file(pt)); /* not uint8_t! -- could be EOF */
  else
    {
      if (port_data_size(pt) <= port_position(pt))
	return(EOF);
      c = (uint8_t)port_data(pt)[port_position(pt)++];
    }

  if (c == '\n')
    port_line_number(pt)++;

  return(c);
}

static void backchar(char c, s7_pointer pt)
{
  if (c == '\n')
    port_line_number(pt)--;

  if (is_file_port(pt))
    ungetc(c, port_file(pt));
  else
    {
      if (port_position(pt) > 0)
	port_position(pt)--;
    }
}

static s7_pointer input_port_if_not_loading(s7_scheme *sc)
{
  s7_pointer port;
  port = sc->input_port;
  if (is_loader_port(port)) /* this flag is turned off by the reader macros, so we aren't in that context */
    {
      int32_t c;
      c = port_read_white_space(port)(sc, port);
      if (c > 0)            /* we can get either EOF or NULL at the end */
	{
	  backchar(c, port);
	  return(NULL);
	}
      return(sc->standard_input);
    }
  return(port);
}


/* -------------------------------- read-char -------------------------------- */
s7_pointer s7_read_char(s7_scheme *sc, s7_pointer port)
{
  int32_t c;
  c = port_read_character(port)(sc, port);
  if  (c == EOF) return(eof_object);
  return(chars[c]);
}

static s7_pointer g_read_char(s7_scheme *sc, s7_pointer args)
{
  #define H_read_char "(read-char (port (current-input-port))) returns the next character in the input port"
  #define Q_read_char s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_char_symbol, sc->is_eof_object_symbol), sc->is_input_port_symbol)
  s7_pointer port;

  if (is_not_null(args))
    port = car(args);
  else
    {
      port = input_port_if_not_loading(sc);
      if (!port) return(eof_object);
    }
  if (!is_input_port(port))
    return(method_or_bust_with_type_one_arg(sc, port, sc->read_char_symbol, args, an_input_port_string));
  return(chars[port_read_character(port)(sc, port)]);
}


/* -------------------------------- write-char -------------------------------- */
s7_pointer s7_write_char(s7_scheme *sc, s7_pointer c, s7_pointer pt)
{
  if (pt != sc->F)
    port_write_character(pt)(sc, s7_character(c), pt);
  return(c);
}

static s7_pointer write_char_p_pp(s7_scheme *sc, s7_pointer c, s7_pointer port)
{
  if (!s7_is_character(c))
    return(method_or_bust(sc, c, sc->write_char_symbol, list_2(sc, c, port), T_CHARACTER, 1));
  if (port == sc->F) return(c);
  if (!is_output_port(port))
    return(method_or_bust_with_type(sc, port, sc->write_char_symbol, list_2(sc, c, port), an_output_port_string, 2));
  port_write_character(port)(sc, s7_character(c), port);
  return(c);
}

static s7_pointer g_write_char(s7_scheme *sc, s7_pointer args)
{
  #define H_write_char "(write-char char (port (current-output-port))) writes char to the output port"
  #define Q_write_char s7_make_signature(sc, 3, sc->is_char_symbol, sc->is_char_symbol, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))

  return(write_char_p_pp(sc, car(args), (is_pair(cdr(args))) ? cadr(args) : sc->output_port));
}

static s7_pointer write_char_p_p(s7_scheme *sc, s7_pointer c)
{
  if (!s7_is_character(c))
    return(method_or_bust(sc, c, sc->write_char_symbol, list_1(sc, c), T_CHARACTER, 1));
  if (sc->output_port == sc->F) return(c);
  port_write_character(sc->output_port)(sc, s7_character(c), sc->output_port);
  return(c);
}

/* (with-output-to-string (lambda () (write-char #\space))) -> " "
 * (with-output-to-string (lambda () (write #\space))) -> "#\\space"
 * (with-output-to-string (lambda () (display #\space))) -> " "
 * is this correct?  It's what Guile does.  write-char is actually display-char.
 */


/* -------------------------------- peek-char -------------------------------- */
s7_pointer s7_peek_char(s7_scheme *sc, s7_pointer port)
{
  int32_t c;              /* needs to be an int32_t so EOF=-1, but not 255 */
  if (is_string_port(port))
    {
      if (port_data_size(port) <= port_position(port))
	return(chars[EOF]);
      return(chars[(uint8_t)port_data(port)[port_position(port)]]);
    }
  c = port_read_character(port)(sc, port);
  if (c == EOF) return(eof_object);
  backchar(c, port);
  return(chars[c]);
}

static s7_pointer g_peek_char(s7_scheme *sc, s7_pointer args)
{
  #define H_peek_char "(peek-char (port (current-input-port))) returns the next character in the input port, but does not remove it from the input stream"
  #define Q_peek_char s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_char_symbol, sc->is_eof_object_symbol), sc->is_input_port_symbol)
  s7_pointer port;

  if (is_not_null(args))
    port = car(args);
  else port = sc->input_port;

  if (!is_input_port(port))
    return(method_or_bust_with_type_one_arg(sc, port, sc->peek_char_symbol, args, an_input_port_string));
  if (port_is_closed(port))
    return(simple_wrong_type_argument_with_type(sc, sc->peek_char_symbol, port, an_open_port_string));

  if (is_function_port(port))
    return((*(port_input_function(port)))(sc, S7_PEEK_CHAR, port));
  return(s7_peek_char(sc, port));
}


/* -------------------------------- read-byte -------------------------------- */
static s7_pointer g_read_byte(s7_scheme *sc, s7_pointer args)
{
  #define H_read_byte "(read-byte (port (current-input-port))): reads a byte from the input port"
  #define Q_read_byte s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_byte_symbol, sc->is_eof_object_symbol), sc->is_input_port_symbol)
  s7_pointer port;
  int32_t c;

  if (is_not_null(args))
    port = car(args);
  else
    {
      port = input_port_if_not_loading(sc);
      if (!port) return(eof_object);
    }
  if (!is_input_port(port))
    return(method_or_bust_with_type_one_arg(sc, port, sc->read_byte_symbol, args, an_input_port_string));

  c = port_read_character(port)(sc, port);
  if (c == EOF)
    return(eof_object);
  return(small_int(c));
}


/* -------------------------------- write-byte -------------------------------- */
static s7_pointer g_write_byte(s7_scheme *sc, s7_pointer args)
{
  #define H_write_byte "(write-byte byte (port (current-output-port))): writes byte to the output port"
  #define Q_write_byte s7_make_signature(sc, 3, sc->is_byte_symbol, sc->is_byte_symbol, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))
  s7_pointer port, b;
  s7_int val;

  b = car(args);
  if (!s7_is_integer(b))
    return(method_or_bust(sc, car(args), sc->write_byte_symbol, args, T_INTEGER, 1));

  val = s7_integer(b);
  if ((val < 0) || (val > 255)) /* need to check this before port==#f, else (write-byte most-positive-fixnum #f) is not an error */
    return(wrong_type_argument_with_type(sc, sc->write_byte_symbol, 1, b, an_unsigned_byte_string));

  if (is_pair(cdr(args)))
    port = cadr(args);
  else port = sc->output_port;

  if (!is_output_port(port))
    {
      if (port == sc->F) return(car(args));
      return(method_or_bust_with_type_one_arg(sc, port, sc->write_byte_symbol, args, an_output_port_string));
    }

  port_write_character(port)(sc, (uint8_t)val, port);
  return(b);
}


/* -------------------------------- read-line -------------------------------- */
static s7_pointer g_read_line(s7_scheme *sc, s7_pointer args)
{
  #define H_read_line "(read-line port (with-eol #f)) returns the next line from port, or #<eof>. \
If 'with-eol' is not #f, read-line includes the trailing end-of-line character."
  #define Q_read_line s7_make_signature(sc, 3, s7_make_signature(sc, 2, sc->is_string_symbol, sc->is_eof_object_symbol), sc->is_input_port_symbol, sc->is_boolean_symbol)

  s7_pointer port;
  bool with_eol = false;

  if (is_not_null(args))
    {
      port = car(args);
      if (!is_input_port(port))
	return(method_or_bust_with_type(sc, port, sc->read_line_symbol, args, an_input_port_string, 1));

      if (is_not_null(cdr(args)))
	with_eol = (cadr(args) != sc->F); /* perhaps this should insist on #t: (read-line port (c-pointer 0)) */
    }
  else
    {
      port = input_port_if_not_loading(sc);
      if (!port) return(eof_object);
    }
  return(port_read_line(port)(sc, port, with_eol, true));
}

static s7_pointer g_read_line_uncopied(s7_scheme *sc, s7_pointer args)
{
  s7_pointer port;
  bool with_eol = false;
  port = car(args);
  if (!is_input_port(port))
    return(g_read_line(sc, args));
  if (is_not_null(cdr(args)))
    with_eol = (cadr(args) != sc->F);
  return(port_read_line(port)(sc, port, with_eol, false));
}

static s7_pointer read_line_p_pp(s7_scheme *sc, s7_pointer port, s7_pointer with_eol)
{
  if (!is_input_port(port))
    return(method_or_bust_with_type(sc, port, sc->read_line_symbol, list_2(sc, port, with_eol), an_input_port_string, 1));
  return(port_read_line(port)(sc, port, with_eol != sc->F, true));
}


/* -------------------------------- read-string -------------------------------- */
static s7_pointer g_read_string(s7_scheme *sc, s7_pointer args)
{
  /* read-chars would be a better name -- read-string could mean CL-style read-from-string (like eval-string)
   *   similarly read-bytes could return a byte-vector (rather than r7rs's read-bytevector)
   *   and write-string -> write-chars, write-bytevector -> write-bytes
   */
  #define H_read_string "(read-string k port) reads k characters from port into a new string and returns it."
  #define Q_read_string s7_make_signature(sc, 3, s7_make_signature(sc, 2, sc->is_string_symbol, sc->is_eof_object_symbol), sc->is_integer_symbol, sc->is_input_port_symbol)
  s7_pointer k, port, s;
  s7_int i, nchars;
  uint8_t *str;

  k = car(args);
  if (!s7_is_integer(k))
    return(method_or_bust(sc, k, sc->read_string_symbol, args, T_INTEGER, 1));
  nchars = s7_integer(k);
  if (nchars < 0)
    return(wrong_type_argument_with_type(sc, sc->read_string_symbol, 1, wrap_integer1(sc, nchars), a_non_negative_integer_string));
  if (nchars > sc->max_string_length)
    return(out_of_range(sc, sc->read_string_symbol, small_int(1), wrap_integer1(sc, nchars), its_too_large_string));

  if (!is_null(cdr(args)))
    port = cadr(args);
  else
    {
      port = input_port_if_not_loading(sc);
      if (!port) return(eof_object);
    }
  if (!is_input_port(port))
    return(method_or_bust_with_type(sc, port, sc->read_string_symbol, list_2(sc, make_integer(sc, nchars), port), an_input_port_string, 2));
  if (port_is_closed(port))
    return(simple_wrong_type_argument_with_type(sc, sc->read_string_symbol, port, an_open_port_string));

  if (nchars == 0)
    return(make_empty_string(sc, 0, 0));

  s = make_empty_string(sc, nchars, 0);
  str = (uint8_t *)string_value(s);
  if (is_string_port(port))
    {
      s7_int pos, end, len;
      pos = port_position(port);
      end = port_data_size(port);
      len = end - pos;
      if (len > nchars) len = nchars;
      if (len <= 0) return(eof_object);
      memcpy((void *)str, (void *)(port_data(port) + pos), len);
      string_length(s) = len;
      str[len] = '\0';
      port_position(port) += len;
      return(s);
    }
  if (is_file_port(port))
    {
      size_t len;
      len = fread((void *)str, 1, nchars, port_file(port));
      str[len] = '\0';
      string_length(s) = len;
      return(s);
    }
  for (i = 0; i < nchars; i++)
    {
      int32_t c;
      c = port_read_character(port)(sc, port);
      if (c == EOF)
	{
	  if (i == 0)
	    return(eof_object);
	  string_length(s) = i;
	  return(s);
	}
      str[i] = (uint8_t)c;
    }
  return(s);
}


#define declare_jump_info() bool old_longjmp; int32_t old_jump_loc, jump_loc; jmp_buf old_goto_start

#define store_jump_info(Sc)						\
  do {									\
      old_longjmp = Sc->longjmp_ok;					\
      old_jump_loc = Sc->setjmp_loc;					\
      memcpy((void *)old_goto_start, (void *)(Sc->goto_start), sizeof(jmp_buf)); \
  } while (0)

#define restore_jump_info(Sc)						\
  do {									\
      Sc->longjmp_ok = old_longjmp;					\
      Sc->setjmp_loc = old_jump_loc;					\
      memcpy((void *)(Sc->goto_start), (void *)old_goto_start, sizeof(jmp_buf)); \
      if ((jump_loc == ERROR_JUMP) &&					\
          (sc->longjmp_ok))						\
        longjmp(sc->goto_start, ERROR_JUMP);				\
  } while (0)

#define set_jump_info(Sc, Tag)				\
  do {							\
      sc->longjmp_ok = true;				\
      sc->setjmp_loc = Tag;				\
      jump_loc = setjmp(sc->goto_start);		\
  } while (0)


/* -------------------------------- read -------------------------------- */
s7_pointer s7_read(s7_scheme *sc, s7_pointer port)
{
  if (is_input_port(port))
    {
      s7_pointer old_envir;
      declare_jump_info();

      old_envir = sc->envir;
      sc->envir = sc->nil;
      push_input_port(sc, port);

      store_jump_info(sc);
      set_jump_info(sc, READ_SET_JUMP);
      if (jump_loc != NO_JUMP)
	{
	  if (jump_loc != ERROR_JUMP)
	    eval(sc, sc->cur_op);
	}
      else
	{
	  push_stack_no_let_no_code(sc, OP_BARRIER, port);
	  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);

	  eval(sc, OP_READ_INTERNAL);

	  if (sc->tok == TOKEN_EOF)
	    sc->value = eof_object;

	  if ((sc->cur_op == OP_EVAL_DONE) &&
	      (stack_op(sc->stack, s7_stack_top(sc) - 1) == OP_BARRIER))
	    pop_stack(sc);
	}
      pop_input_port(sc);
      sc->envir = old_envir;

      restore_jump_info(sc);
      return(sc->value);
    }
  return(simple_wrong_type_argument_with_type(sc, sc->read_symbol, port, an_input_port_string));
}

static s7_pointer g_read(s7_scheme *sc, s7_pointer args)
{
  #define H_read "(read (port (current-input-port))) returns the next object in the input port, or #<eof> at the end"
  #define Q_read s7_make_signature(sc, 2, sc->T, sc->is_input_port_symbol)
  s7_pointer port;

  if (is_not_null(args))
    port = car(args);
  else
    {
      port = input_port_if_not_loading(sc);
      if (!port) return(eof_object);
    }

  if (!is_input_port(port))
    return(method_or_bust_with_type_one_arg(sc, port, sc->read_symbol, args, an_input_port_string));

  if (is_function_port(port))
    return((*(port_input_function(port)))(sc, S7_READ, port));

  if ((is_string_port(port)) &&
      (port_data_size(port) <= port_position(port)))
    return(eof_object);

  push_input_port(sc, port);
  push_stack_op_let(sc, OP_READ_DONE); /* this stops the internal read process so we only get one form */
  push_stack_op_let(sc, OP_READ_INTERNAL);

  return(port);
}


/* -------------------------------- load -------------------------------- */

#if WITH_MULTITHREAD_CHECKS
typedef struct {
  s7_scheme* sc;
  const int32_t lock_count; /* Remember lock count in case we have skipped calls to leave_track_scope by longjmp-ing. */
} lock_scope_t;

static lock_scope_t enter_lock_scope(s7_scheme *sc)
{
  int result = pthread_mutex_trylock(&sc->lock);
  if (result != 0)
    {
      fprintf(stderr, "pthread_mutex_trylock failed: %d (EBUSY: %d)", result, EBUSY);
      abort();
    }

  sc->lock_count++;
  {
    lock_scope_t st = {.sc = sc, .lock_count = sc->lock_count};
    return(st);
  }
}

static void leave_lock_scope(lock_scope_t *st)
{
  while (st->sc->lock_count > st->lock_count)
    {
      st->sc->lock_count--;
      pthread_mutex_unlock(&st->sc->lock);
    }
}
#define TRACK(Sc) lock_scope_t lock_scope __attribute__ ((__cleanup__(leave_lock_scope))) = enter_lock_scope(Sc)
#else
#define TRACK(Sc)
#endif

static block_t *search_load_path(s7_scheme *sc, const char *name)
{
  s7_int len;
  s7_pointer lst;

  lst = s7_load_path(sc);
  len = s7_list_length(sc, lst);

  if (len > 0)
    {
      block_t *b;
      s7_int i;
      char *filename;
      b = mallocate(sc, 1024);
      filename = (char *)block_data(b);

      for (i = 0; i < len; i++)
	{
	  const char *new_dir;
	  new_dir = string_value(s7_list_ref(sc, lst, i));
	  if (new_dir)
	    {
	      FILE *fp;
	      filename[0] = '\0';
	      catstrs(filename, 1024, new_dir, "/", name, NULL);
	      fp = fopen(filename, "r");
	      if (fp)
		{
		  block_info(b) = (void *)fp;
		  return(b);
		}
	    }
	}
      liberate(sc, b);
    }
  return(NULL);
}

s7_pointer s7_load_with_environment(s7_scheme *sc, const char *filename, s7_pointer e)
{
  s7_pointer port;
  FILE *fp;
  char *new_filename = NULL;
  declare_jump_info();
  TRACK(sc);

  fp = fopen(filename, "r");
  if (!fp)
    {
      block_t *b;
      b = search_load_path(sc, filename);
      if (b)
	{
	  new_filename = copy_string((const char *)block_data(b)); /* (require libc.scm) for example needs the directory for cload in some cases */
	  fp = (FILE *)block_info(b);
	  liberate(sc, b);
	}
    }
  if (!fp)
    return(file_error(sc, "load", "can't open", filename));

  if (hook_has_functions(sc->load_hook))
    s7_call(sc, sc->load_hook, list_1(sc, sc->temp4 = s7_make_string(sc, filename)));

  port = read_file(sc, fp, (new_filename) ? (const char *)new_filename : filename, -1, "load");   /* -1 means always read its contents into a local string */
  port_file_number(port) = remember_file_name(sc, filename);
  if (new_filename) free(new_filename);
  set_loader_port(port);
  sc->temp6 = port;
  push_input_port(sc, port);
  sc->temp6 = sc->nil;

  /* it's possible to call this recursively (s7_load is Xen_load_file which can be invoked via s7_call)
   *   but in that case, we actually want it to behave like g_load and continue the evaluation upon completion
   */
  sc->envir = e;
  push_stack(sc, OP_LOAD_RETURN_IF_EOF, port, sc->code);

  store_jump_info(sc);
  set_jump_info(sc, LOAD_SET_JUMP);
  if (jump_loc != NO_JUMP)
    {
      if (jump_loc != ERROR_JUMP)
	eval(sc, sc->cur_op);
    }
  else eval(sc, OP_READ_INTERNAL);

  pop_input_port(sc);
  if (is_input_port(port))
    s7_close_input_port(sc, port);

  restore_jump_info(sc);
  if (is_multiple_value(sc->value))
    sc->value = splice_in_values(sc, multiple_value(sc->value));
  return(sc->value);
}

s7_pointer s7_load(s7_scheme *sc, const char *filename)
{
  return(s7_load_with_environment(sc, filename, sc->nil));
}


#if WITH_C_LOADER
#include <dlfcn.h>

static block_t *full_filename(s7_scheme *sc, const char *filename)
{
  s7_int len;
  char *pwd, *rtn;
  block_t *block;
  pwd = getcwd(NULL, 0); /* docs say this means it will return a new string of the right size */
  len = safe_strlen(pwd) + safe_strlen(filename) + 8;
  block = mallocate(sc, len * sizeof(char));
  rtn = (char *)block_data(block);
  if (pwd)
    {
      rtn[0] = '\0';
      catstrs(rtn, len, pwd, "/", filename, NULL);
      free(pwd);
    }
  else
    {
      memcpy((void *)rtn, (void *)filename, len);
      rtn[len] = '\0';
    }
  return(block);
}
#endif


static s7_pointer g_load(s7_scheme *sc, s7_pointer args)
{
  #define H_load "(load file (env (rootlet))) loads the scheme file 'file'. The 'env' argument \
defaults to the rootlet.  To load into the current environment instead, pass (curlet)."
  #define Q_load s7_make_signature(sc, 3, sc->values_symbol, sc->is_string_symbol, sc->is_let_symbol)

  FILE *fp = NULL;
  s7_pointer name, port;
  const char *fname;

  name = car(args);
  if (!is_string(name))
    return(method_or_bust(sc, name, sc->load_symbol, args, T_STRING, 1));

  if (is_not_null(cdr(args)))
    {
      s7_pointer e;
      e = cadr(args);
      if (!is_let(e))
	return(wrong_type_argument_with_type(sc, sc->load_symbol, 2, e, a_let_string));
      if (e == sc->rootlet)
	sc->envir = sc->nil;
      else sc->envir = e;
    }
  else sc->envir = sc->nil;

  fname = string_value(name);
  if ((!fname) || (!(*fname)))                 /* fopen("", "r") returns a file pointer?? */
    return(s7_error(sc, sc->out_of_range_symbol, set_elist_2(sc, wrap_string(sc, "load's first argument, ~S, should be a filename", 47), name)));

  if (is_directory(fname))
    return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "load argument, ~S, is a directory", 33), name)));

#if WITH_C_LOADER
  /* if fname ends in .so, try loading it as a c shared object
   *   (load "/home/bil/cl/m_j0.so" (inlet (cons 'init_func 'init_m_j0)))
   */
  {
    s7_int fname_len;

    fname_len = safe_strlen(fname);
    if ((fname_len > 3) &&
	(is_pair(cdr(args))) &&
	(local_strcmp((const char *)(fname + (fname_len - 3)), ".so")))
      {
	s7_pointer init;

	init = s7_let_ref(sc, (is_null(sc->envir)) ? sc->rootlet : sc->envir, make_symbol(sc, "init_func"));
	if (is_symbol(init))
	  {
	    void *library;
	    char *pwd_name;
	    block_t *pname = NULL;

	    if (fname[0] != '/')
	      {
		pname = full_filename(sc, fname); /* this is necessary, at least in Linux -- we can't blithely dlopen whatever is passed to us */
		pwd_name = (char *)block_data(pname);
	      }
	    library = dlopen((pname) ? pwd_name : fname, RTLD_NOW);
	    if (library)
	      {
		const char *init_name;
		void *init_func;

		init_name = symbol_name(init);
		init_func = dlsym(library, init_name);
		if (init_func)
		  {
		    typedef void *(*dl_func)(s7_scheme *sc);
		    ((dl_func)init_func)(sc);
		    if (pname) liberate(sc, pname);
		    return(sc->T);
		  }
		s7_warn(sc, 512, "loaded %s, but can't find %s (%s)?\n", fname, init_name, dlerror());
		dlclose(library);
	      }
	    else s7_warn(sc, 512, "load %s failed: %s\n", (pname) ? pwd_name : fname, dlerror());
	    if (pname) liberate(sc, pname);
	  }
	else s7_warn(sc, 512, "can't load %s: no init function\n", fname);
	return(sc->F);
      }
  }
#endif

  fp = fopen(fname, "r");

#if WITH_GCC
  if (!fp)
    {
      /* catch one special case, "~/..." since it causes 99.9% of the "can't load ..." errors */
      if ((fname[0] == '~') &&
	  (fname[1] == '/'))
	{
	  char *home;
	  home = getenv("HOME");
	  if (home)
	    {
	      block_t *b;
	      char *filename;
	      s7_int len;
	      len = safe_strlen(fname) + safe_strlen(home) + 1;
	      b = mallocate(sc, len);
	      filename = (char *)block_data(b);
	      filename[0] = '\0';
	      catstrs(filename, len, home, (char *)(fname + 1), NULL);
	      fp = fopen(filename, "r");
	      liberate(sc, b);
	    }
	}
    }
#endif

  if (!fp)
    {
      block_t *b;
      b = search_load_path(sc, fname);
      if (!b)
	return(file_error(sc, "load", "can't open", fname));
      fp = (FILE *)block_info(b);
      liberate(sc, b);
    }

  port = read_file(sc, fp, fname, -1, "load");
  port_file_number(port) = remember_file_name(sc, fname);
  set_loader_port(port);
  sc->temp6 = port;
  push_input_port(sc, port);
  sc->temp6 = sc->nil;

  push_stack_op_let(sc, OP_LOAD_CLOSE_AND_POP_IF_EOF);  /* was pushing args and code, but I don't think they're used later */
  push_stack_op_let(sc, OP_READ_INTERNAL);

  /* now we've opened and moved to the file to be loaded, and set up the stack to return
   *   to where we were.  Call *load-hook* if it is a procedure.
   */

  if (hook_has_functions(sc->load_hook))
    s7_apply_function(sc, sc->load_hook, list_1(sc, sc->temp4 = s7_make_string(sc, fname)));

  return(sc->unspecified);
}


s7_pointer s7_load_path(s7_scheme *sc)
{
  return(s7_symbol_value(sc, sc->load_path_symbol));
}

s7_pointer s7_add_to_load_path(s7_scheme *sc, const char *dir)
{
  s7_symbol_set_value(sc,
		      sc->load_path_symbol,
		      cons(sc,
			   s7_make_string(sc, dir),
			   s7_symbol_value(sc, sc->load_path_symbol)));
  return(s7_symbol_value(sc, sc->load_path_symbol));
}

static s7_pointer g_load_path_set(s7_scheme *sc, s7_pointer args)
{
  /* new value must be either () or a proper list of strings */
  if (is_null(cadr(args))) return(cadr(args));
  if (is_pair(cadr(args)))
    {
      s7_pointer x;
      for (x = cadr(args); is_pair(x); x = cdr(x))
	if (!is_string(car(x)))
	  return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *load-path* to ~S", 27), cadr(args))));
      if (is_null(x))
	return(cadr(args));
    }
  return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *load-path* to ~S", 27), cadr(args))));
}

static s7_pointer g_cload_directory_set(s7_scheme *sc, s7_pointer args)
{
  s7_pointer cl_dir;
  cl_dir = cadr(args);
  if (!is_string(cl_dir))
    return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *cload-directory* to ~S", 33), cadr(args))));
  s7_symbol_set_value(sc, sc->cload_directory_symbol, cl_dir);
  if (safe_strlen(string_value(cl_dir)) > 0)
    s7_add_to_load_path(sc, (const char *)(string_value(cl_dir)));
  return(cl_dir);
}


/* ---------------- autoload ---------------- */
#define INITIAL_AUTOLOAD_NAMES_SIZE 4

void s7_autoload_set_names(s7_scheme *sc, const char **names, s7_int size)
{
  /* the idea here is that by sticking to string constants we can handle 90% of the work at compile-time,
   *   with less start-up memory.  Then eventually we'll add C libraries a la xg (gtk) as environments
   *   and every name in that library will come as an import once dlopen has picked up the library.
   *   So, hopefully, we can pre-declare as many names as we want from as many libraries as we want,
   *   without a bloated mess of a run-time image.  And new libraries are easy to accommodate --
   *   add the names to be auto-exported to this list with the name of the scheme file that cloads
   *   the library and exports the given name. So, we'll need a separate such file for each library?
   *
   * the environment variable could use the library base name in *: *libm* or *libgtk*
   *   (*libm* 'j0)
   * why not just predeclare these libraries?  The caller could import what he wants via require.
   * So the autoloader need only know which libraries, but this doesn't fit the current use of gtk in xg
   * In fact, we only need to see *libm* -> libm.so etc, but we still need the arg/return types of each function, etc
   * And libgtk is enormous -- seems too bad to tie-in everything via the FFI when we need less than 1% of it.
   *
   * Also we need to decide how to handle name collisions (by order of autoload lib setup)
   * And (lastly?) how to handle different library versions?
   *
   * so autoload known libs here in s7 so we're indepentdent of snd
   *   (currently these are included in make-index.scm[line 575] -> snd-xref.c)
   * for each module, include an env in the lib env (*libgtk* 'gtkwidget.h) or whatever that has the names in that header
   * in autoload below, don't sort! -- just build a list of autoload tables and check each in order at autoload time (we want startup to be fast)
   * for versions, include wrapper macro at end of each c-define choice
   * in the xg case, there's no savings in delaying the defines
   */
  if (!sc->autoload_names)
    {
      sc->autoload_names = (const char ***)calloc(INITIAL_AUTOLOAD_NAMES_SIZE, sizeof(const char **));
      sc->autoload_names_sizes = (s7_int *)calloc(INITIAL_AUTOLOAD_NAMES_SIZE, sizeof(s7_int));
      sc->autoloaded_already = (bool **)calloc(INITIAL_AUTOLOAD_NAMES_SIZE, sizeof(bool *));
      sc->autoload_names_top = INITIAL_AUTOLOAD_NAMES_SIZE;
      sc->autoload_names_loc = 0;
    }
  else
    {
      if (sc->autoload_names_loc >= sc->autoload_names_top)
	{
	  s7_int i;
	  sc->autoload_names_top *= 2;
	  sc->autoload_names = (const char ***)realloc(sc->autoload_names, sc->autoload_names_top * sizeof(const char **));
	  sc->autoload_names_sizes = (s7_int *)realloc(sc->autoload_names_sizes, sc->autoload_names_top * sizeof(s7_int));
	  sc->autoloaded_already = (bool **)realloc(sc->autoloaded_already, sc->autoload_names_top * sizeof(bool *));
	  for (i = sc->autoload_names_loc; i < sc->autoload_names_top; i++)
	    {
	      sc->autoload_names[i] = NULL;
	      sc->autoload_names_sizes[i] = 0;
	      sc->autoloaded_already[i] = NULL;
	    }}}
  sc->autoload_names[sc->autoload_names_loc] = names;
  sc->autoload_names_sizes[sc->autoload_names_loc] = size;
  sc->autoloaded_already[sc->autoload_names_loc] = (bool *)calloc(size, sizeof(bool));
  sc->autoload_names_loc++;
}

static const char *find_autoload_name(s7_scheme *sc, s7_pointer symbol, bool *already_loaded, bool loading)
{
  s7_int l = 0, lib, libs;
  const char *name;

  name = symbol_name(symbol);
  libs = sc->autoload_names_loc;

  for (lib = 0; lib < libs; lib++)
    {
      const char **names;
      s7_int u;
      u = sc->autoload_names_sizes[lib] - 1;
      names = sc->autoload_names[lib];

      while (true)
	{
	  s7_int comp, pos;
	  const char *this_name;
	  if (u < l) break;
	  pos = (l + u) / 2;
	  this_name = names[pos * 2];
	  comp = strcmp(this_name, name);
	  if (comp == 0)
	    {
	      *already_loaded = sc->autoloaded_already[lib][pos];
	      if (loading) sc->autoloaded_already[lib][pos] = true;
	      return(names[pos * 2 + 1]);             /* file name given func name */
	    }
	  if (comp < 0)
	    l = pos + 1;
	  else u = pos - 1;
	}
    }
  return(NULL);
}

s7_pointer s7_autoload(s7_scheme *sc, s7_pointer symbol, s7_pointer file_or_function)
{
  /* add '(symbol . file) to s7's autoload table */
  if (is_null(sc->autoload_table))
    sc->autoload_table = s7_make_hash_table(sc, sc->default_hash_table_length);
  if (sc->safety >= MORE_SAFETY_WARNINGS)
    {
      s7_pointer p;
      p = s7_hash_table_ref(sc, sc->autoload_table, symbol);
      if ((p != sc->F) && (p != file_or_function))
	s7_warn(sc, 256, "'%s autoload value changed\n", symbol_name(symbol));
    }
  s7_hash_table_set(sc, sc->autoload_table, symbol, file_or_function);
  return(file_or_function);
}

static s7_pointer g_autoload(s7_scheme *sc, s7_pointer args)
{
  #define H_autoload "(autoload symbol file-or-function) adds the symbol to its table of autoloadable symbols. \
If that symbol is encountered as an unbound variable, s7 either loads the file (following *load-path*), or calls \
the function.  The function takes one argument, the calling environment.  Presumably the symbol is defined \
in the file, or by the function."
  #define Q_autoload s7_make_signature(sc, 3, sc->T, sc->is_symbol_symbol, sc->T)

  s7_pointer sym, value;

  sym = car(args);
  if (is_string(sym))
    {
      if (string_length(sym) == 0)                   /* (autoload "" ...) */
	return(s7_wrong_type_arg_error(sc, "autoload", 1, sym, "a symbol-name or a symbol"));
      sym = make_symbol_with_length(sc, string_value(sym), string_length(sym));
    }
  if (!is_symbol(sym))
    {
      check_method(sc, sym, sc->autoload_symbol, args);
      return(s7_wrong_type_arg_error(sc, "autoload", 1, sym, "a string (symbol-name) or a symbol"));
    }
  if (is_keyword(sym))
    return(s7_wrong_type_arg_error(sc, "autoload", 1, sym, "a normal symbol (a keyword is never unbound)"));

  value = cadr(args);
  if (is_string(value))
    return(s7_autoload(sc, sym, s7_immutable(make_string_with_length(sc, string_value(value), string_length(value)))));
  if (((is_closure(value)) || (is_closure_star(value))) &&
      (s7_is_aritable(sc, value, 1)))
    return(s7_autoload(sc, sym, value));

  check_method(sc, value, sc->autoload_symbol, args);
  return(s7_wrong_type_arg_error(sc, "autoload", 2, value, "a string (file-name) or a thunk"));
}


/* -------------------------------- *autoload* -------------------------------- */
static s7_pointer g_autoloader(s7_scheme *sc, s7_pointer args)
{
  #define H_autoloader "(*autoload* sym) returns the autoload info for the symbol sym, or #f."
  #define Q_autoloader s7_make_signature(sc, 2, sc->T, sc->is_symbol_symbol)
  s7_pointer sym;

  sym = car(args);
  if (!is_symbol(sym))
    {
      check_method(sc, sym, sc->autoloader_symbol, args);
      return(s7_wrong_type_arg_error(sc, "*autoload*", 1, sym, "a symbol"));
    }
  if (sc->autoload_names)
    {
      const char *file;
      bool loaded = false;
      file = find_autoload_name(sc, sym, &loaded, false);
      if (file)
	return(s7_make_string(sc, file));
    }
  if (is_hash_table(sc->autoload_table))
    return(s7_hash_table_ref(sc, sc->autoload_table, sym));

  return(sc->F);
}


/* ---------------- require ---------------- */
static s7_pointer g_require(s7_scheme *sc, s7_pointer args)
{
  #define H_require "(require symbol . symbols) loads each file associated with each symbol if it has not been loaded already.\
The symbols refer to the argument to \"provide\".  (require lint.scm)"
  /* #define Q_require s7_make_circular_signature(sc, 1, 2, sc->T, sc->is_symbol_symbol) */

  s7_pointer p;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, args);
  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer sym;
      if (is_symbol(car(p)))
	sym = car(p);
      else
	{
	  if ((is_proper_quote(sc, car(p))) &&
	      (is_symbol(cadar(p))))
	    sym = cadar(p);
	  else return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "require: ~S is not a symbol", 27), car(p))));
	}

      if ((!is_slot(symbol_to_slot(sc, sym))) &&
	  (sc->is_autoloading))
	{
	  s7_pointer f;
	  f = g_autoloader(sc, list_1(sc, sym));
	  if (is_string(f))
	    s7_load_with_environment(sc, string_value(f), sc->envir);
	  else return(s7_error(sc, sc->autoload_error_symbol, set_elist_2(sc, wrap_string(sc, "require: no autoload info for ~S", 32), sym)));
	}
    }
  unstack(sc);
  return(sc->T);
}


/* ---------------- provided? ---------------- */
static bool is_memq(s7_pointer sym, s7_pointer lst)
{
  s7_pointer x;
  for (x = lst; is_pair(x); x = cdr(x))
    if (sym == car(x))
      return(true);
  return(false);
}

static s7_pointer g_is_provided(s7_scheme *sc, s7_pointer args)
{
  #define H_is_provided "(provided? symbol) returns #t if symbol is a member of the *features* list"
  #define Q_is_provided s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_symbol_symbol)
  s7_pointer sym, topf, x;

  sym = car(args);
  if (!is_symbol(sym))
    return(method_or_bust_one_arg(sc, sym, sc->is_provided_symbol, list_1(sc, sym), T_SYMBOL));

  /* here the *features* list is spread out (or can be anyway) along the curlet chain,
   *   so we need to travel back all the way to the top level checking each *features* list in turn.
   *   Since *features* grows via cons (newest first), we can stop the scan if we hit the shared
   *   top-level at least.
   */
  topf = slot_value(global_slot(sc->features_symbol));
  if (is_memq(sym, topf))
    return(sc->T);

  if (is_global(sc->features_symbol))
    return(sc->F);
  for (x = sc->envir; symbol_id(sc->features_symbol) < let_id(x); x = outlet(x));
  for (; is_let(x); x = outlet(x))
    {
      s7_pointer y;
      for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	if (slot_symbol(y) == sc->features_symbol)
	  {
	    if ((slot_value(y) != topf) &&
		(is_memq(sym, slot_value(y))))
	      return(sc->T);
	  }
    }
  return(sc->F);
}

bool s7_is_provided(s7_scheme *sc, const char *feature)
{
  return(is_memq(make_symbol(sc, feature), s7_symbol_value(sc, sc->features_symbol))); /* this goes from local outward */
}

static bool is_provided_b_7p(s7_scheme *sc, s7_pointer sym)
{
  if (!is_symbol(sym))
    simple_wrong_type_argument(sc, sc->is_provided_symbol, sym, T_SYMBOL);
  return(is_memq(sym, s7_symbol_value(sc, sc->features_symbol)));
}


/* ---------------- provide ---------------- */
static s7_pointer c_provide(s7_scheme *sc, s7_pointer sym)
{
  /* this has to be relative to the curlet: (load file env)
   *   the things loaded are only present in env, and go away with it, so should not be in the global *features* list
   */
  s7_pointer p;

  if (!is_symbol(sym))
    return(method_or_bust_one_arg(sc, sym, sc->provide_symbol, list_1(sc, sym), T_SYMBOL));

  p = symbol_to_local_slot(sc, sc->features_symbol, sc->envir); /* if sc->envir is nil, this returns the global slot, else local slot */
  if ((is_slot(p)) && (is_immutable(p)))
    s7_warn(sc, 256, "provide: *features* is immutable!\n");
  else
    {
      s7_pointer lst;
      lst = slot_value(symbol_to_slot(sc, sc->features_symbol));    /* in either case, we want the current *features* list */
      if (p == sc->undefined)
	make_slot_1(sc, sc->envir, sc->features_symbol, cons(sc, sym, lst));
      else
	{
	  if (!is_memq(sym, lst))
	    slot_set_value(p, cons(sc, sym, lst));
	}
    }
  /* require looks up its symbol argument to see if the associated code (dsp.scm etc) has been autoloaded,
   *   so here we're defining the provided symbol for that possibility.  Perhaps better would be to forgo
   *   the definition here, and in require check *features* -- it is local to the current env.
   */
  if (!is_slot(symbol_to_slot(sc, sym))) /* *features* name might be the same as an existing function */
    s7_define(sc, sc->envir, sym, sym);

  return(sym);
}

static s7_pointer g_provide(s7_scheme *sc, s7_pointer args)
{
  #define H_provide "(provide symbol) adds symbol to the *features* list"
  #define Q_provide s7_make_signature(sc, 2, sc->is_symbol_symbol, sc->is_symbol_symbol)

  if ((is_immutable(sc->envir)) &&
      (sc->envir != sc->nil))
    s7_error(sc, sc->error_symbol,
	     set_elist_2(sc, wrap_string(sc, "can't provide '~S (current environment is immutable)", 52), car(args)));
  return(c_provide(sc, car(args)));
}

void s7_provide(s7_scheme *sc, const char *feature) {c_provide(sc, s7_make_symbol(sc, feature));}


static s7_pointer g_features_set(s7_scheme *sc, s7_pointer args) /* *features* setter */
{
  s7_pointer nf;
  nf = cadr(args);
  if (is_null(nf))
    return(sc->nil);
  if (is_pair(nf))
    {
      s7_pointer p;
      if (s7_list_length(sc, nf) <= 0)
	return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *features* to ~S", 26), nf)));
      for (p = nf; is_pair(p); p = cdr(p))
	if (!is_symbol(car(p)))
	  return(simple_wrong_type_argument(sc, sc->features_symbol, car(p), T_SYMBOL));
      return(nf);
    }
  return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *features* to ~S", 26), nf)));
}

static s7_pointer g_libraries_set(s7_scheme *sc, s7_pointer args) /* *libraries* setter */
{
  s7_pointer nf;
  nf = cadr(args);
  if (is_null(nf))
    return(sc->nil);
  if (is_pair(nf))
    {
      s7_pointer p;
      if (s7_list_length(sc, nf) <= 0)
	return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *libraries* to ~S", 27), nf)));
      for (p = nf; is_pair(p); p = cdr(p))
	if ((!is_pair(car(p))) ||
	    (!is_string(caar(p))) ||
	    (!is_let(cdar(p))))
	  return(simple_wrong_type_argument_with_type(sc, sc->libraries_symbol, car(p), wrap_string(sc, "a list of conses of the form (string . let)", 43)));
      return(nf);
    }
  return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set *libraries* to ~S", 27), nf)));
}


/* -------------------------------- eval-string -------------------------------- */

s7_pointer s7_eval_c_string_with_environment(s7_scheme *sc, const char *str, s7_pointer e)
{
  s7_pointer code, port;
  TRACK(sc);
  port = s7_open_input_string(sc, str);
  code = s7_read(sc, port);
  s7_close_input_port(sc, port);
  return(s7_eval(sc, T_Pos(code), e));
}

s7_pointer s7_eval_c_string(s7_scheme *sc, const char *str)
{
  return(s7_eval_c_string_with_environment(sc, str, sc->nil));
}

static s7_pointer g_eval_string(s7_scheme *sc, s7_pointer args)
{
  #define H_eval_string "(eval-string str (env (curlet))) returns the result of evaluating the string str as Scheme code"
  #define Q_eval_string s7_make_signature(sc, 3, sc->values_symbol, sc->is_string_symbol, sc->is_let_symbol)
  s7_pointer port, str;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->eval_string_symbol, args, T_STRING, 1));

  if (is_not_null(cdr(args)))
    {
      s7_pointer e;
      e = cadr(args);
      if (!is_let(e))
 	return(wrong_type_argument_with_type(sc, sc->eval_string_symbol, 2, e, a_let_string));
      if (e == sc->rootlet)
	sc->envir = sc->nil;
      else sc->envir = e;
    }

  port = open_and_protect_input_string(sc, str);
  push_input_port(sc, port);

  sc->temp3 = sc->args;
  push_stack(sc, OP_EVAL_STRING, args, sc->code);
  push_stack_op_let(sc, OP_READ_INTERNAL);

  return(sc->F);  /* I think this means that sc->value defaults to #f in op_eval_string below, so (eval-string "") mimics (eval) -> #f */
}

static s7_pointer eval_string_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  check_for_substring_temp(sc, expr);
  return(f);
}

static s7_pointer op_eval_string(s7_scheme *sc)
{
  while (s7_peek_char(sc, sc->input_port) != eof_object) /* (eval-string "(+ 1 2) this is a mistake") */
    {
      int32_t tk;
      tk = token(sc);                             /* (eval-string "(+ 1 2) ; a comment (not a mistake)") */
      if (tk != TOKEN_EOF)
	{
	  s7_int trail_len;
	  s7_pointer trail_data;
	  trail_len = port_data_size(sc->input_port) - port_position(sc->input_port) + 1;
	  if (trail_len > 32) trail_len = 32;
	  trail_data = make_string_with_length(sc, (const char *)(port_data(sc->input_port) + port_position(sc->input_port) - 1), trail_len);
	  s7_close_input_port(sc, sc->input_port);
	  pop_input_port(sc);
	  s7_error(sc, sc->read_error_symbol, set_elist_2(sc, wrap_string(sc, "eval-string trailing junk: ~S", 29), trail_data));
	}
    }
  s7_close_input_port(sc, sc->input_port);
  pop_input_port(sc);
  sc->code = sc->value;
  return(NULL);
}


/* -------------------------------- call-with-input-string -------------------------------- */

static s7_pointer call_with_input(s7_scheme *sc, s7_pointer port, s7_pointer args)
{
  s7_pointer p;
  p = cadr(args);
  port_original_input_string(port) = car(args);
  push_stack(sc, OP_UNWIND_INPUT, sc->input_port, port);
  push_stack(sc, OP_APPLY, list_1(sc, port), p);
  return(sc->F);
}

static s7_pointer g_call_with_input_string(s7_scheme *sc, s7_pointer args)
{
  s7_pointer str, proc;
  #define H_call_with_input_string "(call-with-input-string str proc) opens a string port for str and applies proc to it"
  #define Q_call_with_input_string sc->pl_sf
  /* (call-with-input-string "44" (lambda (p) (+ 1 (read p)))) -> 45 */

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->call_with_input_string_symbol, args, T_STRING, 1));

  proc = cadr(args);
  if (is_let(proc))
    check_method(sc, proc, sc->call_with_input_string_symbol, args);

  if (!s7_is_aritable(sc, proc, 1))
    return(wrong_type_argument_with_type(sc, sc->call_with_input_string_symbol, 2, proc,
					 wrap_string(sc, "a procedure of one argument (the port)", 38)));

  if ((is_continuation(proc)) || (is_goto(proc)))
    return(wrong_type_argument_with_type(sc, sc->call_with_input_string_symbol, 2, proc, a_normal_procedure_string));

  return(call_with_input(sc, open_and_protect_input_string(sc, str), args));
}


/* -------------------------------- call-with-input-file -------------------------------- */

static s7_pointer g_call_with_input_file(s7_scheme *sc, s7_pointer args)
{
  #define H_call_with_input_file "(call-with-input-file filename proc) opens filename and calls proc with the input port as its argument"
  #define Q_call_with_input_file sc->pl_sf
  s7_pointer str, proc;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->call_with_input_file_symbol, args, T_STRING, 1));

  proc = cadr(args);
  if (!s7_is_aritable(sc, proc, 1))
    return(wrong_type_argument_with_type(sc, sc->call_with_input_file_symbol, 2, proc,
					 wrap_string(sc, "a procedure of one argument (the port)", 38)));
  if ((is_continuation(proc)) || (is_goto(proc)))
    return(wrong_type_argument_with_type(sc, sc->call_with_input_file_symbol, 2, proc, a_normal_procedure_string));

  return(call_with_input(sc, open_input_file_1(sc, string_value(str), "r", "call-with-input-file"), args));
}


/* -------------------------------- with-input-from-string -------------------------------- */

static s7_pointer with_input(s7_scheme *sc, s7_pointer port, s7_pointer args)
{
  s7_pointer old_input_port, p;
  old_input_port = sc->input_port;
  sc->input_port = port;
  port_original_input_string(port) = car(args);
  push_stack(sc, OP_UNWIND_INPUT, old_input_port, port);
  p = cadr(args);
  push_stack(sc, OP_APPLY, sc->nil, p);
  return(sc->F);
}

static s7_pointer g_with_input_from_string(s7_scheme *sc, s7_pointer args)
{
  #define H_with_input_from_string "(with-input-from-string str thunk) opens str as the temporary current-input-port and calls thunk"
  #define Q_with_input_from_string sc->pl_sf
  s7_pointer str;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->with_input_from_string_symbol, args, T_STRING, 1));

  if (cadr(args) == slot_value(global_slot(sc->read_symbol)))
    {
      s7_pointer old_input_port;
      if (string_length(str) == 0)
	return(eof_object);

      old_input_port = sc->input_port;
      sc->input_port = open_and_protect_input_string(sc, str);
      port_original_input_string(sc->input_port) = str;
      push_stack(sc, OP_UNWIND_INPUT, old_input_port, sc->input_port);

      push_input_port(sc, sc->input_port);
      push_stack_op_let(sc, OP_READ_DONE);
      push_stack_op_let(sc, OP_READ_INTERNAL);
      return(sc->input_port);
    }

  if (!is_thunk(sc, cadr(args)))
    return(method_or_bust_with_type(sc, cadr(args), sc->with_input_from_string_symbol, args, a_thunk_string, 2));

  /* since the arguments are evaluated before we get here, we can get some confusing situations:
   *   (with-input-from-string "#x2.1" (read))
   *     (read) -> whatever it can get from the current input port!
   *     ";with-input-from-string argument 2, #<eof>, is untyped but should be a thunk"
   *   (with-input-from-string "" (read-line)) -> hangs awaiting stdin input
   */
  return(with_input(sc, open_and_protect_input_string(sc, str), args));
}


/* -------------------------------- with-input-from-file -------------------------------- */

static s7_pointer g_with_input_from_file(s7_scheme *sc, s7_pointer args)
{
  #define H_with_input_from_file "(with-input-from-file filename thunk) opens filename as the temporary current-input-port and calls thunk"
  #define Q_with_input_from_file sc->pl_sf

  if (!is_string(car(args)))
    return(method_or_bust(sc, car(args), sc->with_input_from_file_symbol, args, T_STRING, 1));

  if (!is_thunk(sc, cadr(args)))
    return(method_or_bust_with_type(sc, cadr(args), sc->with_input_from_file_symbol, args, a_thunk_string, 2));

  return(with_input(sc, open_input_file_1(sc, string_value(car(args)), "r", "with-input-from-file"), args));
}


/* -------------------------------- iterators -------------------------------- */

#if S7_DEBUGGING
static s7_pointer titr_let(s7_pointer p, const char *func, int32_t line)
{
  if (!is_let(iterator_sequence(p)))
    {
      fprintf(stderr, "%s%s[%d]: let iterator sequence is %s%s\n", BOLD_TEXT, func, line, check_name(unchecked_type(iterator_sequence(p))), UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  return(p);
}

static s7_pointer titr_pair(s7_pointer p, const char *func, int32_t line)
{
  if (!is_pair(iterator_sequence(p)))
    {
      fprintf(stderr, "%s%s[%d]: pair iterator sequence is %s%s\n", BOLD_TEXT, func, line, check_name(unchecked_type(iterator_sequence(p))), UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  return(p);
}

static s7_pointer titr_hash(s7_pointer p, const char *func, int32_t line)
{
  if (!is_hash_table(iterator_sequence(p)))
    {
      fprintf(stderr, "%s%s[%d]: hash iterator sequence is %s%s\n", BOLD_TEXT, func, line, check_name(unchecked_type(iterator_sequence(p))), UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  return(p);
}

static s7_pointer titr_len(s7_pointer p, const char *func, int32_t line)
{
  if ((is_hash_table(iterator_sequence(p))) ||
      (is_pair(iterator_sequence(p))))
    {
      fprintf(stderr, "%s%s[%d]: iterator length sequence is %s%s\n", BOLD_TEXT, func, line, check_name(unchecked_type(iterator_sequence(p))), UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  return(p);
}

static s7_pointer titr_pos(s7_scheme *sc, s7_pointer p, const char *func, int32_t line)
{
  if (((is_let(iterator_sequence(p))) &&
       (iterator_sequence(p) != sc->rootlet)) ||
      (is_pair(iterator_sequence(p))))
    {
      fprintf(stderr, "%s%s[%d]: iterator position sequence is %s%s\n", BOLD_TEXT, func, line, check_name(unchecked_type(iterator_sequence(p))), UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  return(p);
}
#endif


/* -------------------------------- iterator? -------------------------------- */
static s7_pointer g_is_iterator(s7_scheme *sc, s7_pointer args)
{
  #define H_is_iterator "(iterator? obj) returns #t if obj is an iterator."
  #define Q_is_iterator sc->pl_bt
  s7_pointer x;

  x = car(args);
  if (is_iterator(x)) return(sc->T);
  /* closure itself is not an iterator: (let ((c1 (let ((+iterator+ #t) (a 0)) (lambda () (set! a (+ a 1)))))) (iterate c1)): error (a function not an iterator) */
  check_boolean_method(sc, is_iterator, sc->is_iterator_symbol, args);
  return(sc->F);
}

bool s7_is_iterator(s7_pointer obj) {return(is_iterator(obj));}
static bool is_iterator_b_7p(s7_scheme *sc, s7_pointer obj) {return(g_is_iterator(sc, set_plist_1(sc, obj)) != sc->F);}


static s7_pointer iterator_copy(s7_scheme *sc, s7_pointer p)
{
  /* fields are obj cur [loc|lcur] [len|slow|hcur] next, but untangling them in debugging case is a pain */
  s7_pointer iter;
  new_cell(sc, iter, T_ITERATOR | T_SAFE_PROCEDURE);
  memcpy((void *)iter, (void *)p, sizeof(s7_cell));
  return(iter);
}

static s7_pointer iterator_finished(s7_scheme *sc, s7_pointer iterator)
{
  return(ITERATOR_END);
}

static s7_pointer iterator_quit(s7_pointer iterator)
{
  iterator_next(iterator) = iterator_finished;
  clear_iter_ok(iterator);
  return(ITERATOR_END);
}

static s7_pointer let_iterate(s7_scheme *sc, s7_pointer iterator)
{
  s7_pointer slot;
  slot = iterator_current_slot(iterator);
  if (tis_slot(slot))
    {
      iterator_set_current_slot(iterator, next_slot(slot));
      if (iterator_let_cons(iterator))
	{
	  s7_pointer p;
	  p = iterator_let_cons(iterator);
	  set_car(p, slot_symbol(slot));
	  set_cdr(p, slot_value(slot));
	  return(p);
	}
      return(cons(sc, slot_symbol(slot), slot_value(slot)));
    }
  return(iterator_quit(iterator));
}

static s7_pointer rootlet_iterate(s7_scheme *sc, s7_pointer iterator)
{
  s7_pointer slot;
  slot = iterator_current(iterator);
  if (is_slot(slot))
    {
      if (iterator_position(iterator) < sc->rootlet_entries)
	{
	  iterator_position(iterator)++;
	  iterator_current(iterator) = rootlet_element(sc->rootlet, iterator_position(iterator));
	}
      else iterator_current(iterator) = sc->nil;
      return(cons(sc, slot_symbol(slot), slot_value(slot)));
    }
  return(iterator_quit(iterator));
}

static s7_pointer hash_entry_to_cons(s7_scheme *sc, hash_entry_t *entry, s7_pointer p)
{
  if (p)
    {
      set_car(p, hash_entry_key(entry));
      set_cdr(p, hash_entry_value(entry));
      return(p);
    }
  return(cons(sc, hash_entry_key(entry), hash_entry_value(entry)));
}

static s7_pointer hash_table_iterate(s7_scheme *sc, s7_pointer iterator)
{
  s7_pointer table;
  s7_int loc, len;
  hash_entry_t **elements;
  hash_entry_t *lst;

  lst = iterator_hash_current(iterator);
  if (lst)
    {
      iterator_hash_current(iterator) = hash_entry_next(lst);
      return(hash_entry_to_cons(sc, lst, iterator_current(iterator)));
    }
  table = iterator_sequence(iterator); /* using iterator_length and hash_table_entries here was slightly slower */
  len = hash_table_mask(table) + 1;
  elements = hash_table_elements(table);

  for (loc = iterator_position(iterator) + 1; loc < len;  loc++)
    {
      hash_entry_t *x;
      x = elements[loc];
      if (x)
	{
	  iterator_position(iterator) = loc;
	  iterator_hash_current(iterator) = hash_entry_next(x);
	  return(hash_entry_to_cons(sc, x, iterator_current(iterator)));
	}
    }
  if (is_weak_hash_table(table))
    {
      clear_weak_hash_iterator(iterator);
#if S7_DEBUGGING
      if (weak_hash_iters(table) == 0)
	fprintf(stderr, "weak has iters wrapping under!\n");
#endif
      weak_hash_iters(table)--;
    }
  return(iterator_quit(iterator));
}

static s7_pointer string_iterate(s7_scheme *sc, s7_pointer obj)
{
  if (iterator_position(obj) < iterator_length(obj))
    return(s7_make_character(sc, (uint8_t)(string_value(iterator_sequence(obj))[iterator_position(obj)++])));
  return(iterator_quit(obj));
}

static s7_pointer byte_vector_iterate(s7_scheme *sc, s7_pointer obj)
{
  if (iterator_position(obj) < iterator_length(obj))
    return(small_int(byte_vector_bytes(iterator_sequence(obj))[iterator_position(obj)++]));
  return(iterator_quit(obj));
}

static s7_pointer float_vector_iterate(s7_scheme *sc, s7_pointer obj)
{
  if (iterator_position(obj) < iterator_length(obj))
    return(make_real(sc, float_vector(iterator_sequence(obj), iterator_position(obj)++)));
  return(iterator_quit(obj));
}

static s7_pointer int_vector_iterate(s7_scheme *sc, s7_pointer obj)
{
  if (iterator_position(obj) < iterator_length(obj))
    return(make_integer(sc, int_vector(iterator_sequence(obj), iterator_position(obj)++)));
  return(iterator_quit(obj));
}

static s7_pointer vector_iterate(s7_scheme *sc, s7_pointer obj)
{
  if (iterator_position(obj) < iterator_length(obj))
    return(vector_element(iterator_sequence(obj), iterator_position(obj)++));
  return(iterator_quit(obj));
}

static s7_pointer closure_iterate(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer result;
  result = s7_call(sc, iterator_sequence(obj), sc->nil);
  /* this can't use s7_apply_function -- we need to catch the error handler's longjmp here */
  if (result == ITERATOR_END)
    {
      iterator_next(obj) = iterator_finished;
      clear_iter_ok(obj);
    }
  return(result);
}

static s7_pointer c_object_iterate(s7_scheme *sc, s7_pointer obj)
{
  if (iterator_position(obj) < iterator_length(obj))
    {
      s7_pointer result, p, cur;
      p = iterator_sequence(obj);
      cur = iterator_current(obj);
      set_car(sc->z2_1, sc->x);
      set_car(sc->z2_2, sc->z); /* is this necessary? */
      set_car(cur, p);
      set_car(cdr(cur), make_integer(sc, iterator_position(obj)));
      result = (*(c_object_ref(sc, p)))(sc, cur);
      sc->x = car(sc->z2_1);
      sc->z = car(sc->z2_2);
      iterator_position(obj)++;
      if (result == ITERATOR_END)
	{
	  iterator_next(obj) = iterator_finished;
	  clear_iter_ok(obj);
	}
      return(result);
    }
  return(iterator_quit(obj));
}

static s7_pointer pair_iterate_1(s7_scheme *sc, s7_pointer obj);
static s7_pointer pair_iterate(s7_scheme *sc, s7_pointer obj)
{
  if (is_pair(iterator_current(obj)))
    {
      s7_pointer result;
      result = car(iterator_current(obj));
      iterator_current(obj) = cdr(iterator_current(obj));
      if (iterator_current(obj) == iterator_slow(obj))
	iterator_current(obj) = sc->nil;
      iterator_next(obj) = pair_iterate_1;
      return(result);
    }
  return(iterator_quit(obj));
}

static s7_pointer pair_iterate_1(s7_scheme *sc, s7_pointer obj)
{
  if (is_pair(iterator_current(obj)))
    {
      s7_pointer result;
      result = car(iterator_current(obj));
      iterator_current(obj) = cdr(iterator_current(obj));
      if (iterator_current(obj) == iterator_slow(obj))
	iterator_current(obj) = sc->nil;
      else iterator_set_slow(obj, cdr(iterator_slow(obj)));
      iterator_next(obj) = pair_iterate;
      return(result);
    }
  return(iterator_quit(obj));
}

static s7_pointer iterator_method(s7_scheme *sc, s7_pointer e)
{
  s7_pointer func;
  if ((has_active_methods(sc, e)) &&
      ((func = find_method(sc, find_let(sc, e), sc->make_iterator_symbol)) != sc->undefined))
    {
      s7_pointer it;
      it = s7_apply_function(sc, func, list_1(sc, e));
      if (!is_iterator(it))
	return(s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "make-iterator method must return an interator: ~S", 49), it)));
      return(it);
    }
  return(NULL);
}


/* -------------------------------- make-iterator -------------------------------- */
static bool is_iterable_closure(s7_scheme *sc, s7_pointer x)
{
  if (!is_thunk(sc, x))
    wrong_type_argument_with_type(sc, sc->make_iterator_symbol, 1, x, a_thunk_string);    
  if ((has_closure_let(x)) && (is_let(closure_let(x))))
    {
      s7_pointer val;
      val = symbol_to_local_slot(sc, sc->local_iterator_symbol, closure_let(x));
      if ((!is_slot(val)) && (is_let(outlet(closure_let(x)))))
	val = symbol_to_local_slot(sc, sc->local_iterator_symbol, outlet(closure_let(x)));
      if (is_slot(val))
	return(slot_value(val) != sc->F);
    }
  return(false);
}

s7_pointer s7_make_iterator(s7_scheme *sc, s7_pointer e)
{
  s7_pointer iter;

  new_cell(sc, iter, T_ITERATOR | T_SAFE_PROCEDURE | T_ITER_OK);
  iterator_sequence(iter) = e;
  if ((!is_let(e)) && (!is_pair(e)))
    iterator_position(iter) = 0;

  switch (type(e))
    {
    case T_LET:
      if (e == sc->rootlet)
	{
	  iterator_current(iter) = rootlet_element(e, 0); /* unfortunately tricky -- let_iterate uses different fields */
	  iterator_position(iter) = 0;
	  iterator_next(iter) = rootlet_iterate;
	}
      else
	{
	  s7_pointer f;
	  sc->temp6 = iter;
	  f = iterator_method(sc, e);
	  sc->temp6 = sc->nil;
	  if (f) {free_cell(sc, iter); return(f);}
	  iterator_set_current_slot(iter, let_slots(e));
	  iterator_next(iter) = let_iterate;
	  iterator_let_cons(iter) = NULL;
	}
      break;

    case T_HASH_TABLE:
      iterator_hash_current(iter) = NULL;
      iterator_current(iter) = NULL;
      iterator_position(iter) = -1;
      iterator_next(iter) = hash_table_iterate;
      if (is_weak_hash_table(e))
	{
	  set_weak_hash_iterator(iter);
	  weak_hash_iters(e)++;
	  add_weak_hash_iterator(sc, iter);
	}
      break;

    case T_STRING:
      iterator_length(iter) = string_length(e);
      iterator_next(iter) = string_iterate;
      break;

    case T_BYTE_VECTOR:
      iterator_length(iter) = byte_vector_length(e);
      iterator_next(iter) = byte_vector_iterate;
      break;

    case T_VECTOR:
      iterator_length(iter) = vector_length(e);
      iterator_next(iter) = vector_iterate;
      break;

    case T_INT_VECTOR:
      iterator_length(iter) = vector_length(e);
      iterator_next(iter) = int_vector_iterate;
      break;

    case T_FLOAT_VECTOR:
      iterator_length(iter) = vector_length(e);
      iterator_next(iter) = float_vector_iterate;
      break;

    case T_PAIR:
      iterator_current(iter) = e;
      iterator_next(iter) = pair_iterate;
      iterator_set_slow(iter, e);
      break;

    case T_NIL: /* (make-iterator #()) -> #<iterator: vector>, so I guess () should also work */
      iterator_length(iter) = 0;
      iterator_next(iter) = iterator_finished;
      clear_iter_ok(iter);
      break;

    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
    case T_CLOSURE: case T_CLOSURE_STAR:
      if (is_iterable_closure(sc, e))
	{
	  s7_pointer p;
	  p = cons(sc, small_int(0), sc->nil);
	  iterator_current(iter) = p;
	  set_mark_seq(iter);
	  iterator_next(iter) = closure_iterate;
	  if (has_active_methods(sc, e))
	    iterator_length(iter) = closure_length(sc, e);
	  else iterator_length(iter) = s7_int_max;
	}
      else
	{
	  free_cell(sc, iter);
	  return(simple_wrong_type_argument_with_type(sc, sc->make_iterator_symbol, e,
						      wrap_string(sc, "a function or macro with a '+iterator+ local that is not #f", 59)));
	}
      break;

    case T_C_OBJECT:
      {
	s7_pointer f;
	iterator_length(iter) = c_object_length_to_int(sc, e);
	sc->temp6 = iter;
	f = iterator_method(sc, e);
	sc->temp6 = sc->nil;
	if (f) {free_cell(sc, iter); return(f);}
	iterator_current(iter) = list_2(sc, e, small_int(0));
	set_mark_seq(iter);
	iterator_next(iter) = c_object_iterate;
      }
      break;

    default:
      return(simple_wrong_type_argument_with_type(sc, sc->make_iterator_symbol, e, a_sequence_string));
    }
  return(iter);
}

static s7_pointer g_make_iterator(s7_scheme *sc, s7_pointer args)
{
  #define H_make_iterator "(make-iterator sequence carrier) returns an iterator object that returns the next value \
in the sequence each time it is called.  When it reaches the end, it returns " ITERATOR_END_NAME "."
  #define Q_make_iterator s7_make_signature(sc, 3, sc->is_iterator_symbol, sc->is_sequence_symbol, sc->is_pair_symbol)

  s7_pointer iter, seq, carrier;
  /* we need to call s7_make_iterator before fixing up the optional second arg in case let->method */

  seq = car(args);
  carrier = (is_pair(cdr(args))) ? cadr(args) : NULL;
  iter = s7_make_iterator(sc, seq);

  if (carrier)
    {
      if (!is_pair(carrier))
	return(simple_wrong_type_argument(sc, sc->make_iterator_symbol, carrier, T_PAIR));
      if (is_immutable_pair(carrier))
	return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->make_iterator_symbol, carrier)));

      if (is_hash_table(iterator_sequence(iter)))
	{
	  iterator_current(iter) = carrier;
	  set_mark_seq(iter);
	}
      else
	{
	  if ((is_let(iterator_sequence(iter))) &&
	      (iterator_sequence(iter) != sc->rootlet))
	    {
	      iterator_let_cons(iter) = carrier;
	      set_mark_seq(iter);
	    }
	  else         /* (let-temporarily (((*s7* 'safety) 1)) (make-iterator "asdf" (cons 1 2))) */
	    {
	      if (sc->safety > MORE_SAFETY_WARNINGS)
		s7_warn(sc, 256, "(make-iterator %s %s) does not need the second argument\n", DISPLAY_80(seq), DISPLAY_80(carrier));
	    }
	}
    }
  return(iter);
}


/* -------------------------------- iterate -------------------------------- */
static s7_pointer g_iterate(s7_scheme *sc, s7_pointer args)
{
  #define H_iterate "(iterate obj) returns the next element from the iterator obj, or " ITERATOR_END_NAME "."
  #define Q_iterate s7_make_signature(sc, 2, sc->T, sc->is_iterator_symbol)

  s7_pointer iter;
  iter = car(args);
  if (!is_iterator(iter))
    return(method_or_bust_one_arg(sc, iter, sc->iterate_symbol, args, T_ITERATOR));
  return((iterator_next(iter))(sc, iter));
}

static s7_pointer iterate_p_p(s7_scheme *sc, s7_pointer iter)
{
  if (!is_iterator(iter))
    return(method_or_bust_one_arg(sc, iter, sc->iterate_symbol, set_plist_1(sc, iter), T_ITERATOR));
  return((iterator_next(iter))(sc, iter));
}

s7_pointer s7_iterate(s7_scheme *sc, s7_pointer obj)
{
  return((iterator_next(obj))(sc, obj));
}

bool s7_iterator_is_at_end(s7_scheme *sc, s7_pointer obj)
{
  if (iter_ok(obj))
    return(false);
  if (!is_iterator(obj))
    simple_wrong_type_argument(sc, sc->iterator_is_at_end_symbol, obj, T_ITERATOR);
  return(true);
}

static bool op_iterate(s7_scheme *sc)
{
  s7_pointer s;
  s = lookup_checked(sc, car(sc->code));
  if (!is_iterator(s)) {sc->last_function = s; return(false);}
  sc->value = (iterator_next(s))(sc, s);
  return(true);
}


/* -------------------------------- iterator-at-end? -------------------------------- */
static bool iterator_is_at_end_b_7p(s7_scheme *sc, s7_pointer obj)
{
  if (iter_ok(obj))
    return(false);
  if (!is_iterator(obj))
    simple_wrong_type_argument(sc, sc->iterator_is_at_end_symbol, obj, T_ITERATOR);
  return(true);
}

static s7_pointer g_iterator_is_at_end(s7_scheme *sc, s7_pointer args)
{
  #define H_iterator_is_at_end "(iterator-at-end? iter) returns #t if the iterator has reached the end of its sequence."
  #define Q_iterator_is_at_end s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_iterator_symbol)
  s7_pointer iter;

  iter = car(args);
  if (iter_ok(iter))
    return(sc->F);
  if (!is_iterator(iter))
    return(method_or_bust_one_arg(sc, iter, sc->iterator_is_at_end_symbol, args, T_ITERATOR));
  return(sc->T);
}


/* -------------------------------- iterator-sequence -------------------------------- */
static s7_pointer g_iterator_sequence(s7_scheme *sc, s7_pointer args)
{
  #define H_iterator_sequence "(iterator-sequence iterator) returns the sequence that iterator is traversing."
  #define Q_iterator_sequence s7_make_signature(sc, 2, sc->is_sequence_symbol, sc->is_iterator_symbol)

  s7_pointer iter;

  iter = car(args);
  if (!is_iterator(iter))
    return(method_or_bust_one_arg(sc, iter, sc->iterator_sequence_symbol, args, T_ITERATOR));
  return(iterator_sequence(iter));
}


/* -------- cycles -------- */

#define INITIAL_SHARED_INFO_SIZE 8

static int32_t shared_ref(shared_info *ci, s7_pointer p)
{
  /* from print after collecting refs, not called by equality check, only called in object_to_port_with_circle_check_1 */
  int32_t i;
  s7_pointer *objs;

  objs = ci->objs;
  for (i = 0; i < ci->top; i++)
    if (objs[i] == p)
      {
	int32_t val;
	val = ci->refs[i];
	if (val > 0)
	  ci->refs[i] = -ci->refs[i];
	return(val);
      }
  return(0);
}

static void flip_ref(shared_info *ci, s7_pointer p)
{
  int32_t i;
  s7_pointer *objs;
  objs = ci->objs;
  for (i = 0; i < ci->top; i++)
    if (objs[i] == p)
      {
	ci->refs[i] = -ci->refs[i];
	break;
      }
}

static int32_t peek_shared_ref(shared_info *ci, s7_pointer p)
{
  /* returns 0 if not found, otherwise the ref value for p */
  int32_t i;
  s7_pointer *objs;

  if (!is_collected_unchecked(p)) return(0);

  objs = ci->objs;
  for (i = 0; i < ci->top; i++)
    if (objs[i] == p)
      return(ci->refs[i]);
  return(0);
}

static void enlarge_shared_info(shared_info *ci)
{
  int32_t i;
  ci->size *= 2;
  ci->size2 = ci->size - 2;
  ci->objs = (s7_pointer *)realloc(ci->objs, ci->size * sizeof(s7_pointer));
  ci->refs = (int32_t *)realloc(ci->refs, ci->size * sizeof(int32_t));
  ci->defined = (bool *)realloc(ci->defined, ci->size * sizeof(bool));
  for (i = ci->top; i < ci->size; i++)
    {
      ci->refs[i] = 0;
      ci->objs[i] = NULL;
    }
}

static void add_shared_ref(shared_info *ci, s7_pointer x, int32_t ref_x)
{
  /* called only in equality check, not printer */
  if (ci->top == ci->size)
    enlarge_shared_info(ci);
  set_collected(x);
  ci->objs[ci->top] = x;
  ci->refs[ci->top++] = ref_x;
}

static bool collect_shared_info(s7_scheme *sc, shared_info *ci, s7_pointer top, bool stop_at_print_length);
static hash_entry_t *hash_equal(s7_scheme *sc, s7_pointer table, s7_pointer key);
static hash_entry_t *hash_equivalent(s7_scheme *sc, s7_pointer table, s7_pointer key);

static bool check_collected(s7_pointer top, shared_info *ci)
{
  s7_pointer *p, *objs_end;
  int32_t i;
  objs_end = (s7_pointer *)(ci->objs + ci->top);
  for (p = ci->objs; p < objs_end; p++)
    if ((*p) == top)
      {
	i = (int32_t)(p - ci->objs);
	if (ci->refs[i] == 0)
	  {
	    ci->has_hits = true;
	    ci->refs[i] = ++ci->ref;  /* if found, set the ref number */
	  }
	break;
      }
  set_cyclic(top);
  return(true);
}

static bool collect_vector_info(s7_scheme *sc, shared_info *ci, s7_pointer top, bool stop_at_print_length)
{
  s7_int i, plen;
  bool cyclic = false;

  if (stop_at_print_length)
    {
      plen = sc->print_length;
      if (plen > vector_length(top))
	plen = vector_length(top);
    }
  else plen = vector_length(top);

  for (i = 0; i < plen; i++)
    {
      s7_pointer vel;
      vel = unchecked_vector_element(top, i);   /* "unchecked" because top might be rootlet, I think */
      if ((has_structure(vel)) &&
	  (collect_shared_info(sc, ci, vel, stop_at_print_length)))
	{
	  set_cyclic(vel);
	  cyclic = true;
	  if ((is_c_pointer(vel)) ||
	      (is_iterator(vel)) ||
	      (is_c_object(vel)))
	    check_collected(top, ci);
	}
    }
  if (cyclic) set_cyclic(top);
  return(cyclic);
}

static bool collect_shared_info(s7_scheme *sc, shared_info *ci, s7_pointer top, bool stop_at_print_length)
{
  /* look for top in current list.
   * As we collect objects (guaranteed to have structure) we set the collected bit.  If we ever
   *   encounter an object with that bit on, we've seen it before so we have a possible cycle.
   *   Once the collection pass is done, we run through our list, and clear all these bits.
   */
  bool top_cyclic;

  if (is_collected_or_shared(top))
    {
      if (is_shared(top))
	return(false);
      return(check_collected(top, ci));
    }

  /* top not seen before -- add it to the list */
  set_collected(top);

  if (ci->top == ci->size)
    enlarge_shared_info(ci);
  ci->objs[ci->top++] = top;

  top_cyclic = false;
  /* now search the rest of this structure */
  if (is_pair(top))
    {
      s7_pointer p, cp;
      if ((has_structure(car(top))) &&
	  (collect_shared_info(sc, ci, car(top), stop_at_print_length)))
	top_cyclic = true;

      for (p = cdr(top); is_pair(p); p = cdr(p))
	{
	  if (is_collected_or_shared(p))
	    {
	      set_cyclic(top);
	      set_cyclic(p);
	      if (is_shared(p))
		{
		  if (!top_cyclic)
		    for (cp = top; cp != p; cp = cdr(cp)) set_shared(cp);
		  return(top_cyclic);
		}
	      return(check_collected(p, ci));
	    }
	  set_collected(p);
	  if (ci->top == ci->size)
	    enlarge_shared_info(ci);
	  ci->objs[ci->top++] = p;
	  if ((has_structure(car(p))) &&
	      (collect_shared_info(sc, ci, car(p), stop_at_print_length)))
	    top_cyclic = true;
	}
      if ((has_structure(p)) &&
	  (collect_shared_info(sc, ci, p, stop_at_print_length)))
	{
	  set_cyclic(top);
	  return(true);
	}
      if (!top_cyclic)
	for (cp = top; is_pair(cp); cp = cdr(cp)) set_shared(cp);
      else set_cyclic(top);
      return(top_cyclic);
    }

  switch (type(top))
    {
    case T_VECTOR:
      if (collect_vector_info(sc, ci, top, stop_at_print_length))
	top_cyclic = true;
      break;

    case T_ITERATOR:
      if ((is_sequence(iterator_sequence(top))) && /* might be a function with +iterator+ local */
	  (collect_shared_info(sc, ci, iterator_sequence(top), stop_at_print_length)))
	{
	  if (peek_shared_ref(ci, iterator_sequence(top)) == 0)
	    check_collected(iterator_sequence(top), ci);
	  top_cyclic = true;
	}
      break;

    case T_HASH_TABLE:
      if (hash_table_entries(top) > 0)
	{
	  s7_int i, len;
	  hash_entry_t **entries;
	  bool keys_safe;

	  keys_safe = ((hash_table_checker(top) != hash_equal) && 
		       (hash_table_checker(top) != hash_equivalent) && 
		       (!hash_table_checker_locked(top)));
	  entries = hash_table_elements(top);
	  len = hash_table_mask(top) + 1;
	  for (i = 0; i < len; i++)
	    {
	      hash_entry_t *p;
	      for (p = entries[i]; p; p = hash_entry_next(p))
		{
		  if ((!keys_safe) &&
		      (has_structure(hash_entry_key(p))) &&
		      (collect_shared_info(sc, ci, hash_entry_key(p), stop_at_print_length)))
		    top_cyclic = true;
		  if ((has_structure(hash_entry_value(p))) &&
		      (collect_shared_info(sc, ci, hash_entry_value(p), stop_at_print_length)))
		    {
		      if ((is_c_pointer(hash_entry_value(p))) ||
			  (is_iterator(hash_entry_value(p))) ||
			  (is_c_object(hash_entry_value(p))))
			check_collected(top, ci);
		      top_cyclic = true;
		    }
		}
	    }
	}
      break;

    case T_SLOT: /* this can be hit if we somehow collect_shared_info on sc->rootlet via collect_vector_info (see the let case below) */
      if ((has_structure(slot_value(top))) &&
	  (collect_shared_info(sc, ci, slot_value(top), stop_at_print_length)))
	top_cyclic = true;
      break;

    case T_LET:
      if (top == sc->rootlet)
	{
	  if (collect_vector_info(sc, ci, top, stop_at_print_length))
	    top_cyclic = true;
	}
      else
	{
	  s7_pointer p, q;
	  for (q = top; is_let(q) && (q != sc->rootlet); q = outlet(q))
	    {
	      for (p = let_slots(q); tis_slot(p); p = next_slot(p))
		if ((has_structure(slot_value(p))) &&
		    (collect_shared_info(sc, ci, slot_value(p), stop_at_print_length)))
		  {
		    top_cyclic = true;
		    if ((is_c_pointer(slot_value(p))) ||
			(is_iterator(slot_value(p))) ||
			(is_c_object(slot_value(p))))
		      check_collected(top, ci);
		  }
	    }
	}
      break;

    case T_CLOSURE:
    case T_CLOSURE_STAR:
      if (collect_shared_info(sc, ci, closure_body(top), stop_at_print_length))
	{
	  if (peek_shared_ref(ci, top) == 0)
	    check_collected(top, ci);
	  top_cyclic = true;
	}
      break;

    case T_C_POINTER:
      if ((has_structure(c_pointer_type(top))) &&
	  (collect_shared_info(sc, ci, c_pointer_type(top), stop_at_print_length)))
	{
	  if (peek_shared_ref(ci, c_pointer_type(top)) == 0)
	    check_collected(c_pointer_type(top), ci);
	  top_cyclic = true;
	}
      if ((has_structure(c_pointer_info(top))) &&
	  (collect_shared_info(sc, ci, c_pointer_info(top), stop_at_print_length)))
	{
	  if (peek_shared_ref(ci, c_pointer_info(top)) == 0)
	    check_collected(c_pointer_info(top), ci);
	  top_cyclic = true;
	}
      break;

    case T_C_OBJECT:
      if ((c_object_to_list(sc, top)) &&
	  (c_object_set(sc, top)) &&
	  (collect_shared_info(sc, ci, (*(c_object_to_list(sc, top)))(sc, set_plist_1(sc, top)), stop_at_print_length)))
	{
	  if (peek_shared_ref(ci, top) == 0)
	    check_collected(top, ci);
	  top_cyclic = true;
	}
      break;
    }

  if (!top_cyclic)
    set_shared(top);
  else set_cyclic(top);
  return(top_cyclic);
}

static shared_info *init_circle_info(s7_scheme *sc)
{
  shared_info *ci;
  ci = (shared_info *)calloc(1, sizeof(shared_info));
  ci->size = INITIAL_SHARED_INFO_SIZE;
  ci->size2 = ci->size - 2;
  ci->objs = (s7_pointer *)malloc(ci->size * sizeof(s7_pointer));
  ci->refs = (int32_t *)calloc(ci->size, sizeof(int32_t));   /* finder expects 0 = unseen previously */
  ci->defined = (bool *)calloc(ci->size, sizeof(bool));
  ci->cycle_port = sc->F;
  ci->init_port = sc->F;
  return(ci);
}

static inline shared_info *new_shared_info(s7_scheme *sc)
{
  shared_info *ci;
  ci = sc->circle_info;
  if (ci->top > 0)
    {
      int32_t i;
      memclr((void *)(ci->refs), ci->top * sizeof(int32_t));
      memclr((void *)(ci->defined), ci->top * sizeof(bool));
      for (i = 0; i < ci->top; i++)
	clear_cyclic_bits(ci->objs[i]); /* LOOP_4 is not faster */
      ci->top = 0;
    }
  ci->ref = 0;
  ci->has_hits = false;
  return(ci);
}

static shared_info *make_shared_info(s7_scheme *sc, s7_pointer top, bool stop_at_print_length)
{
  /* for the printer */
  shared_info *ci;
  int32_t i, refs;
  s7_pointer *ci_objs;
  int32_t *ci_refs;
  bool no_problem = true, cyclic = false;
  s7_int k, stop_len;

  /* check for simple cases first */
  if (is_pair(top))
    {
      s7_pointer x;
      x = top;
      if (stop_at_print_length)
	{
	  s7_pointer slow;
	  stop_len = sc->print_length;
	  slow = top;
	  for (k = 0; k < stop_len; k += 2)
	    {
	      if (!is_pair(x))
		break;
	      if (has_structure(car(x)))
		{
		  no_problem = false;
		  break;
		}
	      x = cdr(x);
	      if (!is_pair(x))
		break;
	      if (has_structure(car(x)))
		{
		  no_problem = false;
		  break;
		}
	      x = cdr(x);
	      slow = cdr(slow);
	      if (x == slow)
		{
		  no_problem = false;
		  break;
		}
	    }
	}
      else
	{
	  if (s7_list_length(sc, top) == 0) /* it is circular at the top level (following cdr) */
	    no_problem = false;
	  else
	    {
	      for (; is_pair(x); x = cdr(x))
		if (has_structure(car(x)))
		  {
		    /* it can help a little in some cases to scan vectors here (and slots):
		     *   if no element has structure, it's ok (maybe also hash_table_entries == 0)
		     */
		    no_problem = false;
		    break;
		  }
	    }
	}
      if ((no_problem) &&
	  (!is_null(x)) &&
	  (has_structure(x)))
	no_problem = false;

      if (no_problem)
	return(NULL);
    }
  else
    {
      if (is_any_vector(top))
	{
	  if (!is_normal_vector(top))
	    return(NULL);

	  stop_len = vector_length(top);
	  if ((stop_at_print_length) &&
	      (stop_len > sc->print_length))
	    stop_len = sc->print_length;

	  for (k = 0; k < stop_len; k++)
	    if (has_structure(vector_element(top, k)))
	      {
		no_problem = false;
		break;
	      }
	  if (no_problem)
	    return(NULL);
	}
    }

  ci = new_shared_info(sc);

  /* collect all pointers associated with top */
  cyclic = collect_shared_info(sc, ci, top, stop_at_print_length);

  ci_objs = ci->objs;
  for (i = 0; i < ci->top; i++)
    clear_collected_and_shared(ci_objs[i]);

  if (!cyclic)
    return(NULL);

  if (!(ci->has_hits))
    return(NULL);

  ci_refs = ci->refs;
  /* find if any were referenced twice (once for just being there, so twice=shared)
   *   we know there's at least one such reference because has_hits is true.
   */
  for (i = 0, refs = 0; i < ci->top; i++)
    if (ci_refs[i] > 0)
      {
	set_collected(ci_objs[i]);
	if (i == refs)
	  refs++;
	else
	  {
	    ci_objs[refs] = ci_objs[i];
	    ci_refs[refs++] = ci_refs[i];
	    ci_refs[i] = 0;
	    ci_objs[i] = NULL;
	  }
      }
  ci->top = refs;
  return(ci);
}


/* -------------------------------- cyclic-sequences -------------------------------- */

static s7_pointer cyclic_sequences(s7_scheme *sc, s7_pointer obj)
{
  if (has_structure(obj))
    {
      shared_info *ci;
      if (sc->object_out_locked)
	ci = sc->circle_info;
      else ci = make_shared_info(sc, obj, false); /* false=don't stop at print length (vectors etc) */
      if (ci)
	{
	  int32_t i;
	  s7_pointer lst;
	  sc->w = sc->nil;
	  for (i = 0; i < ci->top; i++)
	    sc->w = cons(sc, ci->objs[i], sc->w);
	  lst = sc->w;
	  sc->w = sc->nil;
	  return(lst);
	}
    }
  return(sc->nil);
}

static s7_pointer g_cyclic_sequences(s7_scheme *sc, s7_pointer args)
{
  #define H_cyclic_sequences "(cyclic-sequences obj) returns a list of elements that are cyclic."
  #define Q_cyclic_sequences s7_make_signature(sc, 2, sc->is_proper_list_symbol, sc->T)
  return(cyclic_sequences(sc, car(args)));
}

static int32_t circular_list_entries(s7_pointer lst)
{
  int32_t i;
  s7_pointer x;
  for (i = 1, x = cdr(lst); ; i++, x = cdr(x))
    {
      int32_t j;
      s7_pointer y;
      for (y = lst, j = 0; j < i; y = cdr(y), j++)
	if (x == y)
	  return(i);
    }
}

static void object_to_port_with_circle_check_1(s7_scheme *sc, s7_pointer vr, s7_pointer port, use_write_t use_write, shared_info *ci);
#define object_to_port_with_circle_check(Sc, Vr, Port, Use_Write, Ci) \
  do { \
      s7_pointer _V_ = Vr; \
      if ((Ci) && (has_structure(_V_))) \
        object_to_port_with_circle_check_1(Sc, _V_, Port, Use_Write, Ci); \
      else object_to_port(Sc, _V_, Port, Use_Write, Ci);\
     } while (0)

static void (*display_functions[256])(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci);
#define object_to_port(Sc, Obj, Port, Use_Write, Ci) (*display_functions[unchecked_type(Obj)])(Sc, Obj, Port, Use_Write, Ci)

static bool string_needs_slashification(const char *str, s7_int len)
{
  /* we have to go by len (str len) not *s==0 because s7 strings can have embedded nulls */
  uint8_t *p, *pend;
  pend = (uint8_t *)(str + len);
  for (p = (uint8_t *)str; p < pend; p++)
    if (slashify_table[*p])
      return(true);
  return(false);
}

#define IN_QUOTES true
#define NOT_IN_QUOTES false

static void slashify_string_to_port(s7_scheme *sc, s7_pointer port, const char *p, s7_int len, bool quoted)
{
  uint8_t *pcur, *pend, *pstart = NULL;

  if (len == 0)
    {
      if (quoted)
	port_write_string(port)(sc, "\"\"", 2, port);
      return;
    }
  pend = (uint8_t *)(p + len);

  /* what about the trailing nulls? Guile writes them out (as does s7 currently)
   *    but that is not ideal.  I'd like to use ~S for error messages, so that
   *    strings are clearly identified via the double-quotes, but this way of
   *    writing them is ugly:
   *      (let ((str (make-string 8 #\null))) (set! (str 0) #\a) str) -> "a\x00\x00\x00\x00\x00\x00\x00"
   *    but it would be misleading to omit them because:
   *      (let ((str (make-string 8 #\null))) (set! (str 0) #\a) (string-append str "bc")) -> "a\x00\x00\x00\x00\x00\x00\x00bc"
   * also it is problematic to use sc->print_length here because
   *    it is normally (say) 8 which truncates just about every string.  In CL, *print-length*
   *    does not affect strings, symbols, or bit-vectors.  But if the string is enormous,
   *    this function can bring us to a complete halt, which is annoying if it is the error
   *    handler that is trying to write the string.  I think if port is sc->error_port, I'll
   *    truncate strings to some reasonable size -- (*s7* 'max-format-length) maybe.
   */
  if ((len > sc->max_format_length) &&
      (port == sc->error_port))
    len = sc->max_format_length;
  if (quoted) port_write_character(port)(sc, '"', port);
  for (pcur = (uint8_t *)p; pcur < pend; pcur++)
    {
      if (slashify_table[*pcur])
	{
	  if (pstart) pstart++; else pstart = (uint8_t *)p;
	  if (pstart != pcur)
	    {
	      port_write_string(port)(sc, (char *)pstart, pcur - pstart, port);
	      pstart = pcur;
	    }
	  port_write_character(port)(sc, '\\', port);
	  switch (*pcur)
	    {
	    case '"':   port_write_character(port)(sc, '"', port);   break;
	    case '\\':  port_write_character(port)(sc, '\\', port);  break;
	    case '\'':  port_write_character(port)(sc, '\'', port);  break;
	    case '\t':  port_write_character(port)(sc, 't', port);   break;
	    case '\r':  port_write_character(port)(sc, 'r', port);   break;
	    case '\b':  port_write_character(port)(sc, 'b', port);   break;
	    case '\f':  port_write_character(port)(sc, 'f', port);   break;
	    case '\?':  port_write_character(port)(sc, '?', port);   break;
	    case 'x':   port_write_character(port)(sc, 'x', port);   break;
	    default:
	      {
		s7_int n;
		port_write_character(port)(sc, 'x', port);
		n = (s7_int)(*pcur);
		if (n < 16)
		  port_write_character(port)(sc, '0', port);
		else port_write_character(port)(sc, dignum[(n / 16) % 16], port);
		port_write_character(port)(sc, dignum[n % 16], port);
		port_write_character(port)(sc, ';', port);
	      }
	      break;
	    }
	}
    }
  if (!pstart)
    port_write_string(port)(sc, (char *)p, len, port);
  else
    {
      pstart++;
      if (pstart != pcur)
	port_write_string(port)(sc, (char *)pstart, pcur - pstart, port);
    }
  if (quoted) port_write_character(port)(sc, '"', port);
}

static void output_port_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if ((obj == sc->standard_output) ||
      (obj == sc->standard_error))
    port_write_string(port)(sc, port_filename(obj), port_filename_length(obj), port);
  else
    {
      if (use_write == P_READABLE)
	{
	  if (port_is_closed(obj))
	    port_write_string(port)(sc, "(let ((p (open-output-string))) (close-output-port p) p)", 56, port);
	  else
	    {
	      if (is_string_port(obj))
		{
		  port_write_string(port)(sc, "(let ((p (open-output-string)))", 31, port);
		  if (port_position(obj) > 0)
		    {
		      port_write_string(port)(sc, " (display ", 10, port);
		      slashify_string_to_port(sc, port, (const char *)port_data(obj), port_position(obj), IN_QUOTES);
		      port_write_string(port)(sc, " p)", 3, port);
		    }
		  port_write_string(port)(sc, " p)", 3, port);
		}
	      else
		{
		  char str[256];
		  int32_t nlen;
		  str[0] = '\0';
		  nlen = catstrs(str, 256, "(open-output-file \"", port_filename(obj), "\" \"a\")", NULL);
		  port_write_string(port)(sc, str, nlen, port);
		}
	    }
	}
      else
	{
	  if (is_string_port(obj))
	    port_write_string(port)(sc, "<output-string-port", 19, port);
	  else
	    {
	      if (is_file_port(obj))
		port_write_string(port)(sc, "<output-file-port", 17, port);
	      else port_write_string(port)(sc, "<output-function-port", 21, port);
	    }
	  if (port_is_closed(obj))
	    port_write_string(port)(sc, " (closed)>", 10, port);
	  else port_write_character(port)(sc, '>', port);
	}
    }
}

static void input_port_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (obj == sc->standard_input)
    port_write_string(port)(sc, port_filename(obj), port_filename_length(obj), port);
  else
    {
      if (use_write == P_READABLE)
	{
	  if (port_is_closed(obj))
	    port_write_string(port)(sc, "(call-with-input-string \"\" (lambda (p) p))", 42, port);
	  else
	    {
	      if (is_function_port(obj))
		port_write_string(port)(sc, "#<input-function-port>", 22, port);
	      else
		{
		  if (is_file_port(obj))
		    {
		      char str[256];
		      int32_t nlen;
		      str[0] = '\0';
		      nlen = catstrs(str, 256, "(open-input-file \"", port_filename(obj), "\")", NULL);
		      port_write_string(port)(sc, str, nlen, port);
		    }
		  else
		    {
		      s7_int data_len;
		      data_len = port_data_size(obj) - port_position(obj);
		      if (data_len > 100)
			{
			  const char *filename;
			  filename = (const char *)s7_port_filename(sc, obj);
			  if (filename)
			    {
			      #define DO_STR_LEN 1024
			      char do_str[DO_STR_LEN];
			      int32_t len;
			      do_str[0] = '\0';
			      if (port_position(obj) > 0)
				{
				  len = catstrs(do_str, DO_STR_LEN, "(let ((port (open-input-file \"", filename, "\")))", NULL);
				  port_write_string(port)(sc, do_str, len, port);
				  do_str[0] = '\0';
				  len = catstrs(do_str, DO_STR_LEN, " (do ((i 0 (+ i 1)) (c (read-char port) (read-char port))) ((= i ",
						pos_int_to_str_direct(sc, port_position(obj) - 1),
						") port)))", NULL);
				}
			      else len = catstrs(do_str, DO_STR_LEN, "(open-input-file \"", filename, "\")", NULL);
			      port_write_string(port)(sc, do_str, len, port);
			      return;
			    }
			}
		      port_write_string(port)(sc, "(open-input-string ", 19, port);
		      /* not port_write_string here because there might be embedded double-quotes */
		      slashify_string_to_port(sc, port, (const char *)(port_data(obj) + port_position(obj)), port_data_size(obj) - port_position(obj), IN_QUOTES);
		      port_write_character(port)(sc, ')', port);
		    }
		}
	    }
	}
      else
	{
	  if (is_string_port(obj))
	    port_write_string(port)(sc, "<input-string-port", 18, port);
	  else
	    {
	      if (is_file_port(obj))
		port_write_string(port)(sc, "<input-file-port", 16, port);
	      else port_write_string(port)(sc, "<input-function-port", 20, port);
	    }
	  if (port_is_closed(obj))
	    port_write_string(port)(sc, " (closed)>", 10, port);
	  else port_write_character(port)(sc, '>', port);
	}
    }
}

static bool symbol_needs_slashification(s7_scheme *sc, s7_pointer obj)
{
  uint8_t *p, *pend;
  const char *str;
  s7_int len;

  str = symbol_name(obj);
  if ((str[0] == '#') || (str[0] == '\'') || (str[0] == ','))
    return(true);

  if (s7_is_number(make_atom(sc, (char *)str, 10, NO_SYMBOLS, WITHOUT_OVERFLOW_ERROR)))
    return(true);

  len = symbol_name_length(obj);
  pend = (uint8_t *)(str + len);
  for (p = (uint8_t *)str; p < pend; p++)
    if (symbol_slashify_table[*p])
      return(true);

  set_clean_symbol(obj);
  return(false);
}

static inline void symbol_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  /* I think this is the only place we print a symbol's name */
  if ((!is_clean_symbol(obj)) &&
      (symbol_needs_slashification(sc, obj)))
    {
      port_write_string(port)(sc, "(symbol \"", 9, port);
      slashify_string_to_port(sc, port, symbol_name(obj), symbol_name_length(obj), NOT_IN_QUOTES);
      port_write_string(port)(sc, "\")", 2, port);
    }
  else
    {
      if (!is_keyword(obj))
	{
	  if (use_write == P_READABLE)
	    port_write_character(port)(sc, '\'', port);
	  else
	    {
	      if (use_write == P_KEY)
		port_write_character(port)(sc, ':', port);
	    }
	}
      if (is_string_port(port))
	{
	  s7_int new_len;
	  new_len = port_position(port) + symbol_name_length(obj);
	  if (new_len >= port_data_size(port))
	    resize_port_data(sc, port, new_len * 2);
	  memcpy((void *)(port_data(port) + port_position(port)), (void *)symbol_name(obj), symbol_name_length(obj));
	  port_position(port) = new_len;
	}
      else port_write_string(port)(sc, symbol_name(obj), symbol_name_length(obj), port);
    }
}

static char *multivector_indices_to_string(s7_scheme *sc, s7_int index, s7_pointer vect, char *str, int32_t cur_dim)
{
  s7_int size, ind;

  size = vector_dimension(vect, cur_dim);
  ind = index % size;
  if (cur_dim > 0)
    multivector_indices_to_string(sc, (index - ind) / size, vect, str, cur_dim - 1);
  catstrs(str, 128, " ", pos_int_to_str_direct(sc, ind), NULL);
  return(str);
}

#define NOT_P_DISPLAY(Choice) ((Choice == P_DISPLAY) ? P_WRITE : Choice)

static int32_t multivector_to_port(s7_scheme *sc, s7_pointer vec, s7_pointer port,
				   int32_t out_len, int32_t flat_ref, int32_t dimension, int32_t dimensions, bool *last,
				   use_write_t use_write, shared_info *ci)
{
  int32_t i;
  if (use_write != P_READABLE)
    {
      if (*last)
	port_write_string(port)(sc, " (", 2, port);
      else port_write_character(port)(sc, '(', port);
      (*last) = false;
    }

  for (i = 0; i < vector_dimension(vec, dimension); i++)
    {
      if (dimension == (dimensions - 1))
	{
	  if (flat_ref < out_len)
	    {
	      object_to_port_with_circle_check(sc, vector_getter(vec)(sc, vec, flat_ref), port, NOT_P_DISPLAY(use_write), ci);

	      if (use_write == P_READABLE)
		port_write_string(port)(sc, ") ", 2, port);
	      flat_ref++;
	    }
	  else
	    {
	      port_write_string(port)(sc, "...)", 4, port);
	      return(flat_ref);
	    }
	  if ((use_write != P_READABLE) &&
	      (i < (vector_dimension(vec, dimension) - 1)))
	    port_write_character(port)(sc, ' ', port);
	}
      else
	{
	  if (flat_ref < out_len)
	    flat_ref = multivector_to_port(sc, vec, port, out_len, flat_ref, dimension + 1, dimensions, last, NOT_P_DISPLAY(use_write), ci);
	  else
	    {
	      port_write_string(port)(sc, "...)", 4, port);
	      return(flat_ref);
	    }
	}
    }
  if (use_write != P_READABLE)
    port_write_character(port)(sc, ')', port);
  (*last) = true;
  return(flat_ref);
}

static void make_vector_to_port(s7_scheme *sc, s7_pointer vect, s7_pointer port)
{
  s7_int vlen;
  int32_t plen;
  char buf[128];
  const char* vtyp = "";

  if (is_float_vector(vect))
    vtyp = "float-";
  else
    {
      if (is_int_vector(vect))
	vtyp = "int-";
      else
	{
	  if (is_byte_vector(vect))
	    vtyp = "byte-";
	}
    }

  vlen = vector_length(vect);
  if (vector_rank(vect) == 1)
    {
      plen = catstrs_direct(buf, "(make-", vtyp, "vector ", integer_to_string_no_length(sc, vlen), " ", NULL);
      port_write_string(port)(sc, buf, plen, port);
    }
  else
    {
      s7_int dim;
      plen = catstrs_direct(buf, "(make-", vtyp, "vector '(", NULL);
      port_write_string(port)(sc, buf, plen, port);
      for (dim = 0; dim < vector_ndims(vect) - 1; dim++)
	{
	  plen = catstrs_direct(buf, integer_to_string_no_length(sc, vector_dimension(vect, dim)), " ", NULL);
	  port_write_string(port)(sc, buf, plen, port);
	}
      plen = catstrs_direct(buf, integer_to_string_no_length(sc, vector_dimension(vect, dim)), ") ", NULL);
      port_write_string(port)(sc, buf, plen, port);
    }
}

static void write_vector_dimensions(s7_scheme *sc, s7_pointer vect, s7_pointer port)
{
  char buf[128];
  s7_int dim, plen;
  port_write_string(port)(sc, " '(", 3, port);
  for (dim = 0; dim < vector_ndims(vect) - 1; dim++)
    {
      plen = catstrs_direct(buf, integer_to_string_no_length(sc, vector_dimension(vect, dim)), " ", NULL);
      port_write_string(port)(sc, buf, plen, port);
    }
  plen = catstrs_direct(buf, integer_to_string_no_length(sc, vector_dimension(vect, dim)), "))", NULL);
  port_write_string(port)(sc, buf, plen, port);
}

static void vector_to_port(s7_scheme *sc, s7_pointer vect, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  s7_int i, len, plen;
  bool too_long = false;
  char buf[128];

  len = vector_length(vect);
  if (len == 0)
    {
      if (vector_rank(vect) > 1)
	{
	  plen = catstrs_direct(buf, "#", pos_int_to_str_direct(sc, vector_ndims(vect)), "d()", NULL);
	  port_write_string(port)(sc, buf, plen, port);
	}
      else port_write_string(port)(sc, "#()", 3, port);
      return;
    }

  if (use_write != P_READABLE)
    {
      if (sc->print_length == 0)
	{
	  if (vector_rank(vect) > 1)
	    {
	      plen = catstrs_direct(buf, "#", pos_int_to_str_direct(sc, vector_ndims(vect)), "d(...)", NULL);
	      port_write_string(port)(sc, buf, plen, port);
	    }
	  else port_write_string(port)(sc, "#(...)", 6, port);
	  return;
	}
      if (len > sc->print_length)
	{
	  too_long = true;
	  len = sc->print_length;
	}
    }
  if ((!ci) &&
      (len > 1000))
    {
      s7_int vlen;
      s7_pointer p0;
      s7_pointer *els;
      vlen = vector_length(vect);
      els = vector_elements(vect);
      p0 = els[0];
      for (i = 1; i < vlen; i++)
	if (els[i] != p0)
	  break;
      if (i == vlen)
	{
	  make_vector_to_port(sc, vect, port);
	  object_to_port(sc, p0, port, use_write, NULL);
	  port_write_character(port)(sc, ')', port);
	  return;
	}
    }
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, vect);
  if (use_write == P_READABLE)
    {
      if ((ci) &&
	  (is_cyclic(vect)) &&
	  (peek_shared_ref(ci, vect) != 0))
	{
	  s7_pointer *els;
	  int32_t vref;
	  vref = peek_shared_ref(ci, vect);
	  if (vref < 0) vref = -vref;

	  els = vector_elements(vect);

	  if ((ci->defined[vref]) || (port == ci->cycle_port))
	    {
	      plen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, vref), ">", NULL);
	      port_write_string(port)(sc, buf, plen, port);
	      unstack(sc);
	      return;
	    }

	  if (vector_rank(vect) > 1)
	    port_write_string(port)(sc, "(subvector ", 11, port);

	  port_write_string(port)(sc, "(vector", 7, port); /* top level let */
	  for (i = 0; i < len; i++)
	    {
	      if (has_structure(els[i]))
		{
		  char *indices;
		  int32_t eref;
		  port_write_string(port)(sc, " #f", 3, port);
		  eref = peek_shared_ref(ci, els[i]);

		  if (eref != 0)
		    {
		      if (eref < 0) eref = -eref;
		      if (vector_rank(vect) > 1)
			{
			  s7_int dimension;
			  block_t *b;
			  dimension = vector_rank(vect) - 1;
			  b = callocate(sc, 128);
			  indices = (char *)block_data(b);
			  plen = catstrs_direct(buf, "  (set! (<", pos_int_to_str_direct(sc, vref), ">",
						multivector_indices_to_string(sc, i, vect, indices, dimension),
						") <", pos_int_to_str_direct_1(sc, eref), ">)\n ", NULL);
			  port_write_string(ci->cycle_port)(sc, buf, plen, ci->cycle_port);
			  liberate(sc, b);
			}
		      else
			{
			  size_t len1;
			  len1 = catstrs_direct(buf, "  (set! (<", pos_int_to_str_direct(sc, vref), "> ",
						integer_to_string(sc, i, &plen), ") <",
						pos_int_to_str_direct_1(sc, eref), ">)\n", NULL);
			  port_write_string(ci->cycle_port)(sc, buf, len1, ci->cycle_port);
			}

		    }
		  else
		    {
		      if (vector_rank(vect) > 1)
			{
			  s7_int dimension;
			  block_t *b;
			  dimension = vector_rank(vect) - 1;
			  b = callocate(sc, 128);
			  indices = (char *)block_data(b);
			  buf[0] = '\0';
			  multivector_indices_to_string(sc, i, vect, indices, dimension); /* writes to indices */
			  plen = catstrs(buf, 128, "  (set! (<", pos_int_to_str_direct(sc, vref), ">", indices, ") ", NULL);
			  port_write_string(ci->cycle_port)(sc, buf, plen, ci->cycle_port);
			  liberate(sc, b);
			}
		      else
			{
			  size_t len1;
			  len1 = catstrs_direct(buf, "  (set! (<", pos_int_to_str_direct(sc, vref), "> ", integer_to_string_no_length(sc, i), ") ", NULL);
			  port_write_string(ci->cycle_port)(sc, buf, len1, ci->cycle_port);
			}

		      object_to_port_with_circle_check(sc, els[i], ci->cycle_port, P_READABLE, ci);
		      port_write_string(ci->cycle_port)(sc, ")\n", 2, ci->cycle_port);
		    }
		}
	      else
		{
		  port_write_character(port)(sc, ' ', port);
		  object_to_port_with_circle_check(sc, els[i], port, P_READABLE, ci);
		}
	    }
	  port_write_character(port)(sc, ')', port);
	  if (vector_rank(vect) > 1)
	    write_vector_dimensions(sc, vect, port);
	}
      else
	{
	  if (vector_rank(vect) > 1)
	    port_write_string(port)(sc, "(subvector ", 11, port);

	  if (is_immutable_vector(vect))
	    port_write_string(port)(sc, "(immutable! ", 12, port);

	  port_write_string(port)(sc, "(vector", 7, port);
	  for (i = 0; i < len; i++)
	    {
	      port_write_character(port)(sc, ' ', port);
	      object_to_port_with_circle_check(sc, vector_element(vect, i), port, P_READABLE, ci);
	    }
	  port_write_character(port)(sc, ')', port);
	  if (is_immutable_vector(vect))
	    port_write_character(port)(sc, ')', port);

	  if (vector_rank(vect) > 1)
	    write_vector_dimensions(sc, vect, port);
	}
    }
  else /* not readable write */
    {
      if (vector_rank(vect) > 1)
	{
	  bool last = false;
	  if (vector_ndims(vect) > 1)
	    {
	      plen = catstrs_direct(buf, "#", pos_int_to_str_direct(sc, vector_ndims(vect)), "d", NULL);
	      port_write_string(port)(sc, buf, plen, port);
	    }
	  else port_write_character(port)(sc, '#', port);
	  multivector_to_port(sc, vect, port, len, 0, 0, vector_ndims(vect), &last, use_write, ci);
	}
      else
	{
	  port_write_string(port)(sc, "#(", 2, port);
	  for (i = 0; i < len - 1; i++)
	    {
	      object_to_port_with_circle_check(sc, vector_element(vect, i), port, NOT_P_DISPLAY(use_write), ci);
	      port_write_character(port)(sc, ' ', port);
	    }
	  object_to_port_with_circle_check(sc, vector_element(vect, i), port, NOT_P_DISPLAY(use_write), ci);

	  if (too_long)
	    port_write_string(port)(sc, " ...)", 5, port);
	  else port_write_character(port)(sc, ')', port);
	}
    }
  unstack(sc);
}

static int32_t print_vector_length(s7_scheme *sc, s7_pointer vect, s7_pointer port, use_write_t use_write)
{
  int32_t len, plen;
  char buf[128];
  const char *vtype = "r";

  if (is_int_vector(vect))
    vtype = "i";
  else
    {
      if (is_byte_vector(vect))
	vtype = "u";
    }
  len = vector_length(vect);
  if (len == 0)
    {
      if (vector_rank(vect) > 1)
	plen = catstrs_direct(buf, "#", vtype, pos_int_to_str_direct(sc, vector_ndims(vect)), "d()", NULL);
      else plen = catstrs_direct(buf, "#", vtype, "()", NULL);
      port_write_string(port)(sc, buf, plen, port);
      return(-1);
    }

  if (use_write == P_READABLE)
    return(len);

  if (sc->print_length == 0)
    {
      if (vector_rank(vect) > 1)
	{
	  plen = catstrs_direct(buf, "#", vtype, pos_int_to_str_direct(sc, vector_ndims(vect)), "d(...)", NULL);
	  port_write_string(port)(sc, buf, plen, port);
	}
      else
	{
	  if (is_int_vector(vect))
	    port_write_string(port)(sc, "#i(...)", 7, port);
	  else
	    {
	      if (is_float_vector(vect))
		port_write_string(port)(sc, "#r(...)", 7, port);
	      else port_write_string(port)(sc, "#u(...)", 7, port);
	    }
	}
      return(-1);
    }

  if (len > sc->print_length)
    return(sc->print_length);
  return(len);
}

static void int_vector_to_port(s7_scheme *sc, s7_pointer vect, s7_pointer port, use_write_t use_write, shared_info *ignored)
{
  s7_int i, len, plen;
  bool too_long;
  char buf[128];
  char *p;

  len = print_vector_length(sc, vect, port, use_write);
  if (len < 0) return;
  too_long = (len < vector_length(vect));

  if ((use_write == P_READABLE) &&
      (is_immutable_vector(vect)))
    port_write_string(port)(sc, "(immutable! ", 12, port);

  if (len > 1000)
    {
      s7_int vlen;
      s7_int first;
      s7_int *els;
      vlen = vector_length(vect);
      els = int_vector_ints(vect);
      first = els[0];
      for (i = 1; i < vlen; i++)
	if (els[i] != first)
	  break;
      if (i == vlen)
	{
	  make_vector_to_port(sc, vect, port);
	  p = integer_to_string(sc, int_vector(vect, 0), &plen);
	  port_write_string(port)(sc, p, plen, port);
	  port_write_character(port)(sc, ')', port);
	  if ((use_write == P_READABLE) &&
	      (is_immutable_vector(vect)))
	    port_write_character(port)(sc, ')', port);
	  return;
	}
    }

  if (vector_rank(vect) == 1)
    {
      port_write_string(port)(sc, "#i(", 3, port);
      if (!is_string_port(port))
	{
	  p = integer_to_string(sc, int_vector(vect, 0), &plen);
	  port_write_string(port)(sc, p, plen, port);
	  for (i = 1; i < len; i++)
	    {
	      plen = catstrs_direct(buf, " ", integer_to_string_no_length(sc, int_vector(vect, i)), NULL);
	      port_write_string(port)(sc, buf, plen, port);
	    }
	}
      else
	{
	  /* an experiment */
	  s7_int new_len, next_len;
	  uint8_t *dbuf;
	  new_len = port_position(port);
	  next_len = port_data_size(port) - 128;
	  dbuf = port_data(port);

	  if (new_len >= next_len)
	    {
	      resize_port_data(sc, port, port_data_size(port) * 2);
	      next_len = port_data_size(port) - 128;
	      dbuf = port_data(port);
	    }
	  p = integer_to_string(sc, int_vector(vect, 0), &plen);
	  memcpy((void *)(dbuf + new_len), (void *)p, plen);
	  new_len += plen;
	  for (i = 1; i < len; i++)
	    {
	      if (new_len >= next_len)
		{
		  resize_port_data(sc, port, port_data_size(port) * 2);
		  next_len = port_data_size(port) - 128;
		  dbuf = port_data(port);
		}
	      plen = catstrs_direct(buf, " ", integer_to_string_no_length(sc, int_vector(vect, i)), NULL);
	      memcpy((void *)(dbuf + new_len), (void *)buf, plen);
	      new_len += plen;
	    }
	  port_position(port) = new_len;
	}

      if (too_long)
	port_write_string(port)(sc, " ...)", 5, port);
      else port_write_character(port)(sc, ')', port);
    }
  else
    {
      bool last = false;
      plen = catstrs_direct(buf, "#i", pos_int_to_str_direct(sc, vector_ndims(vect)), "d", NULL);
      port_write_string(port)(sc, buf, plen, port);
      multivector_to_port(sc, vect, port, len, 0, 0, vector_ndims(vect), &last, P_DISPLAY, NULL);
    }

  if ((use_write == P_READABLE) &&
      (is_immutable_vector(vect)))
    port_write_character(port)(sc, ')', port);
}

static void float_vector_to_port(s7_scheme *sc, s7_pointer vect, s7_pointer port, use_write_t use_write, shared_info *ignored)
{
  s7_int i, len, plen;
  bool too_long;
  char buf[128];
  s7_double *els;

  len = print_vector_length(sc, vect, port, use_write);
  if (len < 0) return;
  too_long = (len < vector_length(vect));
  els = float_vector_floats(vect);

  if ((use_write == P_READABLE) &&
      (is_immutable_vector(vect)))
    port_write_string(port)(sc, "(immutable! ", 12, port);

  if (len > 1000)
    {
      s7_int vlen;
      s7_double first;
      vlen = vector_length(vect);
      first = els[0];
      for (i = 1; i < vlen; i++)
	if (els[i] != first)
	  break;
      if (i == vlen)
	{
	  make_vector_to_port(sc, vect, port);
	  plen = snprintf(buf, 128, "%.*g)", sc->float_format_precision, first);
	  port_write_string(port)(sc, buf, plen, port);
	  if ((use_write == P_READABLE) &&
	      (is_immutable_vector(vect)))
	    port_write_character(port)(sc, ')', port);
	  return;
	}
    }

  if (vector_rank(vect) == 1)
    {
      port_write_string(port)(sc, "#r(", 3, port);
      plen = snprintf(buf, 124, "%.*g", sc->float_format_precision, els[0]); /* 124 so floatify has room */
      floatify(buf, &plen);
      port_write_string(port)(sc, buf, plen, port);
      for (i = 1; i < len; i++)
	{
	  plen = snprintf(buf, 124, " %.*g", sc->float_format_precision, els[i]);
	  floatify(buf, &plen);
	  port_write_string(port)(sc, buf, plen, port);
	}
      if (too_long)
	port_write_string(port)(sc, " ...)", 5, port);
      else port_write_character(port)(sc, ')', port);
    }
  else
    {
      bool last = false;
      plen = catstrs_direct(buf, "#r", pos_int_to_str_direct(sc, vector_ndims(vect)), "d", NULL);
      port_write_string(port)(sc, buf, plen, port);
      multivector_to_port(sc, vect, port, len, 0, 0, vector_ndims(vect), &last, P_DISPLAY, NULL);
    }

  if ((use_write == P_READABLE) &&
      (is_immutable_vector(vect)))
    port_write_character(port)(sc, ')', port);
}

static void byte_vector_to_port(s7_scheme *sc, s7_pointer vect, s7_pointer port, use_write_t use_write, shared_info *ignored)
{
  s7_int i, len, plen;
  bool too_long;
  char buf[128];
  char *p;

  len = print_vector_length(sc, vect, port, use_write);
  if (len < 0) return;
  too_long = (len < vector_length(vect));

  if ((use_write == P_READABLE) &&
      (is_immutable_vector(vect)))
    port_write_string(port)(sc, "(immutable! ", 12, port);

  if (len > 1000)
    {
      s7_int vlen;
      uint8_t first;
      uint8_t *els;
      vlen = vector_length(vect);
      els = byte_vector_bytes(vect);
      first = els[0];
      for (i = 1; i < vlen; i++)
	if (els[i] != first)
	  break;
      if (i == vlen)
	{
	  make_vector_to_port(sc, vect, port);
	  p = integer_to_string(sc, byte_vector(vect, 0), &plen);
	  port_write_string(port)(sc, p, plen, port);
	  port_write_character(port)(sc, ')', port);
	  if ((use_write == P_READABLE) &&
	      (is_immutable_vector(vect)))
	    port_write_character(port)(sc, ')', port);
	  return;
	}
    }

  if (vector_rank(vect) == 1)
    {
      port_write_string(port)(sc, "#u(", 3, port);
      p = integer_to_string(sc, byte_vector(vect, 0), &plen);
      port_write_string(port)(sc, p, plen, port);
      for (i = 1; i < len; i++)
	{
	  plen = catstrs_direct(buf, " ", integer_to_string_no_length(sc, byte_vector(vect, i)), NULL);
	  port_write_string(port)(sc, buf, plen, port);
	}
      if (too_long)
	port_write_string(port)(sc, " ...)", 5, port);
      else port_write_character(port)(sc, ')', port);
    }
  else
    {
      bool last = false;
      plen = catstrs_direct(buf, "#u", pos_int_to_str_direct(sc, vector_ndims(vect)), "d", NULL);
      port_write_string(port)(sc, buf, plen, port);
      multivector_to_port(sc, vect, port, len, 0, 0, vector_ndims(vect), &last, P_DISPLAY, NULL);
    }

  if ((use_write == P_READABLE) &&
      (is_immutable_vector(vect)))
    port_write_character(port)(sc, ')', port);
}

static void string_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ignored)
{
  if ((use_write == P_READABLE) &&
      (is_immutable_string(obj)))
    port_write_string(port)(sc, "(immutable! ", 12, port);

  if (string_length(obj) > 0)
    {
      /* since string_length is a scheme length, not C, this write can embed nulls from C's point of view */
      if (string_length(obj) > 1000) /* was 10000 28-Feb-18 */
	{
	  size_t size;
	  char buf[128];
	  buf[0] = string_value(obj)[0];
	  buf[1] = '\0';
	  size = strspn((const char *)(string_value(obj) + 1), buf); /* if all #\null, this won't work */
	  if (size == (size_t)(string_length(obj) - 1))
	    {
	      int32_t nlen;
	      s7_pointer c;
	      c = chars[(int32_t)((uint8_t)(buf[0]))];
	      nlen = catstrs_direct(buf, "(make-string ", pos_int_to_str_direct(sc, string_length(obj)), " ", NULL);
	      port_write_string(port)(sc, buf, nlen, port);
	      port_write_string(port)(sc, character_name(c), character_name_length(c), port);
	      port_write_character(port)(sc, ')', port);
	      if ((use_write == P_READABLE) &&
		  (is_immutable_string(obj)))
		port_write_character(port)(sc, ')', port);
	      return;
	    }
	}
      if (use_write == P_DISPLAY)
	port_write_string(port)(sc, string_value(obj), string_length(obj), port);
      else
	{
	  if (!string_needs_slashification(string_value(obj), string_length(obj)))
	    {
	      port_write_character(port)(sc, '"', port);
	      port_write_string(port)(sc, string_value(obj), string_length(obj), port);
	      port_write_character(port)(sc, '"', port);
	    }
	  else slashify_string_to_port(sc, port, string_value(obj), string_length(obj), IN_QUOTES);
	}
    }
  else
    {
      if (use_write != P_DISPLAY)
	port_write_string(port)(sc, "\"\"", 2, port);
    }
  if ((use_write == P_READABLE) &&
      (is_immutable_string(obj)))
    port_write_character(port)(sc, ')', port);
}

static void simple_list_readable_display(s7_scheme *sc, s7_pointer lst, s7_int true_len, s7_int len, s7_pointer port, shared_info *ci)
{
  /* the easier cases: no circles or shared refs to patch up */
  s7_pointer x;

  if (is_immutable(lst))
    port_write_string(port)(sc, "immutable! (", 12, port);

  if (true_len > 0)
    {
      port_write_string(port)(sc, "list", 4, port);
      for (x = lst; is_pair(x); x = cdr(x))
	{
	  port_write_character(port)(sc, ' ', port);
	  object_to_port_with_circle_check(sc, car(x), port, P_READABLE, ci);
	}
      port_write_character(port)(sc, ')', port);
    }
  else
    {
      s7_int i;
      port_write_string(port)(sc, "cons ", 5, port);
      object_to_port_with_circle_check(sc, car(lst), port, P_READABLE, ci);
      for (x = cdr(lst); is_pair(x); x = cdr(x))
	{
	  port_write_string(port)(sc, " (cons ", 7, port);
	  object_to_port_with_circle_check(sc, car(x), port, P_READABLE, ci);
	}
      port_write_character(port)(sc, ' ', port);
      object_to_port_with_circle_check(sc, x, port, P_READABLE, ci);
      for (i = 1; i < len; i++)
	port_write_character(port)(sc, ')', port);
    }
  if (is_immutable(lst))
    port_write_character(port)(sc, ')', port);
}

static void pair_to_port(s7_scheme *sc, s7_pointer lst, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  /* we need list_to_starboard... (making port_write_string|character local was noticeably slower) */
  s7_pointer x;
  s7_int i, len, true_len;

  true_len = s7_list_length(sc, lst);
  if (true_len < 0)                    /* a dotted list -- handle cars, then final cdr */
    len = (-true_len + 1);
  else
    {
      if (true_len == 0)               /* circular list (nil is handled by unique_to_port) */
	len = circular_list_entries(lst);
      else len = true_len;
    }

  if ((use_write == P_READABLE) &&
      (ci) &&
      (peek_shared_ref(ci, lst) != 0))
    {
      int32_t href;
      href = peek_shared_ref(ci, lst);
      if (href < 0) href = -href;
      if ((ci->defined[href]) || (port == ci->cycle_port))
	{
	  char buf[128];
	  int32_t plen;
	  plen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, href), ">", NULL);
	  port_write_string(port)(sc, buf, plen, port);
	  return;
	}
    }

  if ((use_write != P_READABLE) &&
      (car(lst) == sc->quote_symbol) &&
      (true_len == 2))
    {
      /* len == 1 is important, otherwise (list 'quote 1 2) -> '1 2 which looks weird
       *   or (object->string (apply . `''1)) -> "'quote 1"
       * so (quote x) = 'x but (quote x y z) should be left alone (if evaluated, it's an error)
       * :readable is tricky because the list might be something like (list 'quote (lambda () #f)) which needs to be evalable back to its original
       */
      port_write_character(port)(sc, '\'', port);
      object_to_port_with_circle_check(sc, cadr(lst), port, P_WRITE, ci);
      return;
    }

  port_write_character(port)(sc, '(', port);
  if (is_multiple_value(lst))
    port_write_string(port)(sc, "values ", 7, port);

  push_stack_no_let_no_code(sc, OP_GC_PROTECT, lst);
  /* (define (f) (display (make-list 1001 (mock-string #\h #\o #\h #\o))) (newline)) (do ((i 0 (+ i 1))) ((= i 1000)) (f)) */

  if (use_write == P_READABLE)
    {
      if (!is_cyclic(lst))
	{
	  simple_list_readable_display(sc, lst, true_len, len, port, ci);
	  unstack(sc);
	  return;
	}
      if (ci)
	{
	  int32_t plen;
	  char buf[128], lst_name[128];
	  int32_t lst_ref;
	  bool lst_local = false;
	  s7_pointer local_port;

	  lst_ref = peek_shared_ref(ci, lst);
	  if (lst_ref == 0)
	    {
	      s7_pointer p;
	      for (p = lst; is_pair(p); p = cdr(p))
		if ((has_structure(car(p))) ||
		    ((is_pair(cdr(p))) &&
		     (peek_shared_ref(ci, cdr(p)) != 0)))
		  {
		    lst_name[0] = '<'; lst_name[1] = 'L'; lst_name[2] = '>'; lst_name[3] = '\0';
		    lst_local = true;
		    port_write_string(port)(sc, "let ((<L> (list", 15, port); /* '(' above */
		    break;
		  }
	      if ((!lst_local) && (!is_null(p)))
		{
		  if (has_structure(p))
		    {
		      lst_name[0] = '<'; lst_name[1] = 'L'; lst_name[2] = '>'; lst_name[3] = '\0';
		      lst_local = true;
		      port_write_string(port)(sc, "let ((<L> (list", 15, port); /* '(' above */
		    }
		}
	      if (!lst_local)
		{
		  simple_list_readable_display(sc, lst, true_len, len, port, ci);
		  unstack(sc);
		  return;
		}
	    }
	  else
	    {
	      if (lst_ref < 0) lst_ref = -lst_ref;
	      catstrs_direct(lst_name, "<", pos_int_to_str_direct(sc, lst_ref), ">", NULL);
	      port_write_string(port)(sc, "list", 4, port); /* '(' above */
	    }

	  for (i = 0, x = lst; (i < len) && (is_pair(x)); x = cdr(x), i++)
	    {
	      if ((has_structure(car(x))) &&
		  (is_cyclic(car(x))))
		port_write_string(port)(sc, " #f", 3, port);
	      else
		{
		  port_write_character(port)(sc, ' ', port);
		  object_to_port_with_circle_check(sc, car(x), port, use_write, ci);
		}
	      if ((is_pair(cdr(x))) &&
		  (peek_shared_ref(ci, cdr(x)) != 0))
		break;
	    }

	  if (lst_local)
	    port_write_string(port)(sc, ")))\n", 4, port);
	  else port_write_character(port)(sc, ')', port);

	  /* fill in the cyclic entries */
	  local_port = ((lst_local) || (ci->cycle_port == sc->F)) ? port : ci->cycle_port; /* (object->string (list-values `(x . 1) (signature (int-vector))) :readable) */
	  for (x = lst, i = 0; (i < len) && (is_pair(x)); x = cdr(x), i++)
	    {
	      if ((has_structure(car(x))) &&
		  (is_cyclic(car(x))))
		{
		  int32_t lref;
		  if (i == 0)
		    plen = catstrs_direct(buf, "  (set-car! ", lst_name, " ", NULL);
		  else plen = catstrs_direct(buf, "  (set! (", lst_name, " ", pos_int_to_str_direct(sc, i), ") ", NULL);
		  port_write_string(local_port)(sc, buf, plen, local_port);
		  lref = peek_shared_ref(ci, car(x));
		  if (lref == 0)
		    object_to_port_with_circle_check(sc, car(x), local_port, use_write, ci);
		  else
		    {
		      if (lref < 0) lref = -lref;
		      plen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, lref), ">", NULL);
		      port_write_string(local_port)(sc, buf, plen, local_port);
		    }
		  port_write_string(local_port)(sc, ")\n", 2, local_port);
		}
	      if ((is_pair(cdr(x))) &&
		  (peek_shared_ref(ci, cdr(x)) != 0))
		{
		  int32_t ref;
		  ref = peek_shared_ref(ci, cdr(x));
		  if (ref < 0) ref = -ref;
		  if (i == 0)
		    plen = catstrs_direct(buf, (lst_local) ? "    " : "  ", "(set-cdr! ", lst_name, " <", pos_int_to_str_direct(sc, ref), ">)\n", NULL);
		  else
		    {
		      if (i == 1)
			plen = catstrs_direct(buf, (lst_local) ? "    " : "  ", "(set-cdr! (cdr ", lst_name, ") <", pos_int_to_str_direct(sc, ref), ">)\n", NULL);
		      else plen = catstrs_direct(buf, (lst_local) ? "    " : "  ",
						 "(set-cdr! (list-tail ", lst_name, " ", pos_int_to_str_direct_1(sc, i),
						 ") <", pos_int_to_str_direct(sc, ref), ">)\n", NULL);
		    }
		  port_write_string(local_port)(sc, buf, plen, local_port);
		  break;
		}
	    }
	  if (true_len < 0) /* dotted list */
	    {
	      s7_pointer end_x;
	      for (end_x = lst; is_pair(end_x); end_x = cdr(end_x)); /* or maybe faster, start at x? */
	      /* we can't depend on the loops above to set x to the last element because they sometimes break out */
	      if (true_len == -1) /* cons cell */
		plen = catstrs_direct(buf, (lst_local) ? "    " : "  ", "(set-cdr! ", lst_name, " ", NULL);
	      else
		{
		  if (true_len == -2)
		    plen = catstrs_direct(buf, (lst_local) ? "    " : "  ", "(set-cdr! (cdr ", lst_name, ") ", NULL);
		  else plen = catstrs_direct(buf, "(set-cdr! (list-tail ", lst_name, " ", pos_int_to_str_direct(sc, len - 2), ") ", NULL);
		}
	      port_write_string(local_port)(sc, buf, plen, local_port);
	      object_to_port_with_circle_check(sc, end_x, local_port, use_write, ci);
	      port_write_string(local_port)(sc, ")\n", 2, local_port);
	    }

	  if (lst_local)
	    port_write_string(local_port)(sc, "    <L>)", 8, local_port);
	}
      else simple_list_readable_display(sc, lst, true_len, len, port, ci);
    }
  else /* not :readable */
    {
      s7_int plen;
      plen = (len > sc->print_length) ? sc->print_length : len;
      if (plen <= 0)
	{
	  port_write_string(port)(sc, "(...))", 6, port); /* open paren above about 150 lines, "list" here is wrong if it's a cons */
	  unstack(sc);
	  return;
	}

      if (ci)
	{
	  for (x = lst, i = 0; (is_pair(x)) && (i < plen) && ((i == 0) || (peek_shared_ref(ci, x) == 0)); i++, x = cdr(x))
	    {
	      object_to_port_with_circle_check(sc, car(x), port, NOT_P_DISPLAY(use_write), ci);
	      if (i < (len - 1))
		port_write_character(port)(sc, ' ', port);
	    }
	  if (is_not_null(x))
	    {
	      if (plen < len)
		port_write_string(port)(sc, " ...", 4, port);
	      else
		{
		  if ((true_len == 0) &&
		      (i == len))
		    port_write_string(port)(sc, " . ", 3, port);
		  else port_write_string(port)(sc, ". ", 2, port);
		  object_to_port_with_circle_check(sc, x, port, NOT_P_DISPLAY(use_write), ci);
		}
	    }
	  port_write_character(port)(sc, ')', port);
	}
      else
	{
	  s7_int len1;
	  len1 = plen - 1;
	  if (is_string_port(port))
	    {
	      for (x = lst, i = 0; (is_pair(x)) && (i < len1); i++, x = cdr(x))
		{
		  object_to_port(sc, car(x), port, NOT_P_DISPLAY(use_write), ci);
		  if (port_position(port) >= sc->objstr_max_len)
		    {
		      unstack(sc);
		      return;
		    }
		  if (port_position(port) >= port_data_size(port))
		    resize_port_data(sc, port, port_data_size(port) * 2);
		  port_data(port)[port_position(port)++] = (uint8_t)' ';
		}
	    }
	  else
	    {
	      for (x = lst, i = 0; (is_pair(x)) && (i < len1); i++, x = cdr(x))
		{
		  object_to_port(sc, car(x), port, NOT_P_DISPLAY(use_write), ci);
		  port_write_character(port)(sc, ' ', port);
		}
	    }
	  if (is_pair(x))
	    {
	      object_to_port(sc, car(x), port, NOT_P_DISPLAY(use_write), ci);
	      x = cdr(x);
	    }
	  if (is_not_null(x))
	    {
	      if (plen < len)
		port_write_string(port)(sc, " ...", 4, port);
	      else
		{
		  port_write_string(port)(sc, ". ", 2, port);
		  object_to_port(sc, x, port, NOT_P_DISPLAY(use_write), ci);
		}
	    }
	  port_write_character(port)(sc, ')', port);
	}
    }
  unstack(sc);
}

static void hash_table_to_port(s7_scheme *sc, s7_pointer hash, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  s7_int i, len, gc_iter;
  bool too_long = false;
  s7_pointer iterator, p;

  /* if hash is a member of ci, just print its number
   * (let ((ht (hash-table '(a . 1)))) (hash-table-set! ht 'b ht))
   *
   * since equal? does not care about the hash-table lengths, we can ignore that complication in the :readable case
   * there's no way to make a truly :readable version of a weak hash-table (or a normal hash-table that uses eq? with pairs, for example)
   */
  len = hash_table_entries(hash);
  if (len == 0)
    {
      if (is_weak_hash_table(hash))
	port_write_string(port)(sc, "(weak-hash-table)", 17, port);
      else port_write_string(port)(sc, "(hash-table)", 12, port);
      return;
    }

  if (use_write != P_READABLE)
    {
      s7_int plen;
      plen = sc->print_length;
      if (plen <= 0)
	{
	  port_write_string(port)(sc, "(hash-table ...)", 16, port);
	  return;
	}
      if (len > plen)
	{
	  too_long = true;
	  len = plen;
	}
    }

  if ((use_write == P_READABLE) &&
      (ci) &&
      (peek_shared_ref(ci, hash) != 0))
    {
      int32_t href;
      href = peek_shared_ref(ci, hash);
      if (href < 0) href = -href;
      if ((ci->defined[href]) || (port == ci->cycle_port))
	{
	  char buf[128];
	  int32_t plen;
	  plen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, href), ">", NULL);
	  port_write_string(port)(sc, buf, plen, port);
	  return;
	}
    }

  iterator = s7_make_iterator(sc, hash);
  gc_iter = s7_gc_protect_1(sc, iterator);
  p = cons(sc, sc->F, sc->F);
  iterator_current(iterator) = p;
  set_mark_seq(iterator);

  if ((use_write == P_READABLE) &&
      (is_immutable(hash)))
    port_write_string(port)(sc, "(immutable! ", 12, port);

  if ((use_write == P_READABLE) &&
      (ci) &&
      (is_cyclic(hash)) &&
      (peek_shared_ref(ci, hash) != 0))
    {
      int32_t href;
      href = peek_shared_ref(ci, hash);
      if (href < 0) href = -href;

      if (is_weak_hash_table(hash))
	port_write_string(port)(sc, "(weak-hash-table", 16, port);
      else port_write_string(port)(sc, "(hash-table", 11, port); /* top level let */
      for (i = 0; i < len; i++)
	{
	  s7_pointer key_val, key, val;

	  key_val = hash_table_iterate(sc, iterator);
	  key = car(key_val);
	  val = cdr(key_val);
	  if ((has_structure(val)) ||
	      (has_structure(key)))
	    {
	      char buf[128];
	      int32_t eref, kref, plen;
	      eref = peek_shared_ref(ci, val);
	      kref = peek_shared_ref(ci, key);
	      plen = catstrs_direct(buf, "  (set! (<", pos_int_to_str_direct(sc, href), "> ", NULL);
	      port_write_string(ci->cycle_port)(sc, buf, plen, ci->cycle_port);

	      if (kref != 0)
		{
		  if (kref < 0) kref = -kref;
		  plen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, kref), ">", NULL);
		  port_write_string(ci->cycle_port)(sc, buf, plen, ci->cycle_port);
		}
	      else object_to_port(sc, key, ci->cycle_port, P_READABLE, ci);

	      if (eref != 0)
		{
		  if (eref < 0) eref = -eref;
		  plen = catstrs_direct(buf, ") <", pos_int_to_str_direct(sc, eref), ">)\n", NULL);
		  port_write_string(ci->cycle_port)(sc, buf, plen, ci->cycle_port);
		}
	      else
		{
		  port_write_string(ci->cycle_port)(sc, ") ", 2, ci->cycle_port);
		  object_to_port_with_circle_check(sc, val, ci->cycle_port, P_READABLE, ci);
		  port_write_string(ci->cycle_port)(sc, ")\n", 2, ci->cycle_port);
		}
	    }
	  else
	    {
	      port_write_character(port)(sc, ' ', port);
	      object_to_port_with_circle_check(sc, key, port, P_READABLE, ci);
	      port_write_character(port)(sc, ' ', port);
	      object_to_port_with_circle_check(sc, val, port, P_READABLE, ci);
	    }
	}
      port_write_character(port)(sc, ')', port);
    }
  else
    {
      if (is_weak_hash_table(hash))
	port_write_string(port)(sc, "(weak-hash-table", 16, port);
      else port_write_string(port)(sc, "(hash-table", 11, port);
      for (i = 0; i < len; i++)
	{
	  s7_pointer key_val;
	  port_write_character(port)(sc, ' ', port);
	  key_val = hash_table_iterate(sc, iterator);
#if S7_DEBUGGING
	  if (!is_pair(key_val))
	    {
	      fprintf(stderr, "hash entries clobbered\n");
	      hash_table_entries(hash) = i;
	      break;
	    }
#endif	  
	  if (use_write != P_READABLE)
	    {
	      if ((is_symbol(car(key_val))) &&
		  (!is_keyword(car(key_val))))
		port_write_character(port)(sc, '\'', port);
	    }
	  object_to_port_with_circle_check(sc, car(key_val), port, NOT_P_DISPLAY(use_write), ci);
	  port_write_character(port)(sc, ' ', port);
	  object_to_port_with_circle_check(sc, cdr(key_val), port, NOT_P_DISPLAY(use_write), ci);
	}
      if (too_long)
	port_write_string(port)(sc, " ...)", 5, port);
      else port_write_character(port)(sc, ')', port);
    }

  if ((use_write == P_READABLE) &&
      (is_immutable(hash)))
    port_write_character(port)(sc, ')', port);

  s7_gc_unprotect_at(sc, gc_iter);
  iterator_current(iterator) = sc->nil;
  free_cell(sc, p);
  /* free_cell(sc, iterator); */ /* 18-Dec-18 removed */
}

static int32_t slot_to_port_1(s7_scheme *sc, s7_pointer x, s7_pointer port, use_write_t use_write, shared_info *ci, int32_t n)
{
  if (tis_slot(x))
    {
      n = slot_to_port_1(sc, next_slot(x), port, use_write, ci, n);
      if (n <= sc->print_length)
	{
	  port_write_character(port)(sc, ' ', port);
	  object_to_port_with_circle_check(sc, x, port, use_write, ci);
	}
      if (n == (sc->print_length + 1))
	port_write_string(port)(sc, " ...", 4, port);
    }
  return(n + 1);
}

static void slot_list_to_port(s7_scheme *sc, s7_pointer slot, s7_pointer port, shared_info *ci, bool bindings)
{
  if (tis_slot(slot))
    {
      slot_list_to_port(sc, next_slot(slot), port, ci, bindings);
      if (bindings)
	{
	  if (tis_slot(next_slot(slot)))
	    port_write_string(port)(sc, " (", 2, port);
	  else port_write_character(port)(sc, '(', port);
	}
      else port_write_character(port)(sc, ' ', port);
      symbol_to_port(sc, slot_symbol(slot), port, (bindings) ? P_DISPLAY : P_KEY, ci);  /* (object->string (inlet (symbol "(\")") 1) :readable) */
      port_write_character(port)(sc, ' ', port);
      object_to_port_with_circle_check(sc, slot_value(slot), port, P_READABLE, ci);
      if (bindings) port_write_character(port)(sc, ')', port);
    }
}

static void slot_list_to_port_with_cycle(s7_scheme *sc, s7_pointer obj, s7_pointer slot, s7_pointer port, shared_info *ci, bool bindings)
{
  if (tis_slot(slot))
    {
      s7_pointer sym, val;
      slot_list_to_port_with_cycle(sc, obj, next_slot(slot), port, ci, bindings);
      sym = slot_symbol(slot);
      val = slot_value(slot);

      if (bindings)
	{
	  if (tis_slot(next_slot(slot)))
	    port_write_string(port)(sc, " (", 2, port);
	  else port_write_character(port)(sc, '(', port);
	}
      else port_write_character(port)(sc, ' ', port);
      symbol_to_port(sc, sym, port, (bindings) ? P_DISPLAY : P_KEY, ci);
      if (has_structure(val))
	{
	  char buf[128];
	  int32_t symref, len;
	  port_write_string(port)(sc, " #f", 3, port);

	  len = catstrs_direct(buf, "  (set! (<", pos_int_to_str_direct(sc, -peek_shared_ref(ci, obj)), "> ", NULL);
	  port_write_string(ci->cycle_port)(sc, buf, len, ci->cycle_port);
	  symbol_to_port(sc, sym, ci->cycle_port, P_KEY, ci);

	  symref = peek_shared_ref(ci, val);
	  if (symref != 0)
	    {
	      if (symref < 0) symref = -symref;
	      len = catstrs_direct(buf, ") <", pos_int_to_str_direct(sc, symref), ">)\n", NULL);
	      port_write_string(ci->cycle_port)(sc, buf, len, ci->cycle_port);
	    }
	  else
	    {
	      port_write_string(ci->cycle_port)(sc, ") ", 2, ci->cycle_port);
	      object_to_port_with_circle_check(sc, val, ci->cycle_port, P_READABLE, ci);
	      port_write_string(ci->cycle_port)(sc, ")\n", 2, ci->cycle_port);
	    }
	}
      else
	{
	  port_write_character(port)(sc, ' ', port);
	  object_to_port_with_circle_check(sc, val, port, P_READABLE, ci);
	}
      if (bindings) port_write_character(port)(sc, ')', port);
      if (is_immutable(obj))
	{
	  char buf[128];
	  int32_t len;
	  len = catstrs_direct(buf, "  (immutable! <", pos_int_to_str_direct(sc, -peek_shared_ref(ci, obj)), ">)\n", NULL);
	  port_write_string(ci->cycle_port)(sc, buf, len, ci->cycle_port);
	}
    }
}

static bool let_has_setter(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer slot;
  for (slot = let_slots(obj); tis_slot(slot); slot = next_slot(slot))
    if (slot_has_setter(slot))
      return(true);
  return(false);
}

static void slot_setters_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, shared_info *ci)
{
  s7_pointer slot;
  for (slot = let_slots(obj); tis_slot(slot); slot = next_slot(slot))
    if (slot_has_setter(slot))
      {
	port_write_string(port)(sc, "(set! (setter '", 15, port);
	symbol_to_port(sc, slot_symbol(slot), port, P_DISPLAY, ci);
	port_write_string(port)(sc, ") ", 2, port);
	object_to_port_with_circle_check(sc, slot_setter(slot), port, P_READABLE, ci);
	port_write_character(port)(sc, ')', port);
      }
}

static void let_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  /* if outer env points to (say) method list, the object needs to specialize object->string itself */
  if (has_active_methods(sc, obj))
    {
      s7_pointer print_func;
      print_func = find_method(sc, obj, sc->object_to_string_symbol);
      if (print_func != sc->undefined)
	{
	  s7_pointer p;
	  /* what needs to be protected here? for one, the function might not return a string! */

	  clear_has_methods(obj);
	  if (use_write == P_WRITE)
	    p = s7_apply_function(sc, print_func, list_1(sc, obj));
	  else p = s7_apply_function(sc, print_func, list_2(sc, obj, (use_write == P_DISPLAY) ? sc->F : sc->key_readable_symbol));
	  set_has_methods(obj);

	  if ((is_string(p)) &&
	      (string_length(p) > 0))
	    port_write_string(port)(sc, string_value(p), string_length(p), port);
	  return;
	}
    }

  if (obj == sc->rootlet)
    port_write_string(port)(sc, "(rootlet)", 9, port);
  else
    {
      if (sc->short_print)
	port_write_string(port)(sc, "#<let>", 6, port);
      else
	{
	  /* circles can happen here:
	   *    (let () (let ((b (curlet))) (curlet))):    #<let 'b #<let>>
	   * or (let ((b #f)) (set! b (curlet)) (curlet)): #1=#<let 'b #1#>
	   */
	  if (use_write == P_READABLE)
	    {
	      if ((ci) &&
		  (is_cyclic(obj)) &&
		  (peek_shared_ref(ci, obj) != 0))
		{
		  int32_t lref;
		  lref = peek_shared_ref(ci, obj);
		  if (lref < 0) lref = -lref;
		  if ((ci->defined[lref]) || (port == ci->cycle_port))
		    {
		      char buf[128];
		      int32_t len;
		      len = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, lref), ">", NULL);
		      port_write_string(ci->cycle_port)(sc, buf, len, ci->cycle_port);
		      return;
		    }
		  if ((outlet(obj) != sc->nil) &&
		      (outlet(obj) != sc->rootlet))
		    {
		      char buf[128];
		      int32_t len;
		      len = catstrs_direct(buf, "  (set! (outlet <", pos_int_to_str_direct(sc, -peek_shared_ref(ci, obj)), ">) ", NULL);
		      port_write_string(ci->cycle_port)(sc, buf, len, ci->cycle_port);
		      let_to_port(sc, outlet(obj), ci->cycle_port, use_write, ci);
		      port_write_string(ci->cycle_port)(sc, ")\n", 2, ci->cycle_port);
		    }
		  if (has_methods(obj))
		    port_write_string(port)(sc, "(openlet ", 9, port);
		  /* not immutable here because we'll need to set the let fields below, then declare it immutable */
		  if (let_has_setter(sc, obj))
		    {
		      port_write_string(port)(sc, "(let (", 6, port);
		      slot_list_to_port_with_cycle(sc, obj, let_slots(obj), port, ci, true);
		      port_write_string(port)(sc, ") ", 2, port);
		      slot_setters_to_port(sc, obj, port, ci);
		      port_write_string(port)(sc, " (curlet))", 10, port);
		    }
		  else
		    {
		      port_write_string(port)(sc, "(inlet", 6, port);
		      slot_list_to_port_with_cycle(sc, obj, let_slots(obj), port, ci, false);
		      port_write_character(port)(sc, ')', port);
		    }
		  if (has_methods(obj))
		    port_write_character(port)(sc, ')', port);
		}
	      else
		{
		  if (has_methods(obj))
		    port_write_string(port)(sc, "(openlet ", 9, port);
		  if (is_immutable(obj))
		    port_write_string(port)(sc, "(immutable! ", 12, port);

		  /* this ignores outlet -- but is that a problem? */
		  /* (object->string (let ((i 0)) (set! (setter 'i) integer?) (curlet)) :readable) -> "(let ((i 0)) (set! (setter 'i) #_integer?) (curlet))" */
		  if (let_has_setter(sc, obj))
		    {
		      port_write_string(port)(sc, "(let (", 6, port);
		      slot_list_to_port(sc, let_slots(obj), port, ci, true);
		      port_write_string(port)(sc, ") ", 2, port);
		      slot_setters_to_port(sc, obj, port, ci);
		      /* perhaps set outlet here?? */
		      port_write_string(port)(sc, " (curlet))", 10, port);
		    }
		  else
		    {
		      if ((outlet(obj) != sc->nil) &&
			  (outlet(obj) != sc->rootlet))
			{
			  port_write_string(port)(sc, "(sublet ", 8, port);
			  if ((ci) && (peek_shared_ref(ci, outlet(obj)) < 0))
			    {
			      char buf[128];
			      int32_t len;
			      len = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, -peek_shared_ref(ci, outlet(obj))), ">", NULL);
			      port_write_string(port)(sc, buf, len, port);
			    }
			  else
			    {
			      s7_pointer name;
			      name = s7_let_ref(sc, obj, make_symbol(sc, "class-name"));
			      if (is_symbol(name))
				symbol_to_port(sc, name, port, P_DISPLAY, ci);
			      else let_to_port(sc, outlet(obj), port, use_write, ci);
			    }
			}
		      else port_write_string(port)(sc, "(inlet", 6, port);
		      slot_list_to_port(sc, let_slots(obj), port, ci, false);
		      port_write_character(port)(sc, ')', port);
		    }
		  if (is_immutable(obj))
		    port_write_character(port)(sc, ')', port);
		  if (has_methods(obj))
		    port_write_character(port)(sc, ')', port);
		}
	    }
	  else /* not readable write */
	    {
	      port_write_string(port)(sc, "(inlet", 6, port);
	      slot_to_port_1(sc, let_slots(obj), port, use_write, ci, 0);
	      port_write_character(port)(sc, ')', port);
	    }
	}
    }
}

static void write_macro_readably(s7_scheme *sc, s7_pointer obj, s7_pointer port)
{
  s7_pointer arglist, body, expr;

  body = closure_body(obj);
  arglist = closure_args(obj);

  port_write_string(port)(sc, "(define-", 8, port);
  port_write_string(port)(sc, ((is_macro(obj)) || (is_macro_star(obj))) ? "macro" : "bacro", 5, port);
  if ((is_macro_star(obj)) || (is_bacro_star(obj)))
    port_write_character(port)(sc, '*', port);
  port_write_string(port)(sc, " (_m_", 5, port);
  if (is_symbol(arglist))
    {
      port_write_string(port)(sc, " . ", 3, port);
      port_write_string(port)(sc, symbol_name(arglist), symbol_name_length(arglist), port);
    }
  else
    {
      if (is_pair(arglist))
	{
	  for (expr = arglist; is_pair(expr); expr = cdr(expr))
	    {
	      port_write_character(port)(sc, ' ', port);
	      object_to_port(sc, car(expr), port, P_WRITE, NULL);
	    }
	  if (!is_null(expr))
	    {
	      port_write_string(port)(sc, " . ", 3, port);
	      object_to_port(sc, expr, port, P_WRITE, NULL);
	    }
	}
    }
  port_write_string(port)(sc, ") ", 2, port);
  for (expr = body; is_pair(expr); expr = cdr(expr))
    object_to_port(sc, car(expr), port, P_WRITE, NULL);
  port_write_character(port)(sc, ')', port);
}


static s7_pointer match_symbol(s7_scheme *sc, s7_pointer symbol, s7_pointer e)
{
  s7_pointer y, le;
  for (le = e; is_let(le) && (le != sc->rootlet); le = outlet(le))
    for (y = let_slots(le); tis_slot(y); y = next_slot(y))
      if (slot_symbol(y) == symbol)
	return(y);
  return(NULL);
}

static bool slot_memq(s7_pointer symbol, s7_pointer symbols)
{
  s7_pointer x;
  for (x = symbols; is_pair(x); x = cdr(x))
    if (slot_symbol(car(x)) == symbol)
      return(true);
  return(false);
}

static bool arg_memq(s7_pointer symbol, s7_pointer args)
{
  s7_pointer x;
  for (x = args; is_pair(x); x = cdr(x))
    if ((car(x) == symbol) ||
	((is_pair(car(x))) &&
	 (caar(x) == symbol)))
      return(true);
  return(false);
}

static void collect_symbol(s7_scheme *sc, s7_pointer sym, s7_pointer e, s7_pointer args, s7_int gc_loc)
{
  if ((!arg_memq(T_Sym(sym), args)) &&
      (!slot_memq(sym, gc_protected_at(sc, gc_loc))))
    {
      s7_pointer slot;
      slot = match_symbol(sc, sym, e);
      if (slot)
	gc_protected_at(sc, gc_loc) = cons(sc, slot, gc_protected_at(sc, gc_loc));
    }
}

static void collect_locals(s7_scheme *sc, s7_pointer body, s7_pointer e, s7_pointer args, s7_int gc_loc)
{ /* currently called only in write_closure_readably */
  if (is_pair(body))
    {
      collect_locals(sc, car(body), e, args, gc_loc);
      collect_locals(sc, cdr(body), e, args, gc_loc);
    }
  else
    {
      if (is_symbol(body))
	collect_symbol(sc, body, e, args, gc_loc);
    }
}

static void collect_specials(s7_scheme *sc, s7_pointer e, s7_pointer args, s7_int gc_loc)
{
  collect_symbol(sc, sc->local_signature_symbol, e, args, gc_loc);
  collect_symbol(sc, sc->local_setter_symbol, e, args, gc_loc);
  collect_symbol(sc, sc->local_documentation_symbol, e, args, gc_loc);
  collect_symbol(sc, sc->local_iterator_symbol, e, args, gc_loc);
}

static s7_pointer find_closure(s7_scheme *sc, s7_pointer closure, s7_pointer cur_env)
{
  s7_pointer e, y;
  for (e = cur_env; is_let(e); e = outlet(e))
    {
      if (is_funclet(e))
	{
	  s7_pointer sym, f;
	  sym = funclet_function(e);
	  f = s7_symbol_local_value(sc, sym, e);
	  if (f == closure)
	    return(sym);
	}

      for (y = let_slots(e); tis_slot(y); y = next_slot(y))
	if (slot_value(y) == closure)
	  return(slot_symbol(y));
    }
  return(sc->nil);
}

static void write_closure_name(s7_scheme *sc, s7_pointer closure, s7_pointer port)
{
  s7_pointer x;
  x = find_closure(sc, closure, closure_let(closure));
  /* this can be confusing!
   * (let ((a (lambda () 1))) a)
   * #<lambda ()>
   * (letrec ((a (lambda () 1))) a)
   * a
   * (let () (define (a) 1) a)
   * a
   * (let () (define a (lambda () 1)))
   * a
   * (let () (define a (lambda () 1)))
   * a
   * (let () (define (a) (lambda () 1)) (a))
   * #<lambda ()>
   */
  if (is_symbol(x)) /* after find_closure */
    {
      port_write_string(port)(sc, symbol_name(x), symbol_name_length(x), port);
      return;
    }

  /* names like #<closure> and #<macro> are useless -- try to be a bit more informative */
  switch (type(closure))
    {
    case T_CLOSURE:
      port_write_string(port)(sc, "#<lambda ", 9, port);
      break;

    case T_CLOSURE_STAR:
      port_write_string(port)(sc, "#<lambda* ", 10, port);
      break;

    case T_MACRO:
      if (is_expansion(closure))
	port_write_string(port)(sc, "#<expansion ", 12, port);
      else port_write_string(port)(sc, "#<macro ", 8, port);
      break;

    case T_MACRO_STAR:
      port_write_string(port)(sc, "#<macro* ", 9, port);
      break;

    case T_BACRO:
      port_write_string(port)(sc, "#<bacro ", 8, port);
      break;

    case T_BACRO_STAR:
      port_write_string(port)(sc, "#<bacro* ", 9, port);
      break;
    }

  if (is_null(closure_args(closure)))
    port_write_string(port)(sc, "()>", 3, port);
  else
    {
      s7_pointer args;
      args = closure_args(closure);
      if (is_symbol(args))
	{
	  port_write_string(port)(sc, symbol_name(args), symbol_name_length(args), port);
	  port_write_character(port)(sc, '>', port);    /* (lambda a a) -> #<lambda a> */
	}
      else
	{
	  port_write_character(port)(sc, '(', port);
	  x = car(args);
	  if (is_pair(x)) x = car(x);
	  port_write_string(port)(sc, symbol_name(x), symbol_name_length(x), port);
	  if (!is_null(cdr(args)))
	    {
	      s7_pointer y;
	      port_write_character(port)(sc, ' ', port);
	      if (is_pair(cdr(args)))
		{
		  y = cadr(args);
		  if (is_pair(y))
		    y = car(y);
		  else
		    {
		      if (y == sc->key_rest_symbol)
			{
			  port_write_string(port)(sc, ":rest ", 6, port);
			  args = cdr(args);
			  y = cadr(args);
			  if (is_pair(y)) y = car(y);
			}
		    }
		}
	      else
		{
		  port_write_string(port)(sc, ". ", 2, port);
		  y = cdr(args);
		}
	      port_write_string(port)(sc, symbol_name(y), symbol_name_length(y), port);
	      if ((is_pair(cdr(args))) &&
		  (!is_null(cddr(args))))
		port_write_string(port)(sc, " ...", 4, port);
	    }
	  port_write_string(port)(sc, ")>", 2, port);
	}
    }
}

static s7_pointer closure_name(s7_scheme *sc, s7_pointer closure)
{
  /* this is used by the error handlers to get the current function name */
  s7_pointer x;

  x = find_closure(sc, closure, sc->envir);
  if (is_symbol(x))
    return(x);

  if (is_pair(current_code(sc)))
    return(current_code(sc));

  return(closure); /* desperation -- the parameter list (caar here) will cause endless confusion in OP_APPLY errors! */
}

static void write_closure_readably_1(s7_scheme *sc, s7_pointer obj, s7_pointer arglist, s7_pointer body, s7_pointer port)
{
  s7_int old_print_length;
  s7_pointer p;

  if (type(obj) == T_CLOSURE_STAR)
    port_write_string(port)(sc, "(lambda* ", 9, port);
  else port_write_string(port)(sc, "(lambda ", 8, port);

  if ((is_pair(arglist)) &&
      (allows_other_keys(arglist)))
    {
      sc->temp9 = s7_append(sc, arglist, cons(sc, sc->key_allow_other_keys_symbol, sc->nil));
      object_to_port(sc, sc->temp9, port, P_WRITE, NULL);
      sc->temp9 = sc->nil;
    }
  else object_to_port(sc, arglist, port, P_WRITE, NULL); /* here we just want the straight output (a b) not (list 'a 'b) */

  old_print_length = sc->print_length;
  sc->print_length = 1048576;
  for (p = body; is_pair(p); p = cdr(p))
    {
      port_write_character(port)(sc, ' ', port);
      object_to_port(sc, car(p), port, P_WRITE, NULL);
    }
  port_write_character(port)(sc, ')', port);
  sc->print_length = old_print_length;
}

static void write_closure_readably(s7_scheme *sc, s7_pointer obj, s7_pointer port, shared_info *ci)
{
  s7_pointer body, arglist, pe, local_slots, setter = NULL;
  s7_int gc_loc;

  body = closure_body(obj);
  if (sc->safety > NO_SAFETY)
    {
      if (tree_is_cyclic(sc, body))
	{
	  port_write_string(port)(sc, "#<write_closure: body is cyclic>", 32, port); /* not s7_error here! */
	  return;
	}
      /* perhaps: if any sequence in the closure_body is cyclic, complain, but how to check without clobbering ci?
       *   perhaps pass ci, and use make_shared_info if ci=null else continue_shared_info?
       *   this can happen only if (apply lambda ... cyclic-seq ...) I think
       *   long-term we need to include closure_body(obj) in the top object_out make_shared_info
       */
    }

  arglist = closure_args(obj);
  if (is_symbol(arglist)) arglist = list_1(sc, arglist);
  pe = closure_let(obj);

  gc_loc = s7_gc_protect_1(sc, sc->nil);
  collect_locals(sc, body, pe, arglist, gc_loc);   /* collect locals used only here (and below) */
  collect_specials(sc, pe, arglist, gc_loc);

  if (s7_is_dilambda(obj))
    {
      setter = closure_setter(obj);
      if (has_closure_let(setter))                 /* collect args etc so need the arglist */
	{
	  arglist = closure_args(setter);
	  if (is_symbol(arglist)) arglist = list_1(sc, arglist);
	  collect_locals(sc, closure_body(setter), pe, arglist, gc_loc);
	}
    }

  local_slots = T_Lst(gc_protected_at(sc, gc_loc)); /* possibly a list of slots */
  if (!is_null(local_slots))
    {
      s7_pointer x;
      port_write_string(port)(sc, "(let (", 6, port);
      for (x = local_slots; is_pair(x); x = cdr(x))
	{
	  s7_pointer slot;
	  slot = car(x);
	  if ((!is_any_closure(slot_value(slot))) &&    /* mutually referencing closures? ./snd -l snd-test 24 hits this in the effects dialogs */
	      ((!has_structure(slot_value(slot))) ||    /* see s7test example, vector has closure that refers to vector */
	       (slot_symbol(slot) == sc->local_signature_symbol)))
	    {
	      port_write_character(port)(sc, '(', port);
	      port_write_string(port)(sc, symbol_name(slot_symbol(slot)), symbol_name_length(slot_symbol(slot)), port);
	      port_write_character(port)(sc, ' ', port);
	      /* (object->string (list (let ((local 1)) (lambda (x) (+ x local)))) :readable) */
	      object_to_port(sc, slot_value(slot), port, P_READABLE, NULL);
	      if (is_null(cdr(x)))
		port_write_character(port)(sc, ')', port);
	      else port_write_string(port)(sc, ") ", 2, port);
	    }
	}
      port_write_string(port)(sc, ") ", 2, port);
    }

  if (setter)
    port_write_string(port)(sc, "(dilambda ", 10, port);

  write_closure_readably_1(sc, obj, closure_args(obj), body, port);

  if (setter)
    {
      port_write_character(port)(sc, ' ', port);
      if (has_closure_let(setter))
	write_closure_readably_1(sc, setter, closure_args(setter), closure_body(setter), port);
      else object_to_port_with_circle_check(sc, setter, port, P_READABLE, ci);
      port_write_character(port)(sc, ')', port);
    }

  if (!is_null(local_slots))
    port_write_character(port)(sc, ')', port);
  s7_gc_unprotect_at(sc, gc_loc);
}


#if TRAP_SEGFAULT
#include <signal.h>
static sigjmp_buf senv; /* global here is not a problem -- it is used only to protect s7_is_valid */
static volatile sig_atomic_t can_jump = 0;
static void segv(int32_t ignored) {if (can_jump) siglongjmp(senv, 1);}
#endif

bool s7_is_valid(s7_scheme *sc, s7_pointer arg)
{
  bool result = false;
  if (!arg) return(false);

#if TRAP_SEGFAULT
  if (sigsetjmp(senv, 1) == 0)
    {
      void (*old_segv)(int32_t sig);
      can_jump = 1;
      old_segv = signal(SIGSEGV, segv);
#endif
      if ((unchecked_type(arg) > T_FREE) &&
	  (unchecked_type(arg) < NUM_TYPES))
	{
	  if (not_in_heap(arg))
	    result = true;
	  else
	    {
	      int64_t loc;
	      loc = heap_location(sc, arg);
	      if ((loc >= 0) && (loc < sc->heap_size))
		result = (sc->heap[loc] == arg);
#if S7_DEBUGGING
	      if (!result)
		check_heap_location(sc, arg, loc, __func__, __LINE__);
#endif
	    }
	}
#if TRAP_SEGFAULT
      signal(SIGSEGV, old_segv);
    }
  else result = false;
  can_jump = 0;
#endif
  return(result);
}

enum {NO_ARTICLE, INDEFINITE_ARTICLE};

static char *describe_type_bits(s7_scheme *sc, s7_pointer obj) /* used outside S7_DEBUGGING in display_any (fallback for display_functions) */
{
  uint64_t full_typ;
  uint8_t typ;
  char *buf;

  buf = (char *)malloc(1024 * sizeof(char));
  typ = unchecked_type(obj);
  full_typ = typeflag(obj);

  /* if debugging all of these bits are being watched, so we need to access them directly */
  snprintf(buf, 1024, "type: %s? (%d), opt_op: %d, flags: #x%" PRIx64 "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
	   type_name(sc, obj, NO_ARTICLE),
	   typ,
	   optimize_op(obj),
	   full_typ,
	   /* bit 0 (the first 8 bits are easy...) */
	   ((full_typ & T_MULTIFORM) != 0) ?      ((is_any_closure(obj)) ? (((full_typ & T_ONE_FORM) != 0) ? " clo-has-fx" : " multiform") : " ?0?") : "",
	   /* bit 1 */
	   ((full_typ & T_SYNTACTIC) != 0) ?      (((is_pair(obj)) || (is_syntax(obj)) || (is_symbol(obj))) ? " syntactic" : " ?1?") : "",
	   /* bit 2 */
	   ((full_typ & T_SIMPLE_ARG_DEFAULTS) != 0) ? ((is_pair(obj)) ? " simple-args|in-use" :
							((is_any_closure(obj)) ? " one-form" :
							 " ?2?")) : "",
	   /* bit 3 */
	   ((full_typ & T_OPTIMIZED) != 0) ?      ((is_c_function(obj)) ? " scope-safe" :
						   ((is_pair(obj)) ? " optimized" :
						    " ?3?")) : "",
	   /* bit 4 */
	   ((full_typ & T_SAFE_CLOSURE) != 0) ?   " safe-closure" : "",
	   /* bit 5 */
	   ((full_typ & T_DONT_EVAL_ARGS) != 0) ? " dont-eval-args" : "",
	   /* bit 6 */
	   ((full_typ & T_EXPANSION) != 0) ?      (((is_symbol(obj)) || (is_macro(obj))) ? " expansion" :
						   " ?6?") : "",
	   /* bit 7 */
	   ((full_typ & T_MULTIPLE_VALUE) != 0) ? ((is_symbol(obj)) ? " matched" :
						   ((is_pair(obj)) ? " values|matched" :
						    " ?7?")) : "",
	   /* bit 8 */
	   ((full_typ & T_GLOBAL) != 0) ?         ((is_pair(obj)) ? " unsafe-do" :
						   (((is_symbol(obj)) || (is_syntax(obj))) ? " global" :
						    " ?8?")) : "",
	   /* bit 9 */
	   ((full_typ & T_COLLECTED) != 0) ?      " collected" : "",
	   /* bit 10 */
	   ((full_typ & T_LINE_NUMBER) != 0) ?    ((is_pair(obj)) ? " line-number" :
						   ((is_input_port(obj)) ? " loader-port" :
						    ((is_let(obj)) ? " with-let" :
						     ((is_any_procedure(obj)) ? " simple-defaults" :
						      (((is_symbol(obj)) || (is_slot(obj))) ? " has-setter" :
						       " ?10?"))))) : "",
	   /* bit 11 */
	   ((full_typ & T_SHARED) != 0) ?         " shared" : "",
	   /* bit 12 */
	   ((full_typ & T_LOCAL) != 0) ?          ((is_symbol(obj)) ? " local" :
						   " ?12?") : "",
	   /* bit 13 */
	   ((full_typ & T_SAFE_PROCEDURE) != 0) ? " safe-procedure" : "",
	   /* bit 14 */
	   ((full_typ & T_CHECKED) != 0) ?        " checked" : "",
	   /* bit 15 */
	   ((full_typ & T_UNSAFE) != 0) ?         ((is_symbol(obj)) ? " clean-symbol" :
						   ((is_slot(obj)) ? " has-stepper" :
						    ((is_pair(obj)) ? " unsafely-opt|no-float-opt" :
						     " ?15?"))) : "",
	   /* bit 16 */
	   ((full_typ & T_IMMUTABLE) != 0) ?      " immutable" : "",
	   /* bit 17 */
	   ((full_typ & T_SETTER) != 0) ?         ((is_symbol(obj)) ? " setter" :
						   ((is_pair(obj)) ? " allow-other-keys|no-int-opt" :
						    (((is_hash_table(obj)) || (is_let(obj))) ? " removed" :
						     ((is_slot(obj)) ? " has-expression" :
						      " ?17?")))) : "",
	   /* bit 18 */
	   ((full_typ & T_MUTABLE) != 0) ?        ((is_number(obj)) ? " mutable" :
						   ((is_symbol(obj)) ? " has-keyword" :
						    ((is_let(obj)) ? " let-ref-fallback" :
						     ((is_iterator(obj)) ? " mark-sequence" :
						      ((is_slot(obj)) ? " step-end" :
						       ((is_let(obj)) ? " ref-fallback" :
							((is_pair(obj)) ? " no-opt" :
							 " ?18?"))))))) : "",
	   /* bit 19 */
	   ((full_typ & T_SAFE_STEPPER) != 0) ?   ((is_let(obj)) ? " set-fallback" :
						   ((is_slot(obj)) ? " safe-stepper" :
						    ((is_c_function(obj)) ? " maybe-safe" :
						     ((is_number(obj)) ? " print-name" :
						      ((is_pair(obj)) ? " direct_x_opt" :
						       ((is_hash_table(obj)) ? " weak-hash" :
							" ?19?")))))) : "",
	   /* bit 20, for c_function case see sc->apply */
	   ((full_typ & T_COPY_ARGS) != 0) ?      (((is_any_macro(obj)) || (is_any_closure(obj)) || (is_c_function(obj))) ? " copy-args" :
						    " ?20?") : "",
	   /* bit 21 */
	   ((full_typ & T_GENSYM) != 0) ?         ((is_let(obj)) ? " funclet" :
						   ((is_symbol(obj)) ? " gensym" :
						    ((is_string(obj)) ? " documented-symbol" :
						     ((is_hash_table(obj)) ? " hash-chosen" :
						      ((is_pair(obj)) ? " dotted" :
						       ((is_any_vector(obj)) ? " subvector" :
							((is_slot(obj)) ? " has-pending-value" :
							 " ?21?"))))))) : "",
	   /* bit 22 */
	   ((full_typ & T_HAS_METHODS) != 0) ?    " has-methods" : "",
	   /* bit 23 */
	   ((full_typ & T_ITER_OK) != 0) ?        ((is_iterator(obj)) ? " iter-ok" : " ?23?") : "",
	   /* bit 24+16 */
	   ((full_typ & T_FULL_SYMCONS) != 0) ?   ((is_symbol(obj)) ? " possibly-constant" :
						   ((is_procedure(obj)) ? " has-let-arg" :
						    " ?24?")) : "",
	   /* bit 25+16 */
	   ((full_typ & T_FULL_S7_LET_FIELD) != 0) ?   ((is_symbol(obj)) ? " s7-let-field" :
							((is_let(obj)) ? " has-let-file" :
							 ((is_pair(obj)) ? " has-oplist" :
							  ((is_any_vector(obj)) ? " typed-vector" :
							   ((is_hash_table(obj)) ? " typed-hash-table" :
							    ((is_c_function(obj)) ? " has-bool-setter" :
							     ((is_slot(obj)) ? " rest-slot" :
							      " ?25?"))))))) : "",
	   /* bit 26+16 */
	   ((full_typ & T_FULL_DEFINER) != 0) ?   ((is_symbol(obj)) ? " definer" :
						   ((is_pair(obj)) ? " has-fx" :
						    ((is_slot(obj)) ? " slot-defaults" :
						     ((is_iterator(obj)) ? " weak-hash-iterator" :
						      " ?26?")))) : "",
	   /* bit 27+16 */
	   ((full_typ & T_FULL_BINDER) != 0) ?    ((is_pair(obj)) ? " tree-collected" :
						   ((is_hash_table(obj)) ? " simple-values" :
						    ((is_symbol(obj)) ? " binder" :
						     " ?27?"))) : "",
	   /* bit 28+16 */
	   ((full_typ & T_VERY_SAFE_CLOSURE) != 0) ? " very-safe-closure" : "",
	   /* bit 29+16 */
	   ((full_typ & T_CYCLIC) != 0) ?         " cyclic" : "",
	   /* bit 30+16 */
	   ((full_typ & T_CYCLIC_SET) != 0) ?     " cyclic-set" : "",
	   /* bit 31+16 */
	   ((full_typ & T_KEYWORD) != 0) ?        ((is_symbol(obj)) ? " keyword" : " ?31?") : "",
	   /* bit 32+16 */
	   ((full_typ & T_FULL_SIMPLE_ELEMENTS) != 0) ? ((is_normal_vector(obj)) ? " simple-elements" :
							 ((is_hash_table(obj)) ? " simple-keys" :
							  ((is_pair(obj)) ? " ctr3-set" :
							   " 32?"))) : "",
	   /* bit 33+16 */
	   ((full_typ & T_FULL_CASE_KEY) != 0) ?  " case-key" : "",
	   ((full_typ & UNUSED_BITS) != 0) ?      " unused bits set?" : "",

	   /* bit 54 */
	   ((full_typ & T_UNHEAP) != 0) ?         " unheap" : "",
	   /* bit 55 */
	   (((full_typ & T_GC_MARK) != 0) && (in_heap(obj))) ? " gc-marked" : "");
  return(buf);
}

#if S7_DEBUGGING
static bool has_odd_bits(s7_pointer obj)
{
  uint64_t full_typ;
  full_typ = typeflag(obj);

  if ((full_typ & UNUSED_BITS) != 0) return(true);
  if (((full_typ & T_MULTIFORM) != 0) && (!is_any_closure(obj))) return(true);
  if (((full_typ & T_KEYWORD) != 0) && (!is_symbol(obj))) return(true);
  if (((full_typ & T_FULL_BINDER) != 0) && ((!is_pair(obj)) && (!is_hash_table(obj)) && (!is_symbol(obj)))) return(true);
  if (((full_typ & T_SYNTACTIC) != 0) && (!is_syntax(obj)) && (!is_pair(obj)) && (!is_symbol(obj))) return(true);
  if (((full_typ & T_SIMPLE_ARG_DEFAULTS) != 0) && (!is_pair(obj)) && (!is_any_closure(obj))) return(true);
  if (((full_typ & T_OPTIMIZED) != 0) && (!is_c_function(obj)) && (!is_pair(obj))) return(true);
  if (((full_typ & T_SAFE_CLOSURE) != 0) && (!is_any_closure(obj)) && (!is_pair(obj))) return(true);
  if (((full_typ & T_EXPANSION) != 0) && (!is_symbol(obj)) && (!is_macro(obj))) return(true);
  if (((full_typ & T_MULTIPLE_VALUE) != 0) && (!is_symbol(obj)) && (!is_pair(obj))) return(true);
  if (((full_typ & T_GLOBAL) != 0) && (!is_pair(obj)) && (!is_symbol(obj)) && (!is_syntax(obj))) return(true);
  if (((full_typ & T_ITER_OK) != 0) && (!is_iterator(obj))) return(true);
  if (((full_typ & T_FULL_DEFINER) != 0) && (!is_symbol(obj)) && (!is_pair(obj)) && (!is_slot(obj)) && (!is_iterator(obj))) return(true);
  if (((full_typ & T_FULL_SYMCONS) != 0) && (!is_symbol(obj)) && (!is_procedure(obj))) return(true);
  if (((full_typ & T_LOCAL) != 0) && (!is_symbol(obj))) return(true);
  if (((full_typ & T_COPY_ARGS) != 0) && (!is_any_macro(obj)) && (!is_any_closure(obj)) && (!is_c_function(obj))) return(true);
  if (((full_typ & T_UNSAFE) != 0) && (!is_symbol(obj)) && (!is_slot(obj)) && (!is_pair(obj))) return(true);
  if (((full_typ & T_VERY_SAFE_CLOSURE) != 0) && (!is_pair(obj)) && (!is_any_closure(obj))) return(true);
  if (((full_typ & T_FULL_SIMPLE_ELEMENTS) != 0) && ((!is_normal_vector(obj)) && (!is_hash_table(obj)) && (!is_pair(obj)))) return(true);
  if (((full_typ & T_FULL_CASE_KEY) != 0) && (!is_symbol(obj))) return(true);
  if (((full_typ & T_FULL_S7_LET_FIELD) != 0) &&
      (!is_symbol(obj)) && (!is_let(obj)) && (!is_pair(obj)) && (!is_any_vector(obj)) && (!is_hash_table(obj)) && (!is_c_function(obj)) && (!is_slot(obj)))
    return(true);
  if (((full_typ & T_SAFE_STEPPER) != 0) &&
      (!is_let(obj)) && (!is_slot(obj)) && (!is_c_function(obj)) && (!is_number(obj)) && (!is_pair(obj)) && (!is_hash_table(obj)))
    return(true);
  if (((full_typ & T_SETTER) != 0) &&
      (!is_slot(obj)) && (!is_symbol(obj)) && (!is_pair(obj)) && (!is_closure(obj)) && (!is_hash_table(obj)) && (!is_let(obj)))
    return(true);
  if (((full_typ & T_LINE_NUMBER) != 0) &&
      (!is_pair(obj)) && (!is_input_port(obj)) && (!is_let(obj)) && (!is_any_procedure(obj)) && (!is_symbol(obj)) && (!is_slot(obj)))
    return(true);
  if (((full_typ & T_MUTABLE) != 0) &&
      (!is_number(obj)) && (!is_symbol(obj)) && (!is_let(obj)) && (!is_iterator(obj)) &&
      (!is_slot(obj)) && (!is_let(obj)) && (!is_pair(obj)))
    return(true);
  if (((full_typ & T_GENSYM) != 0) && (!is_slot(obj)) &&
      (!is_let(obj)) && (!is_symbol(obj)) && (!is_string(obj)) && (!is_hash_table(obj)) && (!is_pair(obj)) && (!is_any_vector(obj)))
    return(true);
  return(false);
}
#endif

void s7_show_let(s7_scheme *sc) /* debugging convenience */
{
  s7_pointer olet;
  for (olet = sc->envir; (is_let(olet)) && (olet != sc->rootlet); olet = outlet(olet))
    {
      if (olet == sc->owlet)
	fprintf(stderr, "(owlet): ");
      else
	{
	  if (is_funclet(olet))
	    fprintf(stderr, "(%s funclet): ", DISPLAY(funclet_function(olet)));
	  else
	    {
	      if (olet == sc->shadow_rootlet)
		fprintf(stderr, "(shadow rootlet): ");
	    }
	}
      fprintf(stderr, "%s\n", DISPLAY(olet));
    }
}

void s7_show_history(s7_scheme *sc)
{
#if WITH_HISTORY
  s7_pointer p;
  int32_t i, size;
  size = sc->history_size;
  for (i = 0, p = cdr(sc->cur_code); i < size; i++, p = cdr(p)) /* stepper "i" is not redundant */
    fprintf(stderr, "%s\n", DISPLAY(car(p)));
#else
  fprintf(stderr, "%s\n", DISPLAY(sc->cur_code));
#endif
}

void s7_show_stack(s7_scheme *sc)
{
#if S7_DEBUGGING || OP_NAMES
  int64_t i;
  fprintf(stderr, "stack:\n");
  for (i = s7_stack_top(sc) - 1; i >= 3; i -= 4)
    fprintf(stderr, "  %s\n", op_names[stack_op(sc->stack, i)]);
#else
  fprintf(stderr, "can't show stack ops (OP_NAMES: 0)\n");
#endif
}

#if S7_DEBUGGING
static const char *check_name(int32_t typ)
{
  if ((typ >= 0) && (typ < NUM_TYPES))
    {
      s7_pointer p;
      p = prepackaged_type_names[typ];
      if (is_string(p)) return(string_value(p));

      switch (typ)
	{
	case T_C_OBJECT:    return("a c-object");
	case T_INPUT_PORT:  return("an input port");
	case T_OUTPUT_PORT: return("an output port");
	}
    }
  return("unknown type!");
}

static char *safe_object_to_string(s7_pointer p)
{
  uint8_t typ;
  char *buf;
  typ = unchecked_type(p);
  buf = (char *)malloc(128 * sizeof(char));
  snprintf(buf, 128, "type: %d", typ);
  return(buf);
}

static void complain(const char* complaint, s7_pointer p, const char *func, int line, uint8_t typ)
{
  fprintf(stderr, complaint,
	  BOLD_TEXT,
	  func, line, check_name(typ), safe_object_to_string(p),
	  UNBOLD_TEXT);
  if (stop_at_error) abort();
}

static char* show_debugger_bits(int64_t bits);

static s7_pointer check_ref(s7_pointer p, uint8_t expected_type, const char *func, int32_t line, const char *func1, const char *func2)
{
  if (!p)
    fprintf(stderr, "%s[%d]: null pointer passed to check_ref\n", func, line);
  else
    {
      uint8_t typ;
      typ = unchecked_type(p);
      if (typ != expected_type)
	{
	  if ((!func1) || (typ != T_FREE))
	    {
	      fprintf(stderr, "%s%s[%d]: not %s, but %s (%s)%s\n",
		      BOLD_TEXT,
		      func, line, check_name(expected_type), check_name(typ), safe_object_to_string(p),
		      UNBOLD_TEXT);
	      if ((typ != T_FREE) && (is_syntactic_pair(p)) && (optimize_op(p) == 0))
		fprintf(stderr, "syn 0: %s[%d]\n", func, line);
	      if (stop_at_error) abort();
	    }
	  else
	    {
	      if ((strcmp(func, func1) != 0) &&
		  ((!func2) || (strcmp(func, func2) != 0)))
		{
		  fprintf(stderr, "%s%s[%d]: free cell, not %s%s\n", BOLD_TEXT, func, line, check_name(expected_type), UNBOLD_TEXT);
		  if (stop_at_error) abort();
		}}}}
  return(p);
}

static s7_pointer check_let_ref(s7_pointer p, uint64_t role, const char *func, int32_t line)
{
  check_ref(p, T_LET, func, line, NULL, NULL);
  if ((p->debugger_bits & L_HIT) == 0) fprintf(stderr, "%s[%d]: let not set\n", func, line);
  if ((p->debugger_bits & L_MASK) != role) fprintf(stderr, "%s[%d]: let bad role\n", func, line);
  return(p);
}

static s7_pointer check_let_set(s7_pointer p, uint64_t role, const char *func, int32_t line)
{
  check_ref(p, T_LET, func, line, NULL, NULL);
  p->debugger_bits &= (~L_MASK);
  p->debugger_bits |= (L_HIT | role);
  return(p);
}

static s7_pointer check_ref2(s7_pointer p, uint8_t expected_type, int32_t other_type, const char *func, int32_t line, const char *func1, const char *func2)
{
  if (!p)
    fprintf(stderr, "%s[%d]: null pointer passed to check_ref2\n", func, line);
  else
    {
      uint8_t typ;
      typ = unchecked_type(p);
      if ((typ != expected_type) && (typ != other_type))
	return(check_ref(p, expected_type, func, line, func1, func2));
    }
  return(p);
}

static s7_pointer check_ref3(s7_pointer p, const char *func, int32_t line)
{
  if ((strcmp(func, "process_input_port") != 0) &&
      (strcmp(func, "process_output_port") != 0) &&
      (strcmp(func, "close_output_port") != 0))
    {
      uint8_t typ;
      typ = unchecked_type(p);
      if ((typ != T_INPUT_PORT) && (typ != T_OUTPUT_PORT))
	complain("%s%s[%d]: not a port, but %s (%s)%s\n", p, func, line, typ);
    }
  return(p);
}

static s7_pointer check_ref4(s7_pointer p, const char *func, int32_t line)
{
  if ((strcmp(func, "sweep") != 0) &&
      (strcmp(func, "process_multivector") != 0))
    {
      uint8_t typ;
      typ = unchecked_type(p);
      if (!t_vector_p[typ])
	complain("%s%s[%d]: not a vector, but %s (%s)%s\n", p, func, line, typ);
    }
  return(p);
}

static s7_pointer check_ref5(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if (!t_has_closure_let[typ])
    complain("%s%s[%d]: not a closure, but %s (%s)%s\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref6(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if ((typ < T_C_FUNCTION_STAR) && (typ != T_C_MACRO))
    complain("%s%s[%d]: not a c function, but %s (%s)%s\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref7(s7_pointer p, const char *func, int32_t line)
{
  if ((!func) || (strcmp(func, "decribe_type_bits") != 0))
    {
      uint8_t typ;
      typ = unchecked_type(p);
      if ((typ < T_INTEGER) || (typ > T_COMPLEX))
	complain("%s%s[%d]: not a number, but %s (%s)%s\n", p, func, line, typ);
    }
  return(p);
}

static s7_pointer check_ref8(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if ((!t_sequence_p[typ]) && (!t_structure_p[typ]) && (!is_any_closure(p))) /* closure as iterator -- see s7test */
    complain("%s%s[%d]: not a sequence or structure, but %s (%s)%s\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref9(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if ((typ != T_LET) && (typ != T_C_OBJECT) && (!is_any_closure(p)) && (!is_any_macro(p)) && (typ != T_C_POINTER))
    complain("%s%s[%d]: not a possible method holder, but %s (%s)%s\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref10(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if ((typ != T_PAIR) && (typ != T_NIL) && (typ != T_SYMBOL))
    complain("%s%s[%d]: arglist is %s (%s)%s?\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref11(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if ((!t_applicable_p[typ]) && (p != cur_sc->F))
    complain("%s%s[%d]: applicable object is %s (%s)%s?\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref12(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  if (is_slot_end(p)) return(p);
  typ = unchecked_type(p);
  if ((typ != T_SLOT) && (typ != T_NIL)) /* unset slots are nil */
    complain("%s%s[%d]: slot is %s (%s)%s?\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref13(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if (!is_any_vector(p))
    complain("%s%s[%d]: subvector is %s (%s)%s?\n", p, func, line, typ);
  if (!is_subvector(p))
    complain("%s%s[%d]: subvector is %s (%s), but not a subvector?%s\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_ref14(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  typ = unchecked_type(p);
  if ((!is_any_procedure(p)) && (p != cur_sc->F))
    complain("%s%s[%d]: procedure setter is %s (%s)%s?\n", p, func, line, typ);
  return(p);
}

static s7_pointer check_cell(s7_pointer p, const char *func, int32_t line)
{
  if (!p)
    {
      fprintf(stderr, "%s%s[%d]: null pointer!%s\n", BOLD_TEXT, func, line, UNBOLD_TEXT);
      if (stop_at_error) abort();
    }
  else
    {
      uint8_t typ;
      typ = unchecked_type(p);
      if (typ >= NUM_TYPES)
	{
	  fprintf(stderr, "%s%s[%d]: attempt to use messed up cell (type: %d)%s\n", BOLD_TEXT, func, line, typ, UNBOLD_TEXT);
	  if (stop_at_error) abort();
	}
    }
  return(p);
}

static s7_pointer check_nref(s7_pointer p, const char *func, int32_t line)
{
  uint8_t typ;
  check_cell(p, func, line);
  typ = unchecked_type(p);
  if (typ == T_FREE)
    {
      char *s;
      fprintf(stderr, "%s%s[%d]: attempt to use free cell%s\n", BOLD_TEXT, func, line, UNBOLD_TEXT);
      typeflag(p) = p->current_alloc_type;
      fprintf(stderr, "  free cell %p alloc: %s[%d], alloc type: #x%x %s\n",
	      p, p->current_alloc_func, p->current_alloc_line,
	      (unsigned int)(p->current_alloc_type), s = describe_type_bits(cur_sc, p));
      free(s);
      typeflag(p) = 0;
      if (stop_at_error) abort();
    }
  return(p);
}

static void print_gc_info(s7_pointer obj, int32_t line)
{
  if (!obj)
    fprintf(stderr, "[%d]: obj is %p\n", line, obj);
  else
    {
      if (unchecked_type(obj) != T_FREE)
	fprintf(stderr, "[%d]: %p type is %d?\n", line, obj, unchecked_type(obj));
      else
	{
	  s7_int free_type;
	  char *bits;
	  free_type = typeflag(obj);
	  typeflag(obj) = obj->current_alloc_type;
	  bits = describe_type_bits(cur_sc, obj); /* this func called in type macro, so use cur_sc */
	  typeflag(obj) = free_type;
	  fprintf(stderr, "%s%p is free (line %d, alloc type: [%s]), current: %s[%d], previous: %s[%d]%s\n",
		  BOLD_TEXT,
		  obj, line, bits,
		  obj->current_alloc_func, obj->current_alloc_line,
		  obj->previous_alloc_func, obj->previous_alloc_line,
		  UNBOLD_TEXT);
	  free(bits);
	}
    }
  abort();
}

static const char *opt1_role_name(uint32_t role)
{
  if (role == E_FAST) return("opt1_fast");
  if (role == E_CFUNC) return("opt1_cfunc");
  if (role == E_LAMBDA) return("opt_lambda");
  if (role == E_CLAUSE) return("opt1_clause");
  if (role == E_GOTO) return("opt1_goto");
  if (role == E_SYM) return("opt1_sym");
  if (role == E_PAIR) return("opt1_pair");
  if (role == E_CON) return("opt1_con");
  if (role == E_ANY) return("opt1_any");
  if (role == E_SLOT) return("opt1_slot");
  return("unknown");
}

static const char *opt2_role_name(uint32_t role)
{
  if (role == F_CALL) return("c_call(ee)");
  if (role == F_KEY) return("opt2_any");
  if (role == F_SLOW) return("opt2_slow");
  if (role == F_SYM) return("opt2_sym");
  if (role == F_PAIR) return("opt2_pair");
  if (role == F_CON) return("opt2_con");
  if (role == F_LAMBDA) return("opt2_lambda");
  return("unknown");
}

static const char *opt3_role_name(uint32_t role)
{
  if (role == G_ARGLEN) return("opt3_arglen");
  if (role == G_SYM) return("opt3_sym");
  if (role == G_AND) return("opt3_pair");
  if (role == G_ANY) return("opt3_any");
  if (role == G_CTR) return("opt3_ctr");
  if (role == G_CON) return("opt3_con");
  if (role == G_DIRECT) return("direct_opt3");
  if (role == S_LEN) return("s_len");
  if (role == S_LINE) return("s_line");
  if (role == S_HASH) return("s_hash");
  return("unknown");
}

static char* show_debugger_bits(int64_t bits)
{
  char *bits_str;
  bits_str = (char *)malloc(512 * sizeof(char));
  snprintf(bits_str, 512, " %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
	  ((bits & E_SET) != 0) ? " e-set" : "",
	  ((bits & E_FAST) != 0) ? " opt1_fast" : "",
	  ((bits & E_CFUNC) != 0) ? " opt1_cfunc" : "",
	  ((bits & E_CLAUSE) != 0) ? " opt1_clause" : "",
	  ((bits & E_LAMBDA) != 0) ? " opt_lambda" : "",
	  ((bits & E_SYM) != 0) ? " opt1_sym" : "",
	  ((bits & E_PAIR) != 0) ? " opt1_pair" : "",
	  ((bits & E_CON) != 0) ? " opt1_con" : "",
	  ((bits & E_GOTO) != 0) ? " opt1_goto" : "",
	  ((bits & E_ANY) != 0) ? " opt1_any" : "",
	  ((bits & E_SLOT) != 0) ? " opt1_slot" : "",
	  ((bits & F_SET) != 0) ? " f-set" : "",
	  ((bits & F_KEY) != 0) ? " opt2_any" : "",
	  ((bits & F_SLOW) != 0) ? " opt2_slow" : "",
	  ((bits & F_SYM) != 0) ? " opt2_sym" : "",
	  ((bits & F_PAIR) != 0) ? " opt2_pair" : "",
	  ((bits & F_CON) != 0) ? " opt2_con" : "",
	  ((bits & F_CALL) != 0) ? " c_call(ee)" : "",
	  ((bits & F_LAMBDA) != 0) ? " opt2_lambda" : "",
	  ((bits & G_SET) != 0) ? " g-set" : "",
	  ((bits & G_ARGLEN) != 0) ? " opt3_arglen" : "",
	  ((bits & G_SYM) != 0) ? " opt3_sym" : "",
	  ((bits & G_AND) != 0) ? " opt3_pair " : "",
	  ((bits & G_ANY) != 0) ? " opt3_any " : "",
	  ((bits & G_CTR) != 0) ? " opt3_ctr " : "",
	  ((bits & G_CON) != 0) ? " opt3_con " : "",
	  ((bits & G_DIRECT) != 0) ? " opt3_direct_x" : "",
	  ((bits & S_NAME) != 0) ? " raw-name" : "",
	  ((bits & S_HASH) != 0) ? " raw-hash" : "",
	  ((bits & S_LINE) != 0) ? " line" : "",
	  ((bits & S_LEN) != 0) ? " len" : "");
  return(bits_str);
}

static void show_opt1_bits(s7_pointer p, const char *func, int32_t line, uint32_t role)
{
  char *bits;
  bits = show_debugger_bits(p->debugger_bits);
  fprintf(stderr, "%s%s[%d]: opt1: %p->%p wants %s, debugger bits are %" PRIx64 "%s but expects %x",
	  BOLD_TEXT,
	  func, line, p, p->object.cons.opt1,
	  opt1_role_name(role),
	  p->debugger_bits, bits, role);
  if (p->opt1_func)
    fprintf(stderr, " (set %s[%d])%s\n", p->opt1_func, p->opt1_line, UNBOLD_TEXT);
  else fprintf(stderr, " (unset)%s\n", UNBOLD_TEXT);
  free(bits);
}

static s7_pointer opt1_1(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  if ((!opt1_is_set(p)) ||
      ((!opt1_role_matches(p, role)) &&
       (role != E_ANY)))
    {
      show_opt1_bits(p, func, line, role);
      if (stop_at_error) abort();
    }
  return(p->object.cons.opt1);
}

static void base_opt1(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  p->opt1_line = line;
  p->opt1_func = func;
  set_opt1_role(p, role);
  set_opt1_is_set(p);
}

static s7_pointer set_opt1_1(s7_pointer p, s7_pointer x, uint32_t role, const char *func, int32_t line)
{
  p->object.cons.opt1 = x;
  base_opt1(p, role, func,  line);
  return(x);
}

static uint64_t s_hash_1(s7_pointer p, const char *func, int32_t line)
{
  if ((!opt1_is_set(p)) ||
      (!opt1_role_matches(p, S_HASH)))
    {
      show_opt1_bits(p, func, line, (uint32_t)S_HASH);
      if (stop_at_error) abort();
    }
  return(p->object.sym_cons.hash);
}

static void set_s_hash_1(s7_pointer p, uint64_t x, const char *func, int32_t line)
{
  p->object.sym_cons.hash = x;
  base_opt1(p, S_HASH, func,  line);
}

static void show_opt2_bits(s7_pointer p, const char *func, int32_t line, uint32_t role)
{
  char *bits;
  bits = show_debugger_bits(p->debugger_bits);
  fprintf(stderr, "%s%s[%d]: opt2: %p->%p wants %s, debugger bits are %" PRIx64 "%s but expects %x%s%s%s%s%s%s%s%s%s",
	  BOLD_TEXT,
	  func, line, p, p->object.cons.opt2,
	  opt2_role_name(role),
	  p->debugger_bits, bits, role,
	  ((role & F_SET) != 0) ? " f-set" : "",
	  ((role & F_KEY) != 0) ? " any" : "",
	  ((role & F_SLOW) != 0) ? " slow" : "",
	  ((role & F_SYM) != 0) ? " sym" : "",
	  ((role & F_PAIR) != 0) ? " pair" : "",
	  ((role & F_CON) != 0) ? " con" : "",
	  ((role & F_CALL) != 0) ? " call" : "",
	  ((role & F_LAMBDA) != 0) ? " lambda" : "",
	  ((role & S_NAME) != 0) ? " raw-name" : "");
  if (p->opt2_func)
    fprintf(stderr, " (set %s[%d])%s\n", p->opt2_func, p->opt2_line, UNBOLD_TEXT);
  else fprintf(stderr, " (unset)%s\n", UNBOLD_TEXT);
  free(bits);
}

static bool f_call_func_mismatch(const char *func)
{
  return((!safe_strcmp(func, "check_and")) &&  /* these reflect set_c_call_checked|unchecked where the destination checks for null c_call */
	 (!safe_strcmp(func, "check_or")) &&
	 (!safe_strcmp(func, "eval")) &&
	 (!safe_strcmp(func, "optimize_func_two_args")) &&
	 (!safe_strcmp(func, "optimize_func_many_args")) &&
	 (!safe_strcmp(func, "optimize_func_three_args")));
}

static s7_pointer opt2_1(s7_scheme *sc, s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  if ((!opt2_is_set(p)) ||
      (!opt2_role_matches(p, role)))
    {
      show_opt2_bits(p, func, line, role);
      fprintf(stderr, "p: %s\n", string_value(s7_object_to_string(sc, p, false)));
      if (stop_at_error) abort();
    }
  if ((role == F_CALL) &&
      (!has_fx(p)) &&
      (f_call_func_mismatch(func)))
    fprintf(stderr, "%s[%d]: f_call but no fx\n", func, line);
  return(p->object.cons.opt2);
}

static void base_opt2(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  p->opt2_line = line;
  p->opt2_func = func;
  set_opt2_role(p, role);
  set_opt2_is_set(p);
}

static void set_opt2_1(s7_scheme *sc, s7_pointer p, s7_pointer x, uint32_t role, const char *func, int32_t line)
{
  if ((role == F_CALL) &&
      (x == NULL) &&
      (f_call_func_mismatch(func)))
    fprintf(stderr, "%s[%d]: set c_call for %s to null\n", func, line, string_value(object_to_truncated_string(sc, p, 80)));
  if (role != F_CALL)
    clear_has_fx(p);
  p->object.cons.opt2 = x;
  base_opt2(p, role, func, line);
}

static const char *s_name_1(s7_pointer p, const char *func, int32_t line)
{
  if ((!opt2_is_set(p)) ||
      (!opt2_role_matches(p, S_NAME)))
    {
      show_opt2_bits(p, func, line, (uint32_t)S_NAME);
      if (stop_at_error) abort();
    }
  return(p->object.sym_cons.fstr);
}

static void set_s_name_1(s7_pointer p, const char *str, const char *func, int32_t line)
{
  p->object.sym_cons.fstr = str;
  base_opt2(p, S_NAME, func, line);
}

static void show_opt3_bits(s7_pointer p, const char *func, int32_t line, int32_t role)
{
  char *bits;
  bits = show_debugger_bits(p->debugger_bits);
  fprintf(stderr, "%s%s[%d]: opt3: %s %" PRIx64 "%s", BOLD_TEXT, func, line, opt3_role_name(role), p->debugger_bits, bits);
  if (p->opt3_func)
    fprintf(stderr, " (set %s[%d])%s\n", p->opt3_func, p->opt3_line, UNBOLD_TEXT);
  else fprintf(stderr, " (unset)%s\n", UNBOLD_TEXT);
  free(bits);
}

static void check_opt3_bits(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  if ((!opt3_is_set(p)) ||
      (!opt3_role_matches(p, role)))
    {
      show_opt3_bits(p, func, line, role);
      if (stop_at_error) abort();
    }
}

static s7_pointer opt3_1(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  check_opt3_bits(p, role, func, line);
  return(p->object.cons.opt3);
}

static void base_opt3(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  p->opt3_line = line;
  p->opt3_func = func;
  set_opt3_role(p, role);
  set_opt3_is_set(p);
}

static void set_opt3_1(s7_pointer p, s7_pointer x, uint32_t role, const char *func, int32_t line)
{
  clear_type_bit(p, T_LINE_NUMBER);
  p->object.cons.opt3 = x;
  base_opt3(p, role, func, line);
}

static uint8_t opt3_con_1(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  check_opt3_bits(p, role, func, line);
  return(p->object.cons_ext.ce.opt_type);
}

static void set_opt3_con_1(s7_pointer p, uint8_t x, uint32_t role, const char *func, int32_t line)
{
  clear_type_bit(p, T_LINE_NUMBER);
  p->object.cons_ext.ce.opt_type = x;
  base_opt3(p, role, func, line);
}

static int32_t opt3_ctr_1(s7_pointer p, int32_t role, const char *func, int32_t line)
{
  check_opt3_bits(p, role, func, line);
  return(p->object.cons_ext.ce.ctr);
}

static void set_opt3_ctr_1(s7_pointer p, int32_t x, uint32_t role, const char *func, int32_t line)
{
  clear_type_bit(p, T_LINE_NUMBER);
  p->object.cons_ext.ce.ctr = x;
  set_ctr3_is_set(p);
  base_opt3(p, role, func, line);
}

static void increment_opt3_ctr_1(s7_pointer p, uint32_t role, const char *func, int32_t line)
{
  clear_type_bit(p, T_LINE_NUMBER);
  if (ctr3_is_set(p))
    p->object.cons_ext.ce.ctr++;
  else p->object.cons_ext.ce.ctr = 0;
  set_ctr3_is_set(p);
  base_opt3(p, role, func, line);
}

/* S_LINE */
static uint32_t s_line_1(s7_pointer p, const char *func, int32_t line)
{
  if ((!opt3_is_set(p)) ||
      ((p->debugger_bits & S_LINE) == 0) ||
      (!has_line_number(p)))
    {
      show_opt3_bits(p, func, line, (uint32_t)S_LINE);
      if (stop_at_error) abort();
    }
  return(p->object.sym_cons.line);
}

static void set_s_line_1(s7_pointer p, uint32_t x, const char *func, int32_t line)
{
  p->object.sym_cons.line = x;
  (p)->debugger_bits = (S_LINE | (p->debugger_bits & ~S_LEN)); /* turn on line, cancel len */
  set_opt3_is_set(p);
}

static void set_s_file_1(s7_scheme *sc, s7_pointer p, uint32_t x, const char *func, int32_t line)
{
  p->object.sym_cons.file = x;
  if ((int32_t)x > sc->file_names_top)
    {
      fprintf(stderr, "%s[%d]: pair_set_file_name to %u?\n", func, line, x);
      if (stop_at_error) abort();
    }
}

/* S_LEN (collides with S_LINE) */
static uint32_t s_len_1(s7_pointer p, const char *func, int32_t line)
{
  if ((!opt3_is_set(p)) ||
      ((p->debugger_bits & S_LEN) == 0) ||
      (has_line_number(p)))
    {
      show_opt3_bits(p, func, line, (uint32_t)S_LEN);
      if (stop_at_error) abort();
    }
  return(p->object.sym_cons.line);
}

static void set_s_len_1(s7_pointer p, uint32_t x, const char *func, int32_t line)
{
  clear_type_bit(p, T_LINE_NUMBER);
  p->object.sym_cons.line = x;
  (p)->debugger_bits = (S_LEN | (p->debugger_bits & ~(S_LINE)));
  set_opt3_is_set(p);
}

static void print_debugging_state(s7_scheme *sc, s7_pointer obj, s7_pointer port)
{
  /* show current state, current allocated state, and previous allocated state */
  char *current_bits, *allocated_bits, *previous_bits, *str;
  int64_t save_typeflag;
  s7_int len, nlen;
  const char *excl_name;
  block_t *b;

  if (is_free(obj))
    excl_name = "free cell!";
  else excl_name = "unknown object!";

  current_bits = describe_type_bits(sc, obj);
  save_typeflag = typeflag(obj);
  typeflag(obj) = obj->current_alloc_type;
  allocated_bits = describe_type_bits(sc, obj);
  typeflag(obj) = obj->previous_alloc_type;
  previous_bits = describe_type_bits(sc, obj);
  typeflag(obj) = save_typeflag;

  len = safe_strlen(excl_name) +
    safe_strlen(current_bits) + safe_strlen(allocated_bits) + safe_strlen(previous_bits) +
    safe_strlen(obj->previous_alloc_func) + safe_strlen(obj->current_alloc_func) + 512;

  b = mallocate(sc, len);
  str = (char *)block_data(b);
  nlen = snprintf(str, len,
		  "\n<%s %s,\n  current: %s[%d] %s,\n  previous: %s[%d] %s\n  %d uses>",
		  excl_name, current_bits,
		  obj->current_alloc_func, obj->current_alloc_line, allocated_bits,
		  obj->previous_alloc_func, obj->previous_alloc_line, previous_bits,
		  obj->uses);
  free(current_bits);
  free(allocated_bits);
  free(previous_bits);
  if (is_null(port))
    fprintf(stderr, "%p: %s\n", obj, str);
  else port_write_string(port)(sc, str, nlen, port);
  liberate(sc, b);
}

static s7_pointer check_null_sym(s7_scheme *sc, s7_pointer p, s7_pointer sym, int32_t line, const char *func)
{
  if (!p)
    {
      s7_pointer slot;
      char *s;
      fprintf(stderr, "%s%s[%d]: %s unbound%s\n", BOLD_TEXT, func, line, symbol_name(sym), UNBOLD_TEXT);
      fprintf(stderr, "  symbol_id: %" print_s7_int ", let_id: %" print_s7_int ", bits: %s", symbol_id(sym), let_id(sc->envir), s = describe_type_bits(sc, sym));
      free(s);
      slot = symbol_to_local_slot(sc, sym, sc->envir);
      if (is_slot(slot)) fprintf(stderr, ", slot: %s", DISPLAY(slot));
      fprintf(stderr, "\n");
      if (stop_at_error) abort();
    }
  return(p);
}
#endif

static void iterator_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (use_write == P_READABLE)
    {
      if (iterator_is_at_end(obj))
	{
	  switch (type(iterator_sequence(obj)))
	    {
	    case T_NIL:
	    case T_PAIR:         port_write_string(port)(sc, "(make-iterator ())", 18, port);	        break;
	    case T_STRING:       port_write_string(port)(sc, "(make-iterator \"\")", 18, port);	        break;
	    case T_BYTE_VECTOR:  port_write_string(port)(sc, "(make-iterator #u())", 20, port);	        break;
	    case T_VECTOR:       port_write_string(port)(sc, "(make-iterator #())", 19, port);	        break;
	    case T_INT_VECTOR:	 port_write_string(port)(sc, "(make-iterator #i())", 20, port);	        break;
	    case T_FLOAT_VECTOR: port_write_string(port)(sc, "(make-iterator #r())", 20, port);	        break;
	    case T_LET:	         port_write_string(port)(sc, "(make-iterator (inlet))", 23, port);      break;

	    case T_HASH_TABLE:
	      if (is_weak_hash_table(iterator_sequence(obj)))
		port_write_string(port)(sc, "(make-iterator (weak-hash-table))", 33, port);
	      else port_write_string(port)(sc, "(make-iterator (hash-table))", 28, port);
	      break;

	    default:	         
	      port_write_string(port)(sc, "(make-iterator ())", 18, port);	        break; /* c-object?? function? */
	    }
	}
      else
	{
	  s7_pointer seq;
	  seq = iterator_sequence(obj);
	  if ((ci) &&
	      (is_cyclic(obj)) &&
	      (peek_shared_ref(ci, obj) != 0))
	    {
	      /* basically the same as c_pointer_to_port */
	      if (!is_cyclic_set(obj))
		{
		  int32_t iter_ref, nlen;
		  char buf[128];
		  iter_ref = peek_shared_ref(ci, obj);
		  if (iter_ref < 0) iter_ref = -iter_ref;

		  if (ci->init_port == sc->F)
		    {
		      ci->init_port = s7_open_output_string(sc);
		      ci->init_loc = s7_gc_protect_1(sc, ci->init_port);
		    }
		  port_write_string(port)(sc, "#f", 2, port);
		  nlen = catstrs_direct(buf, "  (set! <", pos_int_to_str_direct(sc, iter_ref), "> (make-iterator ", NULL);
		  port_write_string(ci->init_port)(sc, buf, nlen, ci->init_port);

		  flip_ref(ci, seq);
		  object_to_port_with_circle_check(sc, seq, ci->init_port, use_write, ci);
		  flip_ref(ci, seq);

		  port_write_string(ci->init_port)(sc, "))\n", 3, ci->init_port);
		  set_cyclic_set(obj);
		  return;
		}
	    }

	  if (is_string(seq))
	    {
	      char *iter_str;
	      s7_int len;
	      iter_str = (char *)(string_value(seq) + iterator_position(obj));
	      len = string_length(seq) - iterator_position(obj);
	      if (len == 0)
		port_write_string(port)(sc, "(make-iterator \"\")", 18, port);
	      else
		{
		  port_write_string(port)(sc, "(make-iterator \"", 16, port);
		  if (!string_needs_slashification(iter_str, len))
		    port_write_string(port)(sc, iter_str, len, port);
		  else slashify_string_to_port(sc, port, iter_str, len, NOT_IN_QUOTES);
		  port_write_string(port)(sc, "\")", 2, port);
		}
	    }
	  else
	    {
	      if (is_pair(seq))
		{
		  port_write_string(port)(sc, "(make-iterator ", 15, port);
		  object_to_port_with_circle_check(sc, iterator_current(obj), port, use_write, ci);
		  port_write_character(port)(sc, ')', port);
		}
	      else
		{
		  if ((is_let(seq)) && (seq != sc->rootlet))
		    {
		      s7_pointer slot;
		      port_write_string(port)(sc, "(let ((iter (make-iterator ", 27, port);
		      object_to_port_with_circle_check(sc, seq, port, use_write, ci);
		      port_write_string(port)(sc, "))) ", 4, port);
		      for (slot = let_slots(seq); slot != iterator_current_slot(obj); slot = next_slot(slot))
			port_write_string(port)(sc, "(iter) ", 7, port);
		      port_write_string(port)(sc, "iter)", 5, port);
		    }
		  else
		    {
		      if (iterator_position(obj) > 0)
			port_write_string(port)(sc, "(let ((iter (make-iterator ", 27, port);
		      else port_write_string(port)(sc, "(make-iterator ", 15, port);
		      object_to_port_with_circle_check(sc, seq, port, use_write, ci);
		      if (iterator_position(obj) > 0)
			{
			  if (iterator_position(obj) == 1)
			    port_write_string(port)(sc, "))) (iter) iter)", 16, port);
			  else
			    {
			      int32_t nlen;
			      char str[128];
			      nlen = catstrs_direct(str, "))) (do ((i 0 (+ i 1))) ((= i ",
						    pos_int_to_str_direct(sc, iterator_position(obj)),
						    ") iter) (iter)))", NULL);
			      port_write_string(port)(sc, str, nlen, port);
			    }
			}
		      else port_write_character(port)(sc, ')', port);
		    }}}}
    }
  else
    {
      const char *str;
      if ((is_hash_table(iterator_sequence(obj))) && (is_weak_hash_table(iterator_sequence(obj))))
	str = "weak-hash-table";
      else str = type_name(sc, iterator_sequence(obj), NO_ARTICLE);
      port_write_string(port)(sc, "#<iterator: ", 12, port);
      port_write_string(port)(sc, str, safe_strlen(str), port);
      port_write_character(port)(sc, '>', port);
    }
}

static void baffle_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  int32_t nlen;          /* (with-baffle (display (curlet)) (newline)) */
  char buf[64];
  nlen = catstrs_direct(buf, "#<baffle: ", pos_int_to_str_direct(sc, baffle_key(obj)), ">", NULL);
  port_write_string(port)(sc, buf, nlen, port);
}

static void c_pointer_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  int32_t nlen;
  char buf[128];
  /* c-pointer is special because we can't set the type or info fields from scheme except via the c-pointer function */

  if (use_write == P_READABLE)
    {
      if ((ci) &&
	  (is_cyclic(obj)) &&
	  (peek_shared_ref(ci, obj) != 0))
	{
	  port_write_string(port)(sc, "#f", 2, port);

	  if (!is_cyclic_set(obj))
	    {
	      if (ci->init_port == sc->F)
		{
		  ci->init_port = s7_open_output_string(sc);
		  ci->init_loc = s7_gc_protect_1(sc, ci->init_port);
		}
	      nlen = snprintf(buf, 128, "  (set! <%d> (c-pointer %" print_pointer, -peek_shared_ref(ci, obj), (intptr_t)c_pointer(obj));
	      port_write_string(ci->init_port)(sc, buf, nlen, ci->init_port);

	      if ((c_pointer_type(obj) != sc->F) ||
		  (c_pointer_info(obj) != sc->F))
		{
		  flip_ref(ci, c_pointer_type(obj));

		  port_write_character(ci->init_port)(sc, ' ', ci->init_port);
		  object_to_port_with_circle_check(sc, c_pointer_type(obj), ci->init_port, use_write, ci);

		  flip_ref(ci, c_pointer_type(obj));
		  flip_ref(ci, c_pointer_info(obj));

		  port_write_character(ci->init_port)(sc, ' ', ci->init_port);
		  object_to_port_with_circle_check(sc, c_pointer_info(obj), ci->init_port, use_write, ci);

		  flip_ref(ci, c_pointer_info(obj));
		}
	      port_write_string(ci->init_port)(sc, "))\n", 3, ci->init_port);
	      set_cyclic_set(obj);
	    }
	}
      else
	{
	  nlen = snprintf(buf, 128, "(c-pointer %" print_pointer, (intptr_t)c_pointer(obj));
	  port_write_string(port)(sc, buf, nlen, port);
	  if ((c_pointer_type(obj) != sc->F) ||
	      (c_pointer_info(obj) != sc->F))
	    {
	      port_write_character(port)(sc, ' ', port);
	      object_to_port_with_circle_check(sc, c_pointer_type(obj), port, use_write, ci);
	      port_write_character(port)(sc, ' ', port);
	      object_to_port_with_circle_check(sc, c_pointer_info(obj), port, use_write, ci);
	    }
	  port_write_character(port)(sc, ')', port);
	}
    }
  else
    {
      if (is_symbol(c_pointer_type(obj)))
	nlen = snprintf(buf, 128, "#<%s %p>", symbol_name(c_pointer_type(obj)), c_pointer(obj));
      else nlen = snprintf(buf, 128, "#<c_pointer %p>", c_pointer(obj));
      port_write_string(port)(sc, buf, nlen, port);
    }
}

static void rng_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  int32_t nlen;
  char buf[128];
#if WITH_GMP
  if (use_write == P_READABLE)
    nlen = snprintf(buf, 128, "#<unprint-readable object>");
  else nlen = snprintf(buf, 128, "#<rng %p>", obj);
#else
  if (use_write == P_READABLE)
    nlen = snprintf(buf, 128, "(random-state %" PRIu64 " %" PRIu64 ")", random_seed(obj), random_carry(obj));
  else nlen = snprintf(buf, 128, "#<rng %" PRIu64 " %" PRIu64 ">", random_seed(obj), random_carry(obj));
#endif
  port_write_string(port)(sc, buf, nlen, port);
}

static void display_any(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
#if S7_DEBUGGING
  print_debugging_state(sc, obj, port);
#else
  {
    char *str, *tmp;
    block_t *b;
    s7_int nlen, len;
    tmp = describe_type_bits(sc, obj);
    len = 32 + safe_strlen(tmp);
    b = mallocate(sc, len);
    str = (char *)block_data(b);
    if (is_free(obj))
      nlen = catstrs_direct(str, "<free cell! ", tmp, ">", NULL);
    else nlen = catstrs_direct(str, "<unknown object! ", tmp, ">", NULL);
    port_write_string(port)(sc, str, nlen, port);
    free(tmp);
    liberate(sc, b);
  }
#endif
}

static void unique_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
#if S7_DEBUGGING
  if ((obj == sc->no_value) &&
      (use_write == P_READABLE))
    port_write_string(port)(sc, "#<unspecified>", 14, port);
  else
#endif
    port_write_string(port)(sc, unique_name(obj), unique_name_length(obj), port);
}

static void undefined_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if ((obj != sc->undefined) &&
      (use_write == P_READABLE))
    {
      port_write_string(port)(sc, "(with-input-from-string \"",25, port);
      port_write_string(port)(sc, unknown_name(obj), unique_name_length(obj), port);
      port_write_string(port)(sc, "\" read)", 7, port);
    }
  else port_write_string(port)(sc, unknown_name(obj), unique_name_length(obj), port);
}

static void eof_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  /* if file has #<eof> it causes read to return #<eof> -> end of read! what is readable version? '#<eof> or (begin #<eof>) as below
   * but this is silly -- to fool read, the #<eof> has to be all by itself at the top-level!
   * and the read of #<eof> does not affect the port, so if you know it's there, just ignore #<eof> and continue reading.
   */
  if (use_write == P_READABLE)
    port_write_string(port)(sc, "(begin #<eof>)", 14, port);
  else port_write_string(port)(sc, unique_name(obj), unique_name_length(obj), port);
}

static void counter_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
#if S7_DEBUGGING
  char data[256];
  size_t len;
  len = snprintf(data, 256, "#<counter: %s %s %s>", DISPLAY_80(counter_list(obj)), DISPLAY_80(counter_result(obj)), DISPLAY_80(counter_let(obj)));
  port_write_string(port)(sc, data, len, port);
#else
  port_write_string(port)(sc, "#<counter>", 10, port);
#endif
}

static void integer_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (has_print_name(obj))
    {
      if (is_string_port(port))
	{
	  if (port_position(port) + print_name_length(obj) < port_data_size(port))
	    {
	      memcpy((void *)(port_data(port) + port_position(port)), (void *)print_name(obj), print_name_length(obj));
	      port_position(port) += print_name_length(obj);
	    }
	  else string_write_string_resized(sc, print_name(obj), print_name_length(obj), port);
	}
      else port_write_string(port)(sc, print_name(obj), print_name_length(obj), port);
    }
  else
    {
      s7_int nlen;
      char *str;
      str = integer_to_string(sc, integer(obj), &nlen);
      set_print_name(obj, str, nlen);
      port_write_string(port)(sc, str, nlen, port);
    }
}

static void number_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (has_print_name(obj))
    port_write_string(port)(sc, print_name(obj), print_name_length(obj), port);
  else
    {
      s7_int nlen;
      char *str;
      nlen = 0;
      str = number_to_string_base_10(sc, obj, 0, sc->float_format_precision, 'g', &nlen, use_write); /* was 14 */
      if ((nlen < PRINT_NAME_SIZE) &&
	  (str[0] != 'n') && (str[0] != 'i') &&
	  ((!(is_t_complex(obj))) ||
	   ((!is_NaN(imag_part(obj))) && (!is_inf(imag_part(obj))))))
	set_print_name(obj, str, nlen);
      port_write_string(port)(sc, str, nlen, port);
    }
}

#if WITH_GMP
static void big_number_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  s7_int nlen;
  char *str;
  nlen = 0;
  str = big_number_to_string_with_radix(obj, BASE_10, 0, &nlen, use_write);
  port_write_string(port)(sc, str, nlen, port);
  free(str);
}
#endif

static void syntax_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  port_display(port)(sc, symbol_name(syntax_symbol(obj)), port);
}

static void character_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (use_write == P_DISPLAY)
    port_write_character(port)(sc, character(obj), port);
  else port_write_string(port)(sc, character_name(obj), character_name_length(obj), port);
}

static void closure_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (has_active_methods(sc, obj))
    {
      /* look for object->string method else fallback on ordinary case.
       * can't use recursion on closure_let here because then the fallback name is #<let>.
       * this is tricky!: (display (openlet (with-let (mock-c-pointer 0) (lambda () 1))))
       *   calls object->string on the closure whose closure_let is the mock-c-pointer;
       *   it has an object->string method that clears mock-c-pointers and tries again...
       *   so, display methods need to use coverlet/openlet.
       */
      s7_pointer print_func;
      print_func = find_method(sc, closure_let(obj), sc->object_to_string_symbol);
      if (print_func != sc->undefined)
	{
	  s7_pointer p;
	  p = s7_apply_function(sc, print_func, list_1(sc, obj));
	  if (string_length(p) > 0)
	    port_write_string(port)(sc, string_value(p), string_length(p), port);
	  return;
	}
    }
  if (use_write == P_READABLE)
    write_closure_readably(sc, obj, port, ci);
  else write_closure_name(sc, obj, port);
}

static void macro_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (use_write == P_READABLE)
    write_macro_readably(sc, obj, port);
  else write_closure_name(sc, obj, port);
}

static void c_function_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (use_write == P_READABLE)
    {
      s7_pointer sym;
      sym = make_symbol(sc, c_function_name(obj));
      if ((is_slot(initial_slot(sym))) && (!is_global(sym)))
	{
	  port_write_string(port)(sc, "#_", 2, port);
	  port_write_string(port)(sc, c_function_name(obj), c_function_name_length(obj), port);
	  return;
	}
    }
  if (c_function_name_length(obj) > 0)
    port_write_string(port)(sc, c_function_name(obj), c_function_name_length(obj), port);
  else port_write_string(port)(sc, "#<unnamed-c-function>", 21, port);
}

static void c_macro_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  if (c_macro_name_length(obj) > 0)
    port_write_string(port)(sc, c_macro_name(obj), c_macro_name_length(obj), port);
  else port_write_string(port)(sc, "#<unnamed-c-macro>", 18, port);
}

static void continuation_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  port_write_string(port)(sc, "#<continuation>", 15, port); /* how can a continuation be printed readably? */
}

static void goto_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  port_write_string(port)(sc, "#<goto>", 7, port); /* same query as above */
}

static void catch_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  port_write_string(port)(sc, "#<catch>", 8, port);
}

static void dynamic_wind_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  /* this can happen because (*s7* 'stack) can involve dynamic-wind markers */
  port_write_string(port)(sc, "#<dynamic-wind>", 15, port);
}

static void c_object_name_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port)
{
  port_write_string(port)(sc, string_value(c_object_scheme_name(sc, obj)),
			  string_length(c_object_scheme_name(sc, obj)),
			  port);
}

static void c_object_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
#if (!DISABLE_DEPRECATED)
  if (c_object_print(sc, obj))
    {
      char *str;
      str = ((*(c_object_print(sc, obj)))(sc, c_object_value(obj)));
      port_display(port)(sc, str, port);
      free(str);
      return;
    }
#endif
  if (c_object_to_string(sc, obj))
    port_display(port)(sc, s7_string((*(c_object_to_string(sc, obj)))(sc, set_plist_2(sc, obj, (use_write == P_READABLE) ? sc->key_readable_symbol : sc->T))), port);
  else
    {
      if ((use_write == P_READABLE) &&
	  (c_object_to_list(sc, obj)) &&  /* to_list and (implicit) set are needed to reconstruct a cyclic c-object, as well as the maker (via type name) */
	  (c_object_set(sc, obj)))
	{
	  s7_pointer obj_list, old_w, p;

	  obj_list = ((*(c_object_to_list(sc, obj)))(sc, set_plist_1(sc, obj)));
	  old_w = sc->w;
	  sc->w = obj_list;

	  if ((ci) &&
	      (is_cyclic(obj)) &&
	      (peek_shared_ref(ci, obj) != 0))
	    {
	      int32_t i, href;
	      href = peek_shared_ref(ci, obj);
	      if (href < 0) href = -href;
	      if ((ci->defined[href]) || (port == ci->cycle_port))
		{
		  int32_t nlen;
		  char buf[128];
		  nlen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, href), ">", NULL);
		  port_write_string(port)(sc, buf, nlen, port);
		  return;
		}

	      port_write_character(port)(sc, '(', port);
	      c_object_name_to_port(sc, obj, port);
	      for (i = 0, p = obj_list; is_pair(p); i++, p = cdr(p))
		{
		  s7_pointer val;
		  val = car(p);
		  if (has_structure(val))
		    {
		      char buf[128];
		      int32_t symref, len;

		      port_write_string(port)(sc, " #f", 3, port);
		      len = catstrs_direct(buf, "  (set! (<", pos_int_to_str_direct(sc, href), "> ", pos_int_to_str_direct_1(sc, i), ") ", NULL);
		      port_write_string(ci->cycle_port)(sc, buf, len, ci->cycle_port);

		      symref = peek_shared_ref(ci, val);
		      if (symref != 0)
			{
			  if (symref < 0) symref = -symref;
			  len = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, symref), ">)\n", NULL);
			  port_write_string(ci->cycle_port)(sc, buf, len, ci->cycle_port);
			}
		      else
			{
			  object_to_port_with_circle_check(sc, val, ci->cycle_port, P_READABLE, ci);
			  port_write_string(ci->cycle_port)(sc, ")\n", 2, ci->cycle_port);
			}
		    }
		  else
		    {
		      port_write_character(port)(sc, ' ', port);
		      object_to_port_with_circle_check(sc, val, port, P_READABLE, ci);
		    }
		}
	    }
	  else
	    {
	      port_write_character(port)(sc, '(', port);
	      c_object_name_to_port(sc, obj, port);
	      for (p = obj_list; is_pair(p); p = cdr(p))
		{
		  s7_pointer val;
		  val = car(p);
		  port_write_character(port)(sc, ' ', port);
		  object_to_port_with_circle_check(sc, val, port, P_READABLE, ci);
		}
	    }
	  port_write_character(port)(sc, ')', port);
	  sc->w = old_w;
	}
      else
	{
	  char buf[128];
	  int32_t nlen;
	  port_write_string(port)(sc, "#<", 2, port);
	  c_object_name_to_port(sc, obj, port);
	  nlen = snprintf(buf, 128, " %p>", obj);
	  port_write_string(port)(sc, buf, nlen, port);
	}
    }
}

static void slot_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  /* the slot symbol might need (symbol...) in which case we don't want the preceding quote */
  symbol_to_port(sc, slot_symbol(obj), port, P_READABLE, ci);
  port_write_character(port)(sc, ' ', port);
  object_to_port_with_circle_check(sc, slot_value(obj), port, use_write, ci);
}

static void stack_to_port(s7_scheme *sc, s7_pointer obj, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  port_write_string(port)(sc, "#<stack>", 8, port);
}

static void init_display_functions(void)
{
  int32_t i;
  for (i = 0; i < 256; i++) display_functions[i] = display_any;
  display_functions[T_FLOAT_VECTOR] = float_vector_to_port;
  display_functions[T_INT_VECTOR] =   int_vector_to_port;
  display_functions[T_BYTE_VECTOR] =  byte_vector_to_port;
  display_functions[T_VECTOR] =       vector_to_port;
  display_functions[T_PAIR] =         pair_to_port;
  display_functions[T_HASH_TABLE] =   hash_table_to_port;
  display_functions[T_ITERATOR] =     iterator_to_port;
  display_functions[T_LET] =          let_to_port;
  display_functions[T_BOOLEAN] =      unique_to_port;
  display_functions[T_NIL] =          unique_to_port;
  display_functions[T_UNUSED] =       unique_to_port;
  display_functions[T_UNSPECIFIED] =  unique_to_port;
  display_functions[T_UNDEFINED] =    undefined_to_port;
  display_functions[T_EOF_OBJECT] =   eof_to_port;
  display_functions[T_INPUT_PORT] =   input_port_to_port;
  display_functions[T_OUTPUT_PORT] =  output_port_to_port;
  display_functions[T_COUNTER] =      counter_to_port;
  display_functions[T_BAFFLE] =       baffle_to_port;
  display_functions[T_STACK] =        stack_to_port;
  display_functions[T_INTEGER] =      integer_to_port;
  display_functions[T_RATIO] =        number_to_port;
  display_functions[T_REAL] =         number_to_port;
  display_functions[T_COMPLEX] =      number_to_port;
#if WITH_GMP
  display_functions[T_BIG_INTEGER] =  big_number_to_port;
  display_functions[T_BIG_RATIO] =    big_number_to_port;
  display_functions[T_BIG_REAL] =     big_number_to_port;
  display_functions[T_BIG_COMPLEX] =  big_number_to_port;
#endif
  display_functions[T_SYMBOL] =       symbol_to_port;
  display_functions[T_SYNTAX] =       syntax_to_port;
  display_functions[T_STRING] =       string_to_port;
  display_functions[T_CHARACTER] =    character_to_port;
  display_functions[T_CLOSURE] =      closure_to_port;
  display_functions[T_CLOSURE_STAR] = closure_to_port;
  display_functions[T_MACRO] =        macro_to_port;
  display_functions[T_MACRO_STAR] =   macro_to_port;
  display_functions[T_BACRO] =        macro_to_port;
  display_functions[T_BACRO_STAR] =   macro_to_port;
  display_functions[T_C_OPT_ARGS_FUNCTION] = c_function_to_port;
  display_functions[T_C_RST_ARGS_FUNCTION] = c_function_to_port;
  display_functions[T_C_ANY_ARGS_FUNCTION] = c_function_to_port;
  display_functions[T_C_FUNCTION] =   c_function_to_port;
  display_functions[T_C_FUNCTION_STAR] = c_function_to_port;
  display_functions[T_C_MACRO] =      c_macro_to_port;
  display_functions[T_C_POINTER] =    c_pointer_to_port;
  display_functions[T_RANDOM_STATE] = rng_to_port;
  display_functions[T_CONTINUATION] = continuation_to_port;
  display_functions[T_GOTO] =         goto_to_port;
  display_functions[T_CATCH] =        catch_to_port;
  display_functions[T_DYNAMIC_WIND] = dynamic_wind_to_port;
  display_functions[T_C_OBJECT] =     c_object_to_port;
  display_functions[T_SLOT] =         slot_to_port;
}

#if CYCLE_DEBUGGING
static char *base = NULL, *min_char = NULL;
#endif

static void object_to_port_with_circle_check_1(s7_scheme *sc, s7_pointer vr, s7_pointer port, use_write_t use_write, shared_info *ci)
{
  int32_t ref;

#if CYCLE_DEBUGGING
  char x;
  if (!base) base = &x; 
  else 
    {
      if (&x > base) base = &x; 
      else 
	{
	  if ((!min_char) || (&x < min_char))
	    {
	      min_char = &x;
	      if ((base - min_char) > 400000)
		{
		  fprintf(stderr, "infinite recursion?\n");
		  if (port_data(port))
		    {
		      fprintf(stderr, "   port contents (%ld bytes): \n", port_position(port));
		      if (port_position(port) > 10000)
			port_data(port)[10000] = '\0';
		      else port_data(port)[port_position(port)] = '\0';
		      fprintf(stderr, "%s\n", port_data(port));
		    }
		  abort();
		}
	    }
	}
    }
#endif

  ref = (is_collected(vr)) ? shared_ref(ci, vr) : 0;
  if (ref != 0)
    {
      char buf[32];
      int32_t nlen;
      char *p;
      s7_int len;
      if (ref > 0)
	{
	  if (use_write == P_READABLE)
	    {
	      if (ci->defined[ref])
		{
		  flip_ref(ci, vr);
		  nlen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, ref), ">", NULL);
		  port_write_string(port)(sc, buf, nlen, port);
		  return;
		}
	      object_to_port(sc, vr, port, P_READABLE, ci);
	    }
	  else
	    {
	      /* "normal" printout involving #n= and #n# */
	      p = pos_int_to_str(sc, (s7_int)ref, &len, '=');
	      *--p = '#';
	      port_write_string(port)(sc, p, len, port);
	      object_to_port(sc, vr, port, NOT_P_DISPLAY(use_write), ci);
	    }
	}
      else
	{
	  if (use_write == P_READABLE)
	    {
	      nlen = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, -ref), ">", NULL);
	      port_write_string(port)(sc, buf, nlen, port);
	    }
	  else
	    {
	      p = pos_int_to_str(sc, (s7_int)(-ref), &len, '#');
	      *--p = '#';
	      port_write_string(port)(sc, p, len, port);
	    }
	}
    }
  else object_to_port(sc, vr, port, use_write, ci);
}

static s7_pointer cyclic_out(s7_scheme *sc, s7_pointer obj, s7_pointer port, shared_info *ci)
{
  int32_t i, ref, len;
  char buf[128];

  ci->cycle_port = s7_open_output_string(sc);
  ci->cycle_loc = s7_gc_protect_1(sc, ci->cycle_port);

  port_write_string(port)(sc, "(let (", 6, port);
  for (i = 0; i < ci->top; i++)
    {
      ref = peek_shared_ref(ci, ci->objs[i]); /* refs may be in any order */
      if (ref < 0) {ref = -ref; flip_ref(ci, ci->objs[i]);}
      len = catstrs_direct(buf, (i == 0) ? "(<" : "\n      (<", pos_int_to_str_direct(sc, ref), "> ", NULL);
      port_write_string(port)(sc, buf, len, port);
      ci->defined[ref] = false;
      object_to_port_with_circle_check(sc, ci->objs[i], port, P_READABLE, ci);
      port_write_character(port)(sc, ')', port);
      ci->defined[ref] = true;
      if (peek_shared_ref(ci, ci->objs[i]) > 0) flip_ref(ci, ci->objs[i]); /* ref < 0 -> use <%d> in object_to_port */
    }
  port_write_string(port)(sc, ")\n", 2, port);

  if (ci->init_port != sc->F)
    {
      port_write_string(port)(sc, (const char *)(port_data(ci->init_port)), port_position(ci->init_port), port);
      s7_close_output_port(sc, ci->init_port);
      s7_gc_unprotect_at(sc, ci->init_loc);
      ci->init_port = sc->F;
    }

  if (port_position(ci->cycle_port) > 0)     /* 0 if e.g. (object->string (object->let (rootlet)) :readable) */
    port_write_string(port)(sc, (const char *)(port_data(ci->cycle_port)), port_position(ci->cycle_port), port);
  s7_close_output_port(sc, ci->cycle_port);
  s7_gc_unprotect_at(sc, ci->cycle_loc);
  ci->cycle_port = sc->F;

  if ((is_immutable(obj)) && (!is_let(obj)))
    port_write_string(port)(sc, "  (immutable! ", 14, port);
  else port_write_string(port)(sc, "  ", 2, port);

  ref = peek_shared_ref(ci, obj);
  if (ref == 0)
    object_to_port_with_circle_check(sc, obj, port, P_READABLE, ci);
  else
    {
      len = catstrs_direct(buf, "<", pos_int_to_str_direct(sc, (ref < 0) ? -ref : ref), ">", NULL);
      port_write_string(port)(sc, buf, len, port);
    }

  if ((is_immutable(obj)) && (!is_let(obj)))
    port_write_string(port)(sc, "))\n", 3, port);
  else port_write_string(port)(sc, ")\n", 2, port);

  return(obj);
}

static void object_out_1(s7_scheme *sc, s7_pointer obj, s7_pointer strport, use_write_t choice)
{
  if (sc->object_out_locked)
    object_to_port_with_circle_check(sc, obj, strport, choice, sc->circle_info);
  else
    {
      shared_info *ci;
      ci = make_shared_info(sc, obj, choice != P_READABLE);
      if (ci)
	{
	  sc->object_out_locked = true;
	  if (choice == P_READABLE)
	    cyclic_out(sc, obj, strport, ci);
	  else object_to_port_with_circle_check(sc, obj, strport, choice, ci);
	  sc->object_out_locked = false;
	}
      else object_to_port(sc, obj, strport, choice, NULL);
    }
}

static inline s7_pointer object_out(s7_scheme *sc, s7_pointer obj, s7_pointer strport, use_write_t choice)
{
  if ((has_structure(obj)) &&
      (obj != sc->rootlet))
    object_out_1(sc, obj, strport, choice);
  else object_to_port(sc, obj, strport, choice, NULL);
  return(obj);
}

static s7_pointer open_format_port(s7_scheme *sc)
{
  s7_pointer x;
  s7_int len;
  block_t *block, *b;

  if (sc->format_ports)
    {
      x = sc->format_ports;
      sc->format_ports = (s7_pointer)(port_next(x));
      port_position(x) = 0;
      port_data(x)[0] = '\0';
      return(x);
    }

  len = FORMAT_PORT_LENGTH;
  x = alloc_pointer(sc);
#if S7_DEBUGGING
  permanent_ports++;
#endif
  set_type(x, T_OUTPUT_PORT);
  b = mallocate_port(sc);
  port_block(x) = b;
  port_port(x) = (port_t *)block_data(b);
  port_type(x) = STRING_PORT;
  port_set_closed(x, false);
  port_data_size(x) = len;
  port_next(x) = NULL;
  block = mallocate(sc, len);
  port_data(x) = (uint8_t *)(block_data(block));
  port_data_block(x) = block;
  port_data(x)[0] = '\0';
  port_position(x) = 0;
  port_needs_free(x) = false;
  port_read_character(x) = output_read_char;
  port_read_line(x) = output_read_line;
  port_display(x) = string_display;
  port_write_character(x) = string_write_char;
  port_write_string(x) = string_write_string;
  return(x);
}

static void close_format_port(s7_scheme *sc, s7_pointer port)
{
  port_next(port) = (struct block_t *)(sc->format_ports);
  sc->format_ports = port;
}

char *s7_object_to_c_string(s7_scheme *sc, s7_pointer obj)
{
  char *str;
  s7_pointer strport;
  s7_int len;

  TRACK(sc);
  if ((sc->safety > NO_SAFETY) &&
      (!s7_is_valid(sc, obj)))
    s7_warn(sc, 256, "bad arg to %s: %p\n", __func__, obj);

  strport = open_format_port(sc);
  object_out(sc, obj, strport, P_WRITE);
  len = port_position(strport);
  if (len == 0) return(NULL);
  str = (char *)malloc((len + 1) * sizeof(char));
  memcpy((void *)str, (void *)port_data(strport), len);
  str[len] = '\0';
  close_format_port(sc, strport);

  return(str);
}

static inline void restore_format_port(s7_scheme *sc, s7_pointer strport)
{
  block_t *block;
  block = mallocate(sc, FORMAT_PORT_LENGTH);
  port_data(strport) = (uint8_t *)(block_data(block));
  port_data_block(strport) = block;
  port_data(strport)[0] = '\0';
  port_position(strport) = 0;
  port_data_size(strport) = FORMAT_PORT_LENGTH;
  port_needs_free(strport) = false;
  close_format_port(sc, strport);
}


/* -------------------------------- object->string -------------------------------- */

s7_pointer s7_object_to_string(s7_scheme *sc, s7_pointer obj, bool use_write) /* unavoidable backwards compatibility rigidity here */
{
  s7_pointer strport, res;

  if ((sc->safety > NO_SAFETY) &&
      (!s7_is_valid(sc, obj)))
    s7_warn(sc, 256, "bad arg to %s: %p\n", __func__, obj);

  strport = open_format_port(sc);
  object_out(sc, obj, strport, (use_write) ? P_WRITE : P_DISPLAY);

  if (port_position(strport) >= port_data_size(strport))
    res = block_to_string(sc, reallocate(sc, port_data_block(strport), port_position(strport) + 1), port_position(strport));
  else res = block_to_string(sc, port_data_block(strport), port_position(strport));
  restore_format_port(sc, strport);
  return(res);
}

static s7_pointer g_object_to_string(s7_scheme *sc, s7_pointer args)
{
  #define H_object_to_string "(object->string obj (write #t) (max-len most-positive-fixnum)) returns a string representation of obj."
  #define Q_object_to_string s7_make_signature(sc, 4, sc->is_string_symbol, sc->T, s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_keyword_symbol), sc->is_integer_symbol)

  use_write_t choice;
  s7_pointer obj, strport, res;
  s7_int out_len, pending_max;
  bool old_openlets;

  pending_max = s7_int_max;
  old_openlets = sc->has_openlets;
  obj = car(args);

  if (is_not_null(cdr(args)))
    {
      s7_pointer arg;
      arg = cadr(args);
      if (arg == sc->F) choice = P_DISPLAY;
      else {if (arg == sc->T) choice = P_WRITE;
	else {if (arg == sc->key_readable_symbol) choice = P_READABLE;
	  else {if (arg == sc->key_display_symbol) choice = P_DISPLAY;
	    else {if (arg == sc->key_write_symbol) choice = P_WRITE;
	      else return(wrong_type_argument_with_type(sc, sc->object_to_string_symbol, 2, arg, wrap_string(sc, "a boolean or :readable", 22)));}}}}

      if (is_not_null(cddr(args)))
	{
	  arg = caddr(args);
	  if (!s7_is_integer(arg))
	    {
	      if (choice == P_READABLE) /* (object->string #r(1 2 3) :readable "hi") */
		return(wrong_type_argument(sc, sc->object_to_string_symbol, 3, arg, T_INTEGER));
	      return(method_or_bust(sc, arg, sc->object_to_string_symbol, args, T_INTEGER, 3));
	    }
	  if (s7_integer(arg) < 0)
	    return(out_of_range(sc, sc->object_to_string_symbol, small_int(3), arg, a_non_negative_integer_string));
	  pending_max = s7_integer(arg);
	}
    }
  else choice = P_WRITE;
  /* can't use s7_object_to_string here anymore because it assumes use_write arg is a boolean */

  if (choice == P_READABLE)
    sc->has_openlets = false;
  else check_method(sc, obj, sc->object_to_string_symbol, args);

  strport = open_format_port(sc);
  sc->objstr_max_len = pending_max;
  object_out(sc, obj, strport, choice);
  sc->objstr_max_len = s7_int_max;
  out_len = port_position(strport);

  if ((pending_max >= 0) &&
      (out_len > pending_max))
    {
      s7_int i;
      if (choice == P_READABLE)  /* (object->string #r(1 2 3) :readable 4) */
	return(out_of_range(sc, sc->object_to_string_symbol, small_int(3), make_integer(sc, out_len), wrap_string(sc, "the readable string is too long", 31)));

      out_len = pending_max;
      if (out_len < 3)
	{
	  close_format_port(sc, strport);
	  sc->has_openlets = old_openlets;
	  return(make_string_with_length(sc, "...", 3));
	}
      for (i = out_len - 3; i < out_len; i++)
	port_data(strport)[i] = (uint8_t)'.';
    }

  if (out_len >= port_data_size(strport))
    res = block_to_string(sc, reallocate(sc, port_data_block(strport), out_len + 1), out_len);
  else res = block_to_string(sc, port_data_block(strport), out_len);
  restore_format_port(sc, strport);
  sc->has_openlets = old_openlets;
  return(res);
}


/* -------------------------------- newline -------------------------------- */
void s7_newline(s7_scheme *sc, s7_pointer port)
{
  if (port != sc->F)
    port_write_character(port)(sc, (uint8_t)'\n', port);
}

#define newline_char chars[(uint8_t)'\n']

static s7_pointer g_newline(s7_scheme *sc, s7_pointer args)
{
  #define H_newline "(newline (port (current-output-port))) writes a carriage return to the port"
  #define Q_newline s7_make_signature(sc, 2, sc->is_char_symbol, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))
  s7_pointer port;

  if (is_not_null(args))
    port = car(args);
  else port = sc->output_port;
  if (port == sc->F) return(newline_char);
  if (!is_output_port(port))
    return(method_or_bust_with_type_one_arg(sc, port, sc->newline_symbol, args, an_output_port_string));
  if (port_is_closed(port))
    s7_wrong_type_arg_error(sc, "newline", 1, port, "an open output port");
  s7_newline(sc, port);
  return(newline_char);  /* return(sc->unspecified) until 28-Sep-17, but for example (display c) returns c */
}

static s7_pointer newline_p(s7_scheme *sc)
{
  s7_newline(sc, sc->output_port);
  return(newline_char);
}

static s7_pointer newline_p_p(s7_scheme *sc, s7_pointer port)
{
  if (!is_output_port(port))
    {
      if (port == sc->F) return(newline_char);
      s7_wrong_type_arg_error(sc, "newline", 1, port, "an open output port");
    }
  s7_newline(sc, port);
  return(newline_char);
}


/* -------------------------------- write -------------------------------- */
s7_pointer s7_write(s7_scheme *sc, s7_pointer obj, s7_pointer port)
{
  if (port != sc->F)
    {
      if (port_is_closed(port))
	s7_wrong_type_arg_error(sc, "write", 2, port, "an open output port");
      object_out(sc, obj, port, P_WRITE);
    }
  return(obj);
}

static s7_pointer write_p_pp(s7_scheme *sc, s7_pointer x, s7_pointer port)
{
  if (port == sc->F) return(x);
  if (!is_output_port(port))
    return(method_or_bust_with_type(sc, port, sc->write_symbol, list_2(sc, x, port), an_output_port_string, 2));
  if (port_is_closed(port))
    s7_wrong_type_arg_error(sc, "write", 2, port, "an open output port");
  return(object_out(sc, x, port, P_WRITE));
}

static s7_pointer g_write(s7_scheme *sc, s7_pointer args)
{
  #define H_write "(write obj (port (current-output-port))) writes (object->string obj) to the output port"
  #define Q_write s7_make_signature(sc, 3, sc->T, sc->T, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))

  check_method(sc, car(args), sc->write_symbol, args);
  return(write_p_pp(sc, car(args), (is_pair(cdr(args))) ? cadr(args) : sc->output_port));
}

static s7_pointer write_p_p(s7_scheme *sc, s7_pointer x)
{
  if (sc->output_port == sc->F) return(x);
  return(object_out(sc, x, sc->output_port, P_WRITE));
}


/* -------------------------------- display -------------------------------- */
s7_pointer s7_display(s7_scheme *sc, s7_pointer obj, s7_pointer port)
{
  if (port != sc->F)
    {
      if (port_is_closed(port))
	s7_wrong_type_arg_error(sc, "display", 2, port, "an open output port");
      object_out(sc, obj, port, P_DISPLAY);
    }
  return(obj);
}

static s7_pointer display_p_pp(s7_scheme *sc, s7_pointer x, s7_pointer port)
{
  if (port == sc->F) return(x);
  if (!is_output_port(port))
    return(method_or_bust_with_type(sc, port, sc->display_symbol, list_2(sc, x, port), an_output_port_string, 2));
  if (port_is_closed(port))
    s7_wrong_type_arg_error(sc, "display", 2, port, "an open output port");
  check_method(sc, x, sc->display_symbol, list_2(sc, x, port));
  return(object_out(sc, x, port, P_DISPLAY));
}

static s7_pointer g_display(s7_scheme *sc, s7_pointer args)
{
  #define H_display "(display obj (port (current-output-port))) prints obj"
  #define Q_display s7_make_signature(sc, 3, sc->T, sc->T, s7_make_signature(sc, 2, sc->is_output_port_symbol, sc->not_symbol))

  return(display_p_pp(sc, car(args), (is_pair(cdr(args))) ? cadr(args) : sc->output_port));
}

static s7_pointer g_display_2(s7_scheme *sc, s7_pointer args)
{
  /* calling display_p_pp here is much slower */
  s7_pointer port;
  port = cadr(args);
  if (port == sc->F) return(car(args));
  if (!is_output_port(port))
    return(method_or_bust_with_type(sc, port, sc->display_symbol, args, an_output_port_string, 2));
  if (port_is_closed(port))
    return(s7_wrong_type_arg_error(sc, "display", 2, port, "an open output port"));
  check_method(sc, car(args), sc->display_symbol, args);
  return(object_out(sc, car(args), port, P_DISPLAY));
}

static s7_pointer display_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2) return(sc->display_2);
  return(f);
}

static s7_pointer display_p_p(s7_scheme *sc, s7_pointer x)
{
  if (sc->output_port == sc->F) return(x);
  check_method(sc, x, sc->display_symbol, list_1(sc, x));
  return(object_out(sc, x, sc->output_port, P_DISPLAY));
}


/* -------------------------------- call-with-output-string -------------------------------- */
static s7_pointer g_call_with_output_string(s7_scheme *sc, s7_pointer args)
{
  #define H_call_with_output_string "(call-with-output-string proc) opens a string port applies proc to it, then returns the collected output"
  #define Q_call_with_output_string s7_make_signature(sc, 2, sc->is_string_symbol, s7_make_signature(sc, 2, sc->is_procedure_symbol, sc->is_macro_symbol))
  s7_pointer port, proc;

  proc = car(args);
  if (is_let(proc))
    check_method(sc, proc, sc->call_with_output_string_symbol, args);
  if ((!is_any_procedure(proc)) ||        /* this disallows goto/continuation */
      (!s7_is_aritable(sc, proc, 1)))
    return(method_or_bust_with_type(sc, proc, sc->call_with_output_string_symbol, args, wrap_string(sc, "a procedure of one argument (the port)", 38), 1));

  port = s7_open_output_string(sc);
  push_stack(sc, OP_UNWIND_OUTPUT, sc->unused, port);     /* #<unused> here is a marker (needed) */
  push_stack(sc, OP_GET_OUTPUT_STRING, sc->unused, port); /* args checked in call_with_exit */
  push_stack(sc, OP_APPLY, list_1(sc, port), proc);
  return(sc->F);
}


/* -------------------------------- call-with-output-file -------------------------------- */
static s7_pointer g_call_with_output_file(s7_scheme *sc, s7_pointer args)
{
  #define H_call_with_output_file "(call-with-output-file filename proc) opens filename and calls proc with the output port as its argument"
  #define Q_call_with_output_file sc->pl_sf
  s7_pointer port, file, proc;

  file = car(args);
  if (!is_string(file))
    return(method_or_bust(sc, file, sc->call_with_output_file_symbol, args, T_STRING, 1));

  proc = cadr(args);
  if ((!is_any_procedure(proc)) ||
      (!s7_is_aritable(sc, proc, 1)))
    return(method_or_bust_with_type(sc, proc, sc->call_with_output_file_symbol, args, wrap_string(sc, "a procedure of one argument (the port)", 38), 2));

  port = s7_open_output_file(sc, string_value(file), "w");
  push_stack(sc, OP_UNWIND_OUTPUT, sc->unused, port); /* #<unused> here is a marker (needed) */
  push_stack(sc, OP_APPLY, list_1(sc, port), proc);
  return(sc->F);
}


/* -------------------------------- with-output-to-string -------------------------------- */
static s7_pointer g_with_output_to_string(s7_scheme *sc, s7_pointer args)
{
  #define H_with_output_to_string "(with-output-to-string thunk) opens a string as a temporary current-output-port, calls thunk, then returns the collected output"
  #define Q_with_output_to_string s7_make_signature(sc, 2, sc->is_string_symbol, s7_make_signature(sc, 2, sc->is_procedure_symbol, sc->is_macro_symbol))
  s7_pointer old_output_port, p;

  p = car(args);
  if (!is_thunk(sc, p))
    return(method_or_bust_with_type(sc, p, sc->with_output_to_string_symbol, args, a_thunk_string, 1));

  if ((is_continuation(p)) || (is_goto(p)))
    return(wrong_type_argument_with_type(sc, sc->with_output_to_string_symbol, 1, p, a_normal_procedure_string));

  old_output_port = sc->output_port;
  sc->output_port = s7_open_output_string(sc);
  push_stack(sc, OP_UNWIND_OUTPUT, old_output_port, sc->output_port);
  push_stack(sc, OP_GET_OUTPUT_STRING, old_output_port, sc->output_port);
  push_stack(sc, OP_APPLY, sc->nil, p);
  return(sc->F);
}

/* (let () (define-macro (mac) (write "123")) (with-output-to-string mac))
 * (string-ref (with-output-to-string (lambda () (write "1234") (values (get-output-string) 1))))
 */


/* -------------------------------- with-output-to-file -------------------------------- */
static s7_pointer g_with_output_to_file(s7_scheme *sc, s7_pointer args)
{
  #define H_with_output_to_file "(with-output-to-file filename thunk) opens filename as the temporary current-output-port and calls thunk"
  #define Q_with_output_to_file sc->pl_sf
  s7_pointer old_output_port, file, proc;

  file = car(args);
  if (!is_string(file))
    return(method_or_bust(sc, file, sc->with_output_to_file_symbol, args, T_STRING, 1));

  proc = cadr(args);
  if (!is_thunk(sc, proc))
    return(method_or_bust_with_type(sc, proc, sc->with_output_to_file_symbol, args, a_thunk_string, 2));

  if ((is_continuation(proc)) || (is_goto(proc)))
    return(wrong_type_argument_with_type(sc, sc->with_output_to_file_symbol, 1, proc, a_normal_procedure_string));

  old_output_port = sc->output_port;
  sc->output_port = s7_open_output_file(sc, string_value(file), "w");
  push_stack(sc, OP_UNWIND_OUTPUT, old_output_port, sc->output_port);
  push_stack(sc, OP_APPLY, sc->nil, proc);
  return(sc->F);
}


/* -------------------------------- format -------------------------------- */

static s7_pointer format_error_1(s7_scheme *sc, s7_pointer msg, const char *str, s7_pointer args, format_data *fdat)
{
  s7_pointer x = NULL, ctrl_str;

  if (fdat->orig_str)
    ctrl_str = fdat->orig_str;
  else ctrl_str = s7_make_string_wrapper(sc, str);

  if (fdat->loc == 0)
    {
      if (is_pair(args))
	x = set_elist_4(sc, format_string_1, ctrl_str, args, msg);
      else x = set_elist_3(sc, format_string_2, ctrl_str, msg);
    }
  else
    {
      if (is_pair(args))
	x = set_elist_5(sc, format_string_3, ctrl_str, args, wrap_integer1(sc, fdat->loc + 20), msg);
      else x = set_elist_4(sc, format_string_4, ctrl_str, wrap_integer1(sc, fdat->loc + 20), msg);
    }
  if (fdat->port)
    {
      close_format_port(sc, fdat->port);
      fdat->port = NULL;
    }
  return(s7_error(sc, sc->format_error_symbol, x));
}

#define format_error(Sc, Msg, Len, Str, Args, Fdat) return(format_error_1(Sc, wrap_string(Sc, Msg, Len), Str, Args, Fdat))
#define just_format_error(Sc, Msg, Len, Str, Args, Fdat) format_error_1(Sc, wrap_string(Sc, Msg, Len), Str, Args, Fdat)

static void format_append_char(s7_scheme *sc, char c, s7_pointer port)
{
  port_write_character(port)(sc, c, port);
  sc->format_column++;

  /* if c is #\null, is this the right thing to do?
   * We used to return "1 2 3 4" because ~C was first turned into a string (empty in this case)
   *   (format #f "1 2~C3 4" #\null) -> "1 2"
   * Clisp does this:
   *   (format nil "1 2~C3 4" (int-char 0)) -> "1 23 4"
   * whereas sbcl says int-char is undefined, and Guile returns "1 2\x003 4"
   */
}

static void format_append_newline(s7_scheme *sc, s7_pointer port)
{
  port_write_character(port)(sc, '\n', port);
  sc->format_column = 0;
}

static void format_append_string(s7_scheme *sc, format_data *fdat, const char *str, s7_int len, s7_pointer port)
{
  port_write_string(port)(sc, str, len, port);
  fdat->loc += len;
  sc->format_column += len;
}

static void format_append_chars(s7_scheme *sc, format_data *fdat, char pad, s7_int chars, s7_pointer port)
{
  if (is_string_port(port))
    {
      if ((port_position(port) + chars) < port_data_size(port))
	{
	  local_memset((char *)port_data(port) + port_position(port), pad, chars);
	  port_position(port) += chars;
	}
      else
	{
	  s7_int new_len;
	  new_len = port_position(port) + chars;
	  resize_port_data(sc, port, new_len * 2);
	  local_memset((char *)port_data(port) + port_position(port), pad, chars);
	  port_position(port) = new_len;
	}
      fdat->loc += chars;
      sc->format_column += chars;
    }
  else
    {
      block_t *b;
      char *str;
      b = mallocate(sc, chars + 1);
      str = (char *)block_data(b);
      local_memset((void *)str, pad, chars);
      str[chars] = '\0';
      format_append_string(sc, fdat, str, chars, port);
      liberate(sc, b);
    }
}

static s7_int format_read_integer(s7_int *cur_i, s7_int str_len, const char *str)
{
  /* we know that str[*cur_i] is a digit */
  s7_int i, lval = 0;
  for (i = *cur_i; i < str_len - 1; i++)
    {
      int32_t dig;
      dig = digits[(uint8_t)str[i]];
      if (dig < 10)
	{
#if HAVE_OVERFLOW_CHECKS
	  if ((multiply_overflow(lval, 10, &lval)) ||
	      (add_overflow(lval, dig, &lval)))
	    break;
#else
	  lval = dig + (lval * 10);
#endif
	}
      else break;
    }
  *cur_i = i;
  return(lval);
}

static void format_number(s7_scheme *sc, format_data *fdat, int32_t radix, s7_int width, s7_int precision, char float_choice, char pad, s7_pointer port)
{
  char *tmp;
  s7_int nlen = 0;
  if (width < 0) width = 0;

  /* precision choice depends on float_choice if it's -1 */
  if (precision < 0)
    {
      if ((float_choice == 'e') ||
	  (float_choice == 'f') ||
	  (float_choice == 'g'))
	precision = 6;
      else
	{
	  /* in the "int" cases, precision depends on the arg type */
	  switch (type(car(fdat->args)))
	    {
	    case T_INTEGER:
	    case T_RATIO:
	      precision = 0;
	      break;

	    default:
	      precision = 6;
	      break;
	    }
	}
    }
  /* should (format #f "~F" 1/3) return "1/3"?? in CL it's "0.33333334" */

  if (pad != ' ')
    {
      char *padtmp;
#if (!WITH_GMP)
      if (radix == 10)
	tmp = number_to_string_base_10(sc, car(fdat->args), width, precision, float_choice, &nlen, P_WRITE);
      else
#endif
	tmp = number_to_string_with_radix(sc, car(fdat->args), radix, width, precision, float_choice, &nlen);
      padtmp = tmp;
      while (*padtmp == ' ') (*(padtmp++)) = pad;
      format_append_string(sc, fdat, tmp, nlen, port);
      if (radix != 10) free(tmp);
    }
  else
    {
#if (!WITH_GMP)
      if (radix == 10)
	tmp = number_to_string_base_10(sc, car(fdat->args), width, precision, float_choice, &nlen, P_WRITE);
      else
#endif
	tmp = number_to_string_with_radix(sc, car(fdat->args), radix, width, precision, float_choice, &nlen);
      format_append_string(sc, fdat, tmp, nlen, port);
      if (radix != 10) free(tmp);
    }
  fdat->args = cdr(fdat->args);
  fdat->ctr++;
}

static s7_int format_nesting(const char *str, char opener, char closer, s7_int start, s7_int end) /* start=i, end=str_len-1 */
{
  s7_int k, nesting = 1;
  for (k = start + 2; k < end; k++)
    if (str[k] == '~')
      {
	if (str[k + 1] == closer)
	  {
	    nesting--;
	    if (nesting == 0)
	      return(k - start - 1);
	  }
	else
	  {
	    if (str[k + 1] == opener)
	      nesting++;
	  }
      }
  return(-1);
}

static bool format_method(s7_scheme *sc, const char *str, format_data *fdat, s7_pointer port)
{
  s7_pointer func, obj;
  char ctrl_str[3];

  obj = car(fdat->args);
  if ((!has_active_methods(sc, obj)) ||
      ((func = find_method(sc, find_let(sc, obj), sc->format_symbol)) == sc->undefined))
    return(false);

  ctrl_str[0] = '~';
  ctrl_str[1] = str[0];
  ctrl_str[2] = '\0';
  s7_apply_function(sc, func, list_3(sc, port, s7_make_string_wrapper(sc, ctrl_str), obj));

  fdat->args = cdr(fdat->args);
  fdat->ctr++;
  return(true);
}

static s7_int format_n_arg(s7_scheme *sc, const char *str, format_data *fdat, s7_pointer args)
{
  s7_int n;

  if (is_null(fdat->args))          /* (format #f "~nT") */
    just_format_error(sc, "~~N: missing argument", 21, str, args, fdat);
  if (!s7_is_integer(car(fdat->args)))
    just_format_error(sc, "~~N: integer argument required", 30, str, args, fdat);
  n = s7_integer(car(fdat->args));

  if (n < 0)
    just_format_error(sc, "~~N value is negative?", 22, str, args, fdat);
  else
    {
      if (n > sc->max_format_length)
	just_format_error(sc, "~~N value is too big", 20, str, args, fdat);
    }
  fdat->args = cdr(fdat->args);    /* I don't think fdat->ctr should be incremented here -- it's for *vector-print-length* etc */
  return(n);
}

static s7_int format_numeric_arg(s7_scheme *sc, const char *str, s7_int str_len, format_data *fdat, s7_int *i)
{
  s7_int width, old_i;
  old_i = *i;
  width = format_read_integer(i, str_len, str);
  if (width < 0)
    {
      if (str[old_i - 1] != ',') /* need branches here, not if-expr because just_format_error creates the permanent string */
	just_format_error(sc, "width is negative?", 18, str, fdat->args, fdat);
      else just_format_error(sc, "precision is negative?", 22, str, fdat->args, fdat);
    }
  else
    {
      if (width > sc->max_format_length)
	{
	  if (str[old_i - 1] != ',')
	    just_format_error(sc, "width is too big", 16, str, fdat->args, fdat);
	  else just_format_error(sc, "precision is too big", 20, str, fdat->args, fdat);
	}
    }
  return(width);
}

#if WITH_GMP
static bool s7_is_one_or_big_one(s7_pointer p);
#else
#define s7_is_one_or_big_one(Num) s7_is_one(Num)
#endif

static s7_pointer object_to_list(s7_scheme *sc, s7_pointer obj);

static s7_pointer format_to_port_1(s7_scheme *sc, s7_pointer port, const char *str, s7_pointer args,
				   s7_pointer *next_arg, bool with_result, bool columnized, s7_int len, s7_pointer orig_str)
{
  s7_int i, str_len;
  format_data *fdat;
  s7_pointer deferred_port;

  if (len <= 0)
    {
      str_len = safe_strlen(str);
      if (str_len == 0)
	{
	  if (is_not_null(args))
	    return(s7_error(sc, sc->format_error_symbol,
			    set_elist_2(sc, wrap_string(sc, "format control string is null, but there are arguments: ~S", 58), args)));
	  if (with_result)
	    return(make_empty_string(sc, 0, 0));
	  return(sc->F);
	}
    }
  else str_len = len;

  sc->format_depth++;
  if (sc->format_depth >= sc->num_fdats)
    {
      int32_t k, new_num_fdats;
      new_num_fdats = sc->format_depth * 2;
      sc->fdats = (format_data **)realloc(sc->fdats, sizeof(format_data *) * new_num_fdats);
      for (k = sc->num_fdats; k < new_num_fdats; k++) sc->fdats[k] = NULL;
      sc->num_fdats = new_num_fdats;
    }

  fdat = sc->fdats[sc->format_depth];
  if (!fdat)
    {
      fdat = (format_data *)malloc(sizeof(format_data));
      sc->fdats[sc->format_depth] = fdat;
      fdat->curly_len = 0;
      fdat->curly_str = NULL;
      fdat->ctr = 0;
    }
  else
    {
      if (fdat->port)
	close_format_port(sc, fdat->port);
      if (fdat->strport)
	close_format_port(sc, fdat->strport);
    }
  fdat->port = NULL;
  fdat->strport = NULL;
  fdat->loc = 0;
  fdat->args = args;
  fdat->orig_str = orig_str;
  fdat->curly_arg = sc->nil;

  /* choose whether to write to a temporary string port, or simply use the in-coming port
   *   if with_result, returned string is wanted.
   *   if port is sc->F, no non-string result is wanted.
   *   if port is not boolean, it better be a port.
   *   if we are about to goto START in eval, and main_stack_op(Sc) == OP_BEGIN1, no return string is wanted -- yow, this is not true
   */

  if (with_result)
    {
      deferred_port = port;
      port = open_format_port(sc);
      fdat->port = port;
    }
  else deferred_port = sc->F;

  for (i = 0; i < str_len - 1; i++)
    {
      if ((uint8_t)(str[i]) == (uint8_t)'~') /* what does MS C want? */
	{
	  use_write_t use_write;
	  switch (str[i + 1])
	    {
	    case '%':                           /* -------- newline -------- */
	      /* sbcl apparently accepts numeric args here (including 0) */

	      if ((port_data(port)) &&
		  (port_position(port) < port_data_size(port)))
		{
		  port_data(port)[port_position(port)++] = '\n';
		  /* which is actually a bad idea, but as a desperate stopgap, I simply padded
		   *  the string port string with 8 chars that are not in the length.
		   */
		  sc->format_column = 0;
		}
	      else format_append_newline(sc, port);
	      i++;
	      break;

	    case '&':                           /* -------- conditional newline -------- */
	      /* this only works if all output goes through format -- display/write for example do not update format_column */
	      if (sc->format_column > 0)
		format_append_newline(sc, port);
	      i++;
	      break;

	    case '~':                           /* -------- tilde -------- */
	      format_append_char(sc, '~', port);
	      i++;
	      break;

	    case '\n':                          /* -------- trim white-space -------- */
	      for (i = i + 2; i <str_len - 1; i++)
		if (!(white_space[(uint8_t)(str[i])]))
		  {
		    i--;
		    break;
		  }
	      break;

	    case '*':                           /* -------- ignore arg -------- */
	      i++;
	      if (is_null(fdat->args))          /* (format #f "~*~A") */
		format_error(sc, "can't skip argument!", 20, str, args, fdat);
	      fdat->args = cdr(fdat->args);
	      break;

	    case '|':                           /* -------- exit if args nil or ctr > (*s7* 'print-length) -------- */
	      if ((is_pair(fdat->args)) &&
		  (fdat->ctr >= sc->print_length))
		{
		  format_append_string(sc, fdat, " ...", 4, port);
		  fdat->args = sc->nil;
		}
	      /* fall through */

	    case '^':                           /* -------- exit -------- */
	      if (is_null(fdat->args))
		{
		  i = str_len;
		  goto ALL_DONE;
		}
	      i++;
	      break;

	    case '@':                           /* -------- plural, 'y' or 'ies' -------- */
	      i += 2;
	      if ((str[i] != 'P') && (str[i] != 'p'))
		format_error(sc, "unknown '@' directive", 21, str, args, fdat);
	      if (!is_pair(fdat->args))
		format_error(sc, "'@' directive argument missing", 30, str, args, fdat);
	      if (!s7_is_real(car(fdat->args)))        /* CL accepts non numbers here */
		format_error(sc, "'@P' directive argument is not a real number", 44, str, args, fdat);

	      if (!s7_is_one_or_big_one(car(fdat->args)))
		format_append_string(sc, fdat, "ies", 3, port);
	      else format_append_char(sc, 'y', port);

	      fdat->args = cdr(fdat->args);
	      break;

	    case 'P': case 'p':                 /* -------- plural in 's' -------- */
	      if (!is_pair(fdat->args))
		format_error(sc, "'P' directive argument missing", 30, str, args, fdat);
	      if (!s7_is_real(car(fdat->args)))
		format_error(sc, "'P' directive argument is not a real number", 43, str, args, fdat);
	      if (!s7_is_one_or_big_one(car(fdat->args)))
		format_append_char(sc, 's', port);
	      i++;
	      fdat->args = cdr(fdat->args);
	      break;

	    case '{':                           /* -------- iteration -------- */
	      {
		s7_int curly_len;

		if (is_null(fdat->args))
		  format_error(sc, "missing argument", 16, str, args, fdat);

		if ((is_pair(car(fdat->args))) &&               /* any sequence is possible here */
		    (s7_list_length(sc, car(fdat->args)) < 0))  /* (format #f "~{~a~e~}" (cons 1 2)) */
		  format_error(sc, "~{ argument is a dotted list", 28, str, args, fdat);

		curly_len = format_nesting(str, '{', '}', i, str_len - 1);

		if (curly_len == -1)
		  format_error(sc, "'{' directive, but no matching '}'", 34, str, args, fdat);
		if (curly_len == 1)
		  format_error(sc, "~{~}' doesn't consume any arguments!", 36, str, args, fdat);

		/* what about cons's here?  I can't see any way in CL either to specify the car or cdr of a cons within the format string
		 *   (cons 1 2) is applicable: ((cons 1 2) 0) -> 1
		 *   also there can be applicable objects that won't work in the map context (arg not integer etc)
		 */
		if (is_not_null(car(fdat->args)))               /* (format #f "~{~A ~}" ()) -> "" */
		  {
		    s7_pointer curly_arg;
		    /* perhaps use an iterator here -- rootlet->list is expensive! */
		    curly_arg = object_to_list(sc, car(fdat->args)); /* if a pair (or non-sequence), this simply returns the original */
		    if (is_pair(curly_arg))                    /* (format #f "~{~A ~}" #()) -> "" */
		      {
			char *curly_str = NULL;                /* this is the local (nested) format control string */
			s7_pointer orig_arg, cycle_arg;

			fdat->curly_arg = curly_arg;
			if (curly_arg != car(fdat->args))
			  orig_arg = curly_arg;
			else orig_arg = sc->nil;

			if (curly_len > fdat->curly_len)
			  {
			    if (fdat->curly_str) free(fdat->curly_str);
			    fdat->curly_len = curly_len;
			    fdat->curly_str = (char *)malloc(curly_len * sizeof(char));
			  }
			curly_str = fdat->curly_str;
			memcpy((void *)curly_str, (void *)(str + i + 2), curly_len - 1);
			curly_str[curly_len - 1] = '\0';

			if ((sc->format_depth < sc->num_fdats - 1) &&
			    (sc->fdats[sc->format_depth + 1]))
			  sc->fdats[sc->format_depth + 1]->ctr = 0;

			/* it's not easy to use an iterator here instead of a list (so object->list isn't needed above),
			 *   because the curly brackets may enclose multiple arguments -- we would need to use
			 *   iterators throughout this function.
			 */
			cycle_arg = curly_arg;
			while (is_pair(curly_arg))
			  {
			    s7_pointer new_arg = sc->nil;
			    format_to_port_1(sc, port, curly_str, curly_arg, &new_arg, false, columnized, curly_len - 1, NULL);
			    if (curly_arg == new_arg)
			      {
				if (cdr(curly_arg) == curly_arg) break;
				fdat->curly_arg = sc->nil;
				format_error(sc, "'{...}' doesn't consume any arguments!", 38, str, args, fdat);
			      }
			    curly_arg = new_arg;
			    if ((!is_pair(curly_arg)) || (curly_arg == cycle_arg))
			      break;
			    cycle_arg = cdr(cycle_arg);
			    format_to_port_1(sc, port, curly_str, curly_arg, &new_arg, false, columnized, curly_len - 1, NULL);
			    curly_arg = new_arg;
			  }
			fdat->curly_arg = sc->nil;
			while (is_pair(orig_arg)) /* free_cell below clears the type, so a circular list here is ok */
 			  {
 			    s7_pointer p;
 			    p = orig_arg;
 			    orig_arg = cdr(orig_arg);
 			    free_cell(sc, p);   /* if car(fdar->args) is a hash-table, we could also free_cell(car(p)), but not in any other case */
			  }
		      }
		    else
		      {
			if (!is_null(curly_arg))
			  format_error(sc, "'{' directive argument should be a list or something we can turn into a list", 76, str, args, fdat);
		      }
		  }

		i += (curly_len + 2); /* jump past the ending '}' too */
		fdat->args = cdr(fdat->args);
		fdat->ctr++;
	      }
	      break;

	    case '}':
	      format_error(sc, "unmatched '}'", 13, str, args, fdat);

	    case 'W': case 'w':
	      use_write = P_READABLE;
	      goto OBJSTR;

	    case 'S': case 's':
	      use_write = P_WRITE;
	      goto OBJSTR;

	    case 'A': case 'a':
	      use_write = P_DISPLAY;
	    OBJSTR:                        /* object->string */
	      {
		s7_pointer obj, strport;
		if (is_null(fdat->args))
		  format_error(sc, "missing argument", 16, str, args, fdat);

		i++;
		obj = car(fdat->args);
		if ((use_write == P_READABLE) ||
		    (!has_active_methods(sc, obj)) ||
		    (!format_method(sc, (char *)(str + i), fdat, port)))
		  {
		    bool old_openlets;
		    old_openlets = sc->has_openlets;
		    /* for the column check, we need to know the length of the object->string output */
		    if (columnized)
		      {
			strport = open_format_port(sc);
			fdat->strport = strport;
		      }
		    else strport = port;
		    if (use_write == P_READABLE)
		      sc->has_openlets = false;
		    object_out(sc, obj, strport, use_write);
		    if (use_write == P_READABLE)
		      sc->has_openlets = old_openlets;
		    if (columnized)
		      {
			if (port_position(strport) >= port_data_size(strport))
			  resize_port_data(sc, strport, port_data_size(strport) * 2);

			port_data(strport)[port_position(strport)] = '\0';
			if (port_position(strport) > 0)
			  format_append_string(sc, fdat, (const char *)port_data(strport), port_position(strport), port);
			close_format_port(sc, strport);
			fdat->strport = NULL;
		      }

		    fdat->args = cdr(fdat->args);
		    fdat->ctr++;
		  }
		}
	      break;

	      /* -------- numeric args -------- */
	    case '0': case '1': case '2': case '3': case '4': case '5':
	    case '6': case '7': case '8': case '9': case ',':
	    case 'N': case 'n':

	    case 'B': case 'b':
	    case 'D': case 'd':
	    case 'E': case 'e':
	    case 'F': case 'f':
	    case 'G': case 'g':
	    case 'O': case 'o':
	    case 'X': case 'x':

	    case 'T': case 't':
	    case 'C': case 'c':
	      {
		s7_int width = -1, precision = -1;
		char pad = ' ';
		i++;                                      /* str[i] == '~' */

		if (isdigit((int32_t)(str[i])))
		  width = format_numeric_arg(sc, str, str_len, fdat, &i);
		else
		  {
		    if ((str[i] == 'N') || (str[i] == 'n'))
		      {
			i++;
			width = format_n_arg(sc, str, fdat, args);
		      }
		  }
		if (str[i] == ',')
		  {
		    i++;                                  /* is (format #f "~12,12D" 1) an error?  The precision (or is it the width?) has no use here. */
		    if (isdigit((int32_t)(str[i])))
		      precision = format_numeric_arg(sc, str, str_len, fdat, &i);
		    else
		      {
			if ((str[i] == 'N') || (str[i] == 'n'))
			  {
			    i++;
			    precision = format_n_arg(sc, str, fdat, args);
			  }
			else
			  {
			    if (str[i] == '\'')              /* (format #f "~12,'xD" 1) -> "xxxxxxxxxxx1" */
			      {
				pad = str[i + 1];
				i += 2;
				if (i >= str_len)            /* (format #f "~,'") */
				  format_error(sc, "incomplete numeric argument", 27, str, args, fdat);
			      }
			    /* is (let ((str "~12,'xD")) (set! (str 5) #\null) (format #f str 1)) an error? */
			  }
		      }
		  }

		switch (str[i])
		  {
		    /* -------- pad to column --------
		     *   are columns numbered from 1 or 0?  there seems to be disagreement about this directive
		     *   does "space over to" mean including?
		     */

		  case 'T': case 't':
		    if (width == -1) width = 0;
		    if (precision == -1) precision = 0;
		    if ((width > 0) || (precision > 0))         /* (format #f "a~8Tb") */
		      {
			/* (length (substring (format #f "~%~10T.") 1)) == (length (format #f "~10T."))
			 * (length (substring (format #f "~%-~10T.~%") 1)) == (length (format #f "-~10T.~%"))
			 */
			if (precision > 0)
			  {
			    int32_t mult;
			    mult = (int32_t)(ceil((s7_double)(sc->format_column + 1 - width) / (s7_double)precision)); /* CLtL2 ("least positive int") */
			    if (mult < 1) mult = 1;
			    width += (precision * mult);
			  }
			width -= (sc->format_column + 1);
			if (width > 0)
			  format_append_chars(sc, fdat, pad, width, port);
		      }
		    break;

		  case 'C': case 'c':
		    {
		      s7_pointer obj;

		      if (is_null(fdat->args))
			format_error(sc, "~~C: missing argument", 21, str, args, fdat);
		      /* the "~~" here and below protects against "~C" being treated as a directive */
		      obj = car(fdat->args);

		      if (!s7_is_character(obj))
			{
			  if (!format_method(sc, (char *)(str + i), fdat, port)) /* i stepped forward above */
			    format_error(sc, "'C' directive requires a character argument", 43, str, args, fdat);
			}
		      else
			{
			  /* here use_write is false, so we just add the char, not its name */
			  if (width == -1)
			    format_append_char(sc, character(obj), port);
			  else
			    {
			      if (width > 0)
				format_append_chars(sc, fdat, character(obj), width, port);
			    }
			  fdat->args = cdr(fdat->args);
			  fdat->ctr++;
			}
		    }
		    break;

		    /* -------- numbers -------- */
		  case 'F': case 'f':
		    if (is_null(fdat->args))
		      format_error(sc, "~~F: missing argument", 21, str, args, fdat);
		    if (!(s7_is_number(car(fdat->args))))
		      {
			if (!format_method(sc, (char *)(str + i), fdat, port))
			  format_error(sc, "~~F: numeric argument required", 30, str, args, fdat);
		      }
		    else format_number(sc, fdat, 10, width, precision, 'f', pad, port);
		    break;

		  case 'G': case 'g':
		    if (is_null(fdat->args))
		      format_error(sc, "~~G: missing argument", 21, str, args, fdat);
		    if (!(s7_is_number(car(fdat->args))))
		      {
			if (!format_method(sc, (char *)(str + i), fdat, port))
			  format_error(sc, "~~G: numeric argument required", 30, str, args, fdat);
		      }
		    else format_number(sc, fdat, 10, width, precision, 'g', pad, port);
		    break;

		  case 'E': case 'e':
		    if (is_null(fdat->args))
		      format_error(sc, "~~E: missing argument", 21, str, args, fdat);
		    if (!(s7_is_number(car(fdat->args))))
		      {
			if (!format_method(sc, (char *)(str + i), fdat, port))
			  format_error(sc, "~~E: numeric argument required", 30, str, args, fdat);
		      }
		    else format_number(sc, fdat, 10, width, precision, 'e', pad, port);
		    break;

		    /* how to handle non-integer arguments in the next 4 cases?  clisp just returns
		     *   the argument: (format nil "~X" 1.25) -> "1.25" which is perverse (ClTl2 p 581:
		     *   "if arg is not an integer, it is printed in ~A format and decimal base")!!
		     *   I think I'll use the type of the number to choose the output format.
		     */
		  case 'D': case 'd':
		    if (is_null(fdat->args))
		      format_error(sc, "~~D: missing argument", 21, str, args, fdat);
		    if (!(s7_is_number(car(fdat->args))))
		      {
			/* (let () (require mockery.scm) (format #f "~D" ((*mock-number* 'mock-number) 123)))
			 *    port here is a string-port, str has the width/precision data if the caller wants it,
			 *    args is the current arg.  But format_number handles fdat->args and so on, so
			 *    I think I'll pass the format method the current control string (str), the
			 *    current object (car(fdat->args)), and the arglist (args), and assume it will
			 *    return a (scheme) string.
			 */
			if (!format_method(sc, (char *)(str + i), fdat, port))
			  format_error(sc, "~~D: numeric argument required", 30, str, args, fdat);
		      }
		    else format_number(sc, fdat, 10, width, precision, 'd', pad, port);
		    break;

		  case 'O': case 'o':
		    if (is_null(fdat->args))
		      format_error(sc, "~~O: missing argument", 21, str, args, fdat);
		    if (!(s7_is_number(car(fdat->args))))
		      {
			if (!format_method(sc, (char *)(str + i), fdat, port))
			  format_error(sc, "~~O: numeric argument required", 30, str, args, fdat);
		      }
		    else format_number(sc, fdat, 8, width, precision, 'o', pad, port);
		    break;

		  case 'X': case 'x':
		    if (is_null(fdat->args))
		      format_error(sc, "~~X: missing argument", 21, str, args, fdat);
		    if (!(s7_is_number(car(fdat->args))))
		      {
			if (!format_method(sc, (char *)(str + i), fdat, port))
			  format_error(sc, "~~X: numeric argument required", 30, str, args, fdat);
		      }
		    else format_number(sc, fdat, 16, width, precision, 'x', pad, port);
		    break;

		  case 'B': case 'b':
		    if (is_null(fdat->args))
		      format_error(sc, "~~B: missing argument", 21, str, args, fdat);
		    if (!(s7_is_number(car(fdat->args))))
		      {
			if (!format_method(sc, (char *)(str + i), fdat, port))
			  format_error(sc, "~~B: numeric argument required", 30, str, args, fdat);
		      }
		    else format_number(sc, fdat, 2, width, precision, 'b', pad, port);
		    break;

		  default:
		    if (width > 0)
		      format_error(sc, "unused numeric argument", 23, str, args, fdat);
		    format_error(sc, "unimplemented format directive", 30, str, args, fdat);
		  }
	      }
	      break;

	    default:
	      format_error(sc, "unimplemented format directive", 30, str, args, fdat);
	    }
	}
      else /* str[i] is not #\~ */
	{
	  s7_int j, new_len;
	  const char *p;

	  p = (char *)strchr((const char *)(str + i + 1), (int)'~');
	  if (!p)
	    j = str_len;
	  else j = p - str;
	  new_len = j - i;

	  if ((port_data(port)) &&
	      ((port_position(port) + new_len) < port_data_size(port)))
	    {
	      memcpy((void *)(port_data(port) + port_position(port)), (void *)(str + i), new_len);
	      port_position(port) += new_len;
	    }
	  else port_write_string(port)(sc, (char *)(str + i), new_len, port);
	  fdat->loc += new_len;
	  sc->format_column += new_len;
	  i = j - 1;
	}
    }

 ALL_DONE:
  if (next_arg)
    (*next_arg) = fdat->args;
  else
    {
      if (is_not_null(fdat->args))
	format_error(sc, "too many arguments", 18, str, args, fdat);
    }
  if (i < str_len)
    {
      if (str[i] == '~')
	format_error(sc, "control string ends in tilde", 28, str, args, fdat);
      format_append_char(sc, str[i], port);
    }

  sc->format_depth--;

  if (with_result)
    {
      s7_pointer result;
      if ((is_output_port(deferred_port)) &&
	  (port_position(port) > 0))
	{
	  if (port_position(port) < port_data_size(port))
	    port_data(port)[port_position(port)] = '\0';
	  port_write_string(deferred_port)(sc, (const char *)port_data(port), port_position(port), deferred_port);
	}
      if (port_position(port) < port_data_size(port))
	{
	  block_t *block;
	  result = block_to_string(sc, port_data_block(port), port_position(port));
	  port_data_size(port) = FORMAT_PORT_LENGTH;
	  block = mallocate(sc, FORMAT_PORT_LENGTH);
	  port_data_block(port) = block;
	  port_data(port) = (uint8_t *)(block_data(block));
	  port_data(port)[0] = '\0';
	  port_position(port) = 0;
	}
      else result = make_string_with_length(sc, (char *)port_data(port), port_position(port));
      close_format_port(sc, port);
      fdat->port = NULL;
      return(result);
    }
  return(sc->F);
}

static bool is_columnizing(const char *str)
{
  /* look for ~t ~,<int>T ~<int>,<int>t */
  char *p;

  for (p = (char *)str; (*p);)
    if (*p++ == '~') /* this is faster than strchr */
      {
	char c;
	c = *p++;
	if ((c == 't') || (c == 'T')) return(true);
	if (!c) return(false);
	if ((c == ',') || ((c >= '0') && (c <= '9')) || (c == 'n') || (c == 'N'))
	  {
	    while (((c >= '0') && (c <= '9')) || (c == 'n') || (c == 'N')) c = *p++;
	    if ((c == 't') || (c == 'T')) return(true);
	    if (!c) return(false);                       /* ~,1 for example */
	    if (c == ',')
	      {
		c = *p++;
		while (((c >= '0') && (c <= '9')) || (c == 'n') || (c == 'N')) c = *p++;
		if ((c == 't') || (c == 'T')) return(true);
		if (!c) return(false);
	      }
	  }
      }
  return(false);
}

static s7_pointer format_to_port(s7_scheme *sc, s7_pointer port, const char *str, s7_pointer args, s7_pointer *next_arg, bool with_result, s7_int len)
{
  if ((with_result) ||
      (port != sc->F))
    return(format_to_port_1(sc, port, str, args, next_arg, with_result, true /* is_columnizing(str) */, len, NULL));
  /* is_columnizing on every call is much slower than ignoring the issue */
  return(sc->F);
}

static s7_pointer g_format_1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer pt, str;
  sc->format_column = 0;
  pt = car(args);
  if (is_null(pt))
    {
      pt = sc->output_port;                  /* () -> (current-output-port) */
      if (pt == sc->F)                       /*   otherwise () -> #f so we get a returned string, which is confusing */
	return(pt);                          /*   but this means some error checks are skipped? */
    }

  if (!((s7_is_boolean(pt)) ||               /* #f or #t */
	((is_output_port(pt)) &&             /* (current-output-port) or call-with-open-file arg, etc */
	 (!port_is_closed(pt)))))
    return(method_or_bust_with_type(sc, pt, sc->format_symbol, args, an_output_port_string, 1));

  if (!is_pair(cdr(args)))                   /* (format #f) */
    return(s7_error(sc, sc->format_error_symbol,
		    set_elist_2(sc, wrap_string(sc, "format has no control string: ~S", 32), args)));
  str = cadr(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->format_symbol, args, T_STRING, 2));

  return(format_to_port_1(sc, (pt == sc->T) ? sc->output_port : pt,
			  string_value(str), cddr(args), NULL, !is_output_port(pt), true, string_length(str), str));
}

static s7_pointer g_format(s7_scheme *sc, s7_pointer args)
{
  #define H_format "(format out str . args) substitutes args into str sending the result to out. Most of \
s7's format directives are taken from CL: ~% = newline, ~& = newline if the preceding output character was \
no a newline, ~~ = ~, ~<newline> trims white space, ~* skips an argument, ~^ exits {} iteration if the arg list is exhausted, \
~nT spaces over to column n, ~A prints a representation of any object, ~S is the same, but puts strings in double quotes, \
~C prints a character, numbers are handled by ~F, ~E, ~G, ~B, ~O, ~D, and ~X with preceding numbers giving \
spacing (and spacing character) and precision.  ~{ starts an embedded format directive which is ended by ~}: \n\
\n\
  >(format #f \"dashed: ~{~A~^-~}\" '(1 2 3))\n\
  \"dashed: 1-2-3\"\n\
\n\
~P inserts \"s\" if the current it is not 1 or 1.0 (use ~@P for \"ies\" or \"y\").\n\
~B is number->string in base 2, ~O in base 8, ~D base 10, ~X base 16,\n\
~E: (format #f \"~E\" 100.1) -&gt; \"1.001000e+02\" (%e in C)\n\
~F: (format #f \"~F\" 100.1) -&gt; \"100.100000\"   (%f in C)\n\
~G: (format #f \"~G\" 100.1) -&gt; \"100.1\"        (%g in C)\n\
\n\
If the 'out' it is not an output port, the resultant string is returned.  If it \
is #t, the string is also sent to the current-output-port."

  #define Q_format s7_make_circular_signature(sc, 2, 3, s7_make_signature(sc, 2, sc->is_string_symbol, sc->not_symbol), s7_make_signature(sc, 3, sc->is_output_port_symbol, sc->is_boolean_symbol, sc->is_null_symbol), sc->T)
  return(g_format_1(sc, args));
}

const char *s7_format(s7_scheme *sc, s7_pointer args)
{
  s7_pointer result;
  result = g_format_1(sc, args);
  if (is_string(result))
    return(string_value(result));
  return(NULL);
}


/* -------------------------------- system extras -------------------------------- */

#if WITH_SYSTEM_EXTRAS
#include <fcntl.h>

/* -------------------------------- directory? -------------------------------- */
static s7_pointer g_is_directory(s7_scheme *sc, s7_pointer args)
{
  #define H_is_directory "(directory? str) returns #t if str is the name of a directory"
  #define Q_is_directory s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_string_symbol)
  s7_pointer name;
  name = car(args);

  if (!is_string(name))
    return(method_or_bust_one_arg(sc, name, sc->is_directory_symbol, args, T_STRING));
  return(s7_make_boolean(sc, is_directory(string_value(name))));
}

static bool is_directory_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_string(p))
    simple_wrong_type_argument(sc, sc->is_directory_symbol, p, T_STRING);
  return(is_directory(string_value(p)));
}

static bool file_probe(const char *arg)
{
#if (!MS_WINDOWS)
  return(access(arg, F_OK) == 0);
#else
  int32_t fd;
  fd = open(arg, O_RDONLY, 0);
  if (fd == -1) return(false);
  close(fd);
  return(true);
#endif
}

/* -------------------------------- file-exists? -------------------------------- */
static s7_pointer g_file_exists(s7_scheme *sc, s7_pointer args)
{
  #define H_file_exists "(file-exists? filename) returns #t if the file exists"
  #define Q_file_exists s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_string_symbol)

  s7_pointer name;
  name = car(args);

  if (!is_string(name))
    return(method_or_bust_one_arg(sc, name, sc->file_exists_symbol, args, T_STRING));
  return(s7_make_boolean(sc, file_probe(string_value(name))));
}

static bool file_exists_b_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_string(p))
    simple_wrong_type_argument(sc, sc->file_exists_symbol, p, T_STRING);
  return(file_probe(string_value(p)));
}

/* -------------------------------- delete-file -------------------------------- */
static s7_pointer g_delete_file(s7_scheme *sc, s7_pointer args)
{
  #define H_delete_file "(delete-file filename) deletes the file filename."
  #define Q_delete_file s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_string_symbol)

  s7_pointer name;
  name = car(args);

  if (!is_string(name))
    return(method_or_bust_one_arg(sc, name, sc->delete_file_symbol, args, T_STRING));
  return(make_integer(sc, unlink(string_value(name))));
}

/* -------------------------------- getenv -------------------------------- */
static s7_pointer g_getenv(s7_scheme *sc, s7_pointer args)
{
  #define H_getenv "(getenv var) returns the value of an environment variable."
  #define Q_getenv sc->pcl_s

  s7_pointer name;
  name = car(args);

  if (!is_string(name))
    return(method_or_bust_one_arg(sc, name, sc->getenv_symbol, args, T_STRING));
  return(s7_make_string(sc, getenv(string_value(name))));
}

/* -------------------------------- system -------------------------------- */
static s7_pointer g_system(s7_scheme *sc, s7_pointer args)
{
  #define H_system "(system command) executes the command.  If the optional second argument is #t, \
system captures the output as a string and returns it."
  #define Q_system s7_make_signature(sc, 3, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_string_symbol), sc->is_string_symbol, sc->is_boolean_symbol)

  s7_pointer name;
  name = car(args);

  if (!is_string(name))
    return(method_or_bust_one_arg(sc, name, sc->system_symbol, args, T_STRING));

  if ((is_pair(cdr(args))) &&
      (cadr(args) == sc->T))
    {
      #define BUF_SIZE 256
      char buf[BUF_SIZE];
      char *str = NULL;
      int32_t cur_len = 0, full_len = 0;
      FILE *fd;

      fd = popen(string_value(name), "r");
      while (fgets(buf, BUF_SIZE, fd))
	{
	  s7_int buf_len;
	  buf_len = safe_strlen(buf);
	  if (cur_len + buf_len >= full_len)
	    {
	      full_len += BUF_SIZE * 2;
	      if (str)
		str = (char *)realloc(str, full_len * sizeof(char));
	      else str = (char *)malloc(full_len * sizeof(char));
	    }
	  memcpy((void *)(str + cur_len), (void *)buf, buf_len);
	  cur_len += buf_len;
	}
      pclose(fd);
      if (str)
	{
	  block_t *b;
	  b = mallocate_block(sc);
	  block_data(b) = (void *)str;
	  block_set_index(b, TOP_BLOCK_LIST);
	  return(block_to_string(sc, b, cur_len));
	}
      return(make_empty_string(sc, 0, 0));
    }
  return(make_integer(sc, system(string_value(name))));
}


#if (!MS_WINDOWS)
#include <dirent.h>

/* -------------------------------- directory->list -------------------------------- */
static s7_pointer g_directory_to_list(s7_scheme *sc, s7_pointer args)
{
  s7_pointer name;
  DIR *dpos;
  s7_pointer result;

  #define H_directory_to_list "(directory->list directory) returns the contents of the directory as a list of strings (filenames)."
  #define Q_directory_to_list s7_make_signature(sc, 2, sc->is_list_symbol, sc->is_string_symbol)   /* can return nil */

  name = car(args);
  if (!is_string(name))
    return(method_or_bust_one_arg(sc, name, sc->directory_to_list_symbol, list_1(sc, name), T_STRING));

  sc->w = sc->nil;
  if ((dpos = opendir(string_value(name))))
    {
      struct dirent *dirp;
      while ((dirp = readdir(dpos)))
	sc->w = cons(sc, s7_make_string(sc, dirp->d_name), sc->w);
      closedir(dpos);
    }

  result = sc->w;
  sc->w = sc->nil;
  return(result);
}

/* -------------------------------- file-mtime -------------------------------- */
static s7_pointer g_file_mtime(s7_scheme *sc, s7_pointer args)
{
  #define H_file_mtime "(file-mtime file): return the write date of file"
  #define Q_file_mtime s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_string_symbol)

  struct stat statbuf;
  int32_t err;
  s7_pointer name;

  name = car(args);
  if (!is_string(name))
    return(method_or_bust_one_arg(sc, name, sc->file_mtime_symbol, args, T_STRING));

  err = stat(string_value(name), &statbuf);
  if (err < 0)
    return(file_error(sc, "file-mtime", strerror(errno), string_value(name)));

  return(s7_make_integer(sc, (s7_int)(statbuf.st_mtime)));
}
#endif
#endif


/* -------------------------------- lists -------------------------------- */

s7_pointer s7_cons(s7_scheme *sc, s7_pointer a, s7_pointer b)
{
  s7_pointer x;
  new_cell(sc, x, T_PAIR | T_SAFE_PROCEDURE);
  set_car(x, a);
  set_cdr(x, b);
  return(x);
}

static s7_pointer cons_unchecked(s7_scheme *sc, s7_pointer a, s7_pointer b)
{
  /* apparently slightly faster as a function? */
  s7_pointer x;
  new_cell_no_check(sc, x, T_PAIR | T_SAFE_PROCEDURE);
  set_car(x, a);
  set_cdr(x, b);
  return(x);
}

static s7_pointer cons_unchecked_with_type(s7_scheme *sc, s7_pointer p, s7_pointer a, s7_pointer b)
{
  /* apparently slightly faster as a function? */
  s7_pointer x;
  new_cell_no_check(sc, x, typeflag(p) & (TYPE_MASK | T_IMMUTABLE | T_SAFE_PROCEDURE));
  set_car(x, a);
  set_cdr(x, b);
  return(x);
}

#if S7_DEBUGGING
static s7_int permanent_conses = 0;
#endif

static s7_pointer permanent_cons(s7_scheme *sc, s7_pointer a, s7_pointer b, uint64_t type)
{
  s7_pointer x;
  x = alloc_pointer(sc);
#if S7_DEBUGGING
  permanent_conses++;
#endif
  set_type(x, type | T_UNHEAP);
  set_car(x, a);
  set_cdr(x, b);
  return(x);
}

static s7_pointer permanent_list(s7_scheme *sc, s7_int len)
{
  s7_int j;
  s7_pointer p;
  p = sc->nil;
  for (j = 0; j < len; j++)
    p = permanent_cons(sc, sc->nil, p, T_PAIR | T_IMMUTABLE);
  return(p);
}

static void check_sig_entry(s7_scheme *sc, s7_pointer p, s7_int pos, bool circle)
{
  if ((!is_symbol(car(p))) &&
      (!s7_is_boolean(car(p))) &&
      (!is_pair(car(p))))
    {
      s7_warn(sc, 512, "s7_make_%ssignature got an invalid entry at position %" print_s7_int ": (", (circle) ? "circular_" : "", pos);
      set_car(p, sc->nil);
    }
}

s7_pointer s7_make_signature(s7_scheme *sc, s7_int len, ...)
{
  va_list ap;
  s7_int i;
  s7_pointer p, res;

  res = permanent_list(sc, len);
  va_start(ap, len);
  for (p = res, i = 0; is_pair(p); p = cdr(p), i++)
    {
      set_car(p, va_arg(ap, s7_pointer));
      check_sig_entry(sc, p, i, false);
    }
  va_end(ap);

  return((s7_pointer)res);
}

s7_pointer s7_make_circular_signature(s7_scheme *sc, s7_int cycle_point, s7_int len, ...)
{
  va_list ap;
  s7_int i;
  s7_pointer p, res, back = NULL, end = NULL;

  res = permanent_list(sc, len);
  va_start(ap, len);
  for (p = res, i = 0; is_pair(p); p = cdr(p), i++)
    {
      set_car(p, va_arg(ap, s7_pointer));
      check_sig_entry(sc, p, i, true);
      if (i == cycle_point) back = p;
      if (i == (len - 1)) end = p;
    }
  va_end(ap);
  if (end) set_cdr(end, back);
  if (i < len)
    s7_warn(sc, 256, "s7_make_circular_signature got too few entries: %s\n", s7_object_to_c_string(sc, res));
  return((s7_pointer)res);
}


bool s7_is_pair(s7_pointer p) {return(is_pair(p));}
static s7_pointer is_pair_p_p(s7_scheme *sc, s7_pointer p) {return((is_pair(p)) ? sc->T : sc->F);}

s7_pointer s7_car(s7_pointer p) {return(car(p));}
s7_pointer s7_cdr(s7_pointer p) {return(cdr(p));}

s7_pointer s7_cadr(s7_pointer p) {return(cadr(p));}
s7_pointer s7_cddr(s7_pointer p) {return(cddr(p));}
s7_pointer s7_cdar(s7_pointer p) {return(cdar(p));}
s7_pointer s7_caar(s7_pointer p) {return(caar(p));}

s7_pointer s7_caadr(s7_pointer p) {return(caadr(p));}
s7_pointer s7_caddr(s7_pointer p) {return(caddr(p));}
s7_pointer s7_cadar(s7_pointer p) {return(cadar(p));}
s7_pointer s7_caaar(s7_pointer p) {return(caaar(p));}
s7_pointer s7_cdadr(s7_pointer p) {return(cdadr(p));}
s7_pointer s7_cdddr(s7_pointer p) {return(cdddr(p));}
s7_pointer s7_cddar(s7_pointer p) {return(cddar(p));}
s7_pointer s7_cdaar(s7_pointer p) {return(cdaar(p));}

s7_pointer s7_caaadr(s7_pointer p) {return(caaadr(p));}
s7_pointer s7_caaddr(s7_pointer p) {return(caaddr(p));}
s7_pointer s7_caadar(s7_pointer p) {return(caadar(p));}
s7_pointer s7_caaaar(s7_pointer p) {return(caaaar(p));}
s7_pointer s7_cadadr(s7_pointer p) {return(cadadr(p));}
s7_pointer s7_cadddr(s7_pointer p) {return(cadddr(p));}
s7_pointer s7_caddar(s7_pointer p) {return(caddar(p));}
s7_pointer s7_cadaar(s7_pointer p) {return(cadaar(p));}

s7_pointer s7_cdaadr(s7_pointer p) {return(cdaadr(p));}
s7_pointer s7_cdaddr(s7_pointer p) {return(cdaddr(p));}
s7_pointer s7_cdadar(s7_pointer p) {return(cdadar(p));}
s7_pointer s7_cdaaar(s7_pointer p) {return(cdaaar(p));}
s7_pointer s7_cddadr(s7_pointer p) {return(cddadr(p));}
s7_pointer s7_cddddr(s7_pointer p) {return(cddddr(p));}
s7_pointer s7_cdddar(s7_pointer p) {return(cdddar(p));}
s7_pointer s7_cddaar(s7_pointer p) {return(cddaar(p));}

s7_pointer s7_set_car(s7_pointer p, s7_pointer q)
{
  set_car(p, q);
  return(q);  /* was p? 5-Aug-17 */
}

s7_pointer s7_set_cdr(s7_pointer p, s7_pointer q)
{
  set_cdr(p, q);
  return(q);  /* was p? 5-Aug-17 */
}


/* -------------------------------------------------------------------------------- */

s7_pointer s7_apply_1(s7_scheme *sc, s7_pointer args, s7_pointer (*f1)(s7_pointer a1))
{
  /* not currently used */
  return(f1(car(args)));
}

s7_pointer s7_apply_2(s7_scheme *sc, s7_pointer args, s7_pointer (*f2)(s7_pointer a1, s7_pointer a2))
{
  return(f2(car(args), cadr(args)));
}

s7_pointer s7_apply_3(s7_scheme *sc, s7_pointer args, s7_pointer (*f3)(s7_pointer a1, s7_pointer a2, s7_pointer a3))
{
  s7_pointer a1;
  a1 = car(args);  args = cdr(args);
  return(f3(a1, car(args), cadr(args)));
}

s7_pointer s7_apply_4(s7_scheme *sc, s7_pointer args, s7_pointer (*f4)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4))
{
  s7_pointer a1, a2;
  a1 = car(args);  a2 = cadr(args);  args = cddr(args);
  return(f4(a1, a2, car(args), cadr(args)));
}

s7_pointer s7_apply_5(s7_scheme *sc, s7_pointer args, s7_pointer (*f5)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4, s7_pointer a5))
{
  s7_pointer a1, a2, a3, a4;
  a1 = car(args);  a2 = cadr(args);  args = cddr(args); a3 = car(args);  a4 = cadr(args);  args = cddr(args);
  return(f5(a1, a2, a3, a4, car(args)));
}

s7_pointer s7_apply_6(s7_scheme *sc, s7_pointer args, s7_pointer (*f6)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4, s7_pointer a5, s7_pointer a6))
{
  s7_pointer a1, a2, a3, a4;
  a1 = car(args);  a2 = cadr(args);  args = cddr(args); a3 = car(args);  a4 = cadr(args);  args = cddr(args);
  return(f6(a1, a2, a3, a4, car(args), cadr(args)));
}

s7_pointer s7_apply_7(s7_scheme *sc, s7_pointer args,
		      s7_pointer (*f7)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4, s7_pointer a5, s7_pointer a6, s7_pointer a7))
{
  s7_pointer a1, a2, a3, a4, a5, a6;
  a1 = car(args);  a2 = cadr(args);  args = cddr(args); a3 = car(args);  a4 = cadr(args);  args = cddr(args); a5 = car(args);  a6 = cadr(args);  args = cddr(args);
  return(f7(a1, a2, a3, a4, a5, a6, car(args)));
}

s7_pointer s7_apply_8(s7_scheme *sc, s7_pointer args,
		      s7_pointer (*f8)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4, s7_pointer a5, s7_pointer a6, s7_pointer a7, s7_pointer a8))
{
  s7_pointer a1, a2, a3, a4, a5, a6;
  a1 = car(args);  a2 = cadr(args);  args = cddr(args); a3 = car(args);  a4 = cadr(args);  args = cddr(args); a5 = car(args);  a6 = cadr(args);  args = cddr(args);
  return(f8(a1, a2, a3, a4, a5, a6, car(args), cadr(args)));
}

s7_pointer s7_apply_9(s7_scheme *sc, s7_pointer args, s7_pointer (*f9)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4,
								       s7_pointer a5, s7_pointer a6, s7_pointer a7, s7_pointer a8, s7_pointer a9))
{
  s7_pointer a1, a2, a3, a4, a5, a6;
  a1 = car(args);  a2 = cadr(args);  args = cddr(args); a3 = car(args);  a4 = cadr(args);  args = cddr(args); a5 = car(args);  a6 = cadr(args);  args = cddr(args);
  return(f9(a1, a2, a3, a4, a5, a6, car(args), cadr(args), caddr(args)));
}

s7_pointer s7_apply_n_1(s7_scheme *sc, s7_pointer args, s7_pointer (*f1)(s7_pointer a1))
{
  if (is_pair(args))
    return(f1(car(args)));
  return(f1(sc->undefined));
}

s7_pointer s7_apply_n_2(s7_scheme *sc, s7_pointer args, s7_pointer (*f2)(s7_pointer a1, s7_pointer a2))
{
  if (is_pair(args))
    {
      if (is_pair(cdr(args)))
	return(f2(car(args), cadr(args)));
      return(f2(car(args), sc->undefined));
    }
  return(f2(sc->undefined, sc->undefined));
}

s7_pointer s7_apply_n_3(s7_scheme *sc, s7_pointer args, s7_pointer (*f3)(s7_pointer a1, s7_pointer a2, s7_pointer a3))
{
  if (is_pair(args))
    {
      s7_pointer a1;
      a1 = car(args); args = cdr(args);
      if (is_pair(args))
	{
	  s7_pointer a2;
	  a2 = car(args);
	  if (is_pair(cdr(args)))
	    return(f3(a1, a2, cadr(args)));
	  return(f3(a1, a2, sc->undefined));
	}
      return(f3(a1, sc->undefined, sc->undefined));
    }
  return(f3(sc->undefined, sc->undefined, sc->undefined));
}

s7_pointer s7_apply_n_4(s7_scheme *sc, s7_pointer args, s7_pointer (*f4)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4))
{
  if (is_pair(args))
    {
      s7_pointer a1;
      a1 = car(args); args = cdr(args);
      if (is_pair(args))
	{
	  s7_pointer a2;
	  a2 = car(args); args = cdr(args);
	  if (is_pair(args))
	    {
	      s7_pointer a3;
	      a3 = car(args);
	      if (is_pair(cdr(args)))
		return(f4(a1, a2, a3, cadr(args)));
	      return(f4(a1, a2, a3, sc->undefined));
	    }
	  return(f4(a1, a2, sc->undefined, sc->undefined));
	}
      return(f4(a1, sc->undefined, sc->undefined, sc->undefined));
    }
  return(f4(sc->undefined, sc->undefined, sc->undefined, sc->undefined));
}

s7_pointer s7_apply_n_5(s7_scheme *sc, s7_pointer args,
			s7_pointer (*f5)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4, s7_pointer a5))
{
  if (is_pair(args))
    {
      s7_pointer a1;
      a1 = car(args); args = cdr(args);
      if (is_pair(args))
	{
	  s7_pointer a2;
	  a2 = car(args); args = cdr(args);
	  if (is_pair(args))
	    {
	      s7_pointer a3;
	      a3 = car(args); args = cdr(args);
	      if (is_pair(args))
		{
		  s7_pointer a4;
		  a4 = car(args);
		  if (is_pair(cdr(args)))
		    return(f5(a1, a2, a3, a4, cadr(args)));
		  return(f5(a1, a2, a3, a4, sc->undefined));
		}
	      return(f5(a1, a2, a3, sc->undefined, sc->undefined));
	    }
	  return(f5(a1, a2, sc->undefined, sc->undefined, sc->undefined));
	}
      return(f5(a1, sc->undefined, sc->undefined, sc->undefined, sc->undefined));
    }
  return(f5(sc->undefined, sc->undefined, sc->undefined, sc->undefined, sc->undefined));
}

#define apply_set_args(args) \
  if (is_pair(args)) \
    { \
      a1 = car(args); args = cdr(args); \
      if (is_pair(args)) \
	{ \
	  a2 = car(args); args = cdr(args); \
	  if (is_pair(args)) \
	    { \
	      a3 = car(args); args = cdr(args); \
	      if (is_pair(args)) \
		{ \
		  a4 = car(args); args = cdr(args); \
		  if (is_pair(args)) \
		    { \
		      a5 = car(args); args = cdr(args); \
		      if (is_pair(args)) \
			{ \
			  a6 = car(args); args = cdr(args); \
			  if (is_pair(args)) \
			    { \
			      a7 = car(args); args = cdr(args); \
			      if (is_pair(args)) \
				{ \
				  a8 = car(args); \
				  if (is_pair(cdr(args))) a9 = cadr(args); \
				}}}}}}}}

s7_pointer s7_apply_n_6(s7_scheme *sc, s7_pointer args,
			s7_pointer (*f6)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4, s7_pointer a5, s7_pointer a6))
{
  s7_pointer a1, a2, a3, a4, a5, a6, a7, a8, a9;
  a7 = sc->undefined; a8 = a7; a9 = a8;
  a1 = a9; a2 = a9; a3 = a9; a4 = a9; a5 = a9; a6 = a9;
  apply_set_args(args)
  return(f6(a1, a2, a3, a4, a5, a6));
}

s7_pointer s7_apply_n_7(s7_scheme *sc, s7_pointer args,
			s7_pointer (*f7)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4,
					 s7_pointer a5, s7_pointer a6, s7_pointer a7))
{
  s7_pointer a1, a2, a3, a4, a5, a6, a7, a8, a9;
  a8 = sc->undefined; a9 = a8;
  a1 = a9; a2 = a9; a3 = a9; a4 = a9; a5 = a9; a6 = a9, a7 = a9;
  apply_set_args(args)
  return(f7(a1, a2, a3, a4, a5, a6, a7));
}

s7_pointer s7_apply_n_8(s7_scheme *sc, s7_pointer args,
			s7_pointer (*f8)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4,
					 s7_pointer a5, s7_pointer a6, s7_pointer a7, s7_pointer a8))
{
  s7_pointer a1, a2, a3, a4, a5, a6, a7, a8, a9;
  a9 = sc->undefined;
  a1 = a9; a2 = a9; a3 = a9; a4 = a9; a5 = a9; a6 = a9, a7 = a9; a8 = a9;
  apply_set_args(args)
  return(f8(a1, a2, a3, a4, a5, a6, a7, a8));
}

s7_pointer s7_apply_n_9(s7_scheme *sc, s7_pointer args,
			s7_pointer (*f9)(s7_pointer a1, s7_pointer a2, s7_pointer a3, s7_pointer a4,
					 s7_pointer a5, s7_pointer a6, s7_pointer a7, s7_pointer a8,
					 s7_pointer a9))
{
  s7_pointer a1, a2, a3, a4, a5, a6, a7, a8, a9;
  a9 = sc->undefined;
  a1 = a9; a2 = a9; a3 = a9; a4 = a9; a5 = a9; a6 = a9, a7 = a9; a8 = a9;
  apply_set_args(args)
  return(f9(a1, a2, a3, a4, a5, a6, a7, a8, a9));
}

/* -------------------------------------------------------------------------------- */

s7_pointer s7_list_ref(s7_scheme *sc, s7_pointer lst, s7_int num)
{
  s7_int i;
  s7_pointer x;
  for (x = lst, i = 0; (i < num) && (is_pair(x)); i++, x = cdr(x)) {}
  if ((i == num) && (is_pair(x)))
    return(car(x));
  return(sc->nil);
}

s7_pointer s7_list_set(s7_scheme *sc, s7_pointer lst, s7_int num, s7_pointer val)
{
  s7_int i;
  s7_pointer x;
  for (x = lst, i = 0; (i < num) && (is_pair(x)); i++, x = cdr(x)) {}
  if ((i == num) &&
      (is_pair(x)))
    set_car(x, T_Pos(val));
  return(val);
}

s7_pointer s7_member(s7_scheme *sc, s7_pointer sym, s7_pointer lst)
{
  s7_pointer x;
  for (x = lst; is_pair(x); x = cdr(x))
    if (s7_is_equal(sc, sym, car(x)))
      return(x);
  return(sc->F);
}

static bool symbol_is_in_arg_list(s7_pointer sym, s7_pointer lst)
{
  s7_pointer x;
  for (x = lst; is_pair(x); x = cdr(x))
    if ((sym == car(x)) ||
	((is_pair(car(x))) &&
	 (sym == caar(x))))
	return(true);
  return(sym == x);
}


/* ---------------- tree-leaves ---------------- */
static inline s7_int tree_len_1(s7_scheme *sc, s7_pointer p)
{
  s7_int sum;
  for (sum = 0; is_pair(p); p = cdr(p))
    {
      s7_pointer cp;
      cp = car(p);
      if ((!is_pair(cp)) ||
	  (car(cp) == sc->quote_symbol))
	sum++;
      else
	{
	  do {
	    s7_pointer ccp;
	    ccp = car(cp);
	    if ((!is_pair(ccp)) ||
		(car(ccp) == sc->quote_symbol))
	      sum++;
	    else
	      {
		do {
		  s7_pointer cccp;
		  cccp = car(ccp);
		  if ((!is_pair(cccp)) ||
		      (car(cccp) == sc->quote_symbol))
		    sum++;
		  else sum += tree_len_1(sc, cccp);
		  ccp = cdr(ccp);
		} while (is_pair(ccp));
		if (!is_null(ccp)) sum++;
	      }
	    cp = cdr(cp);
	    } while (is_pair(cp));
	  if (!is_null(cp)) sum++;
	}
    }
  if (!is_null(p)) return(sum + 1);
  return(sum);
}

static inline s7_int tree_len(s7_scheme *sc, s7_pointer p)
{
  if (is_null(p))
    return(0);
  if ((!is_pair(p)) ||
      (car(p) == sc->quote_symbol))
    return(1);
  return(tree_len_1(sc, p));
}

static s7_int tree_leaves_i_7p(s7_scheme *sc, s7_pointer p)
{
  if ((sc->safety > NO_SAFETY) &&
      (tree_is_cyclic(sc, p)))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "tree-leaves: tree is cyclic", 27));
  return(tree_len(sc, p));
}

static s7_pointer tree_leaves_p_p(s7_scheme *sc, s7_pointer tree) 
{
  if ((sc->safety > NO_SAFETY) && /* repeat code to avoid extra call overhead */
      (tree_is_cyclic(sc, tree)))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "tree-leaves: tree is cyclic", 27));
  return(s7_make_integer(sc, tree_len(sc, tree)));
}

static s7_pointer g_tree_leaves(s7_scheme *sc, s7_pointer args)
{
  #define H_tree_leaves "(tree-leaves tree) returns the number of leaves in the tree"
  #define Q_tree_leaves s7_make_signature(sc, 2, sc->is_integer_symbol, sc->T)
  return(tree_leaves_p_p(sc, car(args)));
}


/* ---------------- tree-memq ---------------- */

static inline bool tree_memq_1(s7_scheme *sc, s7_pointer sym, s7_pointer tree)    /* sym need not be a symbol */
{
  if (car(tree) == sc->quote_symbol)
    {
      if ((is_symbol(sym)) || (is_pair(sym)) || (!is_pair(cdr(tree))))
	return(false);
      return(sym == cadr(tree));
    }
  do {
    if (sym == car(tree))
      return(true);

    if (is_pair(car(tree)))
      {
	s7_pointer cp;
	cp = car(tree);
	if (car(cp) == sc->quote_symbol)
	  {
	    if ((!is_symbol(sym)) && (!is_pair(sym)) && (is_pair(cdr(cp))) && (sym == cadr(cp)))
	      return(true);
	  }
	else
	  {
	    do {
	      if (sym == car(cp))
		return(true);
	      if ((is_pair(car(cp))) &&
		  (tree_memq_1(sc, sym, car(cp))))
		return(true);
	      cp = cdr(cp);
	      if (sym == cp)
		return(true);
	    } while (is_pair(cp));
	  }
      }

    tree = cdr(tree);
    if (sym == tree)
      return(true);
  } while (is_pair(tree));
  return(false);
}

bool s7_tree_memq(s7_scheme *sc, s7_pointer sym, s7_pointer tree)
{
  if (sym == tree) return(true);
  if (!is_pair(tree)) return(false);
  if ((sc->safety > NO_SAFETY) &&
      (tree_is_cyclic(sc, tree)))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "tree-memq: tree is cyclic", 25));
  return(tree_memq_1(sc, sym, tree));
}

static s7_pointer g_tree_memq(s7_scheme *sc, s7_pointer args)
{
  #define H_tree_memq "(tree-memq obj tree) is a tree-oriented version of memq, but returning #t if the object is in the tree."
  #define Q_tree_memq s7_make_signature(sc, 3, sc->is_boolean_symbol, sc->T, sc->T)

  return(make_boolean(sc, s7_tree_memq(sc, car(args), cadr(args))));
}


/* ---------------- tree-set-memq ---------------- */
static inline bool pair_set_memq(s7_scheme *sc, s7_pointer tree)
{
  while (true)
    {
      s7_pointer p;
      p = car(tree);
      if (is_symbol(p))
	{
	  if (symbol_is_in_list(sc, p))
	    return(true);
	}
      if ((is_unquoted_pair(p)) &&
	  (pair_set_memq(sc, p)))
	return(true);
      tree = cdr(tree);
      if (!is_pair(tree)) break;
    }
  return((is_symbol(tree)) && (symbol_is_in_list(sc, tree)));
}

static bool tree_set_memq(s7_scheme *sc, s7_pointer tree)
{
  if (is_symbol(tree))
    return(symbol_is_in_list(sc, tree));
  if ((!is_pair(tree)) ||
      (car(tree) == sc->quote_symbol))
    return(false);
  return(pair_set_memq(sc, tree));
}

static s7_pointer g_tree_set_memq(s7_scheme *sc, s7_pointer args)
{
  #define H_tree_set_memq "(tree-set-memq symbols tree) returns #t if any of the list of symbols is in the tree"
  #define Q_tree_set_memq s7_make_signature(sc, 3, sc->is_boolean_symbol, sc->T, sc->T)

  s7_pointer syms, p, tree;
  syms = car(args);
  if (!is_pair(syms)) return(sc->F);
  tree = cadr(args);
  if (sc->safety > NO_SAFETY)
    {
      if (tree_is_cyclic(sc, syms))
	s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "tree-set-memq: symbol list is cyclic", 36));
      if (tree_is_cyclic(sc, tree))
	s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "tree-set-memq: tree is cyclic", 29));
    }
  clear_symbol_list(sc);
  for (p = syms; is_pair(p); p = cdr(p))
    if (is_symbol(car(p)))
      add_symbol_to_list(sc, car(p));
  return(make_boolean(sc, tree_set_memq(sc, tree)));
}

static bool tree_set_memq_b_7pp(s7_scheme *sc, s7_pointer syms, s7_pointer tree) {return(g_tree_set_memq(sc, set_plist_2(sc, syms, tree)) != sc->F);}

static s7_pointer g_tree_set_memq_1(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p, tree;
  tree = cadr(args);
  if ((sc->safety > NO_SAFETY) &&
      (tree_is_cyclic(sc, tree)))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "tree-set-memq: tree is cyclic", 29));
  clear_symbol_list(sc);
  for (p = car(args); is_pair(p); p = cdr(p))
    add_symbol_to_list(sc, car(p));
  return(make_boolean(sc, tree_set_memq(sc, tree)));
}

static s7_pointer tree_set_memq_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if ((is_proper_quote(sc, cadr(expr))) &&   /* not (tree-set-memq (quote) ... */
      (is_pair(cadadr(expr))))
    {
      s7_pointer p;
      for (p = cadadr(expr); is_pair(p); p = cdr(p))
	if (!is_symbol(car(p)))
	  return(f);
      return(sc->tree_set_memq_syms);
    }
  return(f);
}


/* ---------------- tree-count ---------------- */
static s7_int tree_count(s7_scheme *sc, s7_pointer x, s7_pointer p, s7_int count)
{
  if (p == x)
    return(count + 1);
  if ((!is_pair(p)) || (car(p) == sc->quote_symbol))
    return(count);
  return(tree_count(sc, x, cdr(p), tree_count(sc, x, car(p), count)));
}

static inline s7_int tree_count_at_least(s7_scheme *sc, s7_pointer x, s7_pointer p, s7_int count, s7_int top)
{
  if (p == x) return(count + 1);
  if (!is_pair(p)) return(count);
  if (car(p) == sc->quote_symbol) return(count);
  do
    {
      count = tree_count_at_least(sc, x, car(p), count, top);
      if (count >= top) return(count);
      p = cdr(p);
      if (p == x) return(count + 1);
    } while (is_pair(p));
  return(count);
}

static s7_pointer g_tree_count(s7_scheme *sc, s7_pointer args)
{
  #define H_tree_count "(tree-count obj tree max-count) returns how many times obj is in tree, stopping at max-count (if specified)"
  #define Q_tree_count s7_make_signature(sc, 4, sc->is_integer_symbol, sc->T, sc->T, sc->is_integer_symbol)
  s7_pointer obj, tree, count;

  obj = car(args);
  tree = cadr(args);
  if (!is_pair(tree))
    {
      if ((is_pair(cddr(args))) &&
	  (!is_t_integer(caddr(args))))
	return(simple_wrong_type_argument(sc, sc->tree_count_symbol, caddr(args), T_INTEGER));
      return((obj == tree) ? small_int(1) : small_int(0));
    }
  if ((sc->safety > NO_SAFETY) &&
      (tree_is_cyclic(sc, tree)))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "tree-count: tree is cyclic", 26));
  if (is_null(cddr(args)))
    return(s7_make_integer(sc, tree_count(sc, obj, tree, 0)));
  count = caddr(args);
  if (!s7_is_integer(count))
    return(simple_wrong_type_argument(sc, sc->tree_count_symbol, count, T_INTEGER));
  return(s7_make_integer(sc, tree_count_at_least(sc, obj, tree, 0, s7_integer(count))));
}

s7_pointer s7_assoc(s7_scheme *sc, s7_pointer sym, s7_pointer lst)
{
  s7_pointer x, y;

  if (!is_pair(lst))
    return(sc->F);

  x = lst;
  y = lst;
  while (true)
    {
      if ((is_pair(car(x))) && (s7_is_equal(sc, sym, caar(x)))) return(car(x));
      x = cdr(x);
      if (!is_pair(x)) return(sc->F);

      if ((is_pair(car(x))) && (s7_is_equal(sc, sym, caar(x)))) return(car(x));
      x = cdr(x);
      if (!is_pair(x)) return(sc->F);

      y = cdr(y);
      if (x == y) return(sc->F);
    }
  return(sc->F);
}

s7_pointer s7_reverse(s7_scheme *sc, s7_pointer a)
{
  /* reverse list -- produce new list (other code assumes this function does not return the original!) */
  s7_pointer x, p;

  if (is_null(a)) return(a);

  if (!is_pair(cdr(a)))
    {
      if (is_not_null(cdr(a)))
	return(cons(sc, cdr(a), car(a)));
      return(cons(sc, car(a), sc->nil)); /* don't return 'a' itself */
    }

  sc->w = list_1(sc, car(a));
  for (x = cdr(a), p = a; is_pair(x); x = cdr(x), p = cdr(p))
    {
      sc->w = cons(sc, car(x), sc->w);
      if (is_pair(cdr(x)))
	{
	  x = cdr(x);
	  sc->w = cons(sc, car(x), sc->w);
	}
      if (x == p) /* this can take awhile to notice there's a cycle, but what does the caller expect? */
	break;
    }

  if (is_not_null(x))
    p = cons(sc, x, sc->w);    /* ?? this means that (reverse '(1 2 . 3)) returns '(3 2 1) -- we used to return () here */
  else p = sc->w;

  sc->w = sc->nil;
  return(p);
}

/* s7_reverse sometimes tacks extra nodes on the end of a reversed circular list (it detects the cycle too late)
 *  (let ((lst (list 0))) (set! (cdr lst) lst) (reverse lst)) -> (#1=(0 . #1#) 0 0 0)
 */

static s7_pointer reverse_in_place(s7_scheme *sc, s7_pointer term, s7_pointer list)
{
  s7_pointer p, result;

  if (is_null(list)) return(term);
  p = list;
  result = term;
  while (true)
    {
      s7_pointer q;
      q = cdr(p);
      if (is_null(q))
	{
	  set_cdr(p, result);
	  return(p);
	}
      if ((is_pair(q)) && (!is_immutable_pair(q)))
	{
	  set_cdr(p, result);
	  result = p;
	  p = q;
	}
      else return(sc->nil); /* improper or immutable */
    }
  return(result);
}

static s7_pointer reverse_in_place_unchecked(s7_scheme *sc, s7_pointer term, s7_pointer list)
{
  s7_pointer p = list, result = term;
  while (true)
    {
      s7_pointer q;
      LOOP_4(if (is_null(p)) return(result); q = cdr(p); set_cdr(p, result); result = p; p = q); /* return, not break because LOOP_4 is itself a do loop */
    }
  return(result);
}

static s7_pointer safe_reverse_in_place(s7_scheme *sc, s7_pointer list) /* "safe" here means we guarantee this list is unproblematic */
{
  return(reverse_in_place_unchecked(sc, sc->nil, list));
}

s7_pointer s7_append(s7_scheme *sc, s7_pointer a, s7_pointer b)
{
  s7_pointer p, tp, np;
  if (is_null(a)) return(b);

  tp = cons(sc, car(a), sc->nil);
  sc->y = tp;
  for (p = cdr(a), np = tp; is_pair(p); p = cdr(p), np = cdr(np))
    set_cdr(np, cons(sc, car(p), sc->nil));
  set_cdr(np, b);
  sc->y = sc->nil;

  return(tp);
}

static s7_pointer copy_list(s7_scheme *sc, s7_pointer lst)
{
  s7_pointer p, tp, np;
  if (!is_pair(lst)) return(sc->nil);
  sc->u = lst;
  tp = cons(sc, car(lst), sc->nil);
  sc->y = tp;
  for (p = cdr(lst), np = tp; is_pair(p); p = cdr(p), np = cdr(np))
    set_cdr(np, cons(sc, car(p), sc->nil));
  sc->y = sc->nil;
  sc->u = sc->nil;
  return(tp);
}

static s7_pointer copy_list_with_arglist_error(s7_scheme *sc, s7_pointer lst)
{
  s7_pointer p, tp, np;
  if (is_null(lst)) return(sc->nil);
  if (!is_pair(lst))
    s7_error(sc, sc->syntax_error_symbol, set_elist_2(sc, wrap_string(sc, "stray dot?: ~S", 14), lst));
  sc->u = lst;
  tp = cons(sc, car(lst), sc->nil);
  sc->y = tp;
  for (p = cdr(lst), np = tp; is_pair(p); p = cdr(p), np = cdr(np))
    set_cdr(np, cons(sc, car(p), sc->nil));
  sc->y = sc->nil;
  sc->u = sc->nil;
  if (!is_null(p))
    s7_error(sc, sc->syntax_error_symbol, set_elist_2(sc, wrap_string(sc, "improper list of arguments: ~S", 30), lst));
  return(tp);
}


static s7_pointer revappend(s7_scheme *sc, s7_pointer a, s7_pointer b)
{
  /* (map (lambda (x) (if (odd? x) (apply values '(1 2 3)) (values))) (list 1 2 3 4)) is a bad case -- we have to copy the incoming list */
  s7_pointer p = b, q;

  if (is_not_null(a))
    {
      a = copy_list(sc, a);
      while (is_not_null(a))
	{
	  q = cdr(a);
	  set_cdr(a, p);
	  p = a;
	  a = q;
	}
    }
  return(p);
}

static s7_int safe_list_length(s7_pointer a)
{
  /* assume that "a" is a proper list */
  s7_int i = 0;
  s7_pointer b;
  for (b = a; is_pair(b); i++, b = cdr(b)) {};
  return(i);
}

s7_int s7_list_length(s7_scheme *sc, s7_pointer a)
{
  /* returns -len if list is dotted, 0 if it's (directly) circular */
  s7_int i;
  s7_pointer slow, fast;

  slow = fast = a;
  for (i = 0; ; i += 2)
    {
      if (!is_pair(fast))
	{
	  if (is_null(fast))
	    return(i);
	  return(-i);
	}

      fast = cdr(fast);
      if (!is_pair(fast))
	{
	  if (is_null(fast))
	    return(i + 1);
	  return(-i - 1);
	}
      /* if unrolled further, it's a lot slower? */

      fast = cdr(fast);
      slow = cdr(slow);
      if (fast == slow)
	return(0);
    }
  return(0);
}


/* -------------------------------- null? pair? -------------------------------- */
static s7_pointer g_is_null(s7_scheme *sc, s7_pointer args)
{
  #define H_is_null "(null? obj) returns #t if obj is the empty list"
  #define Q_is_null sc->pl_bt
  check_boolean_method(sc, is_null, sc->is_null_symbol, args);
}

static s7_pointer g_is_pair(s7_scheme *sc, s7_pointer args)
{
  #define H_is_pair "(pair? obj) returns #t if obj is a pair (a non-empty list)"
  #define Q_is_pair sc->pl_bt
  check_boolean_method(sc, is_pair, sc->is_pair_symbol, args);
}


/* -------------------------------- list? proper-list? -------------------------------- */
bool s7_is_list(s7_scheme *sc, s7_pointer p) /* sc for is_null */
{
  return((is_pair(p)) ||
	 (is_null(p)));
}

static bool is_list_b(s7_pointer p) {return((is_pair(p)) || (type(p) == T_NIL));}

bool s7_is_proper_list(s7_scheme *sc, s7_pointer lst)
{
  /* #t if () or undotted/non-circular pair */
  s7_pointer slow, fast;

  fast = lst;
  slow = lst;
  while (true)
    {
      if (!is_pair(fast))
	return(is_null(fast)); /* else it's an improper list */
      LOOP_4(fast = cdr(fast); if (!is_pair(fast)) return(is_null(fast)));
      fast = cdr(fast);
      slow = cdr(slow);
      if (fast == slow) return(false);
    }
  return(true);
}

static s7_pointer g_is_list(s7_scheme *sc, s7_pointer args)
{
  #define H_is_list "(list? obj) returns #t if obj is a pair or null"
  #define Q_is_list sc->pl_bt
  #define is_a_list(p) s7_is_list(sc, p)
  check_boolean_method(sc, is_a_list, sc->is_list_symbol, args);
}

static s7_pointer g_is_proper_list(s7_scheme *sc, s7_pointer args)
{
  #define H_is_proper_list "(proper-list? x) returns #t is x is a list that is neither circular nor dotted."
  #define Q_is_proper_list sc->pl_bt
  s7_pointer p;
  p = car(args);
  return(make_boolean(sc, s7_is_proper_list(sc, p)));
}

static bool is_proper_list_b_7p(s7_scheme *sc, s7_pointer p) {return(s7_is_proper_list(sc, p));}


/* -------------------------------- make-list -------------------------------- */
static s7_pointer make_big_list(s7_scheme *sc, int32_t len, s7_pointer init)
{
  s7_pointer result;
  int32_t i;

  check_heap_size(sc, len);
  sc->v = sc->nil;
  for (i = 0; i < len; i++)
    sc->v = cons_unchecked(sc, init, sc->v);
  result = sc->v;
  sc->v = sc->nil;
  return(result);
}

static inline s7_pointer make_list(s7_scheme *sc, int32_t len, s7_pointer init)
{
  switch (len)
    {
    case 0: return(sc->nil);
    case 1: return(T_Pair(cons(sc, init, sc->nil)));
    case 2: return(T_Pair(cons_unchecked(sc, init, cons(sc, init, sc->nil))));
    case 3: return(T_Pair(cons_unchecked(sc, init, cons_unchecked(sc, init, cons(sc, init, sc->nil)))));
    case 4: return(T_Pair(cons_unchecked(sc, init, cons_unchecked(sc, init, cons_unchecked(sc, init, cons(sc, init, sc->nil))))));
    case 5: return(T_Pair(cons_unchecked(sc, init, cons_unchecked(sc, init, cons_unchecked(sc, init, cons_unchecked(sc, init, cons(sc, init, sc->nil)))))));
    case 6: return(T_Pair(cons_unchecked(sc, init, cons_unchecked(sc, init, cons_unchecked(sc, init,
                    cons_unchecked(sc, init, cons_unchecked(sc, init, cons(sc, init, sc->nil))))))));
    case 7: return(T_Pair(cons_unchecked(sc, init, cons_unchecked(sc, init, cons_unchecked(sc, init,
		    cons_unchecked(sc, init, cons_unchecked(sc, init, cons_unchecked(sc, init, cons(sc, init, sc->nil)))))))));
    default:
      return(make_big_list(sc, len, init));
    }
  return(sc->nil); /* never happens, I hope */
}

static int32_t next_tx(s7_scheme *sc)
{
  sc->t_temp_ctr++;
  sc->t_temp_ctr &= (T_TEMPS_SIZE - 1);
  return(sc->t_temp_ctr);
}

static s7_pointer protected_make_list(s7_scheme *sc, s7_int len, s7_pointer init)
{
  int32_t tx;
  s7_pointer lst;
  tx = next_tx(sc);
  lst = make_list(sc, len, init);
  sc->t_temps[tx] = lst;
  return(lst);
}

static s7_pointer g_make_list(s7_scheme *sc, s7_pointer args)
{
  #define H_make_list "(make-list length (initial-element #f)) returns a list of 'length' elements whose value is 'initial-element'."
  #define Q_make_list s7_make_signature(sc, 3, sc->is_proper_list_symbol, sc->is_integer_symbol, sc->T)

  s7_pointer init, n;
  s7_int len;

  n = car(args);
  if (!s7_is_integer(n))
    return(method_or_bust(sc, n, sc->make_list_symbol, args, T_INTEGER, 1));

  len = s7_integer(n);
#if WITH_GMP
  if ((len == 0) && (!s7_is_zero(n)))
    return(s7_out_of_range_error(sc, "make-list", 1, n, "big integer is too big for s7_int"));
#endif
  if ((len < 0) || (len > sc->max_list_length))
    return(out_of_range(sc, sc->make_list_symbol, small_int(1), n, (len < 0) ? its_negative_string : its_too_large_string));
  if (len == 0) return(sc->nil);          /* what about (make-list 0 123)? */

  if (is_pair(cdr(args)))
    init = cadr(args);
  else init = sc->F;
  return(make_list(sc, (int32_t)len, init));
}


/* -------------------------------- list-ref -------------------------------- */

static s7_pointer list_ref_1(s7_scheme *sc, s7_pointer lst, s7_pointer ind)
{
  s7_int i, index;
  s7_pointer p;

  if (!s7_is_integer(ind))
    return(method_or_bust(sc, ind, sc->list_ref_symbol, list_2(sc, lst, ind), T_INTEGER, 2));
  index = s7_integer(ind);
  if ((index < 0) || (index > sc->max_list_length))
    return(out_of_range(sc, sc->list_ref_symbol, small_int(2), ind, (index < 0) ? its_negative_string : its_too_large_string));

  for (i = 0, p = lst; (i < index) && is_pair(p); i++, p = cdr(p)) {}

  if (!is_pair(p))
    {
      if (is_null(p))
	return(out_of_range(sc, sc->list_ref_symbol, small_int(2), ind, its_too_large_string));
      return(wrong_type_argument_with_type(sc, sc->list_ref_symbol, 1, lst, a_proper_list_string));
    }
  return(car(p));
}

static s7_pointer g_list_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_list_ref "(list-ref lst i ...) returns the i-th element (0-based) of the list"
  #define Q_list_ref s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_pair_symbol, sc->is_integer_symbol)

  /* (let ((L '((1 2 3) (4 5 6)))) (list-ref L 1 2))
    (define (lref L . args)
      (if (null? (cdr args))
          (list-ref L (car args))
          (apply lref (list-ref L (car args)) (cdr args))))
  */
  s7_pointer lst, inds;

  lst = car(args);
  if (!is_pair(lst))
    return(method_or_bust(sc, lst, sc->list_ref_symbol, args, T_PAIR, 1));

  inds = cdr(args);
  while (true)
    {
      lst = list_ref_1(sc, lst, car(inds));
      if (is_null(cdr(inds)))
	return(lst);
      inds = cdr(inds);
      if (!is_pair(lst))
	return(implicit_index(sc, lst, inds)); /* 9-Jan-19 */
    }
}

static bool op_pair_a(s7_scheme *sc)
{
  s7_pointer s, x;
  s = lookup_checked(sc, car(sc->code));
  if (!is_pair(s)) {sc->last_function = s; return(false);}
  x = fx_call(sc, cdr(sc->code));
  sc->value = list_ref_1(sc, s, x);
  return(true);
}


/* -------------------------------- list-set! -------------------------------- */
static s7_pointer g_list_set_1(s7_scheme *sc, s7_pointer lst, s7_pointer args, int32_t arg_num)
{
  #define H_list_set "(list-set! lst i ... val) sets the i-th element (0-based) of the list to val"
  #define Q_list_set s7_make_circular_signature(sc, 3, 4, sc->T, sc->is_pair_symbol, sc->is_integer_symbol, sc->is_integer_or_any_at_end_symbol)

  int32_t i;
  s7_int index;
  s7_pointer p, ind;
  /* (let ((L '((1 2 3) (4 5 6)))) (list-set! L 1 2 32) L) */

  if (!is_mutable_pair(lst))
    return(mutable_method_or_bust(sc, lst, sc->list_set_symbol, cons(sc, lst, args), T_PAIR, 1));

  ind = car(args);
  if ((arg_num > 2) && (is_null(cdr(args))))
    {
      set_car(lst, ind);
      return(ind);
    }
  if (!s7_is_integer(ind))
    return(method_or_bust(sc, ind, sc->list_set_symbol, cons(sc, lst, args), T_INTEGER, 2));
  index = s7_integer(ind);
  if ((index < 0) || (index > sc->max_list_length))
    return(out_of_range(sc, sc->list_set_symbol, small_int(arg_num), ind, (index < 0) ? its_negative_string : its_too_large_string));

  for (i = 0, p = lst; (i < index) && is_pair(p); i++, p = cdr(p)) {}

  if (!is_pair(p))
    {
      if (is_null(p))
	return(out_of_range(sc, sc->list_set_symbol, small_int(arg_num), ind, its_too_large_string));
      return(wrong_type_argument_with_type(sc, sc->list_set_symbol, 1, lst, a_proper_list_string));
    }
  if (is_null(cddr(args)))
    set_car(p, cadr(args));
  else
    {
      if (!s7_is_pair(car(p)))
	return(s7_wrong_number_of_args_error(sc, "too many args for list-set!: ~S", args));
      return(g_list_set_1(sc, car(p), cdr(args), arg_num + 1));
    }
  return(cadr(args));
}

static s7_pointer g_list_set(s7_scheme *sc, s7_pointer args)
{
  return(g_list_set_1(sc, car(args), cdr(args), 2));
}

static s7_pointer list_ref_p_pi_direct(s7_scheme *sc, s7_pointer p1, s7_int i1)
{
  s7_pointer p;
  s7_int i;
  if ((i1 < 0) || (i1 > sc->max_list_length))
    out_of_range(sc, sc->list_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  for (i = 0, p = p1; ((is_pair(p)) && (i < i1)); i++, p = cdr(p));
  if (!is_pair(p))
    {
      if (type(p) == T_NIL)
	out_of_range(sc, sc->list_ref_symbol, small_int(2), wrap_integer1(sc, i1), its_too_large_string);
      else simple_wrong_type_argument_with_type(sc, sc->list_ref_symbol, p1, a_proper_list_string);
    }
  return(car(p));
}

static s7_pointer list_ref_p_pi(s7_scheme *sc, s7_pointer p1, s7_int i1)
{
  if (!is_pair(p1))
    simple_wrong_type_argument(sc, sc->list_ref_symbol, p1, T_PAIR);
  return(list_ref_p_pi_direct(sc, p1, i1));
}

static s7_pointer list_set_p_pip_direct(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2)
{
  s7_pointer p;
  s7_int i;
  if ((i1 < 0) || (i1 > sc->max_list_length))
    out_of_range(sc, sc->list_set_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  for (i = 0, p = p1; ((is_pair(p)) && (i < i1)); i++, p = cdr(p));
  if (!is_pair(p))
    {
      if (type(p) == T_NIL)
	out_of_range(sc, sc->list_set_symbol, small_int(2), wrap_integer1(sc, i1), its_too_large_string);
      else simple_wrong_type_argument_with_type(sc, sc->list_set_symbol, p1, a_proper_list_string);
    }
  set_car(p, p2);
  return(p2);
}

static s7_pointer list_set_p_pip(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2)
{
  if (!is_pair(p1))
    simple_wrong_type_argument(sc, sc->list_set_symbol, p1, T_PAIR);
  return(list_set_p_pip_direct(sc, p1, i1, p2));
}

static s7_pointer g_list_set_ic(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p, lst, val;
  s7_int i, index;
  lst = car(args);
  if (!is_mutable_pair(lst))
    return(mutable_method_or_bust(sc, lst, sc->list_set_symbol, args, T_PAIR, 1));

  index = s7_integer(cadr(args));
  if ((index < 0) || (index > sc->max_list_length))
    return(out_of_range(sc, sc->list_set_symbol, small_int(2), wrap_integer1(sc, index), (index < 0) ? its_negative_string : its_too_large_string));

  for (i = 0, p = lst; (i < index) && is_pair(p); i++, p = cdr(p)) {}
  if (!is_pair(p))
    {
      if (is_null(p))
	return(out_of_range(sc, sc->list_set_symbol, small_int(2), wrap_integer1(sc, index), its_too_large_string));
      return(wrong_type_argument_with_type(sc, sc->list_set_symbol, 1, lst, a_proper_list_string));
    }

  val = caddr(args);
  set_car(p, val);
  return(val);
}


/* -------------------------------- list-tail -------------------------------- */

static s7_pointer g_list_tail(s7_scheme *sc, s7_pointer args)
{
  #define H_list_tail "(list-tail lst i) returns the list from the i-th element on"
  #define Q_list_tail s7_make_signature(sc, 3, sc->T, sc->is_pair_symbol, sc->is_integer_symbol) /* #t: (list-tail '(1 . 2) 1) -> 2 */
  s7_pointer lst, p;
  s7_int i, index;

  lst = car(args);
  p = cadr(args);
  if (!s7_is_integer(p))
    return(method_or_bust(sc, p, sc->list_tail_symbol, args, T_INTEGER, 2));
  index = s7_integer(p);

  if (!is_list(lst))
    return(method_or_bust_with_type(sc, lst, sc->list_tail_symbol, list_2(sc, lst, make_integer(sc, index)), a_list_string, 1));

  if ((index < 0) || (index > sc->max_list_length))
    return(out_of_range(sc, sc->list_tail_symbol, small_int(2), wrap_integer1(sc, index), (index < 0) ? its_negative_string : its_too_large_string));

  for (i = 0, p = lst; (i < index) && (is_pair(p)); i++, p = cdr(p)) {}
  if (i < index)
    return(out_of_range(sc, sc->list_tail_symbol, small_int(2), wrap_integer1(sc, index), its_too_large_string));
  return(p);
}


/* -------------------------------- cons -------------------------------- */
static s7_pointer g_cons(s7_scheme *sc, s7_pointer args)
{
  #define H_cons "(cons a b) returns a pair containing a and b"
  #define Q_cons s7_make_signature(sc, 3, sc->is_pair_symbol, sc->T, sc->T)

  /* set_cdr(args, cadr(args));
   * this is not safe -- it changes a variable's value directly:
   *   (let ((lst (list 1 2))) (list (apply cons lst) lst)) -> '((1 . 2) (1 . 2))
   */
  s7_pointer x;
  new_cell(sc, x, T_PAIR | T_SAFE_PROCEDURE);
  set_car(x, car(args));
  set_cdr(x, cadr(args));
  return(x);
}

static s7_pointer cons_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  s7_pointer x;
  new_cell(sc, x, T_PAIR | T_SAFE_PROCEDURE);
  set_car(x, p1);
  set_cdr(x, p2);
  return(x);
}


/* -------- car -------- */

static s7_pointer g_car(s7_scheme *sc, s7_pointer args)
{
  #define H_car "(car pair) returns the first element of the pair"
  #define Q_car sc->pl_p

  s7_pointer lst;
  lst = car(args);
  if (is_pair(lst))
    return(car(lst));
  return(method_or_bust_one_arg(sc, lst, sc->car_symbol, args, T_PAIR));
}

static s7_pointer car_p_p(s7_scheme *sc, s7_pointer p)
{
  if (is_pair(p))
    return(car(p));
  return(simple_wrong_type_argument(sc, sc->car_symbol, p, T_PAIR));
}


static s7_pointer g_set_car(s7_scheme *sc, s7_pointer args)
{
  #define H_set_car "(set-car! pair val) sets the pair's first element to val"
  #define Q_set_car s7_make_signature(sc, 3, sc->T, sc->is_pair_symbol, sc->T)
  s7_pointer p;

  p = car(args);
  if (!is_mutable_pair(p)) /* this is currently 2.5x slower than is_pair */
    return(mutable_method_or_bust(sc, p, sc->set_car_symbol, args, T_PAIR, 1));
  set_car(p, cadr(args));
  return(car(p));
}

static s7_pointer set_car_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  if (!is_mutable_pair(p1))
    simple_wrong_type_argument(sc, sc->set_car_symbol, p1, T_PAIR);
  set_car(p1, p2);
  return(p2);
}


/* -------- cdr -------- */
static s7_pointer g_cdr(s7_scheme *sc, s7_pointer args)
{
  #define H_cdr "(cdr pair) returns the second element of the pair"
  #define Q_cdr sc->pl_p

  s7_pointer lst;
  lst = car(args);
  if (is_pair(lst))
    return(cdr(lst));
  return(method_or_bust_one_arg(sc, lst, sc->cdr_symbol, args, T_PAIR));
}

static s7_pointer cdr_p_p(s7_scheme *sc, s7_pointer p)
{
  if (is_pair(p))
    return(cdr(p));
  return(simple_wrong_type_argument(sc, sc->cdr_symbol, p, T_PAIR));
}


static s7_pointer g_set_cdr(s7_scheme *sc, s7_pointer args)
{
  #define H_set_cdr "(set-cdr! pair val) sets the pair's second element to val"
  #define Q_set_cdr s7_make_signature(sc, 3, sc->T, sc->is_pair_symbol, sc->T)
  s7_pointer p;

  p = car(args);
  if (!is_mutable_pair(p))
    return(mutable_method_or_bust(sc, p, sc->set_cdr_symbol, args, T_PAIR, 1));

  set_cdr(p, cadr(args));
  return(cdr(p));
}

static s7_pointer set_cdr_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  if (!is_mutable_pair(p1))
    simple_wrong_type_argument(sc, sc->set_cdr_symbol, p1, T_PAIR);
  set_cdr(p1, p2);
  return(p2);
}


/* -------- caar --------*/
static s7_pointer g_caar(s7_scheme *sc, s7_pointer args)
{
  #define H_caar "(caar lst) returns (car (car lst)): (caar '((1 2))) -> 1"
  #define Q_caar sc->pl_p

  s7_pointer lst;
  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caar_symbol, lst, car_a_list_string));
  /* it makes no difference in timing to move lst here or below (i.e. lst=car(lst) then return(car(lst)) and so on) */
  return(caar(lst));
}

static s7_pointer caar_p_p(s7_scheme *sc, s7_pointer p)
{
  if ((is_pair(p)) &&
      (is_pair(car(p))))
    return(caar(p));
  return(simple_wrong_type_argument(sc, sc->caar_symbol, p, T_PAIR));
}


/* -------- cadr --------*/
static s7_pointer g_cadr(s7_scheme *sc, s7_pointer args)
{
  #define H_cadr "(cadr lst) returns (car (cdr lst)): (cadr '(1 2 3)) -> 2"
  #define Q_cadr sc->pl_p

  s7_pointer lst;
  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cadr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadr_symbol, lst, cdr_a_list_string));
  return(cadr(lst));
}

static s7_pointer cadr_p_p(s7_scheme *sc, s7_pointer p)
{
  if ((is_pair(p)) &&
      (is_pair(cdr(p))))
    return(cadr(p));
  return(simple_wrong_type_argument(sc, sc->cadr_symbol, p, T_PAIR));
}


/* -------- cdar -------- */
static s7_pointer g_cdar(s7_scheme *sc, s7_pointer args)
{
  #define H_cdar "(cdar lst) returns (cdr (car lst)): (cdar '((1 2 3))) -> '(2 3)"
  #define Q_cdar sc->pl_p

  s7_pointer lst;
  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdar_symbol, lst, car_a_list_string));
  return(cdar(lst));
}

static s7_pointer cdar_p_p(s7_scheme *sc, s7_pointer p)
{
  if ((is_pair(p)) &&
      (is_pair(car(p))))
    return(cdar(p));
  return(simple_wrong_type_argument(sc, sc->cdar_symbol, p, T_PAIR));
}


/* -------- cddr -------- */
static s7_pointer g_cddr(s7_scheme *sc, s7_pointer args)
{
  #define H_cddr "(cddr lst) returns (cdr (cdr lst)): (cddr '(1 2 3 4)) -> '(3 4)"
  #define Q_cddr sc->pl_p

  s7_pointer lst;
  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cddr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddr_symbol, lst, cdr_a_list_string));
  return(cddr(lst));
}

static s7_pointer cddr_p_p(s7_scheme *sc, s7_pointer p)
{
  if ((is_pair(p)) &&
      (is_pair(cdr(p))))
    return(cddr(p));
  return(simple_wrong_type_argument(sc, sc->cddr_symbol, p, T_PAIR));
}

/* -------- caaar -------- */
static s7_pointer g_caaar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caaar "(caaar lst) returns (car (car (car lst))): (caaar '(((1 2)))) -> 1"
  #define Q_caaar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caaar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaar_symbol, lst, car_a_list_string));
  if (!is_pair(caar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaar_symbol, lst, caar_a_list_string));
  return(caaar(lst));
}

/* -------- caadr -------- */
static s7_pointer g_caadr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caadr "(caadr lst) returns (car (car (cdr lst))): (caadr '(1 (2 3))) -> 2"
  #define Q_caadr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caadr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caadr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caadr_symbol, lst, cadr_a_list_string));
  return(caadr(lst));
}

/* -------- cadar -------- */
static s7_pointer g_cadar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cadar "(cadar lst) returns (car (cdr (car lst))): (cadar '((1 2 3))) -> 2"
  #define Q_cadar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cadar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadar_symbol, lst, car_a_list_string));
  if (!is_pair(cdar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadar_symbol, lst, cdar_a_list_string));
  return(cadar(lst));
}

/* -------- cdaar -------- */
static s7_pointer g_cdaar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdaar "(cdaar lst) returns (cdr (car (car lst))): (cdaar '(((1 2 3)))) -> '(2 3)"
  #define Q_cdaar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdaar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaar_symbol, lst, car_a_list_string));
  if (!is_pair(caar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaar_symbol, lst, caar_a_list_string));
  return(cdaar(lst));
}

/* -------- caddr -------- */
static s7_pointer g_caddr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caddr "(caddr lst) returns (car (cdr (cdr lst))): (caddr '(1 2 3 4)) -> 3"
  #define Q_caddr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caddr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caddr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caddr_symbol, lst, cddr_a_list_string));
  return(caddr(lst));
}

static s7_pointer caddr_p_p(s7_scheme *sc, s7_pointer p)
{
  if ((is_pair(p)) &&
      (is_pair(cdr(p))) &&
      (is_pair(cddr(p))))
    return(caddr(p));
  return(simple_wrong_type_argument(sc, sc->caddr_symbol, p, T_PAIR));
}

/* -------- cdddr -------- */
static s7_pointer g_cdddr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdddr "(cdddr lst) returns (cdr (cdr (cdr lst))): (cdddr '(1 2 3 4)) -> '(4)"
  #define Q_cdddr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdddr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdddr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdddr_symbol, lst, cddr_a_list_string));
  return(cdddr(lst));
}

/* -------- cdadr -------- */
static s7_pointer g_cdadr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdadr "(cdadr lst) returns (cdr (car (cdr lst))): (cdadr '(1 (2 3 4))) -> '(3 4)"
  #define Q_cdadr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdadr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdadr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdadr_symbol, lst, cadr_a_list_string));
  return(cdadr(lst));
}

/* -------- cddar -------- */
static s7_pointer g_cddar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cddar "(cddar lst) returns (cdr (cdr (car lst))): (cddar '((1 2 3 4))) -> '(3 4)"
  #define Q_cddar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cddar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddar_symbol, lst, car_a_list_string));
  if (!is_pair(cdar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddar_symbol, lst, cdar_a_list_string));
  return(cddar(lst));
}

/* -------- caaaar -------- */
static s7_pointer g_caaaar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caaaar "(caaaar lst) returns (car (car (car (car lst)))): (caaaar '((((1 2))))) -> 1"
  #define Q_caaaar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caaaar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaaar_symbol, lst, car_a_list_string));
  if (!is_pair(caar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaaar_symbol, lst, caar_a_list_string));
  if (!is_pair(caaar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaaar_symbol, lst, caaar_a_list_string));
  return(caaaar(lst));
}

/* -------- caaadr -------- */
static s7_pointer g_caaadr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caaadr "(caaadr lst) returns (car (car (car (cdr lst)))): (caaadr '(1 ((2 3)))) -> 2"
  #define Q_caaadr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caaadr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaadr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaadr_symbol, lst, cadr_a_list_string));
  if (!is_pair(caadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaadr_symbol, lst, caadr_a_list_string));
  return(caaadr(lst));
}

/* -------- caadar -------- */
static s7_pointer g_caadar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caadar "(caadar lst) returns (car (car (cdr (car lst)))): (caadar '((1 (2 3)))) -> 2"
  #define Q_caadar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caadar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caadar_symbol, lst, car_a_list_string));
  if (!is_pair(cdar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caadar_symbol, lst, cdar_a_list_string));
  if (!is_pair(cadar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caadar_symbol, lst, cadar_a_list_string));
  return(caadar(lst));
}

/* -------- cadaar -------- */
static s7_pointer g_cadaar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cadaar "(cadaar lst) returns (car (cdr (car (car lst)))): (cadaar '(((1 2 3)))) -> 2"
  #define Q_cadaar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cadaar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadaar_symbol, lst, car_a_list_string));
  if (!is_pair(caar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadaar_symbol, lst, caar_a_list_string));
  if (!is_pair(cdaar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadaar_symbol, lst, cdaar_a_list_string));
  return(cadaar(lst));
}

/* -------- caaddr -------- */
static s7_pointer g_caaddr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caaddr "(caaddr lst) returns (car (car (cdr (cdr lst)))): (caaddr '(1 2 (3 4))) -> 3"
  #define Q_caaddr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caaddr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaddr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaddr_symbol, lst, cddr_a_list_string));
  if (!is_pair(caddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caaddr_symbol, lst, caddr_a_list_string));
  return(caaddr(lst));
}

/* -------- cadddr -------- */
static s7_pointer g_cadddr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cadddr "(cadddr lst) returns (car (cdr (cdr (cdr lst)))): (cadddr '(1 2 3 4 5)) -> 4"
  #define Q_cadddr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cadddr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadddr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadddr_symbol, lst, cddr_a_list_string));
  if (!is_pair(cdddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadddr_symbol, lst, cdddr_a_list_string));
  return(cadddr(lst));
}

/* -------- cadadr -------- */
static s7_pointer g_cadadr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cadadr "(cadadr lst) returns (car (cdr (car (cdr lst)))): (cadadr '(1 (2 3 4))) -> 3"
  #define Q_cadadr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cadadr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadadr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadadr_symbol, lst, cadr_a_list_string));
  if (!is_pair(cdadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cadadr_symbol, lst, cdadr_a_list_string));
  return(cadadr(lst));
}

/* -------- caddar -------- */
static s7_pointer g_caddar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_caddar "(caddar lst) returns (car (cdr (cdr (car lst)))): (caddar '((1 2 3 4))) -> 3"
  #define Q_caddar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->caddar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caddar_symbol, lst, car_a_list_string));
  if (!is_pair(cdar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caddar_symbol, lst, cdar_a_list_string));
  if (!is_pair(cddar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->caddar_symbol, lst, cddar_a_list_string));
  return(caddar(lst));
}

/* -------- cdaaar -------- */
static s7_pointer g_cdaaar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdaaar "(cdaaar lst) returns (cdr (car (car (car lst)))): (cdaaar '((((1 2 3))))) -> '(2 3)"
  #define Q_cdaaar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdaaar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaaar_symbol, lst, car_a_list_string));
  if (!is_pair(caar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaaar_symbol, lst, caar_a_list_string));
  if (!is_pair(caaar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaaar_symbol, lst, caaar_a_list_string));
  return(cdaaar(lst));
}

/* -------- cdaadr -------- */
static s7_pointer g_cdaadr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdaadr "(cdaadr lst) returns (cdr (car (car (cdr lst)))): (cdaadr '(1 ((2 3 4)))) -> '(3 4)"
  #define Q_cdaadr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdaadr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaadr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaadr_symbol, lst, cadr_a_list_string));
  if (!is_pair(caadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaadr_symbol, lst, caadr_a_list_string));
  return(cdaadr(lst));
}

/* -------- cdadar -------- */
static s7_pointer g_cdadar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdadar "(cdadar lst) returns (cdr (car (cdr (car lst)))): (cdadar '((1 (2 3 4)))) -> '(3 4)"
  #define Q_cdadar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdadar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdadar_symbol, lst, car_a_list_string));
  if (!is_pair(cdar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdadar_symbol, lst, cdar_a_list_string));
  if (!is_pair(cadar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdadar_symbol, lst, cadar_a_list_string));
  return(cdadar(lst));
}

/* -------- cddaar -------- */
static s7_pointer g_cddaar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cddaar "(cddaar lst) returns (cdr (cdr (car (car lst)))): (cddaar '(((1 2 3 4)))) -> '(3 4)"
  #define Q_cddaar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cddaar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddaar_symbol, lst, car_a_list_string));
  if (!is_pair(caar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddaar_symbol, lst, caar_a_list_string));
  if (!is_pair(cdaar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddaar_symbol, lst, cdaar_a_list_string));
  return(cddaar(lst));
}

/* -------- cdaddr -------- */
static s7_pointer g_cdaddr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdaddr "(cdaddr lst) returns (cdr (car (cdr (cdr lst)))): (cdaddr '(1 2 (3 4 5))) -> '(4 5)"
  #define Q_cdaddr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdaddr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaddr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaddr_symbol, lst, cddr_a_list_string));
  if (!is_pair(caddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdaddr_symbol, lst, caddr_a_list_string));
  return(cdaddr(lst));
}

/* -------- cddddr -------- */
static s7_pointer g_cddddr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cddddr "(cddddr lst) returns (cdr (cdr (cdr (cdr lst)))): (cddddr '(1 2 3 4 5)) -> '(5)"
  #define Q_cddddr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cddddr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddddr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddddr_symbol, lst, cddr_a_list_string));
  if (!is_pair(cdddr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddddr_symbol, lst, cdddr_a_list_string));
  return(cddddr(lst));
}

/* -------- cddadr -------- */
static s7_pointer g_cddadr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cddadr "(cddadr lst) returns (cdr (cdr (car (cdr lst)))): (cddadr '(1 (2 3 4 5))) -> '(4 5)"
  #define Q_cddadr sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cddadr_symbol, args, T_PAIR));
  if (!is_pair(cdr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddadr_symbol, lst, cdr_a_list_string));
  if (!is_pair(cadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddadr_symbol, lst, cadr_a_list_string));
  if (!is_pair(cdadr(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cddadr_symbol, lst, cdadr_a_list_string));
  return(cddadr(lst));
}

/* -------- cdddar -------- */
static s7_pointer g_cdddar(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  #define H_cdddar "(cdddar lst) returns (cdr (cdr (cdr (car lst)))): (cdddar '((1 2 3 4 5))) -> '(4 5)"
  #define Q_cdddar sc->pl_p

  lst = car(args);
  if (!is_pair(lst)) return(method_or_bust_one_arg(sc, lst, sc->cdddar_symbol, args, T_PAIR));
  if (!is_pair(car(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdddar_symbol, lst, car_a_list_string));
  if (!is_pair(cdar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdddar_symbol, lst, cdar_a_list_string));
  if (!is_pair(cddar(lst))) return(simple_wrong_type_argument_with_type(sc, sc->cdddar_symbol, lst, cddar_a_list_string));
  return(cdddar(lst));
}


/* -------------------------------- assoc assv assq -------------------------------- */
s7_pointer s7_assq(s7_scheme *sc, s7_pointer obj, s7_pointer x)
{
  s7_pointer y;
  y = x;
  while (true)
    {
      /* we can blithely take the car of anything, since we're not treating it as an object,
       *   then if we get a bogus match, the following check that caar made sense ought to catch it.
       * if car(#<unspecified>) = #<unspecified> (initialization time), then cdr(nil)->unspec
       *   and subsequent caar(unspec)->unspec so we could forgo half the is_pair checks below.
       *   This breaks if "x" is a dotted list -- the last cdr is not nil, so we lose.
       */
      LOOP_8(if ((obj == unchecked_car(car(x))) && (is_pair(car(x)))) return(car(x)); x = cdr(x); if (!is_pair(x)) return(sc->F));

      y = cdr(y);
      if (x == y) return(sc->F);
    }
  return(sc->F); /* not reached */
}

static s7_pointer assq_p_pp(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  if (is_pair(y)) return(s7_assq(sc, x, y));
  if (is_null(y)) return(sc->F);
  return(method_or_bust_with_type(sc, y, sc->assq_symbol, list_2(sc, x, y), an_association_list_string, 2));
}

static s7_pointer g_assq(s7_scheme *sc, s7_pointer args)
{
  #define H_assq "(assq obj alist) returns the key-value pair associated (via eq?) with the key obj in the association list alist"
  #define Q_assq s7_make_signature(sc, 3, s7_make_signature(sc, 2, sc->is_pair_symbol, sc->not_symbol), sc->T, sc->is_list_symbol)

  return(assq_p_pp(sc, car(args), cadr(args)));
  /* we don't check for (pair? (car x)) here (or in assv) so we get some inconsistency with assoc:
   *  (assq #f '(#f 2 . 3)) -> #f
   *  (assoc #f '(#f 2 . 3)) -> 'error
   */
}

static s7_pointer g_assv(s7_scheme *sc, s7_pointer args)        /* g_assv is called by g_assoc below */
{
  s7_pointer x, y, z;
  #define H_assv "(assv obj alist) returns the key-value pair associated (via eqv?) with the key obj in the association list alist"
  #define Q_assv Q_assq

  x = car(args);
  y = cadr(args);
  if (!is_pair(y))
    {
      if (is_null(y)) return(sc->F);
      return(method_or_bust_with_type(sc, y, sc->assv_symbol, list_2(sc, x, y), an_association_list_string, 2));
    }

  if (is_simple(x))
    return(s7_assq(sc, x, y));

  z = y;
  while (true)
    {
      /* here we can't play the assq == game because s7_is_eqv thinks it's getting a legit s7 object */
      if ((is_pair(car(y))) && (s7_is_eqv(x, caar(y)))) return(car(y));
      y = cdr(y);
      if (!is_pair(y)) return(sc->F);

      if ((is_pair(car(y))) && (s7_is_eqv(x, caar(y)))) return(car(y));
      y = cdr(y);
      if (!is_pair(y)) return(sc->F);

      z = cdr(z);
      if (z == y) return(sc->F);
    }
  return(sc->F); /* not reached */
}

static s7_pointer g_is_eq(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_eqv(s7_scheme *sc, s7_pointer args);
static s7_function s7_bool_optimize(s7_scheme *sc, s7_pointer expr);
static s7_pointer opt_bool_any(s7_scheme *sc, s7_pointer expr);

static s7_pointer g_assoc(s7_scheme *sc, s7_pointer args)
{
  #define H_assoc "(assoc obj alist (func #f)) returns the key-value pair associated (via equal?) with the key obj in the association list alist.\
If 'func' is a function of 2 arguments, it is used for the comparison instead of 'equal?"
  #define Q_assoc s7_make_signature(sc, 4, s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_boolean_symbol), sc->T, sc->is_list_symbol, sc->is_procedure_symbol)

  s7_pointer x, y, obj, eq_func = NULL;

  x = cadr(args);
  if (!is_null(x))
    {
      if (!is_pair(x))
	return(method_or_bust_with_type(sc, x, sc->assoc_symbol, args, an_association_list_string, 2));

      if ((is_pair(x)) && (!is_pair(car(x))))
	return(wrong_type_argument_with_type(sc, sc->assoc_symbol, 2, x, an_association_list_string)); /* we're assuming caar below so it better exist */
    }

  if (is_not_null(cddr(args)))
    {
      /* check third arg before second (trailing arg error check) */
      eq_func = caddr(args);

      if (type(eq_func) < T_CONTINUATION)
	return(method_or_bust_with_type_one_arg(sc, eq_func, sc->assoc_symbol, args, a_procedure_string));

      if (!s7_is_aritable(sc, eq_func, 2))
	return(wrong_type_argument_with_type(sc, sc->assoc_symbol, 3, eq_func, an_eq_func_string));
    }
  if (is_null(x)) return(sc->F);

  if (eq_func)
    {
      /* here we know x is a pair, but need to protect against circular lists */
      if (s7_list_length(sc, x) != 0)
	{
	  /* now maybe there's a simple case */
	  if ((is_safe_procedure(eq_func)) &&
	      (is_c_function(eq_func)))
	    {
	      s7_function func;

	      func = c_function_call(eq_func);
	      if (func == g_is_eq) return(s7_assq(sc, car(args), x));
	      if (func == g_is_eqv) return(g_assv(sc, args));
	      set_car(sc->t2_1, car(args));

	      for (; is_pair(x); x = cdr(x))
		{
		  if (!is_pair(car(x)))
		    return(wrong_type_argument_with_type(sc, sc->assoc_symbol, 2, cadr(args), an_association_list_string));
		  set_car(sc->t2_2, caar(x));
		  if (is_true(sc, func(sc, sc->t2_1)))
		    return(car(x));
		  /* I wonder if the assoc equality function should get the cons, not just caar? */
		}
	      return(sc->F);
	    }

	  if ((is_closure(eq_func)) &&
	      (is_pair(closure_args(eq_func))) &&
	      (is_pair(cdr(closure_args(eq_func))))) /* not dotted arg list */
	    {
	      s7_pointer body;
	      body = closure_body(eq_func);
	      if (is_null(cdr(body)))
		{
		  s7_function func;

		  new_frame_with_two_slots(sc, sc->envir, sc->envir, car(closure_args(eq_func)), car(args), cadr(closure_args(eq_func)), sc->F);
		  func = s7_bool_optimize(sc, body);
		  if (func)
		    {
		      s7_pointer b;
		      b = next_slot(let_slots(sc->envir));

		      if (func == opt_bool_any)
			{
			  opt_info *o;
			  o = sc->opts[0];
			  for (; is_pair(x); x = cdr(x))
			    {
			      slot_set_value(b, caar(x));
			      sc->pc = 0;
			      if (o->v[0].fb(o))
				return(car(x));
			    }
			  return(sc->F);
			}
		    }
		}
	    }
	}

      /* member_if is similar.  Do not call eval here with op_eval_done to return!  An error will longjmp past the
       *   assoc point, leaving the op_eval_done on the stack, causing s7 to quit.
       */
      y = cons(sc, args, sc->nil);
      set_opt1_fast(y, x);
      set_opt2_slow(y, x);
      push_stack(sc, OP_ASSOC_IF, cons(sc, y, sc->nil), eq_func);
      if (needs_copied_args(eq_func))
	push_stack(sc, OP_APPLY, list_2(sc, car(args), caar(x)), eq_func);
      else
	{
	  set_car(sc->t2_1, car(args));
	  set_car(sc->t2_2, caar(x));
	  push_stack(sc, OP_APPLY, sc->t2_1, eq_func);
	}
      return(sc->unspecified);
    }

  x = cadr(args);
  obj = car(args);
  if (is_simple(obj))
    return(s7_assq(sc, obj, x));

  y = x;
  if (is_string(obj))
    {
      s7_pointer val;
      while (true)
	{
	  if (is_pair(car(x)))
	    {
	      val = caar(x);
	      if ((val == obj) ||
		  ((is_string(val)) &&
		   (scheme_strings_are_equal(obj, val))))
		return(car(x));
	    }
	  x = cdr(x);
	  if (!is_pair(x)) return(sc->F);

	  if (is_pair(car(x)))
	    {
	      val = caar(x);
	      if ((val == obj) ||
		  ((is_string(val)) &&
		   (scheme_strings_are_equal(obj, val))))
		return(car(x));
	    }
	  x = cdr(x);
	  if (!is_pair(x)) return(sc->F);

	  y = cdr(y);
	  if (x == y) return(sc->F);
	}
      return(sc->F);
    }

  while (true)
    {
      if ((is_pair(car(x))) && (s7_is_equal(sc, obj, caar(x)))) return(car(x));
      x = cdr(x);
      if (!is_pair(x)) return(sc->F);

      if ((is_pair(car(x))) && (s7_is_equal(sc, obj, caar(x)))) return(car(x));
      x = cdr(x);
      if (!is_pair(x)) return(sc->F);

      y = cdr(y);
      if (x == y) return(sc->F);
    }
  return(sc->F); /* not reached */
}

static s7_pointer assoc_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(g_assoc(sc, set_plist_2(sc, p1, p2)));}

static bool assoc_if(s7_scheme *sc)
{
  s7_pointer orig_args;
  orig_args = car(sc->args);
  /* code=func, args=(list (list args)) with f/opt1_fast=list, value=result of comparison
   *   (assoc 3 '((1 . a) (2 . b) (3 . c) (4 . d)) =)
   */
  if (sc->value != sc->F)            /* previous comparison was not #f -- return (car list) */
    {
      sc->value = car(opt1_fast(orig_args));
      return(true);
    }
  if (!is_pair(cdr(opt1_fast(orig_args))))             /* (assoc 3 '((1 . 2) . 3) =) or nil */
    {
      sc->value = sc->F;
      return(true);
    }
  set_opt1_fast(orig_args, cdr(opt1_fast(orig_args)));  /* cdr down arg list */

  if (sc->cur_op == OP_ASSOC_IF1)
    {
      /* circular list check */
      if (opt1_fast(orig_args) == opt2_slow(orig_args))
	{
	  sc->value = sc->F;
	  return(true);
	}
      set_opt2_slow(orig_args, cdr(opt2_slow(orig_args))); /* cdr down the slow list */
      push_stack(sc, OP_ASSOC_IF, sc->args, sc->code);
    }
  else push_stack(sc, OP_ASSOC_IF1, sc->args, sc->code);

  if (!is_pair(car(opt1_fast(orig_args))))     /* (assoc 1 '((2 . 2) 3) =) -- we access caaadr below */
    eval_type_error(sc, "assoc: second arg is not an alist: ~S", 37, orig_args);
  /* not sure about this -- we could simply skip the entry both here and in g_assoc
   *   (assoc 1 '((2 . 2) 3)) -> #f
   *   (assoc 1 '((2 . 2) 3) =) -> error currently
   */
  if (needs_copied_args(sc->code))
    sc->args = list_2(sc, caar(orig_args), caar(opt1_fast(orig_args)));
  else sc->args = set_plist_2(sc, caar(orig_args), caar(opt1_fast(orig_args)));
  return(false);
}


/* ---------------- member, memv, memq ---------------- */

s7_pointer s7_memq(s7_scheme *sc, s7_pointer obj, s7_pointer x)
{
  s7_pointer y;
  y = x;
  while (true)
    {
      LOOP_4(if (obj == car(x)) return(x); x = cdr(x); if (!is_pair(x)) return(sc->F));
      y = cdr(y);
      if (x == y) return(sc->F);
    }
  return(sc->F);
}

static s7_pointer g_memq(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, y;
  #define H_memq "(memq obj list) looks for obj in list and returns the list from that point if it is found, otherwise #f. memq uses eq?"
  #define Q_memq sc->pl_tl

  x = car(args);
  y = cadr(args);
  if (is_pair(y))
    return(s7_memq(sc, x, y));
  if (is_null(y))
    return(sc->F);
  return(method_or_bust_with_type(sc, y, sc->memq_symbol, list_2(sc, x, y), a_list_string, 2));
}

/* I think (memq 'c '(a b . c)) should return #f because otherwise (memq () ...) would return the () at the end. */
/* if memq's list is a quoted list, it won't be changing, so we can tell ahead of time that it is a proper list, and what its length is. */

static s7_pointer g_memq_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, obj;
  x = cadr(args);
  obj = car(args);
  if (obj == car(x)) return(x);
  if (obj == cadr(x)) return(cdr(x));
  return(sc->F);
}

static s7_pointer g_memq_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, obj;
  x = cadr(args);
  obj = car(args);
  while (true)
    {
      if (obj == car(x)) return(x);
      x = cdr(x);
      if (obj == car(x)) return(x);
      x = cdr(x);
      if (obj == car(x)) return(x);
      x = cdr(x);
      if (!is_pair(x)) return(sc->F);
    }
  return(sc->F);
}

static s7_pointer g_memq_4(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, obj;
  x = cadr(args);
  obj = car(args);
  while (true)
    {
      LOOP_4(if (obj == car(x)) return(x); x = cdr(x));
      if (!is_pair(x)) return(sc->F);
    }
  return(sc->F);
}

static s7_pointer g_memq_any(s7_scheme *sc, s7_pointer args)
{
  /* no circular list check needed in this case */
  s7_pointer x, obj;
  x = cadr(args);
  obj = car(args);
  while (true)
    {
      LOOP_4(if (obj == car(x)) return(x); x = cdr(x); if (!is_pair(x)) return(sc->F));
    }
  return(sc->F);
}

static s7_pointer g_memq_car(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, obj;

  obj = lookup(sc, opt2_sym(args));
  if (is_pair(obj))
    obj = car(obj);
  else obj = g_car(sc, set_plist_1(sc, obj));
  x = opt3_pair(args);

  while (true)
    {
      LOOP_4(if (obj == car(x)) return(x); x = cdr(x); if (!is_pair(x)) return(sc->F));
    }
  return(sc->F);
}

static s7_pointer g_memq_car_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x, obj;

  obj = lookup(sc, opt2_sym(args));
  if (is_pair(obj))
    obj = car(obj);
  else obj = g_car(sc, set_plist_1(sc, obj));
  x = opt3_pair(args);
  if (obj == car(x)) return(x);
  if (obj == cadr(x)) return(cdr(x));
  return(sc->F);
}

static s7_pointer memq_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if ((is_proper_quote(sc, caddr(expr))) &&
      (is_pair(cadr(caddr(expr)))))
    {
      s7_int len;
      len = s7_list_length(sc, cadr(caddr(expr)));

      if ((ops) && (is_h_safe_c_s(cadr(expr))) &&
	  (c_callee(cadr(expr)) == g_car))
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  set_opt2_sym(cdr(expr), cadadr(expr));
	  set_opt3_pair(cdr(expr), cadr(caddr(expr)));
	  if (len == 2)
	    return(sc->memq_car_2);
	  return(sc->memq_car);
	}

      if (len > 0)
	{
	  if (len == 2)
	    return(sc->memq_2);
	  if ((len % 4) == 0)
	    return(sc->memq_4);
	  if ((len % 3) == 0)
	    return(sc->memq_3);
	  return(sc->memq_any);
	}
    }
  return(f);
}

static bool numbers_are_eqv(s7_pointer a, s7_pointer b)
{
  if (type(a) != type(b)) /* (eqv? 1 1.0) -> #f! */
    return(false);

  switch (type(a))
    {
    case T_INTEGER:
      return((integer(a) == integer(b)));

    case T_RATIO:
      return((numerator(a) == numerator(b)) &&
	     (denominator(a) == denominator(b)));

    case T_REAL:
      if (is_NaN(real(a)))
	return(false);
      return(real(a) == real(b));

    case T_COMPLEX:
      if ((is_NaN(real_part(a))) ||
	  (is_NaN(imag_part(a))))
	return(false);
      return((real_part(a) == real_part(b)) &&
	     (imag_part(a) == imag_part(b)));

    default:
#if WITH_GMP
      if ((is_big_number(a)) || (is_big_number(b))) /* this can happen if (member bignum ...) -> memv */
	return(big_numbers_are_eqv(a, b));
#endif
      break;
    }
  return(false);
}

static s7_pointer memv_number(s7_scheme *sc, s7_pointer obj, s7_pointer x)
{
  s7_pointer y;
  y = x;
  while (true)
    {
      LOOP_4(if ((s7_is_number(car(x))) && (numbers_are_eqv(obj, car(x)))) return(x); x = cdr(x); if (!is_pair(x)) return(sc->F));
      y = cdr(y);
      if (x == y) return(sc->F);
    }
  return(sc->F);
}

static s7_pointer g_memv(s7_scheme *sc, s7_pointer args)
{
  #define H_memv "(memv obj list) looks for obj in list and returns the list from that point if it is found, otherwise #f. memv uses eqv?"
  #define Q_memv sc->pl_tl
  s7_pointer x, y, z;

  x = car(args);
  y = cadr(args);
  if (!is_pair(y))
    {
      if (is_null(y)) return(sc->F);
      return(method_or_bust_with_type(sc, y, sc->memv_symbol, list_2(sc, x, y), a_list_string, 2));
    }

  if (is_simple(x)) return(s7_memq(sc, x, y));
  if (s7_is_number(x)) return(memv_number(sc, x, y));

  z = y;
  while (true)
    {
      if (s7_is_eqv(x, car(y))) return(y);
      y = cdr(y);
      if (!is_pair(y)) return(sc->F);

      if (s7_is_eqv(x, car(y))) return(y);
      y = cdr(y);
      if (!is_pair(y)) return(sc->F);

      z = cdr(z);
      if (z == y) return(sc->F);
    }
  return(sc->F); /* not reached */
}

static s7_pointer member(s7_scheme *sc, s7_pointer obj, s7_pointer x)
{
  s7_pointer y;

  y = x;
  if (is_string(obj))
    {
      while (true)
	{
	  if ((obj == car(x)) ||
	      ((is_string(car(x))) &&
	       (scheme_strings_are_equal(obj, car(x)))))
	    return(x);
	  x = cdr(x);
	  if (!is_pair(x)) return(sc->F);

	  if ((obj == car(x)) ||
	      ((is_string(car(x))) &&
	       (scheme_strings_are_equal(obj, car(x)))))
	    return(x);
	  x = cdr(x);
	  if (!is_pair(x)) return(sc->F);

	  y = cdr(y);
	  if (x == y) return(sc->F);
	}
      return(sc->F);
    }

  while (true)
    {
      LOOP_4(if (s7_is_equal(sc, obj, car(x))) return(x); x = cdr(x); if (!is_pair(x)) return(sc->F));
      y = cdr(y);
      if (x == y) return(sc->F);
    }
  return(sc->F); /* not reached */
}

static s7_pointer g_member(s7_scheme *sc, s7_pointer args)
{
  #define H_member "(member obj list (func #f)) looks for obj in list and returns the list from that point if it is found, otherwise #f. \
member uses equal?  If 'func' is a function of 2 arguments, it is used for the comparison instead of 'equal?"
  #define Q_member s7_make_signature(sc, 4, s7_make_signature(sc, 2, sc->is_pair_symbol, sc->not_symbol), sc->T, sc->is_list_symbol, sc->is_procedure_symbol)

  /* this could be extended to accept sequences:
   *    (member #\a "123123abnfc" char=?) -> "abnfc"
   *    (member "abc" "123abc321" string=?) -> "abc321" but there's the string length complication
   *    (member 1 #(0 1 2) =) -> #(1 2) etc but what would it do for a hash-table?
   * the third arg can be weird: (member #f (list #t) cons) -> (#t) -- cons returns '(#f . #t) which is true, so we get '(#t)
   * should this be an error: (member '(1 2 3) () '(1 . 2)) -- the third arg is bogus, but the second is nil
   *
   * here as in assoc, sort, and make-hash-table we accept macros, but I can't think of a good reason to do so.
   */

  s7_pointer x, obj, eq_func = NULL;
  x = cadr(args);

  if ((!is_pair(x)) && (!is_null(x)))
    return(method_or_bust_with_type(sc, x, sc->member_symbol, args, a_list_string, 2));

  if (is_not_null(cddr(args)))
    {
      /* check third arg before second (trailing arg error check) */
      eq_func = caddr(args);

      if (type(eq_func) < T_CONTINUATION)
	return(method_or_bust_with_type(sc, eq_func, sc->member_symbol, args, a_procedure_string, 3));

      if (!s7_is_aritable(sc, eq_func, 2))
	return(wrong_type_argument_with_type(sc, sc->member_symbol, 3, eq_func, an_eq_func_string));
    }

  if (is_null(x)) return(sc->F);
  if (eq_func)
    {
      s7_pointer y, slow;

      if ((is_safe_procedure(eq_func)) &&
	  (is_c_function(eq_func)))
	{
	  s7_function func;
	  func = c_function_call(eq_func);
	  if (func == g_is_eq) return(s7_memq(sc, car(args), x));
	  if (func == g_is_eqv) return(g_memv(sc, args));
#if (!WITH_GMP)
	  if (func == g_less) func = g_less_2;
	  if (func == g_greater) func = g_greater_2;
#endif
	  set_car(sc->t2_1, car(args));

	  for (slow = x; is_pair(x); x = cdr(x), slow = cdr(slow))
	    {
	      set_car(sc->t2_2, car(x));
	      if (is_true(sc, func(sc, sc->t2_1)))
		return(x);

	      if (!is_pair(cdr(x)))
		return(sc->F);
	      x = cdr(x);
	      if (x == slow)
		return(sc->F);

	      set_car(sc->t2_2, car(x));
	      if (is_true(sc, func(sc, sc->t2_1)))
		return(x);
	    }
	  return(sc->F);
	}

      if ((is_closure(eq_func)) &&
	  (is_pair(closure_args(eq_func))) &&
	  (is_pair(cdr(closure_args(eq_func))))) /* not dotted arg list */
	{
	  s7_pointer body;
	  body = closure_body(eq_func);
	  if (is_null(cdr(body)))
	    {
	      s7_function func;
	      new_frame_with_two_slots(sc, sc->envir, sc->envir, car(closure_args(eq_func)), car(args), cadr(closure_args(eq_func)), sc->F);
	      func = s7_bool_optimize(sc, body);
	      if (func == opt_bool_any)
		{
		  opt_info *o;
		  s7_pointer b;
		  o = sc->opts[0];
		  b = next_slot(let_slots(sc->envir));
		  for (slow = x; is_pair(x); x = cdr(x), slow = cdr(slow))
		    {
		      slot_set_value(b, car(x));
		      sc->pc = 0;
		      if (o->v[0].fb(o)) return(x);

		      if (!is_pair(cdr(x))) return(sc->F);
		      x = cdr(x);
		      if (x == slow) return(sc->F);

		      slot_set_value(b, car(x));
		      sc->pc = 0;
		      if (o->v[0].fb(o)) return(x);
		    }
		  return(sc->F);
		}
	    }
	}

      y = cons(sc, args, sc->nil); /* this could probably be handled with a counter cell (cdr here is unused) */
      set_opt1_fast(y, x);
      set_opt2_slow(y, x);
      push_stack(sc, OP_MEMBER_IF, cons(sc, y, sc->nil), eq_func);
      if (needs_copied_args(eq_func))
	push_stack(sc, OP_APPLY, list_2(sc, car(args), car(x)), eq_func);
      else
	{
	  set_car(sc->t2_1, car(args));
	  set_car(sc->t2_2, car(x));
	  push_stack(sc, OP_APPLY, sc->t2_1, eq_func);
	}
      return(sc->unspecified);
    }

  obj = car(args);
  if (is_simple(obj))
    return(s7_memq(sc, obj, x));

  /* the only things that aren't simply == here are c_object, string, number, vector, hash-table, pair, and c_pointer
   *   but all the other cases are unlikely.
   */
  if (s7_is_number(obj))
    return(memv_number(sc, obj, x));

  return(member(sc, obj, x));
}

static s7_pointer g_member_sq(s7_scheme *sc, s7_pointer args)
{
  s7_pointer obj, lst;
  lst = opt2_con(args); /* cadadr(args); */
  obj = lookup(sc, car(args));

  if (is_simple(obj))
    return(s7_memq(sc, obj, lst));

  if (s7_is_number(obj))
    return(memv_number(sc, obj, lst));

  return(member(sc, obj, lst));
}

static s7_pointer g_member_ss(s7_scheme *sc, s7_pointer args)
{
  s7_pointer obj, x;

  obj = lookup(sc, car(args));
  x = lookup(sc, cadr(args));
  if (!is_pair(x))
    {
      if (is_null(x)) return(sc->F);
      return(method_or_bust_with_type(sc, x, sc->member_symbol, list_2(sc, obj, x), a_list_string, 2));
    }

  if (is_simple(obj))
    return(s7_memq(sc, obj, x));

  if (s7_is_number(obj))
    return(memv_number(sc, obj, x));

  return(member(sc, obj, x));
}

static s7_pointer member_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(g_member(sc, set_plist_2(sc, p1, p2)));}

static s7_pointer member_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if (args == 2)
    {
      if (is_normal_symbol(caddr(expr)))
	{
	  if ((optimize_op(expr) == HOP_SAFE_C_SS) ||
	      ((is_h_safe_c_d(expr)) &&
	       (is_normal_symbol(cadr(expr)))))
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->member_ss);                    /* (member obj lst) */
	    }
	}
      else
	{
	  if (((optimize_op(expr) == HOP_SAFE_C_SC) || /* watch out for (member x '3) etc */
	       (is_h_safe_c_d(expr))) &&
	      (is_normal_symbol(cadr(expr))) &&
	      (is_proper_quote(sc, caddr(expr))) &&
	      (is_pair(cadr(caddr(expr)))))
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->member_sq);                    /* (member q '(quote lambda case)) */
	    }
	}
    }

  if ((args == 3) &&
      (is_normal_symbol(cadddr(expr))) &&
      (cadddr(expr) == sc->is_eq_symbol))
    return(memq_chooser(sc, f, 2, expr, ops));
  return(f);
}

static bool member_if(s7_scheme *sc)
{
  s7_pointer orig_args;
  orig_args = car(sc->args);
  /* code=func, args = (list (list original args)) with opt1_fast->position in cadr (the list),
   *   the extra indirection (list (list...)) is needed because call/cc copies arg lists
   * value = result of comparison
   */
  if (sc->value != sc->F)                      /* previous comparison was not #f -- return list */
    {
      sc->value = opt1_fast(orig_args);
      return(true);
    }
  if (!is_pair(cdr(opt1_fast(orig_args))))      /* no more args -- return #f */
    {
      sc->value = sc->F;
      return(true);
    }
  set_opt1_fast(orig_args, cdr(opt1_fast(orig_args))); /* cdr down arg list */

  if (sc->cur_op == OP_MEMBER_IF1)
    {
      /* circular list check */
      if (opt1_fast(orig_args) == opt2_slow(orig_args))
	{
	  sc->value = sc->F;
	  return(true);
	}
      set_opt2_slow(orig_args, cdr(opt2_slow(orig_args))); /* cdr down the slow list (check for circular list) */
      push_stack(sc, OP_MEMBER_IF, sc->args, sc->code);
    }
  else push_stack(sc, OP_MEMBER_IF1, sc->args, sc->code);

  if (needs_copied_args(sc->code))
    sc->args = list_2(sc, caar(orig_args), car(opt1_fast(orig_args)));
  else sc->args = set_plist_2(sc, caar(orig_args), car(opt1_fast(orig_args)));
  return(false);
}


/* -------------------------------- list -------------------------------- */
static s7_pointer g_list(s7_scheme *sc, s7_pointer args)
{
  #define H_list "(list ...) returns its arguments in a list"
  #define Q_list s7_make_circular_signature(sc, 1, 2, sc->is_proper_list_symbol, sc->T)

  if (is_pair(args))
    {
      if (is_null(cdr(args)))
	return(cons(sc, car(args), sc->nil));
      if (is_null(cddr(args)))
	return(list_2(sc, car(args), cadr(args)));
      return(copy_list(sc, args));
    }
  return(sc->nil);
}

static s7_pointer list_p_p(s7_scheme *sc, s7_pointer p1) {return(list_1(sc, p1));}
static s7_pointer list_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2) {return(list_2(sc, p1, p2));}

static void check_list_validity(s7_scheme *sc, const char *caller, s7_pointer lst)
{
  s7_pointer p;
  int32_t i;
  for (i = 1, p = lst; is_pair(p); p = cdr(p), i++)
    if (!s7_is_valid(sc, car(p)))
      s7_warn(sc, 256, "bad arg (#%d) to %s: %p\n", i, caller, car(p));
}

s7_pointer s7_list(s7_scheme *sc, s7_int num_values, ...)
{
  s7_int i;
  va_list ap;
  s7_pointer p;

  if (num_values == 0)
    return(sc->nil);

  sc->w = make_list(sc, num_values, sc->nil);
  va_start(ap, num_values);
  for (i = 0, p = sc->w; i < num_values; i++, p = cdr(p))
    set_car(p, va_arg(ap, s7_pointer));
  va_end(ap);

  if (sc->safety > NO_SAFETY)
    check_list_validity(sc, "s7_list", sc->w);

  p = sc->w;
  sc->w = sc->nil;
  return(p);
}

s7_pointer s7_list_nl(s7_scheme *sc, s7_int num_values, ...) /* arglist should be NULL terminated */
{
  s7_int i;
  va_list ap;
  s7_pointer p;

  if (num_values == 0)
    return(sc->nil);

  sc->w = sc->nil;
  va_start(ap, num_values);
  for (i = 0; i < num_values; i++)
    {
      p = va_arg(ap, s7_pointer);
      if (!p)
	{
	  va_end(ap);
	  return(s7_wrong_number_of_args_error(sc, "not enough args for s7_list_nl: ~S", safe_reverse_in_place(sc, sc->w)));
	}
      sc->w = cons(sc, p, sc->w);
    }
  p = va_arg(ap, s7_pointer);
  va_end(ap);
  if (p)
    return(s7_wrong_number_of_args_error(sc, "too many args for s7_list_nl: ~S", safe_reverse_in_place(sc, sc->w)));

  if (sc->safety > NO_SAFETY)
    check_list_validity(sc, "s7_list_nl", sc->w);

  p = sc->w;
  sc->w = sc->nil;
  return(safe_reverse_in_place(sc, p));
}

static s7_pointer safe_list_1(s7_scheme *sc)
{
  if (!list_is_in_use(sc->safe_lists[1]))
    {
      sc->current_safe_list = 1;
      set_list_in_use(sc->safe_lists[1]);
      return(sc->safe_lists[1]);
    }
  return(cons(sc, sc->nil, sc->nil));
}

static s7_pointer safe_list_2(s7_scheme *sc)
{
  if (!list_is_in_use(sc->safe_lists[2]))
    {
      sc->current_safe_list = 2;
      set_list_in_use(sc->safe_lists[2]);
      return(sc->safe_lists[2]);
    }
  return(cons_unchecked(sc, sc->nil, cons(sc, sc->nil, sc->nil)));
}

static s7_pointer make_safe_list(s7_scheme *sc, s7_int num_args)
{
  if (num_args < NUM_SAFE_LISTS)
    {
      sc->current_safe_list = num_args;
      if (!is_pair(sc->safe_lists[num_args]))
	sc->safe_lists[num_args] = permanent_list(sc, num_args);
      if (!list_is_in_use(sc->safe_lists[num_args]))
	{
	  set_list_in_use(sc->safe_lists[num_args]);
	  return(sc->safe_lists[num_args]);
	}
    }
  return(make_big_list(sc, num_args, sc->nil));
}

static inline s7_pointer safe_list_if_possible(s7_scheme *sc, s7_int num_args)
{
  if ((num_args < NUM_SAFE_PRELISTS) &&
      (!list_is_in_use(sc->safe_lists[num_args])))
    {
      sc->current_safe_list = num_args;
      set_list_in_use(sc->safe_lists[num_args]);
      return(sc->safe_lists[num_args]);
    }
  return(make_safe_list(sc, num_args));
}

static s7_int sequence_length(s7_scheme *sc, s7_pointer lst);
static s7_pointer s7_copy_1(s7_scheme *sc, s7_pointer caller, s7_pointer args);

static s7_pointer g_list_append(s7_scheme *sc, s7_pointer args)
{
  s7_pointer y, tp, np = NULL, pp;
  bool all_args_are_lists = true;

  /* we know here that args is a pair and cdr(args) is not nil; this function does not check sc->max_list_length; called only in g_append */
  tp = sc->nil;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, args);
  for (y = args; is_pair(y); y = cdr(y)) /* arglist so not dotted */
    {
      s7_pointer p;
      p = car(y);

      check_method(sc, p, sc->append_symbol, (is_null(tp)) ? y : cons(sc, tp, y));

      if (is_null(cdr(y)))
	{
	  if (is_null(tp))
	    return(p);
	  /* (append (list 1) "hi") should return '(1 . "hi") not '(1 #\h #\i)
	   *   but this is inconsistent with (append (list 1) "hi" "hi") -> '(1 #\h #\i . "hi") ?
	   *   Perhaps if all args but last are lists, returned dotted list?
	   */
	  if ((all_args_are_lists) || (is_null(p)))
	    set_cdr(np, p);
	  else
	    {
	      s7_int len;
	      len = sequence_length(sc, p);
	      if (len > 0)
		set_cdr(np, s7_copy_1(sc, sc->append_symbol, set_plist_2(sc, p, protected_make_list(sc, len, sc->F))));
	      else
		{
		  if (len < 0)
		    set_cdr(np, p);
		}
	    }
	  sc->y = sc->nil;
	  unstack(sc);
	  return(tp);
	}

      if (!is_sequence(p))
	return(wrong_type_argument_with_type(sc, sc->append_symbol, position_of(y, args), p, a_sequence_string));

      if (!is_null(p))
	{
	  if (is_pair(p))
	    {
	      if (!s7_is_proper_list(sc, p))
		{
		  sc->y = sc->nil;
		  return(wrong_type_argument_with_type(sc, sc->append_symbol, position_of(y, args), p, a_proper_list_string));
		}
	      /* is this error correct?
	       *     (append '(3) '(1 . 2)) -> '(3 1 . 2) ; (old) guile also returns this
	       * but (append '(1 . 2) '(3)) -> this error
	       */

	      if (is_null(tp))
		{
		  tp = cons(sc, car(p), sc->nil);
		  np = tp;
		  sc->y = tp; /* GC protect? */
		  pp = cdr(p);
		}
	      else pp = p;
	      for (; is_pair(pp); pp = cdr(pp), np = cdr(np))
		set_cdr(np, cons(sc, car(pp), sc->nil));
	    }
	  else
	    {
	      s7_int len;
	      len = sequence_length(sc, p);
	      all_args_are_lists = false;
	      if (len > 0)
		{
		  if (is_null(tp))
		    {
		      tp = s7_copy_1(sc, sc->append_symbol, set_plist_2(sc, p, protected_make_list(sc, len, sc->F)));
		      np = tp;
		      sc->y = tp;
		    }
		  else set_cdr(np, s7_copy_1(sc, sc->append_symbol, set_plist_2(sc, p, protected_make_list(sc, len, sc->F))));
		  for (; is_pair(cdr(np)); np = cdr(np));
		}
	      else
		{
		  if (len < 0)
		    return(wrong_type_argument_with_type(sc, sc->append_symbol, position_of(y, args), p, a_sequence_string));
		}
	    }
	}
    }
  unstack(sc);
  return(tp);
}

static s7_pointer append_in_place(s7_scheme *sc, s7_pointer a, s7_pointer b)
{
  /* tack b onto the end of a without copying either -- 'a' is changed! */
  s7_pointer p;
  if (is_null(a))
    return(b);
  p = a;
  while (is_not_null(cdr(p))) p = cdr(p);
  set_cdr(p, b);
  return(a);
}


/* -------------------------------- vectors -------------------------------- */

bool s7_is_vector(s7_pointer p)       {return(is_any_vector(p));}
bool s7_is_float_vector(s7_pointer p) {return(type(p) == T_FLOAT_VECTOR);}
bool s7_is_int_vector(s7_pointer p)   {return(type(p) == T_INT_VECTOR);}
static bool s7_is_byte_vector(s7_pointer b) {return(is_byte_vector(b));}

s7_int s7_vector_length(s7_pointer vec) {return(vector_length(vec));}

static s7_pointer default_vector_setter(s7_scheme *sc, s7_pointer vec, s7_int loc, s7_pointer val)
{
  vector_element(vec, loc) = val;
  return(val);
}

static const char *make_type_name(s7_scheme *sc, const char *name, int32_t article);

static inline s7_pointer typed_vector_setter(s7_scheme *sc, s7_pointer vec, s7_int loc, s7_pointer val)
{
  if ((sc->safety < 0) || /* or == 0?? */
      (c_function_call(typed_vector_typer(vec))(sc, set_plist_1(sc, val)) != sc->F))
    {
      vector_element(vec, loc) = val;
      return(val);
    }
  return(s7_wrong_type_arg_error(sc, "vector-set!", 3, val,
				 make_type_name(sc, c_function_name(typed_vector_typer(vec)), INDEFINITE_ARTICLE)));
}

static s7_pointer default_vector_getter(s7_scheme *sc, s7_pointer vec, s7_int loc)
{
  return(vector_element(vec, loc));
}

static s7_pointer int_vector_setter(s7_scheme *sc, s7_pointer vec, s7_int loc, s7_pointer val)
{
  if (s7_is_integer(val))
    int_vector(vec, loc) = s7_integer(val);
  else s7_wrong_type_arg_error(sc, "int-vector-set!", 3, val, "an integer");
  return(val);
}

static s7_pointer int_vector_getter(s7_scheme *sc, s7_pointer vec, s7_int loc)
{
  return(make_integer(sc, int_vector(vec, loc)));
}

static s7_pointer float_vector_setter(s7_scheme *sc, s7_pointer vec, s7_int loc, s7_pointer val)
{
  float_vector(vec, loc) = real_to_double(sc, val, "float-vector-set!");
  return(val);
}

static s7_pointer float_vector_getter(s7_scheme *sc, s7_pointer vec, s7_int loc)
{
  return(make_real(sc, float_vector(vec, loc)));
}

static s7_pointer byte_vector_getter(s7_scheme *sc, s7_pointer bv, s7_int loc)
{
  return(make_integer(sc, (uint8_t)(byte_vector(bv, loc))));
}

static s7_pointer byte_vector_setter(s7_scheme *sc, s7_pointer str, s7_int loc, s7_pointer val)
{
  if (s7_is_integer(val))
    {
      s7_int byte;
      byte = s7_integer(val);
      if ((byte >= 0) && (byte < 256))
	{
	  byte_vector(str, loc) = (uint8_t)byte;
	  return(val);
	}
      return(s7_wrong_type_arg_error(sc, "byte-vector-set!", 3, val, "a byte"));
    }
  return(s7_wrong_type_arg_error(sc, "byte-vector-set!", 3, val, "an integer"));
}

static inline block_t *mallocate_vector(s7_scheme *sc, s7_int len)
{
  block_t *b;
  if (len > 0)
    return(mallocate(sc, len));
  b = mallocate_block(sc);
  block_data(b) = NULL;
  block_info(b) = NULL;
  return(b);
}

static inline s7_pointer make_simple_vector(s7_scheme *sc, s7_int len) /* len >= 0 and < max */
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_VECTOR | T_SAFE_PROCEDURE);
  vector_length(x) = len;
  b = mallocate_vector(sc, len * sizeof(s7_pointer));
  vector_block(x) = b;
  vector_elements(x) = (s7_pointer *)block_data(b);
  vector_set_dimension_info(x, NULL);
  vector_getter(x) = default_vector_getter;
  vector_setter(x) = default_vector_setter;
  add_vector(sc, x);
  return(x);
}

static inline s7_pointer make_simple_float_vector(s7_scheme *sc, s7_int len) /* len >= 0 and < max */
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_FLOAT_VECTOR | T_SAFE_PROCEDURE);
  vector_length(x) = len;
  b = mallocate_vector(sc, len * sizeof(s7_double));
  vector_block(x) = b;
  float_vector_floats(x) = (s7_double *)block_data(b);
  vector_set_dimension_info(x, NULL);
  vector_getter(x) = float_vector_getter;
  vector_setter(x) = float_vector_setter;
  add_vector(sc, x);
  return(x);
}

static inline s7_pointer make_simple_int_vector(s7_scheme *sc, s7_int len) /* len >= 0 and < max */
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_INT_VECTOR | T_SAFE_PROCEDURE);
  vector_length(x) = len;
  b = mallocate_vector(sc, len * sizeof(s7_int));
  vector_block(x) = b;
  int_vector_ints(x) = (s7_int *)block_data(b);
  vector_set_dimension_info(x, NULL);
  vector_getter(x) = int_vector_getter;
  vector_setter(x) = int_vector_setter;
  add_vector(sc, x);
  return(x);
}

static s7_pointer make_simple_byte_vector(s7_scheme *sc, s7_int len)
{
  s7_pointer x;
  block_t *b;
  new_cell(sc, x, T_BYTE_VECTOR | T_SAFE_PROCEDURE);
  b = mallocate(sc, len);
  vector_block(x) = b;
  byte_vector_bytes(x) = (uint8_t *)block_data(b);
  vector_length(x) = len;
  vector_set_dimension_info(x, NULL);
  vector_getter(x) = byte_vector_getter;
  vector_setter(x) = byte_vector_setter;
  add_vector(sc, x);
  return(x);
}

static s7_pointer make_vector_1(s7_scheme *sc, s7_int len, bool filled, uint8_t typ)
{
  s7_pointer x;

  if (len < 0)
    return(wrong_type_argument_with_type(sc, sc->make_vector_symbol, 1, wrap_integer1(sc, len), a_non_negative_integer_string));
  if (len > sc->max_vector_length)
    return(out_of_range(sc, sc->make_vector_symbol, small_int(1), wrap_integer1(sc, len), its_too_large_string));

  /* this has to follow the error checks! (else garbage in free_heap temps portion confuses GC when "vector" is finalized) */

  new_cell(sc, x, typ | T_SAFE_PROCEDURE);
  vector_length(x) = len;
  if (len == 0)
    {
      vector_block(x) = mallocate_vector(sc, 0);
      vector_elements(x) = NULL;
      if (typ == T_VECTOR) set_has_simple_elements(x);
    }
  else
    {
      block_t *b;
      if (typ == T_VECTOR)
	{
	  b = mallocate_vector(sc, len * sizeof(s7_pointer));
	  vector_block(x) = b;
	  vector_elements(x) = (s7_pointer *)block_data(b);
	  vector_getter(x) = default_vector_getter;
	  vector_setter(x) = default_vector_setter;
	  if (filled)
	    s7_vector_fill(sc, x, sc->nil);
	}
      else
	{
	  if (typ == T_FLOAT_VECTOR)
	    {
	      b = mallocate_vector(sc, len * sizeof(s7_double));
	      vector_block(x) = b;
	      float_vector_floats(x) = (s7_double *)block_data(b);
	      if (filled)
		{
		  if (STEP_8(len))
		    memclr64((void *)vector_elements(x), len * sizeof(s7_double));
		  else memclr((void *)vector_elements(x), len * sizeof(s7_double));
		}
	      vector_getter(x) = float_vector_getter;
	      vector_setter(x) = float_vector_setter;
	    }
	  else
	    {
	      if (typ == T_INT_VECTOR)
		{
		  b = mallocate_vector(sc, len * sizeof(s7_int));
		  vector_block(x) = b;
		  int_vector_ints(x) = (s7_int *)block_data(b);
		  if (filled)
		    {
		      if (STEP_8(len))
			memclr64((void *)vector_elements(x), len * sizeof(s7_int));
		      else memclr((void *)vector_elements(x), len * sizeof(s7_int));
		    }
		  vector_getter(x) = int_vector_getter;
		  vector_setter(x) = int_vector_setter;
		}
	      else
		{
#if S7_DEBUGGING
		  if (typ != T_BYTE_VECTOR)
		    fprintf(stderr, "%s: typ=%d\n", __func__, (int)typ);
#endif
		  b = mallocate(sc, len);
		  vector_block(x) = b;
		  byte_vector_bytes(x) = (uint8_t *)block_data(b);
		  vector_getter(x) = byte_vector_getter;
		  vector_setter(x) = byte_vector_setter;
		  if (filled)
		    {
		      if (STEP_8(len))
			memclr64((void *)(byte_vector_bytes(x)), len);
		      else memclr((void *)(byte_vector_bytes(x)), len);
		    }}}}}
  vector_set_dimension_info(x, NULL);
  return(x);
}

s7_pointer s7_make_vector(s7_scheme *sc, s7_int len)
{
  s7_pointer v;
  v = make_vector_1(sc, len, FILLED, T_VECTOR);
  add_vector(sc, v);
  return(v);
}

static vdims_t *make_wrap_only(s7_scheme *sc) /* this makes sc->wrap_only */
{
  vdims_t *v;
  v = (vdims_t *)mallocate_block(sc);
  vdims_original(v) = sc->F;
  vector_elements_should_be_freed(v) = false;
  vdims_rank(v) = 1;
  vdims_dims(v) = NULL;
  vdims_offsets(v) = NULL;
  return(v);
}

static vdims_t *make_vdims(s7_scheme *sc, bool elements_should_be_freed, s7_int dims, s7_int *dim_info)
{
  vdims_t *v;

  if ((dims == 1) && (!elements_should_be_freed))
    return(sc->wrap_only);

  if (dims > 1)
    {
      s7_int i, offset = 1;
      v = (vdims_t *)mallocate(sc, dims * 2 * sizeof(s7_int));
      vdims_original(v) = sc->F;
      vector_elements_should_be_freed(v) = elements_should_be_freed;
      vdims_rank(v) = dims;
      vdims_offsets(v) = (s7_int *)(vdims_dims(v) + dims);

      for (i = 0; i < dims; i++)
	vdims_dims(v)[i] = dim_info[i];
      for (i = dims - 1; i >= 0; i--)
	{
	  vdims_offsets(v)[i] = offset;
	  offset *= vdims_dims(v)[i];
	}
    }
  else
    {
      v = (vdims_t *)mallocate_block(sc);
      vdims_original(v) = sc->F;
      vector_elements_should_be_freed(v) = elements_should_be_freed;
      vdims_rank(v) = 1;
      vdims_dims(v) = NULL;
      vdims_offsets(v) = NULL;
    }
  return(v);
}

s7_pointer s7_make_int_vector(s7_scheme *sc, s7_int len, s7_int dims, s7_int *dim_info)
{
  s7_pointer p;
  p = make_vector_1(sc, len, FILLED, T_INT_VECTOR);
  if (dim_info)
    {
      vector_set_dimension_info(p, make_vdims(sc, false, dims, dim_info));
      add_multivector(sc, p);
    }
  else add_vector(sc, p);
  return(p);
}

s7_pointer s7_make_float_vector(s7_scheme *sc, s7_int len, s7_int dims, s7_int *dim_info)
{
  s7_pointer p;
  p = make_vector_1(sc, len, FILLED, T_FLOAT_VECTOR);
  if (dim_info)
    {
      vector_set_dimension_info(p, make_vdims(sc, false, dims, dim_info));
      add_multivector(sc, p);
    }
  else add_vector(sc, p);
  return(p);
}

s7_pointer s7_make_float_vector_wrapper(s7_scheme *sc, s7_int len, s7_double *data, s7_int dims, s7_int *dim_info, bool free_data)
{
  /* this wraps up a C-allocated/freed double array as an s7 vector. */
  s7_pointer x;
  block_t *b;

  new_cell(sc, x, T_FLOAT_VECTOR | T_SAFE_PROCEDURE);
  b = mallocate_vector(sc, 0);
  vector_block(x) = b;
  /* block_data(b) = data; */
  float_vector_floats(x) = data;
  vector_getter(x) = float_vector_getter;
  vector_setter(x) = float_vector_setter;
  vector_length(x) = len;
  if (!dim_info)
    {
      s7_int di[1];
      di[0] = len;
      vector_set_dimension_info(x, make_vdims(sc, free_data, 1, di));
    }
  else vector_set_dimension_info(x, make_vdims(sc, free_data, dims, dim_info));
  add_multivector(sc, x);
  return(x);
}


/* -------------------------------- vector-fill! -------------------------------- */
#if WITH_VECTORIZE
static void float_vector_fill(s7_scheme *sc, s7_pointer vec, s7_double x) __attribute__((optimize("tree-vectorize")));
static void int_vector_fill(s7_scheme *sc, s7_pointer vec, s7_int k) __attribute__((optimize("tree-vectorize")));
static void normal_vector_fill(s7_scheme *sc, s7_pointer vec, s7_pointer obj) __attribute__((optimize("tree-vectorize")));
#endif

static void float_vector_fill(s7_scheme *sc, s7_pointer vec, s7_double x)
{
  s7_int len;
  len = vector_length(vec);
  if (len == 0) return;
  if (x == 0.0)
    {
      if (STEP_8(len))
	memclr64((void *)float_vector_floats(vec), len * sizeof(s7_double));
      else memclr((void *)float_vector_floats(vec), len * sizeof(s7_double));
    }
  else
    {
      s7_int i, left;
      s7_double *orig;
      left = len - 8;
      i = 0;
      orig = float_vector_floats(vec);
      while (i <= left)
	LOOP_8(orig[i++] = x);
      for (; i < len; i++)
	orig[i] = x;
    }
}

static void int_vector_fill(s7_scheme *sc, s7_pointer vec, s7_int k)
{
  s7_int len;
  len = vector_length(vec);
  if (len == 0) return;
  if (k == 0)
    {
      if (STEP_8(len))
	memclr64((void *)int_vector_ints(vec), len * sizeof(s7_int));
      else memclr((void *)int_vector_ints(vec), len * sizeof(s7_int));
    }
  else
    {
      s7_int i, left;
      s7_int* orig;
      left = len - 8;
      i = 0;
      orig = int_vector_ints(vec);
      while (i <= left)
	LOOP_8(orig[i++] = k);
      for (; i < len; i++)
	orig[i] = k;
    }
}

static void byte_vector_fill(s7_scheme *sc, s7_pointer vec, uint8_t byte)
{
  s7_int len;
  len = vector_length(vec);
  if (len == 0) return;
  if (byte == 0)
    memclr((void *)(byte_vector_bytes(vec)), len);
  else local_memset((void *)(byte_vector_bytes(vec)), byte, len);
}

static void normal_vector_fill(s7_scheme *sc, s7_pointer vec, s7_pointer obj)
{
  s7_pointer *orig;
  s7_int len, i, left;

  len = vector_length(vec);
  if (len == 0) return;

  if ((is_typed_vector(vec)) &&
      (c_function_call(typed_vector_typer(vec))(sc, set_plist_1(sc, obj)) == sc->F))
    s7_wrong_type_arg_error(sc, "vector fill!", 2, obj,
			    make_type_name(sc, c_function_name(typed_vector_typer(vec)), INDEFINITE_ARTICLE));
  /* splitting out this part made no difference in speed */
  orig = vector_elements(vec);
  left = len - 8;
  i = 0;
  while (i <= left)
    LOOP_8(orig[i++] = obj);
  for (; i < len; i++)
    orig[i] = obj;
}

static void vector_fill(s7_scheme *sc, s7_pointer vec, s7_pointer obj)
{
  switch (type(vec))
    {
    case T_FLOAT_VECTOR:
      if (!s7_is_real(obj))
	s7_wrong_type_arg_error(sc, "float-vector fill!", 2, obj, "a real");
      else float_vector_fill(sc, vec, s7_real(obj));
      break;

    case T_INT_VECTOR:
      if (!s7_is_integer(obj)) /* possibly a bignum */
	s7_wrong_type_arg_error(sc, "int-vector fill!", 2, obj, "an integer");
      else int_vector_fill(sc, vec, s7_integer(obj));
      break;

    case T_BYTE_VECTOR:
      if (!is_byte(obj))
	s7_wrong_type_arg_error(sc, "byte-vector fill!", 2, obj, "a byte");
      else byte_vector_fill(sc, vec, (uint8_t)s7_integer(obj));
      break;

    default:
      normal_vector_fill(sc, vec, obj);
    }
}

#if (!WITH_GMP)
void s7_vector_fill(s7_scheme *sc, s7_pointer vec, s7_pointer obj) {vector_fill(sc, vec, obj);}
#endif

static s7_pointer g_vector_fill_1(s7_scheme *sc, s7_pointer caller, s7_pointer args)
{
  s7_pointer x, fill;
  s7_int start = 0, end;

  x = car(args);
  if (!is_any_vector(x))
    {
      check_method(sc, x, sc->vector_fill_symbol, args);
      /* not two_methods (and fill!) here else we get stuff like:
       *   (let ((e (openlet (inlet 'fill! (lambda (obj val) (string-fill! (obj 'value) val)) 'value "01234")))) (vector-fill! e #\a) (e 'value)) -> "aaaaa"
       */
      return(wrong_type_argument(sc, caller, 1, x, T_VECTOR));
    }
  if (is_immutable_vector(x))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, caller, x)));

  fill = cadr(args);
  if (is_float_vector(x))
    {
      if (!s7_is_real(fill)) /* possibly a bignum */
	return(method_or_bust(sc, fill, caller, args, T_REAL, 2));
    }
  else
    {
      if ((is_int_vector(x)) || (is_byte_vector(x)))
	{
	  if (!s7_is_integer(fill))
	    return(method_or_bust(sc, fill, caller, args, T_INTEGER, 2));
	  if ((is_byte_vector(x)) &&
	      ((s7_integer(fill) < 0) || (s7_integer(fill) > 255)))
	    return(out_of_range(sc, caller, small_int(2), fill, an_unsigned_byte_string));
	}
    }

  end = vector_length(x);
  if (!is_null(cddr(args)))
    {
      s7_pointer p;
      p = start_and_end(sc, caller, args, 3, &start, &end);
      if (p != sc->unused) return(p);
      if (start == end) return(fill);
    }
  if (end == 0) return(fill);

  if ((start == 0) && (end == vector_length(x)))
    s7_vector_fill(sc, x, fill);
  else
    {
      s7_int i;
      if (is_normal_vector(x))
	{
	  if ((is_typed_vector(x)) &&
	      (c_function_call(typed_vector_typer(x))(sc, set_plist_1(sc, fill)) == sc->F))
	    s7_wrong_type_arg_error(sc, "vector fill!", 2, fill, make_type_name(sc, c_function_name(typed_vector_typer(x)), INDEFINITE_ARTICLE));

	  for (i = start; i < end; i++)
	    vector_element(x, i) = fill;
	}
      else
	{
	  if (is_int_vector(x))
	    {
	      s7_int k;
	      k = s7_integer(fill);
	      if (k == 0)
		memclr((void *)(int_vector_ints(x) + start), (end - start) * sizeof(s7_int));
	      else
		{
		  for (i = start; i < end; i++)
		    int_vector(x, i) = k;
		}
	    }
	  else
	    {
	      if (is_float_vector(x))
		{
		  s7_double y;
		  y = s7_real(fill);
		  if (y == 0.0)
		    memclr((void *)(float_vector_floats(x) + start), (end - start) * sizeof(s7_double));
		  else
		    {
		      s7_double *orig;
		      s7_int left;
		      orig = float_vector_floats(x);
		      left = end - 8;
		      i = start;
		      while (i <= left)
			LOOP_8(orig[i++] = y);
		      for (; i < end; i++)
			orig[i] = y;
		    }
		}
	      else
		{
		  if (is_byte_vector(x))
		    {
		      uint8_t k;
		      k = (uint8_t)s7_integer(fill);
		      if (k == 0)
			memclr((void *)(byte_vector_bytes(x) + start), end - start);
		      else local_memset((void *)(byte_vector_bytes(x) + start), k, end - start);
		    }}}}}
  return(fill);
}

#if (!WITH_PURE_S7)
/* -------------------------------- vector-fill! -------------------------------- */
static s7_pointer g_vector_fill(s7_scheme *sc, s7_pointer args)
{
  #define H_vector_fill "(vector-fill! v val start end) sets all elements of the vector v between start and end to val"
  #define Q_vector_fill s7_make_circular_signature(sc, 3, 4, sc->T, sc->is_vector_symbol, sc->T, sc->is_integer_symbol)
  return(g_vector_fill_1(sc, sc->vector_fill_symbol, args));
}
#endif


/* -------------------------------- vector-ref|set! -------------------------------- */
s7_pointer s7_vector_ref(s7_scheme *sc, s7_pointer vec, s7_int index)
{
  if (index >= vector_length(vec))
    return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), wrap_integer1(sc, index), its_too_large_string));

  return(vector_getter(vec)(sc, vec, index));
}

s7_pointer s7_vector_set(s7_scheme *sc, s7_pointer vec, s7_int index, s7_pointer a)
{
  if (index >= vector_length(vec))
    return(out_of_range(sc, sc->vector_set_symbol, small_int(2), wrap_integer1(sc, index), its_too_large_string));

  if (is_typed_vector(vec))
    return(typed_vector_setter(sc, vec, index, a));
  vector_setter(vec)(sc, vec, index, T_Pos(a));
  return(a);
}


s7_pointer *s7_vector_elements(s7_pointer vec)      {return(vector_elements(vec));}
s7_int *s7_int_vector_elements(s7_pointer vec)      {return(int_vector_ints(vec));}
s7_double *s7_float_vector_elements(s7_pointer vec) {return(float_vector_floats(vec));}

s7_int s7_vector_dimensions(s7_pointer vec, s7_int *dims, s7_int dims_size)
{
  if (dims_size <= 0) return(0);
  if (vector_dimension_info(vec))
    {
      s7_int i, lim;
      lim = vector_ndims(vec);
      if (lim > dims_size) lim = dims_size;
      for (i = 0; i < lim; i++)
	dims[i] = vector_dimension(vec, i);
      return(lim);
    }
  dims[0] = vector_length(vec);
  return(1);
}

s7_int s7_vector_dimension(s7_pointer vec, s7_int dim)
{
  if (vector_dimension_info(vec))
    return(vector_dimension(vec, dim));
  if (dim == 0)
    return(vector_length(vec));
  return(-1);
}

s7_int s7_vector_offsets(s7_pointer vec, s7_int *offs, s7_int offs_size)
{
  if (offs_size <= 0) return(0);
  if (vector_dimension_info(vec))
    {
      s7_int i, lim;
      lim = vector_ndims(vec);
      if (lim > offs_size) lim = offs_size;
      for (i = 0; i < lim; i++)
	offs[i] = vector_offset(vec, i);
      return(lim);
    }
  offs[0] = 1;
  return(1);
}


#if (!WITH_PURE_S7)
/* -------------------------------- vector-append -------------------------------- */
static s7_pointer vector_append(s7_scheme *sc, s7_pointer args, uint8_t typ, s7_pointer caller);

static s7_pointer g_vector_append(s7_scheme *sc, s7_pointer args)
{
  /* returns a one-dimensional vector.  To handle multidimensional vectors, we'd need to
   *   ensure all the dimensional data matches (rank, size of each dimension except the last etc),
   *   which is too much trouble.
   */
  #define H_vector_append "(vector-append . vectors) returns a new (1-dimensional) vector containing the elements of its vector arguments."
  #define Q_vector_append sc->pcl_v

  s7_pointer p;
  int32_t i;

  if (is_null(args))
    return(make_simple_vector(sc, 0));

  for (i = 0, p = args; is_pair(p); p = cdr(p), i++)
    {
      s7_pointer x;
      x = car(p);
      if (!is_any_vector(x))
	{
	  if (has_active_methods(sc, x))
	    {
	      s7_pointer func;
	      func = find_method(sc, find_let(sc, x), sc->vector_append_symbol);
	      if (func != sc->undefined)
		{
		  int32_t k;
		  s7_pointer v, y;
		  if (i == 0)
		    return(s7_apply_function(sc, func, args));
		  /* we have to copy the arglist here */
		  sc->temp9 = make_list(sc, i, sc->F);
		  for (k = 0, y = args, v = sc->temp9; k < i; k++, y = cdr(y), v = cdr(v))
		    set_car(v, car(y));
		  v = g_vector_append(sc, sc->temp9);
		  y = s7_apply_function(sc, func, cons(sc, v, p));
		  sc->temp9 = sc->nil;
		  return(y);
		}
	    }
	  return(wrong_type_argument(sc, sc->vector_append_symbol, i + 1, x, T_VECTOR));
	}
    }
  return(vector_append(sc, args, type(car(args)), sc->vector_append_symbol));
}

static s7_pointer vector_append_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  s7_pointer val;
  sc->temp7 = list_2(sc, p1, p2);
  val = g_vector_append(sc, sc->temp7);
  sc->temp7 = sc->nil;
  return(val);
}

static s7_pointer vector_append_p_ppp(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_pointer p3)
{
  s7_pointer val;
  sc->temp7 = list_3(sc, p1, p2, p3);
  val = g_vector_append(sc, sc->temp7);
  sc->temp7 = sc->nil;
  return(val);
}
#endif

static s7_int flatten_multivector_indices(s7_scheme *sc, s7_pointer vector, s7_int indices, va_list ap)
{
  s7_int rank, index;

  rank = vector_rank(vector);
  if (rank != indices)
    s7_wrong_number_of_args_error(sc, "s7_vector_ref_n: wrong number of indices: ~A", s7_make_integer(sc, indices));

  if (rank == 1)
    index = va_arg(ap, s7_int);
  else
    {
      s7_int i;
      s7_int *offsets, *dimensions;
      dimensions = vector_dimensions(vector);
      offsets = vector_offsets(vector);
      for (i = 0, index = 0; i < indices; i++)
	{
	  s7_int ind;
	  ind = va_arg(ap, s7_int);
	  if ((ind < 0) ||
	      (ind >= dimensions[i]))
	    {
	      va_end(ap);
	      out_of_range(sc, sc->vector_ref_symbol, small_int(i), wrap_integer1(sc, ind), (ind < 0) ? its_negative_string : its_too_large_string);
	      return(-1);
	    }
	  index += (ind * offsets[i]);
	}
    }
  va_end(ap);
  return(index);
}

s7_pointer s7_vector_ref_n(s7_scheme *sc, s7_pointer vector, s7_int indices, ...)
{
  s7_int index;
  va_list ap;
  va_start(ap, indices);
  index = flatten_multivector_indices(sc, vector, indices, ap);
  return(vector_getter(vector)(sc, vector, index));
}

s7_pointer s7_vector_set_n(s7_scheme *sc, s7_pointer vector, s7_pointer value, s7_int indices, ...)
{
  s7_int index;
  va_list ap;
  va_start(ap, indices);
  index = flatten_multivector_indices(sc, vector, indices, ap);
  if (is_typed_vector(vector))
    return(typed_vector_setter(sc, vector, index, value));
  return(vector_setter(vector)(sc, vector, index, value));
}


/* -------------------------------- vector->list -------------------------------- */
s7_pointer s7_vector_to_list(s7_scheme *sc, s7_pointer vect)
{
  s7_int i, len;
  s7_pointer result;
  len = vector_length(vect);
  if (len == 0)
    return(sc->nil);
  check_heap_size(sc, len);
  sc->v = sc->nil;
  for (i = len - 1; i >= 0; i--)
    sc->v = cons_unchecked(sc, vector_getter(vect)(sc, vect, i), sc->v);
  result = sc->v;
  sc->v = sc->nil;
  return(result);
}

#if (!WITH_PURE_S7)
/* -------------------------------- vector->list -------------------------------- */
static s7_pointer g_vector_to_list(s7_scheme *sc, s7_pointer args)
{
  s7_int i, start = 0, end;
  s7_pointer p, vec;
  #define H_vector_to_list "(vector->list v (start 0) end) returns the elements of the vector v as a list; (map values v)"
  #define Q_vector_to_list s7_make_signature(sc, 4, sc->is_proper_list_symbol, sc->is_vector_symbol, sc->is_integer_symbol, sc->is_integer_symbol)

  vec = car(args);
  if (!is_any_vector(vec))
    return(method_or_bust_one_arg(sc, vec, sc->vector_to_list_symbol, args, T_VECTOR));

  end = vector_length(vec);
  if (!is_null(cdr(args)))
    {
      p = start_and_end(sc, sc->vector_to_list_symbol, args, 2, &start, &end);
      if (p != sc->unused) return(p);
      if (start == end) return(sc->nil);
    }
  if ((end - start) > sc->max_list_length)
    return(out_of_range(sc, sc->vector_to_list_symbol, small_int(1), car(args), its_too_large_string));

  if ((start == 0) && (end == vector_length(vec)))
    return(s7_vector_to_list(sc, vec));

  sc->w = sc->nil;
  for (i = end - 1; i >= start; i--)
    sc->w = cons(sc, vector_getter(vec)(sc, vec, i), sc->w);
  p = sc->w;
  sc->w = sc->nil;
  return(p);
}

static s7_pointer vector_to_list_p_p(s7_scheme *sc, s7_pointer p)
{
  s7_pointer val;
  sc->temp7 = list_1(sc, p);
  val = g_vector_to_list(sc, sc->temp7);
  sc->temp7 = sc->nil;
  return(val);
}
#endif


s7_pointer s7_make_and_fill_vector(s7_scheme *sc, s7_int len, s7_pointer fill)
{
  s7_pointer vect;
  vect = make_simple_vector(sc, len);
  s7_vector_fill(sc, vect, fill);
  return(vect);
}


/* -------------------------------- string->byte-vector -------------------------------- */
static s7_pointer g_string_to_byte_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_string_to_byte_vector "(string->byte-vector obj) turns a string into a byte-vector."
  #define Q_string_to_byte_vector s7_make_signature(sc, 2, sc->is_byte_vector_symbol, sc->is_string_symbol)
  s7_pointer str;

  str = car(args);
  if (!is_string(str))
    return(method_or_bust(sc, str, sc->string_to_byte_vector_symbol, list_1(sc, str), T_STRING, 1));
  if (is_immutable_string(str))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->string_to_byte_vector_symbol, str)));

  return(s7_copy_1(sc, sc->string_to_byte_vector_symbol, set_plist_2(sc, str, make_simple_byte_vector(sc, string_length(str)))));
}


/* -------------------------------- byte-vector->string -------------------------------- */
static s7_pointer g_byte_vector_to_string(s7_scheme *sc, s7_pointer args)
{
  #define H_byte_vector_to_string "(byte-vector->string obj) turns a byte-vector into a string."
  #define Q_byte_vector_to_string s7_make_signature(sc, 2, sc->is_string_symbol, sc->is_byte_vector_symbol)
  s7_pointer v;

  v = car(args);
  if (!is_byte_vector(v))
    return(method_or_bust(sc, v, sc->byte_vector_to_string_symbol, list_1(sc, v), T_BYTE_VECTOR, 1));
  if (is_immutable_vector(v))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->byte_vector_to_string_symbol, v)));

  return(s7_copy_1(sc, sc->byte_vector_to_string_symbol, set_plist_2(sc, v, make_empty_string(sc, byte_vector_length(v), 0))));
}


/* -------------------------------- vector -------------------------------- */
static s7_pointer g_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_vector "(vector ...) returns a vector whose elements are the arguments"
  #define Q_vector s7_make_circular_signature(sc, 1, 2, sc->is_vector_symbol, sc->T)

  s7_int len;
  s7_pointer vec;

  len = safe_list_length(args); /* was s7_list_length but don't we ensure that arglists are proper? */
  vec = make_simple_vector(sc, len);
  if (len > 0)
    {
      s7_int i;
      s7_pointer x;
      for (x = args, i = 0; is_pair(x); x = cdr(x), i++)
	vector_element(vec, i) = car(x);
    }
  return(vec);
}


/* -------------------------------- float-vector? -------------------------------- */
static s7_pointer g_is_float_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_is_float_vector "(float-vector? obj) returns #t if obj is an homogeneous float vector"
  #define Q_is_float_vector sc->pl_bt
  check_boolean_method(sc, s7_is_float_vector, sc->is_float_vector_symbol, args);
}


/* -------------------------------- float-vector -------------------------------- */
static s7_pointer g_float_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_float_vector "(float-vector ...) returns an homogeneous float vector whose elements are the arguments"
  #define Q_float_vector s7_make_circular_signature(sc, 1, 2, sc->is_float_vector_symbol, sc->is_real_symbol)

  s7_int len;
  s7_pointer vec;

  len = safe_list_length(args);
  vec = make_simple_float_vector(sc, len);
  if (len > 0)
    {
      s7_int i;
      s7_pointer x;
      sc->w = vec;
      for (x = args, i = 0; is_pair(x); x = cdr(x), i++)
	{
	  s7_pointer p;
	  p = car(x);
	  if (is_t_real(p))
	    float_vector(vec, i) = real(p);
	  else
	    {
	      if (s7_is_real(p))                         /* bignum is ok here */
		float_vector(vec, i) = s7_real(p);
	      else
		{
		  sc->w = sc->nil;
		  return(method_or_bust(sc, p, sc->float_vector_symbol, copy_list(sc, args), T_REAL, i + 1));
		}
	    }
	}
      sc->w = sc->nil;
    }
  return(vec);
}

static s7_pointer float_vector_p_d(s7_scheme *sc, s7_double x)
{
  s7_pointer vec;
  vec = make_simple_float_vector(sc, 1);
  float_vector(vec, 0) = x;
  return(vec);
}


/* -------------------------------- int-vector? -------------------------------- */
static s7_pointer g_is_int_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_is_int_vector "(int-vector? obj) returns #t if obj is an homogeneous s7_int vector"
  #define Q_is_int_vector sc->pl_bt
  check_boolean_method(sc, is_int_vector, sc->is_int_vector_symbol, args);
}


/* -------------------------------- int-vector -------------------------------- */
static s7_pointer g_int_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_int_vector "(int-vector ...) returns an homogeneous s7_int vector whose elements are the arguments"
  #define Q_int_vector s7_make_circular_signature(sc, 1, 2, sc->is_int_vector_symbol, sc->is_integer_symbol)

  s7_int len;
  s7_pointer vec;

  len = safe_list_length(args);
  vec = make_simple_int_vector(sc, len);
  if (len > 0)
    {
      s7_int i;
      s7_pointer x;
      for (x = args, i = 0; is_pair(x); x = cdr(x), i++)
	{
	  s7_pointer p;
	  p = car(x);
	  if (is_t_integer(p))
	    int_vector(vec, i) = integer(p);
	  else
	    {
#if WITH_GMP
	      if (is_t_big_integer(p))
		int_vector(vec, i) = big_integer_to_s7_int(big_integer(p));
	      else
#endif
		return(method_or_bust(sc, p, sc->int_vector_symbol, copy_list(sc, args), T_INTEGER, i + 1));
	    }
	}
    }
  return(vec);
}

static s7_pointer int_vector_p_i(s7_scheme *sc, s7_int x)
{
  s7_pointer vec;
  vec = make_simple_int_vector(sc, 1);
  int_vector(vec, 0) = x;
  return(vec);
}


/* -------------------------------- byte-vector? -------------------------------- */
static s7_pointer g_is_byte_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_is_byte_vector "(byte-vector? obj) returns #t if obj is a byte-vector"
  #define Q_is_byte_vector sc->pl_bt

  check_boolean_method(sc, s7_is_byte_vector, sc->is_byte_vector_symbol, args);
}


/* -------------------------------- byte-vector -------------------------------- */
static s7_pointer g_byte_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_byte_vector "(byte-vector ...) returns a byte-vector whose elements are the arguments"
  #define Q_byte_vector s7_make_circular_signature(sc, 1, 2, sc->is_byte_vector_symbol, sc->is_byte_symbol)

  s7_int i, len;
  s7_pointer vec, x;
  uint8_t *str;

  len = s7_list_length(sc, args);
  vec = make_simple_byte_vector(sc, len);
  str = byte_vector_bytes(vec);

  for (i = 0, x = args; is_pair(x); i++, x = cdr(x))
    {
      s7_pointer byte;
      s7_int b;
      byte = car(x);
      if (is_t_integer(byte))
	b = integer(byte);
      else
	{
#if WITH_GMP
	  if (is_t_big_integer(byte))
	    b = big_integer_to_s7_int(big_integer(byte));
	  else
#endif
	    return(method_or_bust(sc, byte, sc->byte_vector_symbol, copy_list(sc, args), T_INTEGER, i + 1));
	}
      if ((b < 0) || (b > 255))
	return(simple_wrong_type_argument_with_type(sc, sc->byte_vector_symbol, byte, an_unsigned_byte_string));
      str[i] = (uint8_t)b;
    }
  return(vec);
}


#if (!WITH_PURE_S7)
/* -------------------------------- list->vector -------------------------------- */
static s7_pointer g_list_to_vector(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  #define H_list_to_vector "(list->vector lst) returns a vector containing the elements of lst; (apply vector lst)"
  #define Q_list_to_vector s7_make_signature(sc, 2, sc->is_vector_symbol, sc->is_proper_list_symbol)

  p = car(args);
  sc->temp3 = p;
  if (is_null(p))
    return(s7_make_vector(sc, 0));

  if (!s7_is_proper_list(sc, p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->list_to_vector_symbol, list_1(sc, p), a_proper_list_string));

  p = g_vector(sc, p);
  sc->temp3 = sc->nil;
  return(p);
}

/* -------------------------------- vector-length -------------------------------- */
static s7_pointer g_vector_length(s7_scheme *sc, s7_pointer args)
{
  s7_pointer vec;
  #define H_vector_length "(vector-length v) returns the length of vector v"
  #define Q_vector_length s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_vector_symbol)

  vec = car(args);
  if (!is_any_vector(vec))
    return(method_or_bust_one_arg(sc, vec, sc->vector_length_symbol, args, T_VECTOR));

  return(make_integer(sc, vector_length(vec)));
}

static s7_int vector_length_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_any_vector(p))
    return(integer(method_or_bust_one_arg(sc, p, sc->vector_length_symbol, list_1(sc, p), T_VECTOR)));
  return(vector_length(p));
}
#endif


/* -------------------------------- subvector subvector? subvector-vector subvector-position -------------------------------- */

static bool s7_is_subvector(s7_pointer g) {return((is_any_vector(g)) && (is_subvector(g)));}

static s7_pointer g_is_subvector(s7_scheme *sc, s7_pointer args)
{
  #define H_is_subvector "(subvector? obj) returns #t if obj is a subvector"
  #define Q_is_subvector sc->pl_bt

  check_boolean_method(sc, s7_is_subvector, sc->is_subvector_symbol, args);
}

static s7_pointer g_subvector_position(s7_scheme *sc, s7_pointer args)
{
  #define H_subvector_position "(subvector-position obj) returns obj's offset"
  #define Q_subvector_position s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_subvector_symbol)

  s7_pointer sv;
  sv = car(args);
  if (s7_is_subvector(sv))
    return(make_integer(sc, (s7_int)(vector_elements(sv) - vector_elements(subvector_vector(sv)))));

  return(method_or_bust_one_arg(sc, sv, sc->subvector_position_symbol, args, T_VECTOR));
}

static s7_pointer g_subvector_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_subvector_vector "(subvector-vector obj) returns the vector underlying the subvector obj"
  #define Q_subvector_vector s7_make_signature(sc, 2, sc->is_vector_symbol, sc->is_subvector_symbol)

  if (s7_is_subvector(car(args)))
    return(subvector_vector(car(args)));
  return(method_or_bust_one_arg(sc, car(args), sc->subvector_vector_symbol, args, T_VECTOR));
}

static s7_pointer subvector(s7_scheme *sc, s7_pointer vect, s7_int skip_dims, s7_int index)
{
  s7_pointer x;
  s7_int dims;

  new_cell(sc, x, (typeflag(vect) & (~T_COLLECTED)) | T_SUBVECTOR | T_SAFE_PROCEDURE);
  vector_length(x) = 0;
  vector_block(x) = mallocate_vector(sc, 0);
  vector_elements(x) = NULL;
  vector_getter(x) = vector_getter(vect);
  vector_setter(x) = vector_setter(vect);

  dims = vector_ndims(vect) - skip_dims;
  if (dims > 1)
    {
      vdims_t *v;
      v = (vdims_t *)mallocate_block(sc);
      vdims_rank(v) = dims;
      vdims_dims(v) = (s7_int *)(vector_dimensions(vect) + skip_dims);
      vdims_offsets(v) = (s7_int *)(vector_offsets(vect) + skip_dims);
      vdims_original(v) = vect;
      vector_elements_should_be_freed(v) = false;
      vector_set_dimension_info(x, v);
    }
  else
    {
      vector_set_dimension_info(x, NULL);
      subvector_set_vector(x, vect);
    }

  if (is_normal_vector(vect))
    mark_function[T_VECTOR] = mark_vector_possibly_shared;
  else mark_function[type(vect)] = mark_int_or_float_vector_possibly_shared;

  if (skip_dims > 0)
    vector_length(x) = vector_offset(vect, skip_dims - 1);
  else vector_length(x) = vector_length(vect);

  if (is_int_vector(vect))
    int_vector_ints(x) = (s7_int *)(int_vector_ints(vect) + index);
  else
    {
      if (is_float_vector(vect))
	float_vector_floats(x) = (s7_double *)(float_vector_floats(vect) + index);
      else
	{
	  if (is_normal_vector(vect))
	    vector_elements(x) = (s7_pointer *)(vector_elements(vect) + index);
	  else byte_vector_bytes(x) = (uint8_t *)(byte_vector_bytes(vect) + index);
	}
    }
  add_multivector(sc, x);
  return(x);
}

static inline vdims_t *list_to_dims(s7_scheme *sc, s7_pointer x)
{
  s7_int i, offset, len;
  s7_pointer y;
  vdims_t *v;
  s7_int *ds, *os;

  len = safe_list_length(x);
  v = (vdims_t *)mallocate(sc, len * 2 * sizeof(s7_int));
  vdims_rank(v) = len;
  vdims_offsets(v) = (s7_int *)(vdims_dims(v) + len);
  vector_elements_should_be_freed(v) = false;
  ds = vdims_dims(v);
  os = vdims_offsets(v);

  for (i = 0, y = x; is_not_null(y); i++, y = cdr(y))
    ds[i] = s7_integer(car(y));

  for (i = len - 1, offset = 1; i >= 0; i--)
    {
      os[i] = offset;
      offset *= ds[i];
    }
  return(v);
}

static s7_pointer g_subvector(s7_scheme *sc, s7_pointer args)
{
  #define H_subvector "(subvector original-vector new-dimensions (offset 0)) returns \
a vector that points to the same elements as the original-vector but with different dimensional info."
  #define Q_subvector s7_make_signature(sc, 4, sc->is_subvector_symbol, sc->is_vector_symbol, s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_integer_symbol), sc->is_integer_symbol)

  /* (let ((v1 #2d((1 2 3) (4 5 6)))) (let ((v2 (subvector v1 '(6)))) v2)) -> #(1 2 3 4 5 6)
   * (let ((v1 #(1 2 3 4 5 6))) (let ((v2 (subvector v1 '(3 2)))) v2)) -> #2D((1 2) (3 4) (5 6))
   */
  s7_pointer orig, dims, x;
  vdims_t *v;
  s7_int new_len, orig_len, offset = 0;

  orig = car(args);
  if (!is_any_vector(orig))
    return(method_or_bust(sc, orig, sc->subvector_symbol, args, T_VECTOR, 1));

  orig_len = vector_length(orig);

  if (!is_null(cddr(args)))
    {
      s7_pointer off;
      off = caddr(args);
      if (!s7_is_integer(off))
	return(method_or_bust(sc, off, sc->subvector_symbol, args, T_INTEGER, 3));
      offset = s7_integer(off);
      if ((offset < 0) ||
	  (offset >= orig_len))  /* we need this if, for example, offset == 9223372036854775807 */
	return(out_of_range(sc, sc->subvector_symbol, small_int(3), off, (offset < 0) ? its_negative_string : its_too_large_string));
    }

  dims = cadr(args);
  if (is_t_integer(dims))
    {
      new_len = s7_integer(dims);
      if ((new_len > orig_len) || (new_len > sc->max_vector_length)) /* (subvector (make-vector 3) most-positive-fixnum 1) ! */
	return(out_of_range(sc, sc->subvector_symbol, small_int(2), dims, its_too_large_string));
      if ((new_len < 0) ||
	  ((new_len + offset) > orig_len))
	return(out_of_range(sc, sc->subvector_symbol, small_int(2), dims, (new_len < 0) ? its_negative_string : its_too_large_string));
      v = NULL;
    }
  else
    {
      s7_pointer y;
      s7_int i;
      if ((is_null(dims)) ||
	  (!s7_is_proper_list(sc, dims)))
	return(method_or_bust(sc, dims, sc->subvector_symbol, args, T_PAIR, 2));

      for (y = dims; is_pair(y); y = cdr(y))
	if ((!s7_is_integer(car(y)))        ||       /* (subvector v '((1 2) (3 4))) */
	    (s7_integer(car(y)) > orig_len) ||
	    (s7_integer(car(y)) < 0))
	  return(s7_error(sc, sc->wrong_type_arg_symbol,
			  set_elist_1(sc, wrap_string(sc, "subvector: new dimensions should be a list of integers that fits the original vector", 84))));

      v = list_to_dims(sc, dims);

      new_len = vdims_dims(v)[0];
      for (i = 1; i < vdims_rank(v); i++)
	new_len *= vdims_dims(v)[i];
      if ((new_len < 0) ||
	  ((new_len + offset) > vector_length(orig)))
	{
	  liberate(sc, v);
	  return(out_of_range(sc, sc->subvector_symbol, small_int(2), dims,
			      wrap_string(sc, "a subvector has to fit in the original vector", 45)));
	}
      vdims_original(v) = orig;
    }

  if (is_normal_vector(orig))
    mark_function[T_VECTOR] = mark_vector_possibly_shared;
  else mark_function[type(orig)] = mark_int_or_float_vector_possibly_shared; /* I think this works for byte-vectors also */

  new_cell(sc, x, (typeflag(orig) & (~T_COLLECTED)) | T_SUBVECTOR | T_SAFE_PROCEDURE);

  vector_block(x) = mallocate_vector(sc, 0);
  vector_set_dimension_info(x, v);
  if (!v) subvector_set_vector(x, orig);
  vector_length(x) = new_len;                 /* might be less than original length */
  if ((new_len == 0) && (is_normal_vector(orig))) set_has_simple_elements(x);
  vector_getter(x) = vector_getter(orig);
  vector_setter(x) = vector_setter(orig);

  if (is_int_vector(orig))
    int_vector_ints(x) = (s7_int *)(int_vector_ints(orig) + offset);
  else
    {
      if (is_float_vector(orig))
	float_vector_floats(x) = (s7_double *)(float_vector_floats(orig) + offset);
      else
	{
	  if (is_normal_vector(x))
	    vector_elements(x) = (s7_pointer *)(vector_elements(orig) + offset);
	  else byte_vector_bytes(x) = (uint8_t *)(byte_vector_bytes(orig) + offset);
	}
    }

  add_multivector(sc, x);
  return(x);
}


/* -------------------------------- vector-ref -------------------------------- */
static s7_pointer vector_ref_1(s7_scheme *sc, s7_pointer vect, s7_pointer indices)
{
  s7_int index = 0;
  if (vector_length(vect) == 0)
    return(out_of_range(sc, sc->vector_ref_symbol, small_int(1), vect, its_too_large_string));

  if (vector_rank(vect) > 1)
    {
      s7_int i;
      s7_pointer x;
      for (x = indices, i = 0; (is_not_null(x)) && (i < vector_ndims(vect)); x = cdr(x), i++)
	{
	  s7_int n;
	  s7_pointer p;
	  p = car(x);
	  if (!s7_is_integer(p))
	    return(method_or_bust(sc, p, sc->vector_ref_symbol, cons(sc, vect, indices), T_INTEGER, i + 2));
          n = s7_integer(p);
	  if ((n < 0) ||
	      (n >= vector_dimension(vect, i)))
	    return(out_of_range(sc, sc->vector_ref_symbol, wrap_integer1(sc, i + 2), p, (n < 0) ? its_negative_string : its_too_large_string));

	  index += n * vector_offset(vect, i);
	}
      if (is_not_null(x))
	{
	  s7_pointer nv;
	  if (!is_normal_vector(vect))
	    return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), indices, too_many_indices_string));
	  nv = vector_element(vect, index);
	  return(implicit_index(sc, nv, x));
	}

      /* if not enough indices, return a subvector covering whatever is left */
      if (i < vector_ndims(vect))
	return(subvector(sc, vect, i, index));
    }
  else
    {
      s7_pointer p;
      /* (let ((hi (make-vector 3 0.0)) (sum 0.0)) (do ((i 0 (+ i 1))) ((= i 3)) (set! sum (+ sum (hi i)))) sum) */
      p = car(indices);

      if (!s7_is_integer(p))
	return(method_or_bust(sc, p, sc->vector_ref_symbol, cons(sc, vect, indices), T_INTEGER, 2));
      index = s7_integer(p);

      if ((index < 0) ||
	  (index >= vector_length(vect)))
	return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), p, (index < 0) ? its_negative_string : its_too_large_string));

      if (is_not_null(cdr(indices)))                /* (let ((L #(#(1 2 3) #(4 5 6)))) (vector-ref L 1 2)) */
	{
	  s7_pointer nv;
	  if (!is_normal_vector(vect))
	    return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), indices, too_many_indices_string));
	  nv = vector_element(vect, index);
	  return(implicit_index(sc, nv, cdr(indices)));
	}
    }
  return((vector_getter(vect))(sc, vect, index));
}

static s7_pointer g_vector_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_vector_ref "(vector-ref v ... i) returns the i-th element of vector v."
  #define Q_vector_ref s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_vector_symbol, sc->is_integer_symbol)

  s7_pointer vec;

  vec = car(args);
  if (!is_any_vector(vec))
    return(method_or_bust(sc, vec, sc->vector_ref_symbol, args, T_VECTOR, 1));
  return(vector_ref_1(sc, vec, cdr(args))); /* 19-Jan-19 */
}

static s7_pointer g_vector_ref_ic_n(s7_scheme *sc, s7_pointer args, s7_int index)
{
  s7_pointer vec;
  vec = lookup(sc, car(args));
  if (!is_any_vector(vec))
    return(method_or_bust(sc, vec, sc->vector_ref_symbol, list_2(sc, vec, cadr(args)), T_VECTOR, 1));

  if (index >= vector_length(vec))
    return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), cadr(args), its_too_large_string));
  if (vector_rank(vec) > 1)
    {
      if (index >= vector_dimension(vec, 0))
	return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), cadr(args), its_too_large_string));
      return(subvector(sc, vec, 1, index * vector_offset(vec, 0)));
    }
  return(vector_getter(vec)(sc, vec, index));
}

static s7_pointer vector_ref_p_pi(s7_scheme *sc, s7_pointer v, s7_int i)
{
  if ((!is_any_vector(v)) ||
      (vector_rank(v) > 1) ||
      (i < 0) ||
      (i >= vector_length(v)))
    return(g_vector_ref(sc, set_plist_2(sc, v, make_integer(sc, i))));
  return(vector_getter(v)(sc, v, i));
}

static s7_pointer vector_ref_p_pi_direct(s7_scheme *sc, s7_pointer v, s7_int i)
{
  if ((i >= 0) && (i < vector_length(v)))
    return(vector_getter(v)(sc, v, i));
  out_of_range(sc, sc->vector_ref_symbol, small_int(2), wrap_integer1(sc, i), (i < 0) ? its_negative_string : its_too_large_string);
  return(v);
}

static s7_pointer vector_ref_p_pii(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2)
{
  if ((!is_any_vector(v)) ||
      (vector_rank(v) != 2) ||
      (i1 < 0) || (i2 < 0) ||
      (i1 >= vector_dimension(v, 0)) ||
      (i2 >= vector_dimension(v, 1)))
    return(g_vector_ref(sc, set_plist_3(sc, v, make_integer(sc, i1), make_integer(sc, i2))));
  return(vector_getter(v)(sc, v, i2 + (i1 * vector_offset(v, 0))));
}

static s7_pointer vector_ref_p_pii_direct(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2)
{
  if ((i1 < 0) || (i2 < 0) ||
      (i1 >= vector_dimension(v, 0)) ||
      (i2 >= vector_dimension(v, 1)))
    return(g_vector_ref(sc, set_plist_3(sc, v, make_integer(sc, i1), make_integer(sc, i2))));
  return(vector_element(v, i2 + (i1 * vector_offset(v, 0))));
}

/* this is specific to T_VECTOR */
static s7_pointer vector_ref_unchecked(s7_scheme *sc, s7_pointer v, s7_int i)
{
#if S7_DEBUGGING
  if (!is_normal_vector(v))
    fprintf(stderr, "%s[%d]: vector is not T_VECTOR\n", __func__, __LINE__);
#endif
  return(vector_element(v, i));
}

static s7_pointer g_vector_ref_ic(s7_scheme *sc, s7_pointer args) {return(g_vector_ref_ic_n(sc, args, s7_integer(cadr(args))));}
static s7_pointer g_vector_ref_ic_0(s7_scheme *sc, s7_pointer args) {return(g_vector_ref_ic_n(sc, args, 0));}
static s7_pointer g_vector_ref_ic_1(s7_scheme *sc, s7_pointer args) {return(g_vector_ref_ic_n(sc, args, 1));}
static s7_pointer g_vector_ref_ic_2(s7_scheme *sc, s7_pointer args) {return(g_vector_ref_ic_n(sc, args, 2));}
static s7_pointer g_vector_ref_ic_3(s7_scheme *sc, s7_pointer args) {return(g_vector_ref_ic_n(sc, args, 3));}

static inline s7_pointer vector_ref_p_pp(s7_scheme *sc, s7_pointer vec, s7_pointer ind)
{
  s7_int index;
  if ((!is_any_vector(vec)) ||
      (vector_rank(vec) != 1) ||
      (!s7_is_integer(ind)))
    return(g_vector_ref(sc, set_plist_2(sc, vec, ind)));
  index = s7_integer(ind);
  if ((index < 0) || (index >= vector_length(vec)))
    return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), ind, (index < 0) ? its_negative_string : its_too_large_string));
  return(vector_getter(vec)(sc, vec, index));
}

static s7_pointer g_vector_ref_2(s7_scheme *sc, s7_pointer args) {return(vector_ref_p_pp(sc, car(args), cadr(args)));}

static s7_pointer g_vector_ref_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer vec, i1, i2;
  s7_int ix, iy;

  vec = car(args);
  if (!is_any_vector(vec))
    return(g_vector_ref(sc, args));
  if (vector_rank(vec) != 2)
    return(g_vector_ref(sc, args));

  i1 = cadr(args);
  if (!s7_is_integer(i1))
    return(g_vector_ref(sc, args));
  i2 = caddr(args);
  if (!s7_is_integer(i2))
    return(g_vector_ref(sc, args));
  ix = s7_integer(i1);
  iy = s7_integer(i2);
  if ((ix >= 0) &&
      (iy >= 0) &&
      (ix < vector_dimension(vec, 0)) &&
      (iy < vector_dimension(vec, 1)))
    {
      s7_int index;
      index = (ix * vector_offset(vec, 0)) + iy; /* vector_offset(vec, 1) == 1 */
      return(vector_getter(vec)(sc, vec, index));
    }
  return(g_vector_ref(sc, args));
}

static s7_pointer g_vector_ref_2_direct(s7_scheme *sc, s7_pointer args)
{
  s7_pointer vec, ind;
  s7_int index;
  vec = car(args);
  ind = cadr(args);
  if (!s7_is_integer(ind))
    return(method_or_bust(sc, ind, sc->vector_ref_symbol, args, T_INTEGER, 2));
  index = s7_integer(ind);
  if ((index < 0) || (index >= vector_length(vec)))
    return(out_of_range(sc, sc->vector_ref_symbol, small_int(2), ind, (index < 0) ? its_negative_string : its_too_large_string));
  return(vector_element(vec, index));
}


/* -------------------------------- vector-set! -------------------------------- */
static s7_pointer g_vector_set(s7_scheme *sc, s7_pointer args)
{
  #define H_vector_set "(vector-set! v i ... value) sets the i-th element of vector v to value."
  #define Q_vector_set s7_make_circular_signature(sc, 3, 4, sc->T, sc->is_vector_symbol, sc->is_integer_symbol, sc->is_integer_or_any_at_end_symbol)

  s7_pointer vec, val;
  s7_int index;

  vec = car(args);
  if (!is_any_vector(vec))
    return(method_or_bust(sc, vec, sc->vector_set_symbol, args, T_VECTOR, 1));
  if (is_immutable_vector(vec))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->vector_set_symbol, vec)));

  if (vector_length(vec) == 0)
    return(out_of_range(sc, sc->vector_set_symbol, small_int(1), vec, its_too_large_string));

  if (vector_rank(vec) > 1)
    {
      s7_int i;
      s7_pointer x;
      index = 0;
      for (x = cdr(args), i = 0; (is_not_null(cdr(x))) && (i < vector_ndims(vec)); x = cdr(x), i++)
	{
	  s7_int n;
	  s7_pointer p;
	  p = car(x);
	  if (!s7_is_integer(p))
	    return(method_or_bust(sc, p, sc->vector_set_symbol, args, T_INTEGER, i + 2));
          n = s7_integer(p);
	  if ((n < 0) ||
	      (n >= vector_dimension(vec, i)))
	    return(out_of_range(sc, sc->vector_set_symbol, wrap_integer1(sc, i + 2), p, (n < 0) ? its_negative_string : its_too_large_string));

	  index += n * vector_offset(vec, i);
	}

      if (is_not_null(cdr(x)))
	return(s7_wrong_number_of_args_error(sc, "too many args for vector-set!: ~S", args));
      if (i != vector_ndims(vec))
	return(s7_wrong_number_of_args_error(sc, "not enough args for vector-set!: ~S", args));

      val = car(x);
    }
  else
    {
      s7_pointer p;
      p = cadr(args);
      if (!s7_is_integer(p))
	return(method_or_bust(sc, p, sc->vector_set_symbol, args, T_INTEGER, 2));
      index = s7_integer(p);
      if ((index < 0) ||
	  (index >= vector_length(vec)))
	return(out_of_range(sc, sc->vector_set_symbol, small_int(2), p, (index < 0) ? its_negative_string : its_too_large_string));

      if (is_not_null(cdddr(args)))
	{
	  set_car(sc->temp_cell_2, vector_getter(vec)(sc, vec, index));
	  if (!is_any_vector(car(sc->temp_cell_2)))
	    return(s7_wrong_number_of_args_error(sc, "too many args for vector-set!: ~S", args));
	  set_cdr(sc->temp_cell_2, cddr(args));
	  return(g_vector_set(sc, sc->temp_cell_2));
	}
      val = caddr(args);
    }

  if (is_typed_vector(vec))
    {
      if ((sc->safety < 0) || /* or == 0?? */
	  (c_function_call(typed_vector_typer(vec))(sc, set_plist_1(sc, val)) != sc->F))
	{
	  vector_element(vec, index) = val;
	  return(val);
	}
      return(s7_wrong_type_arg_error(sc, "vector-set!", 3, val,
				     make_type_name(sc, c_function_name(typed_vector_typer(vec)), INDEFINITE_ARTICLE)));
    }

  vector_setter(vec)(sc, vec, index, val);
  return(val);
}

static s7_pointer vector_set_p_pip(s7_scheme *sc, s7_pointer v, s7_int i, s7_pointer p)
{
  if ((!is_any_vector(v)) ||
      (vector_rank(v) > 1) ||
      (i < 0) ||
      (i >= vector_length(v)))
    return(g_vector_set(sc, set_plist_3(sc, v, make_integer(sc, i), p)));

  if (is_typed_vector(v))
    return(typed_vector_setter(sc, v, i, p));

  vector_setter(v)(sc, v, i, p);
  return(p);
}

static s7_pointer vector_set_p_pip_direct(s7_scheme *sc, s7_pointer v, s7_int i, s7_pointer p)
{
  if ((i >= 0) && (i < vector_length(v)))
    vector_element(v, i) = p;
  else out_of_range(sc, sc->vector_set_symbol, small_int(2), wrap_integer1(sc, i), (i < 0) ? its_negative_string : its_too_large_string);
  return(p);
}

static s7_pointer vector_set_p_piip(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2, s7_pointer p)
{
  if ((!is_any_vector(v)) ||
      (vector_rank(v) != 2) ||
      (i1 < 0) || (i2 < 0) ||
      (i1 >= vector_dimension(v, 0)) ||
      (i2 >= vector_dimension(v, 1)))
    return(g_vector_set(sc, set_elist_4(sc, v, make_integer(sc, i1), make_integer(sc, i2), p)));

  if (is_typed_vector(v))
    return(typed_vector_setter(sc, v, i2 + (i1 * vector_offset(v, 0)), p));

  vector_setter(v)(sc, v, i2 + (i1 * vector_offset(v, 0)), p);
  return(p);
}

static s7_pointer vector_set_p_piip_direct(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2, s7_pointer p)
{
  /* normal untyped vector, rank == 2 */
  if ((i1 < 0) || (i2 < 0) ||
      (i1 >= vector_dimension(v, 0)) ||
      (i2 >= vector_dimension(v, 1)))
    return(g_vector_set(sc, set_elist_4(sc, v, make_integer(sc, i1), make_integer(sc, i2), p)));
  vector_element(v, i2 + (i1 * vector_offset(v, 0))) = p;
  return(p);
}

static s7_pointer typed_vector_set_p_pip_direct(s7_scheme *sc, s7_pointer v, s7_int i, s7_pointer p)
{
  if ((i >= 0) && (i < vector_length(v)))
    typed_vector_setter(sc, v, i, p);
  else out_of_range(sc, sc->vector_set_symbol, small_int(2), wrap_integer1(sc, i), (i < 0) ? its_negative_string : its_too_large_string);
  return(p);
}

static s7_pointer typed_vector_set_p_piip_direct(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2, s7_pointer p)
{
  if ((i1 < 0) || (i2 < 0) ||
      (i1 >= vector_dimension(v, 0)) ||
      (i2 >= vector_dimension(v, 1)))
    return(g_vector_set(sc, set_elist_4(sc, v, make_integer(sc, i1), make_integer(sc, i2), p)));
  return(typed_vector_setter(sc, v, i2 + (i1 * vector_offset(v, 0)), p));
}

static s7_pointer vector_set_unchecked(s7_scheme *sc, s7_pointer v, s7_int i, s7_pointer p)
{
  vector_element(v, i) = p;
  return(p);
}

static s7_pointer typed_vector_set_unchecked(s7_scheme *sc, s7_pointer v, s7_int i, s7_pointer p)
{
  typed_vector_setter(sc, v, i, p);
  return(p);
}

static s7_pointer g_vector_set_3(s7_scheme *sc, s7_pointer args)
{
  /* (vector-set! vector index value) */
  s7_pointer ind, vec, val;
  s7_int index;

  vec = car(args);
  if (!is_any_vector(vec))
    return(g_vector_set(sc, args));
  if (is_immutable_vector(vec))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->vector_set_symbol, vec)));
  if (vector_rank(vec) > 1)
    return(g_vector_set(sc, args));

  ind = cadr(args);
  if (!s7_is_integer(ind))
    return(g_vector_set(sc, args));
  index = s7_integer(ind);
  if ((index < 0) ||
      (index >= vector_length(vec)))
    return(out_of_range(sc, sc->vector_set_symbol, small_int(2), wrap_integer1(sc, index), (index < 0) ? its_negative_string : its_too_large_string));

  val = caddr(args);
  if (is_typed_vector(vec))
    return(typed_vector_setter(sc, vec, index, val));

  vector_setter(vec)(sc, vec, index, val);
  return(val);
}

static s7_pointer g_vector_set_4(s7_scheme *sc, s7_pointer args)
{
  s7_pointer v, ip1, ip2, val;
  s7_int i1, i2;
  v = car(args);
  ip1 = cadr(args);
  ip2 = caddr(args);
  if ((!is_any_vector(v)) ||
      (vector_rank(v) != 2) ||
      (is_immutable(v)) ||
      (!s7_is_integer(ip1)) ||
      (!s7_is_integer(ip2)))
    return(g_vector_set(sc, args));
  i1 = s7_integer(ip1);
  i2 = s7_integer(ip2);
  if ((i1 < 0) || (i2 < 0) ||
      (i1 >= vector_dimension(v, 0)) ||
      (i2 >= vector_dimension(v, 1)))
    return(g_vector_set(sc, args));
  val = cadddr(args);
  if (is_typed_vector(v))
    return(typed_vector_setter(sc, v, i2 + (i1 * vector_offset(v, 0)), val));
  vector_setter(v)(sc, v, i2 + (i1 * vector_offset(v, 0)), val);
  return(val);
}


/* -------------------------------- make-vector -------------------------------- */

static s7_int multivector_length(s7_scheme *sc, s7_pointer x, s7_pointer caller)
{
  s7_int len, dims;
  s7_pointer y;

  dims = s7_list_length(sc, x);
  if (dims <= 0)                /* 0 if circular, negative if dotted */
    wrong_type_argument_with_type(sc, caller, 1, x, a_proper_list_string);
  if (dims > sc->max_vector_dimensions)
    out_of_range(sc, caller, small_int(1), x, its_too_large_string);

  for (len = 1, y = x; is_pair(y); y = cdr(y))
    {
      if (!s7_is_integer(car(y)))
	wrong_type_argument(sc, caller, position_of(y, x), car(y), T_INTEGER);
#if HAVE_OVERFLOW_CHECKS
      if (multiply_overflow(len, s7_integer(car(y)), &len)) /* or better perhaps len > sc->max_vector_length */
	out_of_range(sc, caller, s7_make_integer(sc, position_of(y, x)), car(y), its_too_large_string);
#else
      len *= s7_integer(car(y));
#endif
      if (len < 0)
	wrong_type_argument_with_type(sc, caller, position_of(y, x), car(y), a_non_negative_integer_string);
    }
  return(len);
}

static inline s7_pointer make_multivector(s7_scheme *sc, s7_pointer vec, s7_pointer x)
{
  vdims_t *v;
  v = list_to_dims(sc, x);
  vdims_original(v) = sc->F;
  vector_set_dimension_info(vec, v);
  add_multivector(sc, vec);
  return(vec);
}

static s7_pointer g_make_vector_1(s7_scheme *sc, s7_pointer args, s7_pointer caller)
{
  s7_int len;
  s7_pointer x, fill, vec, typf;
  int32_t result_type = T_VECTOR;

  fill = sc->unspecified;
  typf = sc->T;
  x = car(args);
  if (s7_is_integer(x))
    {
      len = s7_integer(x);
      if (len < 0)
	return(wrong_type_argument_with_type(sc, caller, 1, x, a_non_negative_integer_string));
    }
  else
    {
      if (!(is_pair(x)))
	return(method_or_bust_with_type(sc, x, caller, args, wrap_string(sc, "an integer or a list of integers", 32), 1));

      if (!s7_is_integer(car(x)))
	return(wrong_type_argument_with_type(sc, caller, 1, car(x), wrap_string(sc, "each dimension should be an integer", 35)));
      if (is_null(cdr(x)))
	len = s7_integer(car(x));
      else len = multivector_length(sc, x, caller);
    }

  if (is_pair(cdr(args)))
    {
      fill = cadr(args);
      if (caller == sc->make_int_vector_symbol)
	result_type = T_INT_VECTOR;
      else
	{
	  if (caller == sc->make_float_vector_symbol)
	    result_type = T_FLOAT_VECTOR;
	  else
	    {
	      if (caller == sc->make_byte_vector_symbol)
		result_type = T_BYTE_VECTOR;
	    }
	}
      if (is_pair(cddr(args)))
	{
	  typf = caddr(args);
	  if ((!is_c_function(typf)) && (typf != sc->T))
	    return(wrong_type_argument_with_type(sc, caller, 3, typf, wrap_string(sc, "a procedure or #t", 17)));
	  if (is_c_function(typf))
	    {
	      if (typf == slot_value(global_slot(sc->is_float_symbol)))
		result_type = T_FLOAT_VECTOR;
	      else
		{
		  if (typf == slot_value(global_slot(sc->is_integer_symbol)))
		    result_type = (WITH_GMP) ? T_VECTOR : T_INT_VECTOR;
		  else
		    {
		      if (typf == slot_value(global_slot(sc->is_byte_symbol)))
			result_type = T_BYTE_VECTOR;
		      else
			{
			  s7_pointer sig;
			  if (!c_function_name(typf))
			    return(wrong_type_argument_with_type(sc, caller, 3, typf, wrap_string(sc, "type procedure must have a name", 31)));
			  if (!c_function_marker(typf))
			    c_function_set_marker(typf, mark_vector_1);
			  if (!c_function_symbol(typf))
			    c_function_symbol(typf) = make_symbol(sc, c_function_name(typf));
			  sig = c_function_signature(typf);
			  if ((sig != sc->pl_bt) &&
			      (is_pair(sig)))
			    {
			      if ((car(sig) != sc->is_boolean_symbol) || (cadr(sig) != sc->T) || (!is_null(cddr(sig))))
				return(wrong_type_argument_with_type(sc, caller, 3, typf, wrap_string(sc, "type is not a boolean procedure", 31)));
			    }}}}}}}
  /* before making the new vector, if fill is specified and the vector is typed, we have to check for a type error.
   *    otherwise we can end up with a vector whose elements are NULL, causing a segfault in the  gc.
   */
  if ((result_type == T_VECTOR) &&
      (is_c_function(typf)) &&
      (c_function_call(typf)(sc, set_plist_1(sc, fill)) == sc->F))
    s7_wrong_type_arg_error(sc, "make-vector", 3, fill, make_type_name(sc, c_function_name(typf), INDEFINITE_ARTICLE));

  vec = make_vector_1(sc, len, NOT_FILLED, result_type);

  if ((result_type == T_VECTOR) &&
      (!s7_is_boolean(typf)))
    {
      set_typed_vector(vec);
      typed_vector_typer(vec) = typf;
      if (c_function_has_simple_elements(typf))
	set_has_simple_elements(vec);
    }

  s7_vector_fill(sc, vec, fill);

  if ((is_pair(x)) &&
      (is_pair(cdr(x))))
    return(make_multivector(sc, vec, x));

  add_vector(sc, vec);
  return(vec);
}

static s7_pointer g_make_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_make_vector "(make-vector len (value #<unspecified>) type) returns a vector of len elements initialized to value. \
To create a multidimensional vector, put the dimension bounds in a list (this is to avoid ambiguities such as \
(make-vector 1 2) where it's not clear whether the '2' is an initial value or a dimension size).  (make-vector '(2 3) 1.0) \
returns a 2 dimensional vector of 6 total elements, all initialized to 1.0."
  #define Q_make_vector s7_make_signature(sc, 4, sc->is_vector_symbol, \
					  s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_pair_symbol), sc->T, \
					  s7_make_signature(sc, 2, sc->is_procedure_symbol, sc->is_boolean_symbol))
  return(g_make_vector_1(sc, args, sc->make_vector_symbol));
}


/* -------------------------------- make-float-vector -------------------------------- */
static s7_pointer g_make_float_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_make_float_vector "(make-float-vector len (init 0.0)) returns a float-vector."
  #define Q_make_float_vector s7_make_signature(sc, 3, sc->is_float_vector_symbol, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_pair_symbol), sc->is_real_symbol)
  s7_int len;
  s7_pointer x, p;
  block_t *arr;

  p = car(args);
  if ((is_pair(cdr(args))) ||
      (!s7_is_integer(p)))      /* (make-float-vector (bignum "3")) */
    {
      s7_pointer init;
      if (is_pair(cdr(args)))
	{
	  init = cadr(args);
	  if (!s7_is_real(init))
	    return(method_or_bust(sc, init, sc->make_float_vector_symbol, args, T_REAL, 2));
#if WITH_GMP
	  if (s7_is_bignum(init))
	    return(g_make_vector_1(sc, set_plist_2(sc, p, wrap_real(sc, s7_real(init))), sc->make_float_vector_symbol));
#endif
	  if (is_rational(init))
	    return(g_make_vector_1(sc, set_plist_2(sc, p, wrap_real(sc, rational_to_double(sc, init))), sc->make_float_vector_symbol));
	}
      else init = real_zero;
      if (s7_is_integer(p))
	len = s7_integer(p);
      else
	{
	  if (!is_pair(p))
	    return(method_or_bust_with_type(sc, p, sc->make_float_vector_symbol, args, wrap_string(sc, "an integer or a list of integers", 32), 1));
	  len = multivector_length(sc, p, sc->make_float_vector_symbol);
	}
      x = make_vector_1(sc, len, NOT_FILLED, T_FLOAT_VECTOR);
      float_vector_fill(sc, x, s7_real(init));
      if (s7_is_integer(p))
	{
	  add_vector(sc, x);
	  return(x);
	}
      return(make_multivector(sc, x, p));
    }

  len = s7_integer(p);
  if (len < 0)
    return(wrong_type_argument_with_type(sc, sc->make_float_vector_symbol, 1, p, a_non_negative_integer_string));
  if (len > sc->max_vector_length)
    return(out_of_range(sc, sc->make_float_vector_symbol, small_int(1), p, its_too_large_string));

  arr = mallocate_vector(sc, len * sizeof(s7_double));
  new_cell(sc, x, T_FLOAT_VECTOR | T_SAFE_PROCEDURE);
  vector_length(x) = len;
  vector_block(x) = arr;
  float_vector_floats(x) = (s7_double *)block_data(arr);
  if (len > 0)
    {
      if (STEP_8(len))
	memclr64((void *)float_vector_floats(x), len * sizeof(s7_double));
      else memclr((void *)float_vector_floats(x), len * sizeof(s7_double));
    }
  vector_set_dimension_info(x, NULL);
  vector_getter(x) = float_vector_getter;
  vector_setter(x) = float_vector_setter;

  add_vector(sc, x);
  return(x);
}


/* -------------------------------- make-int-vector -------------------------------- */
static s7_pointer g_make_int_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_make_int_vector "(make-int-vector len (init 0)) returns an int-vector."
  #define Q_make_int_vector s7_make_signature(sc, 3, sc->is_int_vector_symbol, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_pair_symbol), sc->is_integer_symbol)

  s7_int len;
  s7_pointer x, p;
  block_t *arr;

  p = car(args);
  if ((is_pair(cdr(args))) ||
      (!s7_is_integer(p)))
    {
      s7_pointer init;
      if (is_pair(cdr(args)))
	{
	  init = cadr(args);
	  if (!s7_is_integer(init))
	    return(method_or_bust(sc, init, sc->make_int_vector_symbol, args, T_INTEGER, 2));
	}
      else init = small_int(0);
      if (s7_is_integer(p))
	len = s7_integer(p);
      else
	{
	  if (!is_pair(p))
	    return(method_or_bust_with_type(sc, p, sc->make_int_vector_symbol, args, wrap_string(sc, "an integer or a list of integers", 32), 1));
	  len = multivector_length(sc, p, sc->make_int_vector_symbol);
	}
      x = make_vector_1(sc, len, NOT_FILLED, T_INT_VECTOR);
      int_vector_fill(sc, x, s7_integer(init));
      if (s7_is_integer(p))
	{
	  add_vector(sc, x);
	  return(x);
	}
      return(make_multivector(sc, x, p));
    }

  len = s7_integer(p);
  if (len < 0)
    return(wrong_type_argument_with_type(sc, sc->make_int_vector_symbol, 1, p, a_non_negative_integer_string));
  if (len > sc->max_vector_length)
    return(out_of_range(sc, sc->make_int_vector_symbol, small_int(1), p, its_too_large_string));

  arr = mallocate_vector(sc, len * sizeof(s7_int));
  new_cell(sc, x, T_INT_VECTOR | T_SAFE_PROCEDURE);
  vector_length(x) = len;
  vector_block(x) = arr;
  int_vector_ints(x) = (s7_int *)block_data(arr);
  if (len > 0)
    {
      if (STEP_8(len))
	memclr64((void *)int_vector_ints(x), len * sizeof(s7_int));
      else memclr((void *)int_vector_ints(x), len * sizeof(s7_int));
    }
  vector_set_dimension_info(x, NULL);
  vector_getter(x) = int_vector_getter;
  vector_setter(x) = int_vector_setter;

  add_vector(sc, x);
  return(x);
}

static s7_pointer make_int_vector_p_ii(s7_scheme *sc, s7_int len, s7_int init)
{
  s7_pointer x;
  x = make_vector_1(sc, len, NOT_FILLED, T_INT_VECTOR);
  int_vector_fill(sc, x, init);
  add_vector(sc, x);
  return(x);
}


/* -------------------------------- make-byte-vector -------------------------------- */
static s7_pointer g_make_byte_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_make_byte_vector "(make-byte-vector len (byte 0)) makes a byte-vector of length len filled with byte."
  #define Q_make_byte_vector s7_make_signature(sc, 3, sc->is_byte_vector_symbol, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_pair_symbol), sc->is_byte_symbol)

  s7_int len = 0, ib = 0;
  s7_pointer p, init;
  p = car(args);

  if (!is_pair(p))
    {
      if (!s7_is_integer(p))
	return(method_or_bust(sc, p, sc->make_byte_vector_symbol, args, T_INTEGER, 1));
      len = s7_integer(p);
      if ((len < 0) || (len > sc->max_vector_length))
	return(out_of_range(sc, sc->make_byte_vector_symbol, small_int(1), p, (len < 0) ? its_negative_string : its_too_large_string));
    }
  if (is_pair(cdr(args)))
    {
      init = cadr(args);
      if (!s7_is_integer(init))
	return(method_or_bust(sc, init, sc->make_byte_vector_symbol, args, T_INTEGER, 2));
      ib = s7_integer(init);
      if ((ib < 0) || (ib > 255))
	return(simple_wrong_type_argument_with_type(sc, sc->make_byte_vector_symbol, init, an_unsigned_byte_string));
    }
  else init = small_int(0);

 if (!s7_is_integer(p))
   return(g_make_vector_1(sc, set_plist_2(sc, p, init), sc->make_byte_vector_symbol));

  p = make_simple_byte_vector(sc, len);
  if ((len > 0) && (is_pair(cdr(args))))
    local_memset((void *)(byte_vector_bytes(p)), ib, len);
  return(p);
}

static s7_pointer make_byte_vector_p_ii(s7_scheme *sc, s7_int len, s7_int init)
{
  s7_pointer p;
  if ((len < 0) || (len > sc->max_vector_length))
    return(out_of_range(sc, sc->make_byte_vector_symbol, small_int(1), make_integer(sc, len), (len < 0) ? its_negative_string : its_too_large_string));
  if ((init < 0) || (init > 255))
    return(simple_wrong_type_argument_with_type(sc, sc->make_byte_vector_symbol, make_integer(sc, init), an_unsigned_byte_string));
  p = make_simple_byte_vector(sc, len);
  if (len > 0)
    local_memset((void *)(byte_vector_bytes(p)), init, len);
  return(p);
}


/* -------------------------------- vector? -------------------------------- */
static s7_pointer g_is_vector(s7_scheme *sc, s7_pointer args)
{
  #define H_is_vector "(vector? obj) returns #t if obj is a vector"
  #define Q_is_vector sc->pl_bt
  check_boolean_method(sc, is_any_vector, sc->is_vector_symbol, args);
}


/* -------------------------------- vector-rank -------------------------------- */
s7_int s7_vector_rank(s7_pointer vect)
{
  return((s7_int)(vector_rank(vect)));
}


/* -------------------------------- vector-dimensions -------------------------------- */
static s7_pointer g_vector_dimensions(s7_scheme *sc, s7_pointer args)
{
  #define H_vector_dimensions "(vector-dimensions vect) returns a list of vect's dimensions.  In srfi-63 terms:\n\
    (define array-dimensions vector-dimensions)\n\
    (define (array-rank v) (length (vector-dimensions v)))"
  #define Q_vector_dimensions s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_vector_symbol)

  s7_pointer x;
  x = car(args);
  if (!is_any_vector(x))
    return(method_or_bust_one_arg(sc, x, sc->vector_dimensions_symbol, args, T_VECTOR));

  if (vector_rank(x) > 1)
    {
      s7_int i;
      sc->w = sc->nil;
      for (i = vector_ndims(x) - 1; i >= 0; i--)
	sc->w = cons(sc, make_integer(sc, vector_dimension(x, i)), sc->w);
      x = sc->w;
      sc->w = sc->nil;
      return(x);
    }
  return(list_1(sc, make_integer(sc, vector_length(x))));
}


#define MULTIVECTOR_TOO_MANY_ELEMENTS -1
#define MULTIVECTOR_NOT_ENOUGH_ELEMENTS -2

static int32_t traverse_vector_data(s7_scheme *sc, s7_pointer vec, s7_int flat_ref, s7_int dimension, s7_int dimensions, s7_int *sizes, s7_pointer lst)
{
  /* we're filling vec, we're currently looking for element flat_ref,
   *   we're at ref in dimension of dimensions, where sizes gives the bounds, and lst is our data
   *   #3D(((1 2 3) (4 5 6)) ((7 8 9) (10 11 12)))
   */
  s7_int i;
  s7_pointer x;

  for (i = 0, x = lst; i < sizes[dimension]; i++, x = cdr(x))
    {
      if (!is_pair(x))
	return(MULTIVECTOR_NOT_ENOUGH_ELEMENTS);

      if (dimension == (dimensions - 1))
	vector_setter(vec)(sc, vec, flat_ref++, car(x));
      else
	{
	  flat_ref = traverse_vector_data(sc, vec, flat_ref, dimension + 1, dimensions, sizes, car(x));
	  if (flat_ref < 0) return(flat_ref);
	}
    }
  if (is_not_null(x))
    return(MULTIVECTOR_TOO_MANY_ELEMENTS);
  return(flat_ref);
}

static s7_pointer s7_multivector_error(s7_scheme *sc, const char *message, s7_pointer data)
{
  return(s7_error(sc, sc->read_error_symbol,
		  set_elist_3(sc, wrap_string(sc, "reading constant vector, ~A: ~A", 31),
			      s7_make_string_wrapper(sc, message), data)));
}

static s7_pointer g_multivector(s7_scheme *sc, s7_int dims, s7_pointer data)
{
  /* get the dimension bounds from data, make the new vector, fill it from data
   * dims needs to be s7_int so we can at least give correct error messages.
   */
  s7_pointer vec, x;
  s7_int i, err, vec_loc;
  s7_int *sizes;

  /* (#2d((1 2 3) (4 5 6)) 0 0) -> 1
   * (#2d((1 2 3) (4 5 6)) 1 1) -> 5
   * (#3d(((1 2) (3 4)) ((5 6) (7 8))) 1 1 0) -> 7
   * #3d(((1 2) (3 4)) ((5 6) (7))) -> error, #3d(((1 2) (3 4)) ((5 6) (7 8 9))), #3d(((1 2) (3 4)) (5 (7 8 9))) etc
   * but a special case: #nd() is an n-dimensional empty vector
   */

  if (dims <= 0)      /* #0d(...) #2147483649D() [if dims is int32_t this is negative] */
    return(s7_out_of_range_error(sc, "#nD(...) dimensions", 1, wrap_integer1(sc, dims), "must be 1 or more"));
  if (dims > sc->max_vector_dimensions)
    return(s7_out_of_range_error(sc, "#nD(...) dimensions", 1, wrap_integer1(sc, dims), "must be < 512")); /* sc->max_vector_dimensions=512 currently */

  sc->w = sc->nil;
  if (is_null(data))  /* dims are already 0 (calloc above) */
    return(g_make_vector(sc, set_plist_1(sc, protected_make_list(sc, dims, small_int(0)))));

  sizes = (s7_int *)calloc(dims, sizeof(s7_int));
  for (x = data, i = 0; i < dims; i++)
    {
      sizes[i] = safe_list_length(x);
      sc->w = cons(sc, make_integer(sc, sizes[i]), sc->w);
      x = car(x);
      if ((i < (dims - 1)) &&
	  (!is_pair(x)))
	{
	  free(sizes);
	  return(s7_multivector_error(sc, "we need a list that fully specifies the vector's elements", data));
	}
    }

  vec = g_make_vector(sc, set_plist_1(sc, sc->w = safe_reverse_in_place(sc, sc->w)));
  vec_loc = s7_gc_protect_1(sc, vec);
  sc->w = sc->nil;

  /* now fill the vector checking that all the lists match */
  err = traverse_vector_data(sc, vec, 0, 0, dims, sizes, data);

  free(sizes);
  s7_gc_unprotect_at(sc, vec_loc);
  if (err < 0)
    return(s7_multivector_error(sc, (err == MULTIVECTOR_TOO_MANY_ELEMENTS) ? "found too many elements" : "not enough elements found", data));

  return(vec);
}

static s7_pointer g_int_multivector(s7_scheme *sc, s7_int dims, s7_pointer data)
{
  /* dims > 1, sc->value is a pair (not null) */
  s7_pointer *src;
  s7_int i, len;
  sc->value = g_multivector(sc, dims, data);
  src = (s7_pointer *)vector_elements(sc->value);
  len = vector_length(sc->value);
  for (i = 0; i < len; i++)
    if (!is_t_integer(src[i]))
      return(s7_wrong_type_arg_error(sc, "#i(...)", i + 1, src[i], "an integer"));
  sc->args = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, sc->value)), small_int(0)), sc->make_int_vector_symbol);
  return(s7_copy_1(sc, sc->int_vector_symbol, set_plist_2(sc, sc->value, sc->args)));
}

static s7_pointer g_byte_multivector(s7_scheme *sc, s7_int dims, s7_pointer data)
{
  /* dims > 1, sc->value is a pair (not null) */
  s7_pointer *src;
  s7_int i, len;
  sc->value = g_multivector(sc, dims, data);
  src = (s7_pointer *)vector_elements(sc->value);
  len = vector_length(sc->value);
  for (i = 0; i < len; i++)
    if (!is_byte(src[i]))
      return(s7_wrong_type_arg_error(sc, "#u(...)", i + 1, src[i], "a byte"));
  sc->args = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, sc->value)), small_int(0)), sc->make_byte_vector_symbol);
  return(s7_copy_1(sc, sc->byte_vector_symbol, set_plist_2(sc, sc->value, sc->args)));
}

static s7_pointer g_float_multivector(s7_scheme *sc, s7_int dims, s7_pointer data)
{
  /* dims > 1, sc->value is a pair (not null) */
  s7_pointer *src;
  s7_int i, len;
  sc->value = g_multivector(sc, dims, data);
  src = (s7_pointer *)vector_elements(sc->value);
  len = vector_length(sc->value);
  for (i = 0; i < len; i++)
    if (!s7_is_real(src[i]))
      return(s7_wrong_type_arg_error(sc, "#r(...)", i + 1, src[i], "a real"));
  sc->args = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, sc->value)), real_zero), sc->make_float_vector_symbol);
  return(s7_copy_1(sc, sc->float_vector_symbol, set_plist_2(sc, sc->value, sc->args)));
}

#if WITH_VECTORIZE
static s7_pointer s7_vector_copy_1(s7_scheme *sc, s7_pointer old_vect) __attribute__((optimize("tree-vectorize")));
static s7_pointer s7_vector_copy_1(s7_scheme *sc, s7_pointer old_vect)
#else
s7_pointer s7_vector_copy(s7_scheme *sc, s7_pointer old_vect)
#endif
{
  s7_int i, len;
  s7_pointer new_vect;

  len = vector_length(old_vect);
  if (is_normal_vector(old_vect))
    {
      s7_pointer *src, *dst;
      if ((is_typed_vector(old_vect)) && (len > 0)) /* preserve the type info as well */
	{
	  if (vector_rank(old_vect) > 1)
	    new_vect = g_make_vector(sc, set_plist_3(sc, g_vector_dimensions(sc, list_1(sc, old_vect)), vector_element(old_vect, 0), typed_vector_typer(old_vect)));
	  else new_vect = g_make_vector(sc, set_plist_3(sc, make_integer(sc, len), vector_element(old_vect, 0), typed_vector_typer(old_vect)));
	}
      else
	{
	  if (vector_rank(old_vect) > 1)
	    new_vect = g_make_vector(sc, set_plist_1(sc, g_vector_dimensions(sc, list_1(sc, old_vect))));
	  else new_vect = make_simple_vector(sc, len);
	}
      /* here and in vector-fill! we have a problem with bignums -- should new bignums be allocated? (copy_list also) */
      src = (s7_pointer *)vector_elements(old_vect);
      dst = (s7_pointer *)vector_elements(new_vect);
      for (i = len; i > 0; i--) *dst++ = *src++;
      return(new_vect);
    }

  if (is_float_vector(old_vect))
    {
      s7_double *src, *dst;
      if (vector_rank(old_vect) > 1)
	new_vect = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, old_vect)), real_zero), sc->make_float_vector_symbol);
      else new_vect = make_simple_float_vector(sc, len);
      src = (s7_double *)float_vector_floats(old_vect);
      dst = (s7_double *)float_vector_floats(new_vect);
      for (i = len; i > 0; i--) *dst++ = *src++;  /* same speed as memcpy(dst, src, len * sizeof(s7_double)); */
      return(new_vect);
    }

  if (is_int_vector(old_vect))
    {
      s7_int *src, *dst;
      if (vector_rank(old_vect) > 1)
	new_vect = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, old_vect)), small_int(0)), sc->make_int_vector_symbol);
      else new_vect = make_simple_int_vector(sc, len);
      src = (s7_int *)int_vector_ints(old_vect);
      dst = (s7_int *)int_vector_ints(new_vect);
      for (i = len; i > 0; i--) *dst++ = *src++;
      return(new_vect);
    }

  if (is_byte_vector(old_vect))
    {
      uint8_t *src, *dst;
      if (vector_rank(old_vect) > 1)
	new_vect = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, old_vect)), small_int(0)), sc->make_byte_vector_symbol);
      else new_vect = make_simple_byte_vector(sc, len);
      src = (uint8_t *)byte_vector_bytes(old_vect);
      dst = (uint8_t *)byte_vector_bytes(new_vect);
      for (i = len; i > 0; i--) *dst++ = *src++;
      return(new_vect);
    }
  return(NULL);
}

#if WITH_VECTORIZE
s7_pointer s7_vector_copy(s7_scheme *sc, s7_pointer old_vect) {return(s7_vector_copy_1(sc, old_vect));}
#endif

static s7_pointer univect_ref(s7_scheme *sc, s7_pointer args, s7_pointer caller, int32_t typ)
{
  s7_pointer v, index;
  s7_int ind;

  v = car(args);
  if (type(v) != typ)
    return(method_or_bust(sc, v, caller, args, typ, 1));

  if (vector_rank(v) == 1)
    {
      index = cadr(args);
      if (!s7_is_integer(index))
	return(method_or_bust(sc, index, caller, args, T_INTEGER, 2));
      ind = s7_integer(index);
      if ((ind < 0) || (ind >= vector_length(v)))
	return(simple_out_of_range(sc, caller, index, (ind < 0) ? its_negative_string : its_too_large_string));
      if (!is_null(cddr(args)))
	return(out_of_range(sc, caller, small_int(2), cdr(args), too_many_indices_string));
    }
  else
    {
      s7_int i;
      s7_pointer x;
      ind = 0;
      for (x = cdr(args), i = 0; (is_not_null(x)) && (i < vector_ndims(v)); x = cdr(x), i++)
	{
	  s7_int n;
	  index = car(x);
	  if (!s7_is_integer(index))
	    return(method_or_bust(sc, index, caller, args, T_INTEGER, i + 2));
	  n = s7_integer(index);
	  if ((n < 0) ||
	      (n >= vector_dimension(v, i)))
	    return(out_of_range(sc, caller, wrap_integer1(sc, i + 2), index, (n < 0) ? its_negative_string : its_too_large_string));
	  ind += n * vector_offset(v, i);
	}
      if (is_not_null(x))
	return(out_of_range(sc, caller, small_int(2), cdr(args), too_many_indices_string));

      /* if not enough indices, return a subvector covering whatever is left */
      if (i < vector_ndims(v))
	return(subvector(sc, v, i, ind));
    }
  if (typ == T_FLOAT_VECTOR)
    return(make_real(sc, float_vector(v, ind)));
  if (typ == T_INT_VECTOR)
    return(make_integer(sc, int_vector(v, ind)));
  return(small_int(byte_vector(v, ind)));
}

static s7_pointer univect_set(s7_scheme *sc, s7_pointer args, s7_pointer caller, int32_t typ)
{
  s7_pointer vec, val, index;
  s7_int ind;

  vec = car(args);
  if (type(vec) != typ)
    return(method_or_bust(sc, vec, caller, args, typ, 1));
  if (is_immutable_vector(vec))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, caller, vec)));

  if (vector_rank(vec) > 1)
    {
      s7_int i;
      s7_pointer x;
      ind = 0;
      for (x = cdr(args), i = 0; (is_not_null(cdr(x))) && (i < vector_ndims(vec)); x = cdr(x), i++)
	{
	  s7_int n;
	  index = car(x);
	  if (!s7_is_integer(index))
	    return(method_or_bust(sc, index, caller, args, T_INTEGER, i + 2));
	  n = s7_integer(index);
	  if ((n < 0) ||
	      (n >= vector_dimension(vec, i)))
	    return(out_of_range(sc, caller, wrap_integer1(sc, i + 2), index, (n < 0) ? its_negative_string : its_too_large_string));
	  ind += n * vector_offset(vec, i);
	}
      if (is_not_null(cdr(x)))
	return(s7_wrong_number_of_args_error(sc, "too many args: ~S", args));
      if (i != vector_ndims(vec))
	return(s7_wrong_number_of_args_error(sc, "not enough args: ~S", args));
      val = car(x);
    }
  else
    {
      s7_pointer p;
      p = cdr(args);
      index = car(p);
      if (!s7_is_integer(index))
	return(method_or_bust(sc, index, caller, args, T_INTEGER, 2));
      ind = s7_integer(index);
      if ((ind < 0) ||
	  (ind >= vector_length(vec)))
	return(out_of_range(sc, caller, small_int(2), index, (ind < 0) ? its_negative_string : its_too_large_string));
      if (is_not_null(cddr(p)))
	return(s7_wrong_number_of_args_error(sc, "too many args: ~S", args));
      val = cadr(p);
    }

  if (typ == T_FLOAT_VECTOR)
    {
      if (!s7_is_real(val))
	return(method_or_bust(sc, val, caller, args, T_REAL, 3));
      float_vector(vec, ind) = s7_real(val);
    }
  else
    {
      if (typ == T_INT_VECTOR)
	{
	  if (!s7_is_integer(val))
	    return(method_or_bust(sc, val, caller, args, T_INTEGER, 3));
	  int_vector(vec, ind) = s7_integer(val);
	}
      else
	{
	  if (!is_byte(val))
	    return(method_or_bust(sc, val, caller, args, T_INTEGER, 3));
	  byte_vector(vec, ind) = (uint8_t)s7_integer(val);
	}
    }
  return(val);
}


/* -------------------------------- float-vector-ref -------------------------------- */
static s7_pointer g_float_vector_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_float_vector_ref "(float-vector-ref v ...) returns an element of the float-vector v."
  #define Q_float_vector_ref s7_make_circular_signature(sc, 2, 3, s7_make_signature(sc, 2, sc->is_float_symbol, sc->is_float_vector_symbol), sc->is_float_vector_symbol, sc->is_integer_symbol)
  return(univect_ref(sc, args, sc->float_vector_ref_symbol, T_FLOAT_VECTOR));
}

static inline s7_pointer float_vector_ref_p_pp(s7_scheme *sc, s7_pointer v, s7_pointer index)
{
  s7_int ind;
  if (!is_float_vector(v))
    return(method_or_bust(sc, v, sc->float_vector_ref_symbol, list_2(sc, v, index), T_FLOAT_VECTOR, 1));
  if (vector_rank(v) != 1)
    return(univect_ref(sc, set_plist_2(sc, v, index), sc->float_vector_ref_symbol, T_FLOAT_VECTOR));
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->float_vector_ref_symbol, list_2(sc, v, index), T_INTEGER, 2));
  ind = s7_integer(index);
  if ((ind < 0) || (ind >= vector_length(v)))
    return(simple_out_of_range(sc, sc->float_vector_ref_symbol, index, (ind < 0) ? its_negative_string : its_too_large_string));
  return(make_real(sc, float_vector(v, ind)));
}

static s7_pointer g_fv_ref_2(s7_scheme *sc, s7_pointer args) {return(float_vector_ref_p_pp(sc, car(args), cadr(args)));}

static s7_pointer g_fv_ref_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer fv, index;
  s7_int ind1, ind2;
  fv = car(args);
  if (!is_float_vector(fv))
    return(method_or_bust(sc, fv, sc->float_vector_ref_symbol, args, T_FLOAT_VECTOR, 1));
  if (vector_rank(fv) != 2)
    return(univect_ref(sc, args, sc->float_vector_ref_symbol, T_FLOAT_VECTOR));
  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->float_vector_ref_symbol, args, T_INTEGER, 2));
  ind1 = s7_integer(index);
  if ((ind1 < 0) || (ind1 >= vector_dimension(fv, 0)))
    return(simple_out_of_range(sc, sc->float_vector_ref_symbol, index, (ind1 < 0) ? its_negative_string : its_too_large_string));
  index = caddr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->float_vector_ref_symbol, args, T_INTEGER, 3));
  ind2 = s7_integer(index);
  if ((ind2 < 0) || (ind2 >= vector_dimension(fv, 1)))
    return(simple_out_of_range(sc, sc->float_vector_ref_symbol, index, (ind2 < 0) ? its_negative_string : its_too_large_string));
  ind1 = ind1 * vector_offset(fv, 0) + ind2;
  return(make_real(sc, float_vector(fv, ind1)));
}

static s7_double float_vector_ref_unchecked(s7_scheme *sc, s7_pointer v, s7_int i) {return(float_vector(v, i));}
static inline s7_int ref_check_index(s7_scheme *sc, s7_pointer v, s7_int i)
{
  /* according to valgrind, it is faster to split out the bounds check */
  if ((i < 0) || (i >= vector_length(v)))
    out_of_range(sc, sc->float_vector_ref_symbol, small_int(2), wrap_integer1(sc, i), (i < 0) ? its_negative_string : its_too_large_string);
  return(i);
}
static s7_double float_vector_ref_d_7pi(s7_scheme *sc, s7_pointer v, s7_int i) {return(float_vector(v, ref_check_index(sc, v, i)));}
static s7_pointer float_vector_ref_unchecked_p(s7_scheme *sc, s7_pointer v, s7_int i) {return(make_real(sc, float_vector(v, i)));}

static s7_double float_vector_ref_d_7pii(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2)
{
  if ((i1 >= 0) && (i1 < vector_dimension(v, 0)))
    {
      if ((i2 >= 0) && (i2 < vector_dimension(v, 1)))
	return(float_vector(v, i2 + (i1 * vector_offset(v, 0))));
      out_of_range(sc, sc->float_vector_ref_symbol, small_int(3), wrap_integer1(sc, i2), (i2 < 0) ? its_negative_string : its_too_large_string);
    }
  out_of_range(sc, sc->float_vector_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static s7_pointer float_vector_ref_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    return(sc->fv_ref_2);
  if (args == 3)
    return(sc->fv_ref_3);
  return(f);
}


/* -------------------------------- float-vector-set! -------------------------------- */
static s7_pointer g_float_vector_set(s7_scheme *sc, s7_pointer args)
{
  #define H_float_vector_set "(float-vector-set! v i ... value) sets the i-th element of the float-vector v to value."
  #define Q_float_vector_set s7_make_circular_signature(sc, 3, 4, sc->is_real_symbol, sc->is_float_vector_symbol, sc->is_integer_symbol, sc->is_integer_or_real_at_end_symbol)
  return(univect_set(sc, args, sc->float_vector_set_symbol, T_FLOAT_VECTOR));
}

static s7_pointer g_fv_set_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer fv, index, value;
  s7_int ind;
  fv = car(args);
  if (!is_float_vector(fv))
    return(method_or_bust(sc, fv, sc->float_vector_set_symbol, args, T_FLOAT_VECTOR, 1));
  if (vector_rank(fv) != 1)
    return(univect_set(sc, args, sc->float_vector_set_symbol, T_FLOAT_VECTOR));
  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->float_vector_set_symbol, args, T_INTEGER, 2));
  ind = s7_integer(index);
  if ((ind < 0) || (ind >= vector_length(fv)))
    return(simple_out_of_range(sc, sc->float_vector_set_symbol, index, (ind < 0) ? its_negative_string : its_too_large_string));
  value = caddr(args);
  if (!s7_is_real(value))
    return(method_or_bust(sc, value, sc->float_vector_set_symbol, args, T_REAL, 3));
  if (is_immutable_vector(fv))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->float_vector_set_symbol, fv)));
  float_vector(fv, ind) = s7_real(value);
  return(value);
}

static s7_pointer g_fv_set_unchecked(s7_scheme *sc, s7_pointer args)
{
  s7_pointer fv, value;
  s7_int ind;
  value = caddr(args);
  if (!s7_is_real(value))
    return(wrong_type_argument(sc, sc->float_vector_set_symbol, 3, value, T_REAL));
  fv = car(args);
  if (is_immutable_vector(fv))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->float_vector_set_symbol, fv)));
  ind = s7_integer(cadr(args));
  float_vector(fv, ind) = s7_real(value);
  return(value);
}

static bool find_matching_ref(s7_scheme *sc, s7_pointer getter, s7_pointer expr)
{
  /* expr: (*set! v i val), val exists (i.e. args=3, so cddddr is null) */
  s7_pointer v, ind;
  v = cadr(expr);
  ind = caddr(expr);
  if ((is_symbol(v)) && (!is_pair(ind)))
    {
      s7_pointer val;
      val = cadddr(expr);
      if (is_optimized(val)) /* includes is_pair */
	{
	  s7_pointer p;
	  for (p = val; is_pair(p); p = cdr(p))
	    if (is_pair(car(p)))
	      {
		s7_pointer ref;
		ref = car(p);
		if ((car(ref) == getter) &&
		    (is_pair(cdr(ref))) &&
		    (cadr(ref) == v) &&
		    (is_pair(cddr(ref))) &&
		    (caddr(ref) == ind) &&
		    (is_null(cdddr(ref))))
		  return(true);
		if ((car(ref) == v) &&
		    (is_pair(cdr(ref))) &&
		    (cadr(ref) == ind) &&
		    (is_null(cddr(ref))))
		  return(true);
	      }
	}
    }
  return(false);
}

static s7_pointer float_vector_set_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 3)
    {
      if (find_matching_ref(sc, sc->float_vector_ref_symbol, expr))
	return(sc->fv_set_unchecked);
      return(sc->fv_set_3);
    }
  return(f);
}

static s7_double float_vector_set_unchecked(s7_scheme *sc, s7_pointer v, s7_int i, s7_double x) {float_vector(v, i) = x; return(x);}
static s7_int set_check_index(s7_scheme *sc, s7_pointer v, s7_int i)
{
  if ((i < 0) || (i >= vector_length(v)))
    out_of_range(sc, sc->float_vector_set_symbol, small_int(2), wrap_integer1(sc, i), (i < 0) ? its_negative_string : its_too_large_string);
  return(i);
}

static s7_double float_vector_set_d_7pid(s7_scheme *sc, s7_pointer v, s7_int i, s7_double x) {float_vector(v, (set_check_index(sc, v, i))) = x; return(x);}
static s7_double float_vector_set_d_7piid(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2, s7_double x)
{
  if ((i1 >= 0) && (i1 < vector_dimension(v, 0)))
    {
      if ((i2 >= 0) && (i2 < vector_dimension(v, 1)))
	{
	  float_vector(v, i2 + (i1 * vector_offset(v, 0))) = x;
	  return(x);
	}
      out_of_range(sc, sc->float_vector_set_symbol, small_int(3), wrap_integer1(sc, i2), (i2 < 0) ? its_negative_string : its_too_large_string);
    }
  out_of_range(sc, sc->float_vector_set_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(x);
}

static s7_pointer float_vector_set_unchecked_p(s7_scheme *sc, s7_pointer v, s7_int i, s7_pointer p)
{
  float_vector(v, i) = real_to_double(sc, p, "float-vector-set!");
  return(p);
}


/* -------------------------------- int-vector-ref -------------------------------- */
static s7_pointer g_int_vector_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_int_vector_ref "(int-vector-ref v ...) returns an element of the int-vector v."
  #define Q_int_vector_ref s7_make_circular_signature(sc, 2, 3, s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_int_vector_symbol), sc->is_int_vector_symbol, sc->is_integer_symbol)
  return(univect_ref(sc, args, sc->int_vector_ref_symbol, T_INT_VECTOR));
}

static s7_int int_vector_ref_unchecked(s7_scheme *sc, s7_pointer v, s7_int i) {return(int_vector(v, i));}
static s7_int int_vector_ref_i_7pi(s7_scheme *sc, s7_pointer v, s7_int i)
{
  if ((i >= 0) && (i < vector_length(v)))
    return(int_vector(v, i));
  out_of_range(sc, sc->int_vector_ref_symbol, small_int(2), wrap_integer1(sc, i), (i < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static s7_pointer int_vector_ref_unchecked_p(s7_scheme *sc, s7_pointer v, s7_int i) {return(make_integer(sc, int_vector(v, i)));}

static s7_int int_vector_ref_i_7pii(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2)
{
  if ((i1 >= 0) && (i1 < vector_dimension(v, 0)))
    {
      if ((i2 >= 0) && (i2 < vector_dimension(v, 1)))
	return(int_vector(v, i2 + (i1 * vector_offset(v, 0))));
      out_of_range(sc, sc->int_vector_ref_symbol, small_int(3), wrap_integer1(sc, i2), (i2 < 0) ? its_negative_string : its_too_large_string);
    }
  out_of_range(sc, sc->int_vector_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static s7_int int_vector_ref_i_7piii(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2, s7_int i3)
{
  if ((i1 >= 0) && (i1 < vector_dimension(v, 0)))
    {
      if ((i2 >= 0) && (i2 < vector_dimension(v, 1)))
	{
	  if ((i3 >= 0) && (i3 < vector_dimension(v, 2)))
	    return(int_vector(v, i3 + (i2 * vector_offset(v, 1)) + (i1 * vector_offset(v, 0))));
	  out_of_range(sc, sc->int_vector_ref_symbol, small_int(4), wrap_integer1(sc, i3), (i3 < 0) ? its_negative_string : its_too_large_string);
	}
      out_of_range(sc, sc->int_vector_ref_symbol, small_int(3), wrap_integer1(sc, i2), (i2 < 0) ? its_negative_string : its_too_large_string);
    }
  out_of_range(sc, sc->int_vector_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static inline s7_pointer int_vector_ref_p_pp(s7_scheme *sc, s7_pointer v, s7_pointer index)
{
  s7_int ind;
  if (!is_int_vector(v))
    return(method_or_bust(sc, v, sc->int_vector_ref_symbol, list_2(sc, v, index), T_INT_VECTOR, 1));
  if (vector_rank(v) != 1)
    return(univect_ref(sc, set_plist_2(sc, v, index), sc->int_vector_ref_symbol, T_INT_VECTOR));
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->int_vector_ref_symbol, list_2(sc, v, index), T_INTEGER, 2));
  ind = s7_integer(index);
  if ((ind < 0) || (ind >= vector_length(v)))
    return(simple_out_of_range(sc, sc->int_vector_ref_symbol, index, (ind < 0) ? its_negative_string : its_too_large_string));
  return(make_integer(sc, int_vector(v, ind)));
}

static s7_pointer g_iv_ref_2(s7_scheme *sc, s7_pointer args) {return(int_vector_ref_p_pp(sc, car(args), cadr(args)));}

static s7_pointer g_iv_ref_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer iv, index;
  s7_int ind1, ind2;
  iv = car(args);
  if (!is_int_vector(iv))
    return(method_or_bust(sc, iv, sc->int_vector_ref_symbol, args, T_INT_VECTOR, 1));
  if (vector_rank(iv) != 2)
    return(univect_ref(sc, args, sc->int_vector_ref_symbol, T_INT_VECTOR));
  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->int_vector_ref_symbol, args, T_INTEGER, 2));
  ind1 = s7_integer(index);
  if ((ind1 < 0) || (ind1 >= vector_dimension(iv, 0)))
    return(simple_out_of_range(sc, sc->int_vector_ref_symbol, index, (ind1 < 0) ? its_negative_string : its_too_large_string));
  index = caddr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->int_vector_ref_symbol, args, T_INTEGER, 3));
  ind2 = s7_integer(index);
  if ((ind2 < 0) || (ind2 >= vector_dimension(iv, 1)))
    return(simple_out_of_range(sc, sc->int_vector_ref_symbol, index, (ind2 < 0) ? its_negative_string : its_too_large_string));
  ind1 = ind1 * vector_offset(iv, 0) + ind2;
  return(make_integer(sc, int_vector(iv, ind1)));
}

static s7_pointer int_vector_ref_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    return(sc->iv_ref_2);
  if (args == 3)
    return(sc->iv_ref_3);
  return(f);
}


/* -------------------------------- int-vector-set! -------------------------------- */
static s7_pointer g_int_vector_set(s7_scheme *sc, s7_pointer args)
{
  #define H_int_vector_set "(int-vector-set! v i ... value) sets the i-th element of the int-vector v to value."
  #define Q_int_vector_set s7_make_circular_signature(sc, 2, 3, sc->is_integer_symbol, sc->is_int_vector_symbol, sc->is_integer_symbol)
  return(univect_set(sc, args, sc->int_vector_set_symbol, T_INT_VECTOR));
}

static s7_int int_vector_set_unchecked(s7_scheme *sc, s7_pointer v, s7_int i, s7_int x) {int_vector(v, i) = x; return(x);}
static s7_int int_vector_set_i_7pii(s7_scheme *sc, s7_pointer v, s7_int i, s7_int x)
{
  if ((i < 0) || (i >= vector_length(v)))
    out_of_range(sc, sc->int_vector_set_symbol, small_int(2), wrap_integer1(sc, i), (i < 0) ? its_negative_string : its_too_large_string);
  int_vector(v, i) = x;
  return(x);
}

static s7_int int_vector_set_i_7piii(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2, s7_int i3)
{
  if ((i1 >= 0) && (i1 < vector_dimension(v, 0)))
    {
      if ((i2 >= 0) && (i2 < vector_dimension(v, 1)))
	{
	  int_vector(v, i2 + (i1 * vector_offset(v, 0))) = i3;
	  return(i3);
	}
      out_of_range(sc, sc->int_vector_set_symbol, small_int(3), wrap_integer1(sc, i2), (i2 < 0) ? its_negative_string : its_too_large_string);
    }
  out_of_range(sc, sc->int_vector_set_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static s7_pointer int_vector_set_unchecked_p(s7_scheme *sc, s7_pointer v, s7_int i, s7_pointer p)
{
  if (!s7_is_integer(p))
    s7_wrong_type_arg_error(sc, "int-vector-set!", 3, p, "an integer");
  int_vector(v, i) = s7_integer(p);
  return(p);
}

static s7_pointer g_iv_set_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer v, index, value;
  s7_int ind;
  v = car(args);
  if (!is_int_vector(v))
    return(method_or_bust(sc, v, sc->int_vector_set_symbol, args, T_INT_VECTOR, 1));
  if (vector_rank(v) != 1)
    return(univect_set(sc, args, sc->int_vector_set_symbol, T_INT_VECTOR));
  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->int_vector_set_symbol, args, T_INTEGER, 2));
  ind = s7_integer(index);
  if ((ind < 0) || (ind >= vector_length(v)))
    return(simple_out_of_range(sc, sc->int_vector_set_symbol, index, (ind < 0) ? its_negative_string : its_too_large_string));
  value = caddr(args);
  if (!s7_is_integer(value))
    return(method_or_bust(sc, value, sc->int_vector_set_symbol, args, T_INTEGER, 3));
  if (is_immutable_vector(v))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->int_vector_set_symbol, v)));
  int_vector(v, ind) = s7_integer(value);
  return(value);
}

static s7_pointer int_vector_set_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 3)
    return(sc->iv_set_3);
  return(f);
}


/* -------------------------------- byte-vector-ref -------------------------------- */
static s7_pointer g_byte_vector_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_byte_vector_ref "(byte-vector-ref vect index) returns the byte at the index-th element of the byte-vector vect"
  #define Q_byte_vector_ref s7_make_circular_signature(sc, 2, 3, s7_make_signature(sc, 2, sc->is_byte_symbol, sc->is_byte_vector_symbol), sc->is_byte_vector_symbol, sc->is_integer_symbol)
  return(univect_ref(sc, args, sc->byte_vector_ref_symbol, T_BYTE_VECTOR));
}

static s7_int byte_vector_ref_i_7pi(s7_scheme *sc, s7_pointer p1, s7_int i1)
{
  if ((i1 >= 0) && (i1 < byte_vector_length(p1)))
    return((s7_int)((byte_vector(p1, i1))));
  out_of_range(sc, sc->byte_vector_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static s7_int byte_vector_ref_i_7pii(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2)
{
  if ((i1 >= 0) && (i1 < vector_dimension(v, 0)))
    {
      if ((i2 >= 0) && (i2 < vector_dimension(v, 1)))
	return((s7_int)byte_vector(v, i2 + (i1 * vector_offset(v, 0))));
      out_of_range(sc, sc->byte_vector_ref_symbol, small_int(3), wrap_integer1(sc, i2), (i2 < 0) ? its_negative_string : its_too_large_string);
    }
  out_of_range(sc, sc->byte_vector_ref_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static s7_pointer byte_vector_ref_unchecked_p(s7_scheme *sc, s7_pointer p1, s7_int i1) {return(small_int((byte_vector(p1, i1))));}
static s7_int byte_vector_ref_unchecked(s7_scheme *sc, s7_pointer p1, s7_int i1) {return(byte_vector(p1, i1));}

static s7_pointer g_bv_ref_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer v, index;
  s7_int ind;
  v = car(args);
  if (!is_byte_vector(v))
    return(method_or_bust(sc, v, sc->byte_vector_ref_symbol, args, T_BYTE_VECTOR, 1));
  if (vector_rank(v) != 1)
    return(univect_ref(sc, args, sc->byte_vector_ref_symbol, T_BYTE_VECTOR));
  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->byte_vector_ref_symbol, args, T_INTEGER, 2));
  ind = s7_integer(index);
  if ((ind < 0) || (ind >= vector_length(v)))
    return(simple_out_of_range(sc, sc->byte_vector_ref_symbol, index, (ind < 0) ? its_negative_string : its_too_large_string));
  return(make_integer(sc, byte_vector(v, ind)));
}

static s7_pointer g_bv_ref_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer iv, index;
  s7_int ind1, ind2;
  iv = car(args);
  if (!is_byte_vector(iv))
    return(method_or_bust(sc, iv, sc->byte_vector_ref_symbol, args, T_BYTE_VECTOR, 1));
  if (vector_rank(iv) != 2)
    return(univect_ref(sc, args, sc->byte_vector_ref_symbol, T_BYTE_VECTOR));
  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->byte_vector_ref_symbol, args, T_INTEGER, 2));
  ind1 = s7_integer(index);
  if ((ind1 < 0) || (ind1 >= vector_dimension(iv, 0)))
    return(simple_out_of_range(sc, sc->byte_vector_ref_symbol, index, (ind1 < 0) ? its_negative_string : its_too_large_string));
  index = caddr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->byte_vector_ref_symbol, args, T_INTEGER, 3));
  ind2 = s7_integer(index);
  if ((ind2 < 0) || (ind2 >= vector_dimension(iv, 1)))
    return(simple_out_of_range(sc, sc->byte_vector_ref_symbol, index, (ind2 < 0) ? its_negative_string : its_too_large_string));
  ind1 = ind1 * vector_offset(iv, 0) + ind2;
  return(make_integer(sc, byte_vector(iv, ind1)));
}

static s7_pointer byte_vector_ref_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    return(sc->bv_ref_2);
  if (args == 3)
    return(sc->bv_ref_3);
  return(f);
}


/* -------------------------------- byte-vector-set -------------------------------- */
static s7_pointer g_byte_vector_set(s7_scheme *sc, s7_pointer args)
{
  #define H_byte_vector_set "(byte-vector-set! vect index byte) sets the index-th element of the byte-vector vect to the integer byte"
  #define Q_byte_vector_set s7_make_circular_signature(sc, 2, 3, sc->is_byte_symbol, sc->is_byte_vector_symbol, sc->is_integer_symbol)
  return(univect_set(sc, args, sc->byte_vector_set_symbol, T_BYTE_VECTOR));
}

static s7_int byte_vector_set_i_7pii(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2)
{
  if (!is_byte_vector(p1))
    simple_wrong_type_argument_with_type(sc, sc->byte_vector_set_symbol, p1, a_byte_vector_string);
  if ((i2 < 0) || (i2 > 255))
    simple_wrong_type_argument_with_type(sc, sc->byte_vector_set_symbol, wrap_integer1(sc, i2), an_unsigned_byte_string);
  if ((i1 >= 0) && (i1 < byte_vector_length(p1)))
    byte_vector(p1, i1) = (uint8_t)i2;
  else simple_out_of_range(sc, sc->byte_vector_set_symbol, wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(i2);
}

static s7_int byte_vector_set_unchecked(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_int i2) {byte_vector(p1, i1) = (uint8_t)i2; return(i2);}
static s7_pointer byte_vector_set_unchecked_p(s7_scheme *sc, s7_pointer p1, s7_int i1, s7_pointer p2) {byte_vector(p1, i1) = (uint8_t)s7_integer(p2); return(p2);}

static s7_int byte_vector_set_i_7piii(s7_scheme *sc, s7_pointer v, s7_int i1, s7_int i2, s7_int i3)
{
  if ((i3 < 0) || (i3 > 255))
    simple_wrong_type_argument_with_type(sc, sc->byte_vector_set_symbol, wrap_integer1(sc, i3), an_unsigned_byte_string);
  if ((i1 >= 0) && (i1 < vector_dimension(v, 0)))
    {
      if ((i2 >= 0) && (i2 < vector_dimension(v, 1)))
	{
	  byte_vector(v, i2 + (i1 * vector_offset(v, 0))) = i3;
	  return(i3);
	}
      out_of_range(sc, sc->int_vector_set_symbol, small_int(3), wrap_integer1(sc, i2), (i2 < 0) ? its_negative_string : its_too_large_string);
    }
  out_of_range(sc, sc->int_vector_set_symbol, small_int(2), wrap_integer1(sc, i1), (i1 < 0) ? its_negative_string : its_too_large_string);
  return(0);
}

static s7_pointer g_bv_set_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer v, index, value;
  s7_int ind, uval;
  v = car(args);
  if (!is_byte_vector(v))
    return(method_or_bust(sc, v, sc->byte_vector_set_symbol, args, T_BYTE_VECTOR, 1));
  if (vector_rank(v) != 1)
    return(univect_set(sc, args, sc->byte_vector_set_symbol, T_BYTE_VECTOR));
  index = cadr(args);
  if (!s7_is_integer(index))
    return(method_or_bust(sc, index, sc->byte_vector_set_symbol, args, T_INTEGER, 2));
  ind = s7_integer(index);
  if ((ind < 0) || (ind >= vector_length(v)))
    return(simple_out_of_range(sc, sc->byte_vector_set_symbol, index, (ind < 0) ? its_negative_string : its_too_large_string));
  value = caddr(args);
  if (!s7_is_integer(value))
    return(method_or_bust(sc, value, sc->byte_vector_set_symbol, args, T_INTEGER, 3));
  if ((ind < 0) || (ind >= vector_length(v)))
    return(simple_out_of_range(sc, sc->byte_vector_set_symbol, index, (ind < 0) ? its_negative_string : its_too_large_string));
  uval = s7_integer(value);
  if ((uval < 0) || (uval > 255))
    simple_wrong_type_argument_with_type(sc, sc->byte_vector_set_symbol, value, an_unsigned_byte_string);
  if (is_immutable_vector(v))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->byte_vector_set_symbol, v)));
  byte_vector(v, ind) = (uint8_t)uval;
  return(value);
}

static s7_pointer byte_vector_set_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 3)
    return(sc->bv_set_3);
  return(f);
}


/* -------------------------------------------------------------------------------- */

static bool c_function_is_ok(s7_scheme *sc, s7_pointer x)
{
  /* macro version of this (below) is much slower! Since this is almost never false,
   *   I tried __builtin_expect throughout eval below.  The result was not faster.
   */
  s7_pointer p;

  p = car(x);               /* function name (symbol) */
  if (is_global(p))
    p = slot_value(global_slot(p));
  else p = lookup_checked(sc, p);

  /* this is nearly always global and p == opt1_cfunc(x)
   * p can be null if we evaluate some code, optimizing it, then eval it again in a context
   *   where the incoming p was undefined(!) -- explicit use of eval and so on.
   *   I guess ideally eval would ignore optimization info -- copy :readable or something.
   */
  return((p == opt1_any(x)) ||
	 ((is_any_c_function(p)) &&
	  (c_function_class(p) == c_function_class(opt1_cfunc(x)))));
}

static bool arglist_has_rest(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  for (p = args; is_pair(p); p = cdr(p))
    if (car(p) == sc->key_rest_symbol)
      return(true);
  return(!is_null(p));
}

static bool bool_optimize(s7_scheme *sc, s7_pointer expr);
static bool bool_optimize_nw(s7_scheme *sc, s7_pointer expr);
static bool cell_optimize(s7_scheme *sc, s7_pointer expr);

static void pc_fallback(s7_scheme *sc, int32_t new_pc)
{
  sc->pc = new_pc;
}


/* -------------------------------- sort! -------------------------------- */

#if (!WITH_GMP)
static int32_t dbl_less(const void *f1, const void *f2)
{
  if ((*((s7_double *)f1)) < (*((s7_double *)f2))) return(-1);
  if ((*((s7_double *)f1)) > (*((s7_double *)f2))) return(1);
  return(0);
}

static int32_t int_less(const void *f1, const void *f2)
{
  if ((*((s7_int *)f1)) < (*((s7_int *)f2))) return(-1);
  if ((*((s7_int *)f1)) > (*((s7_int *)f2))) return(1);
  return(0);
}

static int32_t dbl_greater(const void *f1, const void *f2) {return(-dbl_less(f1, f2));}
static int32_t int_greater(const void *f1, const void *f2) {return(-int_less(f1, f2));}

static int32_t byte_less(const void *f1, const void *f2)
{
  if ((*((uint8_t *)f1)) < (*((uint8_t *)f2))) return(-1);
  if ((*((uint8_t *)f1)) > (*((uint8_t *)f2))) return(1);
  return(0);
}

static int32_t byte_greater(const void *f1, const void *f2) {return(-byte_less(f1, f2));}

static int32_t dbl_less_2(const void *f1, const void *f2)
{
  s7_pointer p1, p2;
  p1 = (*((s7_pointer *)f1));
  p2 = (*((s7_pointer *)f2));
  if (real(p1) < real(p2)) return(-1);
  if (real(p1) > real(p2)) return(1);
  return(0);
}

static int32_t int_less_2(const void *f1, const void *f2)
{
  s7_pointer p1, p2;
  p1 = (*((s7_pointer *)f1));
  p2 = (*((s7_pointer *)f2));
  if (integer(p1) < integer(p2)) return(-1);
  if (integer(p1) > integer(p2)) return(1);
  return(0);
}

static int32_t dbl_greater_2(const void *f1, const void *f2) {return(-dbl_less_2(f1, f2));}
static int32_t int_greater_2(const void *f1, const void *f2) {return(-int_less_2(f1, f2));}

static int32_t str_less_2(const void *f1, const void *f2)
{
  s7_pointer p1, p2;
  p1 = (*((s7_pointer *)f1));
  p2 = (*((s7_pointer *)f2));
  return(scheme_strcmp(p1, p2));
}

static int32_t str_greater_2(const void *f1, const void *f2) {return(-str_less_2(f1, f2));}

static int32_t chr_less_2(const void *f1, const void *f2)
{
  s7_pointer p1, p2;
  p1 = (*((s7_pointer *)f1));
  p2 = (*((s7_pointer *)f2));
  if (character(p1) < character(p2)) return(-1);
  if (character(p1) > character(p2)) return(1);
  return(0);
}

static int32_t chr_greater_2(const void *f1, const void *f2) {return(-chr_less_2(f1, f2));}
#endif

#if MS_WINDOWS || defined(__APPLE__) || defined(__FreeBSD__)
/* from stackoverflow */
struct sort_r_data
{
  void *arg;
  int (*compar)(const void *a1, const void *a2, void *aarg);
};

int sort_r_arg_swap(void *s, const void *aa, const void *bb)
{
  struct sort_r_data *ss = (struct sort_r_data*)s;
  return (ss->compar)(aa, bb, ss->arg);
}
#endif

/* qsort_r in Linux requires _GNU_SOURCE and is different from q_sort_r in FreeBSD, neither matches qsort_s in Windows
 *  this code tested only in Linux and the mac -- my virtualbox freebsd died, netbsd and openbsd run using fallback code.
 */
void local_qsort_r(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *, void *), void *arg)
{
#if defined(__linux__)
  qsort_r(base, nmemb, size, compar, arg);
#else
#if defined(__APPLE__) || defined(__FreeBSD__) /* not in OpenBSD or NetBSD as far as I can tell */
  struct sort_r_data tmp = {arg, compar};
  qsort_r(base, nmemb, size, &tmp, &sort_r_arg_swap);
#else
#if MS_WINDOWS
  struct sort_r_data tmp = {arg, compar};
  qsort_s(*base, nmemb, size, &sort_r_arg_swap, &tmp);
#else
    /* from the Net somewhere, by "Pete", about 25 times slower than libc's qsort_r in this context */
  if (nmemb > 1)
    {
      uint8_t *array, *i, *j, *k;
      size_t h, t;
      uint8_t *after;
      array = base;
      after = nmemb * size + array;
      nmemb /= 4;
      h = nmemb + 1;
      for (t = 1; nmemb != 0; nmemb /= 4)
	t *= 2;
      do {
	size_t bytes;
	bytes = h * size;
	i = bytes + array;
	do {
	  j = i - bytes;
	  if (compar(j, i, arg) > 0)
	    {
	      k = i;
	      do {
		uint8_t *end, *p1, *p2;
		p1  = j;
		p2  = k;
		end = p2 + size;
		do {
		  uint8_t swap;
		  swap  = *p1;
		  *p1++ = *p2;
		  *p2++ = swap;
		} while (p2 != end);
		if (bytes + array > j)
		  break;
		k = j;
		j -= bytes;
	      } while (compar(j, k, arg) > 0);
	    }
	  i += size;
	} while (i != after);
	t /= 2;
	h = t * t - t * 3 / 2 + 1;
      } while (t != 0);
    }
#endif
#endif
#endif
}

static int32_t vector_sort(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  return(((*(sc->sort_f))(sc, (*(s7_pointer *)v1), (*(s7_pointer *)v2))) ? -1 : 1);
}

static int32_t vector_sort_lt(const void *v1, const void *v2, void *arg) /* for qsort_r */
{
  return((lt_b_7pp((s7_scheme *)arg, (*(s7_pointer *)v1), (*(s7_pointer *)v2))) ? -1 : 1);
}

static int32_t vector_car_sort(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  s7_pointer a, b;
  a = (*(s7_pointer *)v1);
  b = (*(s7_pointer *)v2);
  a = (is_pair(a)) ? car(a) : g_car(sc, set_plist_1(sc, a));
  b = (is_pair(b)) ? car(b) : g_car(sc, set_plist_1(sc, b));
  return(((*(sc->sort_f))(sc, a, b)) ? -1 : 1);
}

static int32_t vector_cdr_sort(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  s7_pointer a, b;
  a = (*(s7_pointer *)v1);
  b = (*(s7_pointer *)v2);
  a = (is_pair(a)) ? cdr(a) : g_cdr(sc, set_plist_1(sc, a));
  b = (is_pair(b)) ? cdr(b) : g_cdr(sc, set_plist_1(sc, b));
  return(((*(sc->sort_f))(sc, a, b)) ? -1 : 1);
}

static int32_t opt_bool_sort(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  slot_set_value(sc->sort_v1, (*(s7_pointer *)v1)); /* first slot in curlet */
  slot_set_value(sc->sort_v2, (*(s7_pointer *)v2)); /* second slot in curlet */
  sc->pc = 0;                                       /* always opt_bool_call here, so insert it */
  return((sc->opts[0]->v[0].fb(sc->opts[0])) ? -1 : 1);
}

static int32_t opt_bool_sort_p(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  slot_set_value(sc->sort_v1, (*(s7_pointer *)v1));
  slot_set_value(sc->sort_v2, (*(s7_pointer *)v2));
  sc->pc = 0;
  return((sc->opts[0]->v[7].fp(sc->opts[0]) == sc->F) ? 1 : -1);
}

static int32_t opt_begin_bool_sort_b(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  s7_int i;
  opt_info *o;
  slot_set_value(sc->sort_v1, (*(s7_pointer *)v1));
  slot_set_value(sc->sort_v2, (*(s7_pointer *)v2));
  sc->pc = -1;
  for (i = 0; i < sc->sort_body_len - 1; i++)
    {
      o = sc->opts[++sc->pc];
      o->v[0].fp(o);
    }
  o = sc->opts[++sc->pc];
  return((o->v[0].fb(o)) ? -1 : 1);
}

static int32_t opt_begin_bool_sort_p(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  s7_int i;
  opt_info *o;
  s7_pointer val;
  slot_set_value(sc->sort_v1, (*(s7_pointer *)v1));
  slot_set_value(sc->sort_v2, (*(s7_pointer *)v2));
  sc->pc = -1;
  for (i = 0; i < sc->sort_body_len - 1; i++)
    {
      o = sc->opts[++sc->pc];
      o->v[0].fp(o);
    }
  o = sc->opts[++sc->pc];
  val = o->v[0].fp(o);
  return((val != sc->F) ? -1 : 1);
}

static int32_t closure_sort(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  slot_set_value(sc->sort_v1, (*(s7_pointer *)v1));
  slot_set_value(sc->sort_v2, (*(s7_pointer *)v2));
  push_stack(sc, OP_EVAL_DONE, sc->sort_body, sc->code);
  sc->code = sc->sort_body; /* this should be ok because we checked in advance that it is a safe closure (no sort! for example) */
  eval(sc, sc->sort_op);
  return((sc->value != sc->F) ? -1 : 1);
}

static int32_t closure_sort_begin(const void *v1, const void *v2, void *arg)
{
  s7_scheme *sc = (s7_scheme *)arg;
  slot_set_value(sc->sort_v1, (*(s7_pointer *)v1));
  slot_set_value(sc->sort_v2, (*(s7_pointer *)v2));
  push_stack(sc, OP_EVAL_DONE, sc->sort_body, sc->code);
  push_stack_no_args(sc, OP_BEGIN1, sc->sort_begin);
  sc->code = sc->sort_body;
  eval(sc, sc->sort_op);
  return((sc->value != sc->F) ? -1 : 1);
}

static bool p_to_b(void *p);
static s7_b_7pp_t s7_b_7pp_function(s7_pointer f);

static s7_pointer g_sort(s7_scheme *sc, s7_pointer args)
{
  #define H_sort "(sort! sequence less?) sorts a sequence using the function 'less?' to compare elements."
  #define Q_sort s7_make_signature(sc, 3, sc->is_sequence_symbol, sc->is_sequence_symbol, sc->is_procedure_symbol)

  s7_pointer data, lessp, lx;
  s7_int len = 0, n, k;
  int32_t (*sort_func)(const void *v1, const void *v2, void *arg);
  s7_pointer *elements;

  /* both the intermediate vector (if any) and the current args pointer need GC protection,
   *   but it is a real bother to unprotect args at every return statement, so I'll use temp3
   */
  sc->temp3 = args; /* this is needed! */
  data = car(args);
  if (is_null(data))
    {
      /* (apply sort! () #f) should be an error I think */
      lessp = cadr(args);
      if (type(lessp) < T_CONTINUATION)
	return(method_or_bust_with_type(sc, lessp, sc->sort_symbol, args, a_procedure_string, 2));
      if (!s7_is_aritable(sc, lessp, 2))
	return(wrong_type_argument_with_type(sc, sc->sort_symbol, 2, lessp, an_eq_func_string));
      return(sc->nil);
    }

  if (is_immutable(data))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->sort_symbol, data)));
  if (!is_sequence(data))
    return(wrong_type_argument_with_type(sc, sc->sort_symbol, 1, data, a_sequence_string));

  lessp = cadr(args);
  if (type(lessp) <= T_GOTO)
    return(wrong_type_argument_with_type(sc, sc->sort_symbol, 2, lessp, a_normal_procedure_string));
  if (!s7_is_aritable(sc, lessp, 2))
    return(wrong_type_argument_with_type(sc, sc->sort_symbol, 2, lessp, an_eq_func_string));

  sort_func = NULL;
  sc->sort_f = NULL;

  if ((is_safe_procedure(lessp)) &&     /* (sort! a <) */
      (is_c_function(lessp)))
    {
      s7_pointer sig;
      sig = c_function_signature(lessp);
      if ((sig) &&
	  (is_pair(sig)) &&
	  (car(sig) != sc->is_boolean_symbol))
	return(wrong_type_argument_with_type(sc, sc->sort_symbol, 2, lessp,
					     wrap_string(sc, "sort! function should return a boolean", 38)));
      sc->sort_f = s7_b_7pp_function(lessp);
      if (sc->sort_f) sort_func = (sc->sort_f == lt_b_7pp) ? vector_sort_lt : vector_sort;
    }
  else
    {
      if (is_closure(lessp))
	{
	  s7_pointer expr, largs;
	  expr = car(closure_body(lessp));
	  largs = closure_args(lessp);

	  if ((is_pair(largs)) &&       /* closure args not a symbol, etc */
	      (!arglist_has_rest(sc, largs)))
	    {
	      if (is_null(cdr(closure_body(lessp))))
		{
		  if ((is_optimized(expr)) &&
		      /* since (sort seq (lambda (a b) ...)) can't return a "safe closure" (the hop bit is off in
		       *   optimize in this case, for some arcane reason), the optimized expression won't be hop_safe,
		       *   but that is irrelevant at this point -- if c_function_is_ok, we're good to go.
		       */
		      (((optimize_op(expr) & 1) != 0) ||
		       ((is_global(car(expr))) &&            /* (sort! x (lambda (car y) (car x)...))! */
			(c_function_is_ok(sc, expr)))))
		    {
		      int32_t orig_data;
		      s7_pointer lp;

		      orig_data = optimize_op(expr);
		      set_optimize_op(expr, optimize_op(expr) | 1);
		      if ((optimize_op(expr) == HOP_SAFE_C_SS) &&
			  (car(largs) == cadr(expr)) &&
			  (cadr(largs) == caddr(expr)))
			{
			  lp = lookup(sc, car(expr));
			  sc->sort_f = s7_b_7pp_function(lp);
			  if (sc->sort_f)
			    {
			      sort_func = (sc->sort_f == lt_b_7pp) ? vector_sort_lt : vector_sort;
			      lessp = lp;
			    }
			}
		      else
			{
			  if ((optimize_op(expr) == HOP_SAFE_C_opSq_opSq) &&
			      ((caadr(expr) == sc->car_symbol) || (caadr(expr) == sc->cdr_symbol)) &&
			      (caadr(expr) == caaddr(expr)) &&
			      (car(largs) == cadadr(expr)) &&
			      (cadr(largs) == cadr(caddr(expr))))
			    {
			      lp = lookup(sc, car(expr));
			      sc->sort_f = s7_b_7pp_function(lp);
			      if (sc->sort_f)
				{
				  sort_func = ((caadr(expr) == sc->car_symbol) ? vector_car_sort : vector_cdr_sort);
				  lessp = lp;
				}
			    }
			}
		      set_optimize_op(expr, orig_data);
		    }
		}

	      if (!sort_func)
		{
		  s7_pointer init_val, old_e;
		  if (is_float_vector(data))
		    init_val = real_zero;
		  else
		    {
		      if ((is_int_vector(data)) || (is_byte_vector(data)))
			init_val = small_int(0);
		      else init_val = sc->F;
		    }
		  old_e = sc->envir;
		  new_frame_with_two_slots(sc, closure_let(lessp), sc->envir, car(largs), init_val, cadr(largs), init_val);
		  sc->sort_body = expr;
		  sc->sort_v1 = let_slots(sc->envir);
		  sc->sort_v2 = next_slot(let_slots(sc->envir));
		  if (is_null(cdr(closure_body(lessp))))
		    {
		      s7_function sf1;
		      sf1 = s7_bool_optimize(sc, closure_body(lessp));
		      if (sf1 == opt_bool_any)
			{
			  if (sc->opts[0]->v[0].fb == p_to_b)
			    sort_func = opt_bool_sort_p;
			  else sort_func = opt_bool_sort;
			}
		    }
		  else
		    {
		      if (setjmp(sc->opt_exit) == 0)
			{
			  s7_pointer p;
			  sc->sort_body_len = s7_list_length(sc, closure_body(lessp));
			  sc->pc = 0;
			  for (p = closure_body(lessp); is_pair(cdr(p)); p = cdr(p))
			    if (!cell_optimize(sc, p))
			      break;
			  if (is_null(cdr(p)))
			    {
			      int32_t start;
			      start = sc->pc;
			      if (bool_optimize_nw(sc, p))
				sort_func = opt_begin_bool_sort_b;
			      else
				{
				  pc_fallback(sc, start);
				  if (cell_optimize(sc, p))
				    sort_func = opt_begin_bool_sort_p;
				}
			    }
			}
		    }
		  if (!sort_func)
		    sc->envir = old_e;
		}

	      if ((!sort_func) &&
		  (is_safe_closure(lessp))) /* no embedded sort! or call/cc, etc */
		{
		  new_frame_with_two_slots(sc, closure_let(lessp), sc->envir, car(largs), sc->F, cadr(largs), sc->F);
		  sc->sort_body = car(closure_body(lessp));
		  sc->sort_begin = cdr(closure_body(lessp));
		  if (is_null(sc->sort_begin))
		    sort_func = closure_sort;
		  else sort_func = closure_sort_begin;
		  if (is_syntactic_pair(sc->sort_body))
		    sc->sort_op = (opcode_t)optimize_op(sc->sort_body);
		  else sc->sort_op = OP_EVAL;
		  sc->sort_v1 = let_slots(sc->envir);
		  sc->sort_v2 = next_slot(let_slots(sc->envir));
		}
	    }
	}
    }

  switch (type(data))
    {
    case T_PAIR:
      len = s7_list_length(sc, data);            /* 0 here == infinite */
      if (len <= 0)
	return(s7_error(sc, sc->wrong_type_arg_symbol,
			set_elist_2(sc, wrap_string(sc, "sort! argument 1 should be a proper list: ~S", 44), data)));
      if (len < 2)
	return(data);

      if (sort_func)
	{
	  s7_int i;
	  s7_pointer vec, p;

	  vec = g_vector(sc, data);
	  push_stack_no_let_no_code(sc, OP_GC_PROTECT, vec);
	  elements = s7_vector_elements(vec);

	  sc->v = vec;
	  local_qsort_r((void *)elements, len, sizeof(s7_pointer), sort_func, (void *)sc);
	  for (p = data, i = 0; i < len; i++, p = cdr(p))
	    set_car(p, elements[i]);

	  unstack(sc); /* not pop_stack! */
	  return(data);
	}

      push_stack(sc, OP_SORT_PAIR_END, cons(sc, data, lessp), sc->code); /* save and gc protect the original list and func */
      set_car(args, g_vector(sc, data));
      break;

    case T_BYTE_VECTOR:
    case T_STRING:
      {
	s7_int i;
	s7_pointer vec;
	uint8_t *chrs;

	if (is_string(data))
	  {
	    len = string_length(data);
	    chrs = (uint8_t *)string_value(data);
	  }
	else
	  {
	    len = byte_vector_length(data);
	    chrs = byte_vector_bytes(data);
	  }
	if (len < 2) return(data);

#if (!WITH_GMP)
	if (is_c_function(lessp))
	  {
	    if (((is_string(data)) && (sc->sort_f == char_lt_b_7pp)) ||
		((is_byte_vector(data)) && (sc->sort_f == lt_b_7pp)))
	      {
		qsort((void *)chrs, len, sizeof(uint8_t), byte_less);
		return(data);
	      }
	    if (((is_string(data)) && (sc->sort_f == char_gt_b_7pp)) ||
		((is_byte_vector(data)) && (sc->sort_f == gt_b_7pp)))
	      {
		qsort((void *)chrs, len, sizeof(uint8_t), byte_greater);
		return(data);
	      }
	  }
#endif
	vec = make_simple_vector(sc, len);
	push_stack_no_let_no_code(sc, OP_GC_PROTECT, vec);
	elements = s7_vector_elements(vec);

	if (is_byte_vector(data))
	  {
	    for (i = 0; i < len; i++)
	      elements[i] = small_int(chrs[i]);
	  }
	else
	  {
	    for (i = 0; i < len; i++)
	      elements[i] = chars[chrs[i]];
	  }

	if (sort_func)
	  {
	    sc->v = vec;
	    local_qsort_r((void *)elements, len, sizeof(s7_pointer), sort_func, (void *)sc);

	    if (is_byte_vector(data))
	      {
		for (i = 0; i < len; i++)
		  chrs[i] = (char)integer(elements[i]);
	      }
	    else
	      {
		for (i = 0; i < len; i++)
		  chrs[i] = character(elements[i]);
	      }
	    unstack(sc); /* not pop_stack! */
	    return(data);
	  }

	unstack(sc); /* not pop_stack! */
	push_stack(sc, OP_SORT_STRING_END, cons(sc, data, lessp), sc->code);
	set_car(args, vec);
      }
      break;

    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
      {
	s7_int i;
	s7_pointer vec;

	len = vector_length(data);
	if (len < 2)
	  return(data);
#if (!WITH_GMP)
	if (is_c_function(lessp))
	  {
	    if (sc->sort_f == lt_b_7pp)
	      {
		if (is_float_vector(data))
		  qsort((void *)vector_elements(data), len, sizeof(s7_double), dbl_less);
		else qsort((void *)vector_elements(data), len, sizeof(s7_int), int_less);
		return(data);
	      }
	    if (sc->sort_f == gt_b_7pp)
	      {
		if (is_float_vector(data))
		  qsort((void *)vector_elements(data), len, sizeof(s7_double), dbl_greater);
		else qsort((void *)vector_elements(data), len, sizeof(s7_int), int_greater);
		return(data);
	      }
	  }
#endif
	/* currently we have to make the ordinary vector here even if not sf1
	 *   because the sorter uses vector_element to access sort args (see SORT_DATA in eval).
	 *   This is probably better than passing down getter/setter (fewer allocations).
	 *   get/set macro in eval is SORT_DATA(k) then s7_vector_to_list if pair at start (sort_*_end)
	 */
	vec = make_vector_1(sc, len, FILLED, T_VECTOR);
	add_vector(sc, vec);
	/* we need this vector prefilled because vector_getter below makes reals/int, causing possible GC
	 *   at any time during that loop, and the GC mark process expects the vector to have an s7_pointer
	 *   at every element.
	 */
	push_stack_no_let_no_code(sc, OP_GC_PROTECT, vec);
	elements = s7_vector_elements(vec);

	for (i = 0; i < len; i++)
	  elements[i] = vector_getter(data)(sc, data, i);

	if (sort_func)
	  {
	    sc->v = vec;
	    local_qsort_r((void *)elements, len, sizeof(s7_pointer), sort_func, (void *)sc);

	    for (i = 0; i < len; i++)
	      vector_setter(data)(sc, data, i, elements[i]); /* data is not a typed vector */

	    unstack(sc);
	    return(data);
	  }
	unstack(sc);
	set_car(args, vec);
	push_stack(sc, OP_SORT_VECTOR_END, cons(sc, data, lessp), sc->code); /* save and gc protect the original homogeneous vector and func */
      }
      break;

    case T_VECTOR:
      len = vector_length(data);
      if (len < 2)
	return(data);
      if (sort_func)
	{
#if (!WITH_GMP)
	  int32_t typ;
	  s7_pointer *els;
	  els = s7_vector_elements(data);
	  typ = type(els[0]);
	  if ((typ == T_INTEGER) || (typ == T_REAL) || (typ == T_STRING) || (typ == T_CHARACTER))
	    {
	      s7_int i;
	      for (i = 1; i < len; i++)
		if (type(els[i]) != typ)
		  {
		    typ = T_FREE;
		    break;
		  }
	    }
	  if ((sc->sort_f == lt_b_7pp) || (sc->sort_f == gt_b_7pp))
	    {
	      if (typ == T_INTEGER)
		{
		  qsort((void *)els, len, sizeof(s7_pointer), ((sc->sort_f == lt_b_7pp) ? int_less_2 : int_greater_2));
		  return(data);
		}
	      if (typ == T_REAL)
		{
		  qsort((void *)els, len, sizeof(s7_pointer), ((sc->sort_f == lt_b_7pp) ? dbl_less_2 : dbl_greater_2));
		  return(data);
		}
	    }
	  if ((typ == T_STRING) &&
	      ((sc->sort_f == string_lt_b_7pp) || (sc->sort_f == string_gt_b_7pp)))
	    {
	      qsort((void *)els, len, sizeof(s7_pointer), ((sc->sort_f == string_lt_b_7pp) ? str_less_2 : str_greater_2));
	      return(data);
	    }
	  if ((typ == T_CHARACTER) &&
	      ((sc->sort_f == char_lt_b_7pp) || (sc->sort_f == char_gt_b_7pp)))
	    {
	      qsort((void *)els, len, sizeof(s7_pointer), ((sc->sort_f = char_lt_b_7pp) ? chr_less_2 : chr_greater_2));
	      return(data);
	    }
#endif
	  local_qsort_r((void *)s7_vector_elements(data), len, sizeof(s7_pointer), sort_func, (void *)sc);
	  return(data);
	}
      break;

    default:
      return(method_or_bust_with_type(sc, data, sc->sort_symbol, args, a_sequence_string, 1));
    }

  n = len - 1;
  k = (n / 2) + 1;

  lx = s7_make_vector(sc, (sc->safety == NO_SAFETY) ? 4 : 6);
  {
    s7_int gc_loc;
    gc_loc = s7_gc_protect_1(sc, lx);
    sc->v = lx;

    vector_element(lx, 0) = make_mutable_integer(sc, n);
    vector_element(lx, 1) = make_mutable_integer(sc, k);
    vector_element(lx, 2) = make_mutable_integer(sc, 0);
    vector_element(lx, 3) = make_mutable_integer(sc, 0);
    if (sc->safety > NO_SAFETY)
      {
	vector_element(lx, 4) = make_mutable_integer(sc, 0);
	vector_element(lx, 5) = make_integer(sc, n * n);
      }
    push_stack(sc, OP_SORT, args, lx);
    s7_gc_unprotect_at(sc, gc_loc);
  }
  return(sc->F);
  /* if the comparison function waffles, sort! can hang: (sort! '(1 2 3) (lambda (a b) (= a b)))
   * set 'safety to 1 to add a check for this loop, but the "safe" procedures are direct, so unchecked.
   */
}

/* these are for the eval sort -- sort a vector, then if necessary put that data into the original sequence */
static s7_pointer vector_into_list(s7_pointer vect, s7_pointer lst)
{
  s7_pointer p;
  s7_pointer *elements;
  s7_int i, len;

  elements = s7_vector_elements(vect);
  len = vector_length(vect);
  for (i = 0, p = lst; i < len; i++, p = cdr(p))
    set_car(p, elements[i]);
  return(lst);
}

static s7_pointer vector_into_fi_vector(s7_pointer source, s7_pointer dest)
{
  s7_pointer *elements;
  s7_int i, len;

  elements = s7_vector_elements(source);
  len = vector_length(source);

  if (is_float_vector(dest))
    {
      s7_double *flts;
      flts = float_vector_floats(dest);
      for (i = 0; i < len; i++)
	flts[i] = real(elements[i]);
    }
  else
    {
      s7_int *ints;
      ints = int_vector_ints(dest);
      for (i = 0; i < len; i++)
	ints[i] = integer(elements[i]);
    }
  return(dest);
}

static s7_pointer vector_into_string(s7_pointer vect, s7_pointer dest)
{
  s7_pointer *elements;
  s7_int i, len;
  uint8_t *str;

  elements = s7_vector_elements(vect);
  len = vector_length(vect);

  if (is_byte_vector(dest))
    {
      str = (uint8_t *)byte_vector_bytes(dest);
      for (i = 0; i < len; i++)
	str[i] = (uint8_t)integer(elements[i]);
    }
  else
    {
      str = (uint8_t *)string_value(dest);
      for (i = 0; i < len; i++)
	str[i] = character(elements[i]);
    }
  return(dest);
}

#define SORT_N integer(vector_element(sc->code, 0))
#define SORT_K integer(vector_element(sc->code, 1))
#define SORT_J integer(vector_element(sc->code, 2))
#define SORT_K1 integer(vector_element(sc->code, 3))
#define SORT_CALLS integer(vector_element(sc->code, 4))
#define SORT_STOP integer(vector_element(sc->code, 5))
#define SORT_DATA(K) vector_element(car(sc->args), K)
#define SORT_LESSP cadr(sc->args)

static s7_pointer op_heapsort(s7_scheme *sc)
{
  s7_int n, j, k;
  s7_pointer lx;
  n = SORT_N;
  k = SORT_K1;

  if ((n == k) || (k > ((s7_int)(n / 2)))) /* k == n == 0 is the first case */
    return(sc->code);

  if (sc->safety > NO_SAFETY)
    {
      SORT_CALLS++;
      if (SORT_CALLS > SORT_STOP)
	eval_range_error(sc, "sort! is caught in an infinite loop, comparison: ~S", 51, SORT_LESSP);
    }
  j = 2 * k;
  SORT_J = j;
  if (j < n)
    {
      push_stack(sc, OP_SORT1, sc->args, sc->code);
      lx = SORT_LESSP; /* cadr of sc->args */
      if (needs_copied_args(lx))
	sc->args = list_2(sc, SORT_DATA(j), SORT_DATA(j + 1));
      else
	{
	  set_car(sc->t2_1, SORT_DATA(j));
	  set_car(sc->t2_2, SORT_DATA(j + 1));
	  sc->args = sc->t2_1;
	}
      sc->code = lx;
      sc->value = sc->T; /* for eval */
    }
  else sc->value = sc->F;
  return(NULL);
}

static bool op_sort1(s7_scheme *sc)
{
  s7_int j, k;
  s7_pointer lx;
  k = SORT_K1;
  j = SORT_J;
  if (is_true(sc, sc->value))
    {
      j = j + 1;
      SORT_J = j;
    }
  push_stack(sc, OP_SORT2, sc->args, sc->code);
  lx = SORT_LESSP;
  if (needs_copied_args(lx))
    sc->args = list_2(sc, SORT_DATA(k), SORT_DATA(j));
  else
    {
      set_car(sc->t2_1, SORT_DATA(k));
      set_car(sc->t2_2, SORT_DATA(j));
      sc->args = sc->t2_1;
    }
  sc->code = lx;
  return(false);
}

static bool op_sort2(s7_scheme *sc)
{
  s7_int j, k;
  k = SORT_K1;
  j = SORT_J;
  if (is_true(sc, sc->value))
    {
      s7_pointer lx;
      lx = SORT_DATA(j);
      SORT_DATA(j) = SORT_DATA(k);
      SORT_DATA(k) = lx;
    }
  else return(true);
  SORT_K1 = SORT_J;
  return(false);
}

static bool op_sort(s7_scheme *sc)
{
  /* coming in sc->args is sort args (data less?), sc->code = #(n k 0 ...)
   * here we call the inner loop until k <= 0 [the local k! -- this is tricky because scheme passes args by value]
   */
  s7_int k;
  k = SORT_K;
  if (k > 0)
    {
      SORT_K = k - 1;
      SORT_K1 = k - 1;
      push_stack(sc, OP_SORT, sc->args, sc->code);
      return(false);
    }
  return(true);
}

static bool op_sort3(s7_scheme *sc)
{
  s7_int n;
  s7_pointer lx;
  n = SORT_N;
  if (n <= 0)
    {
      sc->value = car(sc->args);
      return(true);
    }
  lx = SORT_DATA(0);
  SORT_DATA(0) = SORT_DATA(n);
  SORT_DATA(n) = lx;
  SORT_N = n - 1;
  SORT_K1 = 0;
  push_stack(sc, OP_SORT3, sc->args, sc->code);
  return(false);
}


/* -------- hash tables -------- */

static void free_hash_table(s7_scheme *sc, s7_pointer table)
{
  hash_entry_t **entries;
  entries = hash_table_elements(table);

  if (hash_table_entries(table) > 0)
    {
      s7_int i, len;
      len = hash_table_mask(table) + 1;

      for (i = 0; i < len; i++)
	{
	  hash_entry_t *p, *n;
	  for (p = entries[i++]; p; p = n)
	    {
	      n = hash_entry_next(p);
	      liberate_block(sc, p);
	    }
	  for (p = entries[i]; p; p = n)
	    {
	      n = hash_entry_next(p);
	      liberate_block(sc, p);
	    }
	}
    }
  liberate(sc, hash_table_block(table));
}

static hash_entry_t *make_hash_entry(s7_scheme *sc, s7_pointer key, s7_pointer value, s7_int raw_hash)
{
  hash_entry_t *p;
  p = (hash_entry_t *)mallocate_block(sc);
  hash_entry_key(p) = key;
  hash_entry_set_value(p, value);
  hash_entry_set_raw_hash(p, raw_hash);
  return(p);
}


/* -------------------------------- hash-table? -------------------------------- */
bool s7_is_hash_table(s7_pointer p) {return(is_hash_table(p));}

static s7_pointer g_is_hash_table(s7_scheme *sc, s7_pointer args)
{
  #define H_is_hash_table "(hash-table? obj) returns #t if obj is a hash-table"
  #define Q_is_hash_table sc->pl_bt
  check_boolean_method(sc, is_hash_table, sc->is_hash_table_symbol, args);
}


/* -------------------------------- hash-table-entries -------------------------------- */
static s7_pointer g_hash_table_entries(s7_scheme *sc, s7_pointer args)
{
  #define H_hash_table_entries "(hash-table-entries obj) returns the number of entries in the hash-table obj"
  #define Q_hash_table_entries s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_hash_table_symbol)

  if (!is_hash_table(car(args)))
    return(method_or_bust_one_arg(sc, car(args), sc->hash_table_entries_symbol, args, T_HASH_TABLE));
  return(make_integer(sc, hash_table_entries(car(args))));
}

static s7_int hash_table_entries_i_7p(s7_scheme *sc, s7_pointer p)
{
  if (!is_hash_table(p))
    return(integer(method_or_bust_one_arg(sc, p, sc->hash_table_entries_symbol, list_1(sc, p), T_HASH_TABLE)));
  return(hash_table_entries(p));
}


/* ---------------- mappers ---------------- */
static s7_int hash_float_location(s7_double x)
{
#if defined(__clang__)
  if ((is_inf(x)) || (is_NaN(x))) return(0);
#endif
  x = fabs(x);
  if (x < 100.0)
    return(1000.0 * x);     /* this means hash_table_float_epsilon only works if it is less than about .001 */
  return((s7_int)x);
}

/* built in hash loc tables for eq? eqv? equal? equivalent? = string=? string-ci=? char=? char-ci=? (default=equal?) */
#define hash_loc(Sc, Table, Key) (*(hash_table_mapper(Table)[type(Key)]))(Sc, Table, Key)

static hash_map_t eq_hash_map[NUM_TYPES];
static hash_map_t eqv_hash_map[NUM_TYPES];
static hash_map_t string_eq_hash_map[NUM_TYPES];
static hash_map_t number_eq_hash_map[NUM_TYPES];
static hash_map_t char_eq_hash_map[NUM_TYPES];
static hash_map_t closure_hash_map[NUM_TYPES];
static hash_map_t equivalent_hash_map[NUM_TYPES];
static hash_map_t c_function_hash_map[NUM_TYPES];
#if (!WITH_PURE_S7)
static hash_map_t string_ci_eq_hash_map[NUM_TYPES];
static hash_map_t char_ci_eq_hash_map[NUM_TYPES];
#endif

static s7_int hash_map_nil(s7_scheme *sc, s7_pointer table, s7_pointer key)     {return(type(key));}
static s7_int hash_map_int(s7_scheme *sc, s7_pointer table, s7_pointer key)     {return(integer(key));}
static s7_int hash_map_char(s7_scheme *sc, s7_pointer table, s7_pointer key)    {return(character(key));}
static s7_int hash_map_ratio(s7_scheme *sc, s7_pointer table, s7_pointer key)   {return(denominator(key));}
static s7_int hash_map_complex(s7_scheme *sc, s7_pointer table, s7_pointer key) {return(hash_float_location(real_part(key)));}
static s7_int hash_map_symbol(s7_scheme *sc, s7_pointer table, s7_pointer key)  {return(symbol_hmap(key));}
static s7_int hash_map_syntax(s7_scheme *sc, s7_pointer table, s7_pointer key)  {return(symbol_hmap(syntax_symbol(key)));}

#if WITH_GMP
static s7_int hash_map_big_int(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return((s7_int)(big_integer_to_s7_int(big_integer(key))));
}

static s7_int hash_map_big_ratio(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return((s7_int)(big_integer_to_s7_int(mpq_denref(big_ratio(key)))));
}

static s7_int hash_map_big_real(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return((s7_int)mpfr_get_d(big_real(key), GMP_RNDN));
}

static s7_int hash_map_big_complex(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return((s7_int)mpfr_get_d(mpc_realref(big_complex(key)), GMP_RNDN));
}
#endif

static s7_int hash_map_string(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (string_hash(key) == 0)
    string_hash(key) = raw_string_hash((const uint8_t *)string_value(key), string_length(key));
  return(string_hash(key));
}

#if (!WITH_PURE_S7)
static s7_int hash_map_ci_char(s7_scheme *sc, s7_pointer table, s7_pointer key) {return(upper_character(key));}

static s7_int hash_map_ci_string(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  s7_int len;
  len = string_length(key);
  if (len == 0) return(0);
  return(len + (uppers[(int32_t)(string_value(key)[0])] << 4));
}
#endif

static s7_int hash_map_real(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return(hash_float_location(real(key)));
  /* currently 1e300 goes to most-negative-fixnum! -> 0 after logand size, I hope
   *
   * we need round, not floor for the location calculation in the real/complex cases else
   *    1-eps doesn't match 1.0, but 1+eps does.  And what if round(val) is too big for int?
   *    lrint is complex and requires special compiler flags to get any speed (-fno-math-errno).
   *    all we need is (int32_t)(val+0.5) -- all the other stuff is pointless in this context
   */
}

static s7_int hash_map_real_eq(s7_scheme *sc, s7_pointer table, s7_pointer x)
{
  if (real(x) < 0.0)
    return(s7_round(-real(x)));
  return(s7_round(real(x)));
}

static s7_int hash_map_ratio_eq(s7_scheme *sc, s7_pointer table, s7_pointer y)
{
  s7_double x;
  x = fraction(y);
  if (x < 0.0)
    return(s7_round(-x));
  return(s7_round(x));
}

static s7_int hash_map_hash_table(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  /* hash-tables are equal if key/values match independent of table size and entry order.
   * if not using equivalent?, hash_table_checker|mapper must also be the same.
   * Keys are supposed to be constant while keys, so a hash-table shouldn't be a key of itself.
   */
  return(hash_table_entries(key));
}

static s7_int hash_map_int_vector(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (vector_length(key) == 0)
    return(0);
  if (vector_length(key) == 1)
    return(s7_int_abs(int_vector(key, 0)));
  return(vector_length(key) + s7_int_abs(int_vector(key, 0)) + s7_int_abs(int_vector(key, 1)));
}

static s7_int hash_map_byte_vector(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (byte_vector_length(key) == 0)
    return(0);
  if (byte_vector_length(key) == 1)
    return((s7_int)byte_vector(key, 0));
  return(byte_vector_length(key) + byte_vector(key, 0) + byte_vector(key, 1));
}

static s7_int hash_map_float_vector(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (vector_length(key) == 0)
    return(0);
  if (vector_length(key) == 1)
    return(hash_float_location(float_vector(key, 0)));
  return(vector_length(key) + hash_float_location(float_vector(key, 0)) + hash_float_location(float_vector(key, 1)));
}

static s7_int hash_map_vector(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if ((vector_length(key) == 0) ||
      (is_sequence(vector_element(key, 0))))
    return(vector_length(key));
  if ((vector_length(key) == 1) ||
      (is_sequence(vector_element(key, 1))))
    return(hash_loc(sc, table, vector_element(key, 0)));
  return(vector_length(key) + hash_loc(sc, table, vector_element(key, 0)) + hash_loc(sc, table, vector_element(key, 1)));
}

static s7_int hash_map_eq(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return(symbol_hmap(key)); /* weird -- this can be negative and not unique, needs to match symbol case */
}

static s7_int hash_map_closure(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  s7_pointer f, old_e, args, body;

  f = hash_table_procedures_mapper(table);
  old_e = sc->envir;
  args = closure_args(f);
  body = closure_body(f);
  new_frame_with_slot(sc, closure_let(f), sc->envir, (is_symbol(car(args))) ? car(args) : caar(args), key);
  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
  if (is_pair(cdr(body)))
    push_stack_no_args(sc, sc->begin_op, cdr(body));
  sc->code = car(body);
  eval(sc, OP_EVAL);
  sc->envir = old_e;
  return(integer(sc->value));
}

static s7_int hash_map_c_function(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  s7_function f;
  f = c_function_call(hash_table_procedures_mapper(table));
  set_car(sc->t1_1, key);
  return(integer(f(sc, sc->t1_1)));
}

static s7_int hash_map_let(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  /* lets are equal if same symbol/value pairs, independent of order, taking into account shadowing
   *   (length (inlet 'a 1 'a 2)) = 2
   * but this counts as just one entry from equal?'s point of view, so if more than one entry, we have a problem.
   *   (equal? (inlet 'a 1) (inlet 'a 3 'a 2 'a 1)) = #t
   * also currently equal? follows outlet, but that is ridiculous here, so in this case hash equal?
   *   is not the same as equal?  Surely anyone using lets as keys wants eq?
   */
  s7_pointer slot;
  s7_int slots;

  if ((key == sc->rootlet) ||
      (!tis_slot(let_slots(key))))
    return(0);
  slot = let_slots(key);
  if (!tis_slot(next_slot(slot)))
    {
      if (is_sequence(slot_value(slot))) /* avoid loop if cycles */
	return(symbol_hmap(slot_symbol(slot)));
      return(symbol_hmap(slot_symbol(slot)) + hash_loc(sc, table, slot_value(slot)));
    }
  slots = 0;
  for (; tis_slot(slot); slot = next_slot(slot))
    if (!is_matched_symbol(slot_symbol(slot)))
      {
	set_match_symbol(slot_symbol(slot));
	slots++;
      }
  for (slot = let_slots(key); tis_slot(slot); slot = next_slot(slot))
    clear_match_symbol(slot_symbol(slot));

  if (slots == 1)
    {
      slot = let_slots(key);
      if (is_sequence(slot_value(slot))) /* avoid loop if cycles */
	return(symbol_hmap(slot_symbol(slot)));
      return(symbol_hmap(slot_symbol(slot)) + hash_loc(sc, table, slot_value(slot)));
    }

  return(slots);
}

static int32_t len_upto_8(s7_pointer p)
{
  s7_pointer x;
  int32_t i;   /* unrolling this loop saves 10-15% */
  for (i = 0, x = p; (is_pair(x)) && (i < 8); i++, x = cdr(x));
  return(i);
}

static s7_int hash_map_pair(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  /* len+loc(car) is not horrible, but it means (for example) every list '(set! ...) is hashed to the same location,
   *   so at least we need to take cadr into account if possible.  Better would combine the list_length
   *   with stats like symbols/pairs/constants at top level, then use those to spread it out over all the locs.
   */
  s7_pointer p1;
  s7_int loc = 0;

  if (!is_sequence(car(key)))
    loc = hash_loc(sc, table, car(key)) + 1;
  else
    {
      if ((is_pair(car(key))) &&
	  (!is_sequence(caar(key))))
	loc = hash_loc(sc, table, caar(key)) + 1;
    }
  p1 = cdr(key);
  if (is_pair(p1))
    {
      if (!is_sequence(car(p1)))
	loc += hash_loc(sc, table, car(p1)) + 1;
      else
	{
	  if ((is_pair(car(p1))) &&
	      (!is_sequence(caar(p1))))
	    loc += hash_loc(sc, table, caar(p1)) + 1;
	}
    }
  loc = (loc << 3) | len_upto_8(key);
  return(loc);
}


/* ---------------- checkers ---------------- */
static hash_entry_t *hash_empty(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return(sc->unentry);
}

static hash_entry_t *hash_int(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (is_t_integer(key))
    {
      s7_int loc, hash_mask, kv;
      hash_entry_t *x;

      hash_mask = hash_table_mask(table);
      kv = integer(key);
      loc = kv & hash_mask;
      for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
	if (integer(hash_entry_key(x)) == kv)
	  return(x);
    }
  return(sc->unentry);
}

static hash_entry_t *hash_string(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (is_string(key))
    {
      hash_entry_t *x;
      s7_int key_len, hash_mask;
      uint64_t hash;
      const char *key_str;

      key_len = string_length(key);
      key_str = string_value(key);

      if (string_hash(key) == 0)
	string_hash(key) = raw_string_hash((const uint8_t *)string_value(key), string_length(key));
      hash = string_hash(key);

      hash_mask = hash_table_mask(table);
      if (key_len <= 8)
	{
	  for (x = hash_table_element(table, hash & hash_mask); x; x = hash_entry_next(x))
	    if ((hash == string_hash(hash_entry_key(x))) &&
		(key_len == string_length(hash_entry_key(x))))
	      return(x);
	}
      else
	{
	  for (x = hash_table_element(table, hash & hash_mask); x; x = hash_entry_next(x))
	    if ((hash == string_hash(hash_entry_key(x))) &&
		(key_len == string_length(hash_entry_key(x))) &&        /* these are scheme strings, so we can't assume 0=end of string */
		(strings_are_equal_with_length(key_str, string_value(hash_entry_key(x)), key_len)))
	      return(x);
	}
    }
  return(sc->unentry);
}

#if (!WITH_PURE_S7)
static hash_entry_t *hash_ci_string(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (is_string(key))
    {
      hash_entry_t *x;
      s7_int hash, hash_mask;

      hash_mask = hash_table_mask(table);
      hash = hash_map_ci_string(sc, table, key);

      for (x = hash_table_element(table, hash & hash_mask); x; x = hash_entry_next(x))
	if (scheme_strequal_ci(key, hash_entry_key(x)))
	  return(x);
    }
  return(sc->unentry);
}

static hash_entry_t *hash_ci_char(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (s7_is_character(key))
    {
      hash_entry_t *x;
      s7_int hash_mask, loc;

      hash_mask = hash_table_mask(table);
      loc = hash_loc(sc, table, key) & hash_mask;

      for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
	if (upper_character(key) == upper_character(hash_entry_key(x)))
	  return(x);
    }
  return(sc->unentry);
}
#endif

static hash_entry_t *hash_float_1(s7_scheme *sc, s7_pointer table, s7_int loc, s7_double keyval)
{
  hash_entry_t *x;
  bool look_for_nan;
  look_for_nan = is_NaN(keyval);

  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    {
      if (is_t_real(hash_entry_key(x))) /* we're possibly called from hash_equal, so keys might not be T_REAL */
	{
	  s7_double val;
	  val = real(hash_entry_key(x));
	  if (look_for_nan)
	    {
	      if (is_NaN(val))
		return(x);
	    }
	  else
	    {
	      if ((val == keyval) ||   /* inf case */
		  (fabs(val - keyval) < sc->hash_table_float_epsilon))
		return(x);
	    }
	}
    }
  return(sc->unentry);
}

static hash_entry_t *hash_float(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  /* give the equality check some room. also inf == inf and nan == nan */
  if (type(key) == T_REAL)
    {
      s7_double keyval;
      s7_int hash_mask, loc;

      hash_mask = hash_table_mask(table);
      keyval = real(key);
      loc = hash_float_location(keyval) & hash_mask;

      return(hash_float_1(sc, table, loc, keyval));
    }
  return(sc->unentry);
}

static hash_entry_t *hash_complex_1(s7_scheme *sc, s7_pointer table, s7_int loc, s7_pointer key)
{
  hash_entry_t *x;
  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if ((is_t_complex(hash_entry_key(x))) &&
	(s7_is_equivalent(sc, hash_entry_key(x), key)))
      return(x);
  return(sc->unentry);
}

static hash_entry_t *hash_equal_real(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return(hash_float_1(sc, table, hash_loc(sc, table, key) & hash_table_mask(table), real(key)));
}

static hash_entry_t *hash_equal_complex(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return(hash_complex_1(sc, table, hash_loc(sc, table, key) & hash_table_mask(table), key));
}

static hash_entry_t *hash_equal_syntax(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  s7_int loc;
  loc = hash_loc(sc, table, key) & hash_table_mask(table);
  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if ((is_syntax(hash_entry_key(x))) &&
	(syntax_symbol(hash_entry_key(x)) == syntax_symbol(key))) /* the opcodes might differ, but the symbols should not */
      return(x);
  return(sc->unentry);
}

static hash_entry_t *hash_equal_eq(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  s7_int loc;
  loc = hash_loc(sc, table, key) & hash_table_mask(table);
  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if (hash_entry_key(x) == key)
      return(x);
  return(sc->unentry);
}

static hash_entry_t *hash_equal_any(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  s7_int hash, loc;

  hash = hash_loc(sc, table, key);
  loc = hash & hash_table_mask(table);

  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if (hash_entry_raw_hash(x) == hash)
      if (s7_is_equal(sc, hash_entry_key(x), key))
	return(x);
  return(sc->unentry);
}

static hash_entry_t *(*default_hash_checks[NUM_TYPES])(s7_scheme *sc, s7_pointer table, s7_pointer key);
static hash_entry_t *(*equal_hash_checks[NUM_TYPES])(s7_scheme *sc, s7_pointer table, s7_pointer key);
static hash_entry_t *(*equivalent_hash_checks[NUM_TYPES])(s7_scheme *sc, s7_pointer table, s7_pointer key);

static hash_entry_t *hash_equal(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  return((*(equal_hash_checks[type(key)]))(sc, table, key));
}

static hash_entry_t *hash_equivalent(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  s7_int hash, loc;

  hash = hash_loc(sc, table, key);
  loc = hash & hash_table_mask(table);
  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if (hash_entry_key(x) == key)
      return(x);

  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if ((hash_entry_raw_hash(x) == hash) &&
	(s7_is_equivalent(sc, hash_entry_key(x), key)))
      return(x);
  return(sc->unentry);
}

static hash_entry_t *hash_c_function(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  s7_int hash_mask, hash, loc;
  s7_function f;

  f = c_function_call(hash_table_procedures_checker(table));
  hash_mask = hash_table_mask(table);
  hash = hash_loc(sc, table, key);
  loc = hash & hash_mask;

  set_car(sc->t2_1, key);
  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if (hash_entry_raw_hash(x) == hash)
      {
	set_car(sc->t2_2, hash_entry_key(x));
	if (is_true(sc, f(sc, sc->t2_1)))
	  return(x);
      }
  return(sc->unentry);
}

static hash_entry_t *hash_eq(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  /* explicit eq? as hash equality func or (for example) symbols as keys */
  hash_entry_t *x;
  s7_int hash_mask, loc;

  hash_mask = hash_table_mask(table);
  loc = symbol_hmap(key) & hash_mask; /* hash_map_eq */

  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if (key == hash_entry_key(x))
      return(x);

  return(sc->unentry);
}

static hash_entry_t *hash_eqv(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  s7_int hash_mask, loc;

  hash_mask = hash_table_mask(table);
  loc = hash_loc(sc, table, key) & hash_mask;

  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if (s7_is_eqv(key, hash_entry_key(x)))
      return(x);

  return(sc->unentry);
}

static hash_entry_t *hash_number(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (is_number(key))
    {
      hash_entry_t *x;
      s7_int hash_mask, loc;

      hash_mask = hash_table_mask(table);
      loc = hash_loc(sc, table, key) & hash_mask;

#if (!WITH_GMP)
      for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
	if ((is_number(hash_entry_key(x))) &&
	    (is_true(sc, c_equal_2(sc, key, hash_entry_key(x)))))
	  return(x);
#else
      for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
	if ((is_number(hash_entry_key(x))) &&
	    (is_true(sc, big_equal(sc, set_plist_2(sc, key, hash_entry_key(x))))))
	  return(x);
#endif
    }
  return(sc->unentry);
}

static hash_entry_t *hash_symbol(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  for (x = hash_table_element(table, symbol_hmap(key) & hash_table_mask(table)); x; x = hash_entry_next(x))
    if (key == hash_entry_key(x))
      return(x);
  return(sc->unentry);
}

static hash_entry_t *hash_char(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  if (s7_is_character(key))
    {
      /* return(hash_eq(sc, table, key));
       *   but I think if we get here at all, we have to be using default_hash_checks|maps -- see hash_symbol above.
       */
      hash_entry_t *x;
      s7_int loc;
      loc = character(key) & hash_table_mask(table);
      for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
	if (key == hash_entry_key(x))
	  return(x);
    }
  return(sc->unentry);
}

static hash_entry_t *hash_closure(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  s7_int hash_mask, hash, loc;
  s7_pointer f, args, body, old_e;

  f = hash_table_procedures_checker(table);
  hash_mask = hash_table_mask(table);
  hash = hash_loc(sc, table, key);
  loc = hash & hash_mask;

  old_e = sc->envir;
  args = closure_args(f);    /* in lambda* case, car/cadr(args) can be lists */
  body = closure_body(f);
  new_frame_with_two_slots(sc, closure_let(f), sc->envir,
			   (is_symbol(car(args))) ? car(args) : caar(args), key,
			   (is_symbol(cadr(args))) ? cadr(args) : caadr(args), sc->F);

  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if (hash_entry_raw_hash(x) == hash)
      {
	slot_set_value(next_slot(let_slots(sc->envir)), hash_entry_key(x));
	push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
	if (is_pair(cdr(body)))
	  push_stack_no_args(sc, sc->begin_op, cdr(body));
	sc->code = car(body);
	eval(sc, OP_EVAL);
	if (is_true(sc, sc->value))
	  {
	    sc->envir = old_e;
	    return(x);
	  }
      }
  sc->envir = old_e;
  return(sc->unentry);
}


/* -------------------------------- make-hash-table -------------------------------- */

s7_pointer s7_make_hash_table(s7_scheme *sc, s7_int size)
{
  s7_pointer table;
  block_t *els;
  /* size is rounded up to the next power of 2 */

  if (size < 2)
    size = 2;
  else
    {
      if ((size & (size - 1)) != 0)          /* already 2^n ? */
	{
	  if ((size & (size + 1)) != 0)      /* already 2^n - 1 ? */
	    {
	      size--;
	      size |= (size >> 1);
	      size |= (size >> 2);
	      size |= (size >> 4);
	      size |= (size >> 8);
	      size |= (size >> 16);
	      if (s7_int_bits > 31)          /* this is either 31 or 63 */
		size |= (size >> 32);
	    }
	  size++;
	}
    }

  els = (block_t *)callocate(sc, size * sizeof(hash_entry_t *));
  new_cell(sc, table, T_HASH_TABLE | T_SAFE_PROCEDURE);
  hash_table_mask(table) = size - 1;
  hash_table_set_block(table, els);
  hash_table_elements(table) = (hash_entry_t **)(block_data(els));
  hash_table_checker(table) = hash_empty;
  hash_table_mapper(table) = default_hash_map;
  hash_table_entries(table) = 0;
  hash_table_set_procedures(table, sc->nil);
  add_hash_table(sc, table);

  return(table);
}

static bool compatible_types(s7_scheme *sc, s7_pointer eq_type, s7_pointer value_type)
{
  if (eq_type == sc->T) return(true);
  if (eq_type == value_type) return(true);

  if (eq_type == sc->is_number_symbol)              /* only = among built-ins, so otherr cases aren't needed */
    return((value_type == sc->is_integer_symbol) ||
	   (value_type == sc->is_real_symbol) ||
	   (value_type == sc->is_complex_symbol) ||
	   (value_type == sc->is_rational_symbol));

  return(false);
}

static s7_pointer g_is_equal(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_equivalent(s7_scheme *sc, s7_pointer args);

static s7_pointer g_make_hash_table_1(s7_scheme *sc, s7_pointer args, s7_pointer caller)
{
  #define H_make_hash_table "(make-hash-table (size 8) eq-func typer) returns a new hash table"
  #define Q_make_hash_table s7_make_signature(sc, 4, sc->is_hash_table_symbol, sc->is_integer_symbol, \
					      s7_make_signature(sc, 3, sc->is_procedure_symbol, sc->is_pair_symbol, sc->not_symbol), \
					      s7_make_signature(sc, 2, sc->is_pair_symbol, sc->not_symbol))
  s7_int size;
  size = sc->default_hash_table_length;

  if (is_not_null(args))
    {
      s7_pointer p;
      p = car(args);
      if (!s7_is_integer(p))
	return(method_or_bust(sc, p, caller, args, T_INTEGER, 1));
      size = s7_integer(p);
      if (size <= 0)                      /* we need s7_int here to catch (make-hash-table most-negative-fixnum) etc */
	return(simple_out_of_range(sc, caller, p, wrap_string(sc, "should be a positive integer", 28)));
      if ((size > sc->max_vector_length) ||
	  (size >= (1LL << 32LL)))
	return(simple_out_of_range(sc, caller, p, its_too_large_string));

      if (is_not_null(cdr(args)))
	{
	  s7_pointer ht, proc, dproc;

	  ht = s7_make_hash_table(sc, size);
	  /* look for key/value type functions */
	  dproc = sc->nil;

	  /* check for typers */
	  if (is_pair(cddr(args)))
	    {
	      s7_pointer typers;
	      typers = caddr(args);
	      if (is_pair(typers))
		{
		  s7_pointer keyp, valp;
		  keyp = car(typers);
		  valp = cdr(typers);
		  if ((keyp != sc->T) || (valp != sc->T)) /* one of them is a type checker */
		    {
		      if (((keyp != sc->T) && (!is_c_function(keyp))) ||
			  ((valp != sc->T) && (!is_c_function(valp))))
			return(wrong_type_argument_with_type(sc, caller, 3, typers, wrap_string(sc, "(key-type . value-type)", 23)));
		      dproc = cons(sc, sc->T, sc->T);
		      hash_table_set_procedures(ht, dproc);
		      hash_table_set_key_typer(dproc, keyp);
		      hash_table_set_value_typer(dproc, valp);
		      if (is_c_function(keyp))
			{
			  if (!c_function_name(keyp))
			    return(wrong_type_argument_with_type(sc, caller, 3, keyp, wrap_string(sc, "key type procedure must have a name", 31)));
			  if (c_function_has_simple_elements(keyp))
			    set_has_simple_keys(ht);
			  if (!c_function_symbol(keyp))
			    c_function_symbol(keyp) = make_symbol(sc, c_function_name(keyp));
			  /* c_function_marker is not currently used in this context */
			}
		      if (is_c_function(valp))
			{
			  if (!c_function_name(valp))
			    return(wrong_type_argument_with_type(sc, caller, 3, valp, wrap_string(sc, "value type procedure must have a name", 31)));
			  if (c_function_has_simple_elements(valp))
			    set_has_simple_values(ht);
			  if (!c_function_symbol(valp))
			    c_function_symbol(valp) = make_symbol(sc, c_function_name(valp));

			  /* now a consistency check for eq-func and value type */
			  proc = cadr(args);
			  if (is_c_function(proc))
			    {
			      s7_pointer eq_sig;
			      eq_sig = c_function_signature(proc);
			      if ((eq_sig) &&
				  (is_pair(eq_sig)) &&
				  (is_pair(cdr(eq_sig))) &&
				  (!compatible_types(sc, cadr(eq_sig), c_function_symbol(valp))))
				return(wrong_type_argument_with_type(sc, caller, 2, proc, wrap_string(sc, "make-hash-table eq-func must match value type func", 50)));
			    }
			}
		      set_typed_hash_table(ht);
		    }
		}
	      else
		{
		  if (typers != sc->F)
		    return(wrong_type_argument_with_type(sc, caller, 3, typers, wrap_string(sc, "(key-type . value-type)", 23)));
		}
	    }

	  /* check eq_func */
	  proc = cadr(args);

	  if (is_c_function(proc))
	    {
	      hash_set_chosen(ht);

	      if (!s7_is_aritable(sc, proc, 2))
		return(wrong_type_argument_with_type(sc, caller, 2, proc, an_eq_func_string));

	      if (c_function_call(proc) == g_is_equal)
		{
		  hash_table_checker(ht) = hash_equal;
		  return(ht);
		}
	      if (c_function_call(proc) == g_is_equivalent)
		{
		  hash_table_checker(ht) = hash_equivalent;
		  hash_table_mapper(ht) = equivalent_hash_map;
		  return(ht);
		}
	      if (c_function_call(proc) == g_is_eq)
		{
		  hash_table_checker(ht) = hash_eq;
		  hash_table_mapper(ht) = eq_hash_map;
		  return(ht);
		}
	      if (c_function_call(proc) == g_strings_are_equal)
		{
		  hash_table_checker(ht) = hash_string;
		  hash_table_mapper(ht) = string_eq_hash_map;
		  return(ht);
		}
#if (!WITH_PURE_S7)
	      if (c_function_call(proc) == g_strings_are_ci_equal)
		{
		  hash_table_checker(ht) = hash_ci_string;
		  hash_table_mapper(ht) = string_ci_eq_hash_map;
		  return(ht);
		}
	      if (c_function_call(proc) == g_chars_are_ci_equal)
		{
		  hash_table_checker(ht) = hash_ci_char;
		  hash_table_mapper(ht) = char_ci_eq_hash_map;
		  return(ht);
		}
#endif
	      if (c_function_call(proc) == g_chars_are_equal)
		{
		  hash_table_checker(ht) = hash_char;
		  hash_table_mapper(ht) = char_eq_hash_map;
		  return(ht);
		}
#if (!WITH_GMP)
	      if (c_function_call(proc) == g_equal)
#else
	      if ((c_function_call(proc) == g_equal) ||
		  (c_function_call(proc) == big_equal))
#endif
		{
		  hash_table_checker(ht) = hash_number;
		  hash_table_mapper(ht) = number_eq_hash_map;
		  return(ht);
		}
	      if (c_function_call(proc) == g_is_eqv)
		{
		  hash_table_checker(ht) = hash_eqv;
		  hash_table_mapper(ht) = eqv_hash_map;
		  return(ht);
		}
	      return(wrong_type_argument_with_type(sc, caller, 2, proc, wrap_string(sc, "a hash function", 15)));
	    }
	  /* proc not c_function */
	  else
	    {
	      if (is_pair(proc))
		{
		  s7_pointer checker, mapper;

		  checker = car(proc);
		  mapper = cdr(proc);
		  hash_set_chosen(ht);

		  if (((is_any_c_function(checker)) || (is_any_closure(checker))) &&
		      ((is_any_c_function(mapper)) || (is_any_closure(mapper))) &&
		      (s7_is_aritable(sc, checker, 2)) &&
		      (s7_is_aritable(sc, mapper, 1)))
		    {
		      s7_pointer sig;
		      if (is_any_c_function(checker))
			{
			  sig = c_function_signature(checker);
			  if ((sig) &&
			      (is_pair(sig)) &&
			      (car(sig) != sc->is_boolean_symbol))
			    return(wrong_type_argument_with_type(sc, caller, 2, proc, wrap_string(sc, "equality function should return a boolean", 41)));
			  hash_table_checker(ht) = hash_c_function;
			}
		      else hash_table_checker(ht) = hash_closure;
		      if (is_any_c_function(mapper))
			{
			  sig = c_function_signature(mapper);
			  if ((sig) &&
			      (is_pair(sig)) &&
			      (car(sig) != sc->is_integer_symbol))
			    return(wrong_type_argument_with_type(sc, caller, 2, proc, wrap_string(sc, "mapping function should return an integer", 41)));
			  hash_table_mapper(ht) = c_function_hash_map;
			}
		      else hash_table_mapper(ht) = closure_hash_map;
		      if (is_null(dproc))
			hash_table_set_procedures(ht, proc); /* only place this is newly set (as opposed to preserved in copy) */
		      else
			{
			  set_car(dproc, car(proc));
			  set_cdr(dproc, cdr(proc));
			}
		      return(ht);
		    }
		  return(wrong_type_argument_with_type(sc, caller, 2, proc, wrap_string(sc, "a cons of two functions", 23)));
		}
	      if (proc == sc->F)
		return(ht);
	      return(wrong_type_argument_with_type(sc, caller, 2, proc, wrap_string(sc, "a cons of two functions", 23)));
	    }
	}
    }
  return(s7_make_hash_table(sc, size));
}

static s7_pointer g_make_hash_table(s7_scheme *sc, s7_pointer args)
{
  return(g_make_hash_table_1(sc, args, sc->make_hash_table_symbol));
}


/* -------------------------------- make-weak-hash-table -------------------------------- */
static s7_pointer g_make_weak_hash_table(s7_scheme *sc, s7_pointer args)
{
  #define H_make_weak_hash_table "(make-weak-hash-table (size 8) eq-func typers) returns a new weak hash table"
  #define Q_make_weak_hash_table s7_make_signature(sc, 4, sc->is_weak_hash_table_symbol, sc->is_integer_symbol, \
						   s7_make_signature(sc, 3, sc->is_procedure_symbol, sc->is_pair_symbol, sc->not_symbol), \
						   s7_make_signature(sc, 2, sc->is_pair_symbol, sc->not_symbol))
  s7_pointer table;
  table = g_make_hash_table_1(sc, args, sc->make_weak_hash_table_symbol);
  set_weak_hash_table(table);
  weak_hash_iters(table) = 0;
  return(table);
}


/* -------------------------------- weak-hash-table? -------------------------------- */
static s7_pointer g_is_weak_hash_table(s7_scheme *sc, s7_pointer args)
{
  #define H_is_weak_hash_table "(weak-hash-table? obj) returns #t if obj is a weak hash-table"
  #define Q_is_weak_hash_table sc->pl_bt
  #define is_weak_hash(p) ((is_hash_table(p)) && (is_weak_hash_table(p)))
  check_boolean_method(sc, is_weak_hash, sc->is_weak_hash_table_symbol, args);
}

void init_hash_maps(void)
{
  int32_t i;

  for (i = 0; i < NUM_TYPES; i++)
    {
      default_hash_map[i] = hash_map_nil;
      string_eq_hash_map[i] = hash_map_nil;
      char_eq_hash_map[i] = hash_map_nil;
#if (!WITH_PURE_S7)
      string_ci_eq_hash_map[i] = hash_map_nil;
      char_ci_eq_hash_map[i] = hash_map_nil;
#endif
      number_eq_hash_map[i] = hash_map_nil;
      closure_hash_map[i] = hash_map_closure;
      c_function_hash_map[i] = hash_map_c_function;
      eq_hash_map[i] = hash_map_eq;
      eqv_hash_map[i] = hash_map_eq;

      equal_hash_checks[i] = hash_equal_any;
      equivalent_hash_checks[i] = hash_equal_any;
      default_hash_checks[i] = hash_equal;
    }
  default_hash_map[T_INTEGER] =       hash_map_int;
  default_hash_map[T_RATIO] =         hash_map_ratio;
  default_hash_map[T_REAL] =          hash_map_real;
  default_hash_map[T_COMPLEX] =       hash_map_complex;
  default_hash_map[T_CHARACTER] =     hash_map_char;
  default_hash_map[T_SYMBOL] =        hash_map_symbol;
  default_hash_map[T_SYNTAX] =        hash_map_syntax;
  default_hash_map[T_STRING] =        hash_map_string;
  default_hash_map[T_BYTE_VECTOR] =   hash_map_byte_vector;
  default_hash_map[T_HASH_TABLE] =    hash_map_hash_table;
  default_hash_map[T_VECTOR] =        hash_map_vector;
  default_hash_map[T_INT_VECTOR] =    hash_map_int_vector;
  default_hash_map[T_FLOAT_VECTOR] =  hash_map_float_vector;
  default_hash_map[T_LET] =           hash_map_let;
  default_hash_map[T_PAIR] =          hash_map_pair;
#if WITH_GMP
  default_hash_map[T_BIG_INTEGER] =   hash_map_big_int;
  default_hash_map[T_BIG_RATIO] =     hash_map_big_ratio;
  default_hash_map[T_BIG_REAL] =      hash_map_big_real;
  default_hash_map[T_BIG_COMPLEX] =   hash_map_big_complex;
#endif

  for (i = 0; i < NUM_TYPES; i++) equivalent_hash_map[i] = default_hash_map[i];

  string_eq_hash_map[T_STRING] =      hash_map_string;
  string_eq_hash_map[T_BYTE_VECTOR] = hash_map_byte_vector;
  char_eq_hash_map[T_CHARACTER] =     hash_map_char;
#if (!WITH_PURE_S7)
  string_ci_eq_hash_map[T_STRING] =   hash_map_ci_string;
  char_ci_eq_hash_map[T_CHARACTER] =  hash_map_ci_char;
#endif

  number_eq_hash_map[T_INTEGER] =     hash_map_int;
  number_eq_hash_map[T_RATIO] =       hash_map_ratio_eq;
  number_eq_hash_map[T_REAL] =        hash_map_real_eq;
  number_eq_hash_map[T_COMPLEX] =     hash_map_complex;
#if (WITH_GMP)
  number_eq_hash_map[T_BIG_INTEGER] = hash_map_big_int;
  number_eq_hash_map[T_BIG_RATIO] =   hash_map_big_ratio;
  number_eq_hash_map[T_BIG_REAL] =    hash_map_big_real;
  number_eq_hash_map[T_BIG_COMPLEX] = hash_map_big_complex;
#endif

  eqv_hash_map[T_INTEGER] =           hash_map_int;
  eqv_hash_map[T_RATIO] =             hash_map_ratio_eq;
  eqv_hash_map[T_REAL] =              hash_map_real_eq;
  eqv_hash_map[T_COMPLEX] =           hash_map_complex;

  equivalent_hash_map[T_INTEGER] =    hash_map_int;
  equivalent_hash_map[T_RATIO] =      hash_map_ratio_eq;
  equivalent_hash_map[T_REAL] =       hash_map_real_eq;
  equivalent_hash_map[T_COMPLEX] =    hash_map_complex;

  equal_hash_checks[T_REAL] =         hash_equal_real;
  equal_hash_checks[T_COMPLEX] =      hash_equal_complex;
  equal_hash_checks[T_SYNTAX] =       hash_equal_syntax;
  equal_hash_checks[T_SYMBOL] =       hash_equal_eq;
  equal_hash_checks[T_CHARACTER] =    hash_equal_eq;

  default_hash_checks[T_STRING] =     hash_string;
  default_hash_checks[T_INTEGER] =    hash_int;
  default_hash_checks[T_REAL] =       hash_float;
  default_hash_checks[T_SYMBOL] =     hash_symbol;
  default_hash_checks[T_CHARACTER] =  hash_char;
}

static void resize_hash_table(s7_scheme *sc, s7_pointer table)
{
  s7_int hash_mask, loc, i, old_size, new_size;
  hash_entry_t **new_els, **old_els;
  block_t *np;
  s7_pointer dproc;
  s7_int entries;

  dproc = hash_table_procedures(table); /* new block_t so we need to pass this across */
  entries = hash_table_entries(table);
  old_size = hash_table_mask(table) + 1;
  new_size = old_size * 4;
  hash_mask = new_size - 1;
  np = (block_t *)callocate(sc, new_size * sizeof(hash_entry_t *));
  new_els = (hash_entry_t **)(block_data(np));
  old_els = hash_table_elements(table);

  for (i = 0; i < old_size; i++)
    {
      hash_entry_t *x, *n;
      for (x = old_els[i]; x; x = n)
	{
	  n = hash_entry_next(x);
	  loc = hash_entry_raw_hash(x) & hash_mask;
	  hash_entry_next(x) = new_els[loc];
	  new_els[loc] = x;
	}
    }
  liberate(sc, hash_table_block(table));
  hash_table_set_block(table, np);
  hash_table_elements(table) = new_els;
  hash_table_mask(table) = new_size - 1;
  hash_table_set_procedures(table, dproc);
  hash_table_entries(table) = entries;
}


/* -------------------------------- hash-table-ref -------------------------------- */

inline s7_pointer s7_hash_table_ref(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  x = (*hash_table_checker(table))(sc, table, key);
  return(hash_entry_value(x));
}

static s7_pointer g_hash_table_ref(s7_scheme *sc, s7_pointer args)
{
  #define H_hash_table_ref "(hash-table-ref table key) returns the value associated with key in the hash table"
  #define Q_hash_table_ref s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_hash_table_symbol, sc->T)

  s7_pointer table, nt;
  table = car(args);
  if (!is_hash_table(table))
    return(method_or_bust(sc, table, sc->hash_table_ref_symbol, args, T_HASH_TABLE, 1));
  nt = s7_hash_table_ref(sc, table, cadr(args));
  if (is_null(cddr(args)))
    return(nt);
  return(implicit_index(sc, nt, cddr(args))); /* 9-Jan-19 */
}

static s7_pointer g_hash_table_ref_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer table;
  hash_entry_t *x;

  table = car(args);
  if (!is_hash_table(table))
    return(method_or_bust(sc, table, sc->hash_table_ref_symbol, args, T_HASH_TABLE, 1));

  x = (*hash_table_checker(table))(sc, table, cadr(args));
  return(hash_entry_value(x));
}

static s7_pointer g_hash_table_ref_ss(s7_scheme *sc, s7_pointer args)
{
  s7_pointer table, key;
  hash_entry_t *x;

  table = lookup(sc, car(args));
  key = lookup(sc, cadr(args));
  if (!is_hash_table(table))
    return(method_or_bust(sc, table, sc->hash_table_ref_symbol, list_2(sc, table, key), T_HASH_TABLE, 1));

  x = (*hash_table_checker(table))(sc, table, key);
  return(hash_entry_value(x));
}

static s7_pointer g_hash_table_ref_car(s7_scheme *sc, s7_pointer args)
{
  s7_pointer y, table;
  hash_entry_t *x;

  table = lookup(sc, car(args));
  y = lookup(sc, opt3_sym(args));
  if (!is_pair(y))
    return(simple_wrong_type_argument(sc, sc->car_symbol, y, T_PAIR));

  if (!is_hash_table(table))
    return(method_or_bust(sc, table, sc->hash_table_ref_symbol, list_2(sc, table, car(y)), T_HASH_TABLE, 1));

  x = (*hash_table_checker(table))(sc, table, car(y));
  return(hash_entry_value(x));
}

static s7_pointer hash_table_ref_p_pp(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  if (!is_hash_table(table))
    simple_wrong_type_argument(sc, sc->hash_table_ref_symbol, table, T_HASH_TABLE);
  x = (*hash_table_checker(table))(sc, table, key);
  return(hash_entry_value(x));
}

static bool op_hash_table_a(s7_scheme *sc)
{
  s7_pointer s;
  s = lookup_checked(sc, car(sc->code));
  if (!is_hash_table(s)) {sc->last_function = s; return(false);}
  sc->value = s7_hash_table_ref(sc, s, fx_call(sc, cdr(sc->code)));
  return(true);
}


/* -------------------------------- hash-table-set! -------------------------------- */

static s7_pointer remove_from_hash_table(s7_scheme *sc, s7_pointer table, s7_pointer key, hash_entry_t *p)
{
  hash_entry_t *x;
  s7_int hash_mask, loc;

  if (p == sc->unentry) return(sc->F);
  hash_mask = hash_table_mask(table);
  loc = hash_entry_raw_hash(p) & hash_mask;
  x = hash_table_element(table, loc);
  if (x == p)
    hash_table_element(table, loc) = hash_entry_next(x);
  else
    {
      hash_entry_t *y;
      for (y = x, x = hash_entry_next(x); x; y = x, x = hash_entry_next(x))
	if (x == p)
	  {
	    hash_entry_next(y) = hash_entry_next(x);
	    break;
	  }
    }
  hash_table_entries(table)--;
  if ((hash_table_entries(table) == 0) &&
      (!hash_table_checker_locked(table)))
    {
      hash_table_checker(table) = hash_empty;
      hash_clear_chosen(table);
    }
  liberate_block(sc, x);
  return(sc->F);
}

static void cull_weak_hash_table(s7_scheme *sc, s7_pointer table)
{
  if (hash_table_entries(table) > 0)
    {
      s7_int i, len;
      hash_entry_t **entries;

      entries = hash_table_elements(table);
      len = hash_table_mask(table) + 1;

      for (i = 0; i < len; i++)
	{
	  hash_entry_t *xp, *nxp, *lxp;
	  lxp = entries[i];
	  for (xp = entries[i]; xp; xp = nxp)
	    {
	      nxp = hash_entry_next(xp);
	      if (is_free_and_clear(hash_entry_key(xp)))
		{
		  if (xp == entries[i])
		    {
		      entries[i] = nxp;
		      lxp = nxp;
		    }
		  else hash_entry_next(lxp) = nxp;
                  liberate_block(sc, xp);
		  hash_table_entries(table)--;
		  if (hash_table_entries(table) == 0)
		    {
		      if (!hash_table_checker_locked(table))
			{
			  hash_table_checker(table) = hash_empty;
			  hash_clear_chosen(table);
			}
		      return;
		    }
		}
	      else lxp = xp;
	    }
	}
    }
}

static void hash_table_set_checker(s7_pointer table, uint8_t typ)
{
  if (hash_table_checker(table) != default_hash_checks[typ])
    {
      if (hash_table_checker(table) == hash_empty)
	hash_table_checker(table) = default_hash_checks[typ];
      else
	{
	  hash_table_checker(table) = hash_equal;
	  hash_set_chosen(table);
	}
    }
}

static void check_hash_types(s7_scheme *sc, s7_pointer table, s7_pointer key, s7_pointer value)
{
  if ((is_c_function(hash_table_key_typer(table))) && /* might be #t = untyped */
      (c_function_call(hash_table_key_typer(table))(sc, set_plist_1(sc, key)) == sc->F))
    s7_wrong_type_arg_error(sc, "hash-table-set! key", 2, key,
			    make_type_name(sc, c_function_name(hash_table_key_typer(table)), INDEFINITE_ARTICLE));
  if ((is_c_function(hash_table_value_typer(table))) &&
      (c_function_call(hash_table_value_typer(table))(sc, set_plist_1(sc, value)) == sc->F))
    s7_wrong_type_arg_error(sc, "hash-table-set! value", 3, value,
			    make_type_name(sc, c_function_name(hash_table_value_typer(table)), INDEFINITE_ARTICLE));
}

inline s7_pointer s7_hash_table_set(s7_scheme *sc, s7_pointer table, s7_pointer key, s7_pointer value)
{
  s7_int hash_mask, loc;
  hash_entry_t *p, *x;
#if S7_DEBUGGING
  if (is_immutable(table)) fprintf(stderr, "%s[%d]: table immutable\n", __func__, __LINE__);
#endif
  if (value == sc->F)
    return(remove_from_hash_table(sc, table, key, (*hash_table_checker(table))(sc, table, key)));

  if ((is_typed_hash_table(table)) &&
      (sc->safety >= 0))
    check_hash_types(sc, table, key, value);

  x = (*hash_table_checker(table))(sc, table, key);
  if (x != sc->unentry)
    {
      hash_entry_set_value(x, T_Pos(value));
      return(value);
    }
  /* hash_entry_raw_hash(x) can save the hash_loc from the lookup operations, but at some added complexity in
   *   all the preceding code.  This saves about 5% compute time best case in this function.
   */

  if (!hash_chosen(table))
    hash_table_set_checker(table, type(key)); /* raw_hash value (hash_loc(sc, table, key)) does not change via hash_table_set_checker etc */

  p = mallocate_block(sc);
  hash_entry_key(p) = key;
  hash_entry_set_value(p, T_Pos(value));
  hash_entry_set_raw_hash(p, hash_loc(sc, table, key));
  hash_mask = hash_table_mask(table);
  loc = hash_entry_raw_hash(p) & hash_mask;
  hash_entry_next(p) = hash_table_element(table, loc);
  hash_table_element(table, loc) = p;

  hash_table_entries(table)++;
  if (hash_table_entries(table) > hash_mask)
    resize_hash_table(sc, table);

  return(value);
}

static s7_pointer g_hash_table_set(s7_scheme *sc, s7_pointer args)
{
  #define H_hash_table_set "(hash-table-set! table key value) sets the value associated with key in the hash table to value"
  #define Q_hash_table_set s7_make_signature(sc, 4, sc->T, sc->is_hash_table_symbol, sc->T, sc->T)

  s7_pointer table;
  table = car(args);
  if (!is_mutable_hash_table(table))
    return(mutable_method_or_bust(sc, table, sc->hash_table_set_symbol, args, T_HASH_TABLE, 1));
  return(s7_hash_table_set(sc, table, cadr(args), caddr(args)));
}

static s7_pointer hash_table_set_p_ppp(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_pointer p3)
{
  if (!is_hash_table(p1))
    simple_wrong_type_argument(sc, sc->hash_table_set_symbol, p1, T_HASH_TABLE);
  if (!is_mutable_hash_table(p1))
    return(mutable_method_or_bust(sc, p1, sc->hash_table_set_symbol, list_3(sc, p1, p2, p3), T_HASH_TABLE, 1));
  return(s7_hash_table_set(sc, p1, p2, p3));
}


/* -------------------------------- hash-table -------------------------------- */

static inline s7_pointer hash_table_add(s7_scheme *sc, s7_pointer table, s7_pointer key, s7_pointer value)
{
  s7_int hash, hash_mask, loc;
  hash_entry_t *x, *p;

  if (!hash_chosen(table))
    hash_table_set_checker(table, type(key)); /* raw_hash value (hash_loc(sc, table, key)) does not change via hash_table_set_checker etc */

  hash_mask = hash_table_mask(table);
  hash = hash_loc(sc, table, key);
  loc = hash & hash_mask;

  for (x = hash_table_element(table, loc); x; x = hash_entry_next(x))
    if ((hash_entry_raw_hash(x) == hash) &&
	(s7_is_equal(sc, hash_entry_key(x), key)))
      return(value);

  p = mallocate_block(sc);
  hash_entry_key(p) = key;
  hash_entry_set_value(p, T_Pos(value));
  hash_entry_set_raw_hash(p, hash);
  hash_entry_next(p) = hash_table_element(table, loc);
  hash_table_element(table, loc) = p;

  hash_table_entries(table)++;
  if (hash_table_entries(table) > hash_mask)
    resize_hash_table(sc, table);

  return(value);
}

static s7_pointer g_hash_table(s7_scheme *sc, s7_pointer args)
{
  #define H_hash_table "(hash-table ...) returns a hash-table containing the symbol/value pairs passed as its arguments. \
That is, (hash-table 'a 1 'b 2) returns a new hash-table with the two key/value pairs preinstalled."
  #define Q_hash_table s7_make_circular_signature(sc, 1, 2, sc->is_hash_table_symbol, sc->T)

  s7_int len;
  s7_pointer ht;

  len = safe_list_length(args);
  if (len & 1)
    return(s7_error(sc, sc->wrong_number_of_args_symbol,
		    set_elist_2(sc, wrap_string(sc, "hash-table got an odd number of arguments: ~S", 45), args)));
  len /= 2;

  ht = s7_make_hash_table(sc, (len > sc->default_hash_table_length) ? len : sc->default_hash_table_length);
  if (len > 0)
    {
      s7_int ht_loc;
      s7_pointer x, y;
      ht_loc = s7_gc_protect_1(sc, ht); /* hash_table_set can cons (but only if ht=let??), so we need to protect this */

      for (x = args, y = cdr(args); is_pair(x); x = cddr(x), y = unchecked_cdr(cdr(y)))
	if (car(y) != sc->F)
	  hash_table_add(sc, ht, car(x), car(y));

      s7_gc_unprotect_at(sc, ht_loc);
    }
  return(ht);
}

static s7_pointer g_hash_table_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer ht;
  ht = s7_make_hash_table(sc, sc->default_hash_table_length);
  if (cadr(args) != sc->F)
    hash_table_add(sc, ht, car(args), cadr(args));
  return(ht);
}


/* -------------------------------- weak-hash-table -------------------------------- */
static s7_pointer g_weak_hash_table(s7_scheme *sc, s7_pointer args)
{
  #define H_weak_hash_table "(weak-hash-table ...) returns a weak-hash-table containing the symbol/value pairs passed as its arguments. \
That is, (weak-hash-table 'a 1 'b 2) returns a new weak-hash-table with the two key/value pairs preinstalled."
  #define Q_weak_hash_table Q_hash_table

  s7_pointer table;
  table = g_hash_table(sc, args);
  set_weak_hash_table(table);
  return(table);
}

static s7_pointer hash_table_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    return(sc->hash_table_2);
  return(f);
}

static void check_old_hash(s7_scheme *sc, s7_pointer old_hash, s7_pointer new_hash, s7_int start, s7_int end)
{
  s7_int i, old_len, count = 0;
  hash_entry_t **old_lists;
  hash_entry_t *x;

  old_len = hash_table_mask(old_hash) + 1;
  old_lists = hash_table_elements(old_hash);

  for (i = 0; i < old_len; i++)
    for (x = old_lists[i]; x; x = hash_entry_next(x))
      {
	if (count >= end)
	  return;
	if (count >= start)
	  check_hash_types(sc, new_hash, hash_entry_key(x), hash_entry_value(x));
      }
}

static s7_pointer hash_table_copy(s7_scheme *sc, s7_pointer old_hash, s7_pointer new_hash, s7_int start, s7_int end)
{
  s7_int i, old_len, new_mask, count = 0;
  hash_entry_t **old_lists, **new_lists;
  hash_entry_t *x, *p;

  if ((is_typed_hash_table(new_hash)) &&
      (sc->safety >= 0) &&
      ((!is_typed_hash_table(old_hash)) ||
       (hash_table_key_typer(old_hash) != hash_table_key_typer(new_hash)) ||
       (hash_table_value_typer(old_hash) != hash_table_value_typer(new_hash))))
    check_old_hash(sc, old_hash, new_hash, start, end);

  old_len = hash_table_mask(old_hash) + 1;
  new_mask = hash_table_mask(new_hash);
  old_lists = hash_table_elements(old_hash);
  new_lists = hash_table_elements(new_hash);

  if (hash_table_entries(new_hash) == 0)
    {
      hash_table_checker(new_hash) = hash_table_checker(old_hash);
      if (hash_chosen(old_hash)) hash_set_chosen(new_hash);
      if ((start == 0) &&
	  (end >= hash_table_entries(old_hash)))
	{
	  for (i = 0; i < old_len; i++)
	    for (x = old_lists[i]; x; x = hash_entry_next(x))
	      {
		s7_int loc;
		loc = hash_entry_raw_hash(x) & new_mask;
		p = make_hash_entry(sc, hash_entry_key(x), hash_entry_value(x), hash_entry_raw_hash(x));
		hash_entry_next(p) = new_lists[loc];
		new_lists[loc] = p;
	      }
	  hash_table_entries(new_hash) = hash_table_entries(old_hash);
	  return(new_hash);
	}
      for (i = 0; i < old_len; i++)
	for (x = old_lists[i]; x; x = hash_entry_next(x))
	  {
	    if (count >= end)
	      {
		hash_table_entries(new_hash) = end - start;
		return(new_hash);
	      }
	    if (count >= start)
	      {
		s7_int loc;
		loc = hash_entry_raw_hash(x) & new_mask;
		p = make_hash_entry(sc, hash_entry_key(x), hash_entry_value(x), hash_entry_raw_hash(x));
		hash_entry_next(p) = new_lists[loc];
		new_lists[loc] = p;
	      }
	    count++;
	  }
      hash_table_entries(new_hash) = count - start;
      return(new_hash);
    }

  /* this can't be optimized much because we have to look for key matches (we're copying old_hash into the exisiting, non-empty new_hash) */
  for (i = 0; i < old_len; i++)
    for (x = old_lists[i]; x; x = hash_entry_next(x))
      {
	if (count >= end)
	  return(new_hash);
	if (count >= start)
	  {
	    hash_entry_t *y;
	    y = (*hash_table_checker(new_hash))(sc, new_hash, hash_entry_key(x));
	    if (y != sc->unentry)
	      hash_entry_set_value(y, hash_entry_value(x));
	    else
	      {
		s7_int loc;
		loc = hash_entry_raw_hash(x) & new_mask;
		p = make_hash_entry(sc, hash_entry_key(x), hash_entry_value(x), hash_entry_raw_hash(x));
		hash_entry_next(p) = new_lists[loc];
		new_lists[loc] = p;
		hash_table_entries(new_hash)++;
		if (!hash_chosen(new_hash))
		  hash_table_set_checker(new_hash, type(hash_entry_key(x)));
	      }
	  }
	count++;
      }
  return(new_hash);
}

static s7_pointer hash_table_fill(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val, table;
  table = car(args);
  if (is_immutable(table))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->fill_symbol, table)));

  val = cadr(args);
  if (hash_table_entries(table) > 0)
    {
      s7_int len;
      hash_entry_t **entries;
      entries = hash_table_elements(table);
      len = hash_table_mask(table) + 1;      /* minimum len is 2 (see s7_make_hash_table) */
      if (val == sc->F)                      /* hash-table-ref returns #f if it can't find a key, so val == #f here means empty the table */
	{
	  hash_entry_t **hp, **hn;
	  hash_entry_t *p;
	  hp = entries;
	  hn = (hash_entry_t **)(hp + len);
	  for (; hp < hn; hp++)
	    {
	      if (*hp)
		{
		  p = *hp;
		  while (hash_entry_next(p)) p = hash_entry_next(p);
		  hash_entry_next(p) = sc->block_lists[BLOCK_LIST];
		  sc->block_lists[BLOCK_LIST] = *hp;
		}
	      hp++;
	      if (*hp)
		{
		  p = *hp;
		  while (hash_entry_next(p)) p = hash_entry_next(p);
		  hash_entry_next(p) = sc->block_lists[BLOCK_LIST];
		  sc->block_lists[BLOCK_LIST] = *hp;
		}
	    }
	  if (len >= 8)
	    memclr64(entries, len * sizeof(hash_entry_t *));
	  else memclr(entries, len * sizeof(hash_entry_t *));
	  if (!hash_table_checker_locked(table))
	    {
	      hash_table_checker(table) = hash_empty;
	      hash_clear_chosen(table);
	    }
	  hash_table_entries(table) = 0;
	}
      else
	{
	  s7_int i;
	  hash_entry_t *x;

	  if ((is_typed_hash_table(table)) &&
	      (c_function_call(hash_table_value_typer(table))(sc, set_plist_1(sc, val)) == sc->F))
	    s7_wrong_type_arg_error(sc, "fill!", 2, val,
				    make_type_name(sc, c_function_name(hash_table_value_typer(table)), INDEFINITE_ARTICLE));

	  for (i = 0; i < len; i++)
	    for (x = entries[i]; x; x = hash_entry_next(x))
	      hash_entry_set_value(x, val);
	  /* keys haven't changed, so no need to mess with hash_table_checker */
	}
    }
  return(val);
}

static s7_pointer hash_table_reverse(s7_scheme *sc, s7_pointer old_hash)
{
  s7_int i, len;
  s7_pointer new_hash;
  hash_entry_t **old_lists;
  s7_int gc_loc;

  len = hash_table_mask(old_hash) + 1;
  new_hash = s7_make_hash_table(sc, len);
  gc_loc = s7_gc_protect_1(sc, new_hash);

  /* I don't think the original hash functions can make any sense in general, so ignore them */
  old_lists = hash_table_elements(old_hash);
  for (i = 0; i < len; i++)
    {
      hash_entry_t *x;
      for (x = old_lists[i]; x; x = hash_entry_next(x))
	s7_hash_table_set(sc, new_hash, hash_entry_value(x), hash_entry_key(x));
    }
  s7_gc_unprotect_at(sc, gc_loc);
  return(new_hash);
}


/* -------------------------------- functions -------------------------------- */

bool s7_is_function(s7_pointer p)
{
  return(is_c_function(p));
}

static s7_pointer fallback_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  return(f);
}

static void s7_function_set_class(s7_pointer f, s7_pointer base_f)
{
  c_function_class(f) = c_function_class(base_f);
  c_function_set_base(f, base_f);
}

static s7_pointer make_function(s7_scheme *sc, const char *name, s7_function f, s7_int req, s7_int opt, bool rst, const char *doc, s7_pointer x, c_proc_t *ptr)
{
  uint32_t ftype = T_C_FUNCTION;
  if (req == 0)
    {
      if (rst)
	ftype = T_C_ANY_ARGS_FUNCTION;
      else
	{
	  if (opt != 0)
	    ftype = T_C_OPT_ARGS_FUNCTION;
	}
    }
  else
    {
      if (rst)
	ftype = T_C_RST_ARGS_FUNCTION;
    }

  set_type(x, ftype);

  c_function_data(x) = ptr;
  c_function_call(x) = f;               /* f is T_App but needs cast */
  c_function_set_base(x, x);
  c_function_set_setter(x, sc->F);
  c_function_name(x) = name;            /* (procedure-name proc) => (format #f "~A" proc) */
  c_function_name_length(x) = safe_strlen(name);
  if (doc)
    c_function_documentation(x) = make_permanent_c_string(sc, doc);
  else c_function_documentation(x) = NULL;
  c_function_signature(x) = sc->F;

  c_function_required_args(x) = req;
  c_function_optional_args(x) = opt;    /* T_C_FUNCTION_STAR type may be set later, so T_Fst not usable here */
  if (rst)
    c_function_all_args(x) = MAX_ARITY;
  else c_function_all_args(x) = req + opt;

  c_function_class(x) = ++sc->f_class;
  c_function_chooser(x) = fallback_chooser;
  c_function_opt_data(x) = NULL;
  c_function_marker(x) = NULL;
  c_function_symbol(x) = NULL;

  return(x);
}

static s7_pointer s7_lambda(s7_scheme *sc, s7_function f, s7_int required_args, s7_int optional_args, bool rest_arg)
{
  /* same as s7_make_function but the new function is not global and permanent; it can be GC'd */
  s7_pointer fnc;
  block_t *block;
  new_cell(sc, fnc, T_PAIR);  /* just a place-holder */
  block = mallocate(sc, sizeof(c_proc_t));
  fnc = make_function(sc, NULL, f, required_args, optional_args, rest_arg, NULL, fnc, (c_proc_t *)block_data(block));
  c_function_block(fnc) = block;
  add_lambda(sc, fnc);
  return(fnc);
}

static c_proc_t *alloc_permanent_function(s7_scheme *sc)
{
  #define ALLOC_FUNCTION_SIZE 128

  if (sc->alloc_function_k == ALLOC_FUNCTION_SIZE)
    {
      sc->alloc_function_cells = (c_proc_t *)malloc(ALLOC_FUNCTION_SIZE * sizeof(c_proc_t));
      sc->alloc_function_k = 0;
    }
  return(&(sc->alloc_function_cells[sc->alloc_function_k++]));
}

#if S7_DEBUGGING
static s7_int permanent_functions = 0;
#endif

s7_pointer s7_make_function(s7_scheme *sc, const char *name, s7_function f, s7_int required_args, s7_int optional_args, bool rest_arg, const char *doc)
{
  s7_pointer x;
  x = alloc_pointer(sc);
#if S7_DEBUGGING
  permanent_functions++;
#endif
  x = make_function(sc, name, f, required_args, optional_args, rest_arg, doc, x, alloc_permanent_function(sc));
  unheap(sc, x);
  return(x);
}

s7_pointer s7_make_safe_function(s7_scheme *sc, const char *name, s7_function f,
				 s7_int required_args, s7_int optional_args, bool rest_arg, const char *doc)
{
  s7_pointer p;
  p = s7_make_function(sc, name, f, required_args, optional_args, rest_arg, doc);
  set_type_bit(p, T_SAFE_PROCEDURE);
  return(p);
}

s7_pointer s7_make_typed_function(s7_scheme *sc, const char *name, s7_function f,
				  s7_int required_args, s7_int optional_args, bool rest_arg, const char *doc, s7_pointer signature)
{
  s7_pointer func;
  func = s7_make_function(sc, name, f, required_args, optional_args, rest_arg, doc);
  set_type_bit(func, T_SAFE_PROCEDURE);
  if (signature) c_function_signature(func) = signature;
  return(func);
}


/* -------------------------------- procedure? -------------------------------- */
bool s7_is_procedure(s7_pointer x)
{
  return(is_procedure(x));
}

static s7_pointer g_is_procedure(s7_scheme *sc, s7_pointer args)
{
  #define H_is_procedure "(procedure? obj) returns #t if obj is a procedure"
  #define Q_is_procedure sc->pl_bt

  return(make_boolean(sc, is_procedure(car(args))));
}


static void s7_function_set_setter(s7_scheme *sc, const char *getter, const char *setter)
{
  /* this is internal, used only with c_function setters, so we don't need to worry about the GC mark choice */
  c_function_set_setter(s7_name_to_value(sc, getter), s7_name_to_value(sc, setter));
}

s7_pointer s7_closure_body(s7_scheme *sc, s7_pointer p)
{
  if (has_closure_let(p))
    return(closure_body(p));
  return(sc->nil);
}

s7_pointer s7_closure_let(s7_scheme *sc, s7_pointer p)
{
  if (has_closure_let(p))
    return(closure_let(p));
  return(sc->nil);
}

s7_pointer s7_closure_args(s7_scheme *sc, s7_pointer p)
{
  if (has_closure_let(p))
    return(closure_args(p));
  return(sc->nil);
}

/* -------------------------------- procedure-source -------------------------------- */
static s7_pointer g_procedure_source(s7_scheme *sc, s7_pointer args)
{
  /* make it look like a scheme-level lambda */
  s7_pointer p;
  #define H_procedure_source "(procedure-source func) tries to return the definition of func"
  #define Q_procedure_source s7_make_signature(sc, 2, sc->is_list_symbol, s7_make_signature(sc, 2, sc->is_procedure_symbol, sc->is_macro_symbol))

  p = car(args);
  if (is_symbol(p))
    {
      p = s7_symbol_value(sc, p);
      if (p == sc->undefined)
	return(s7_error(sc, sc->wrong_type_arg_symbol,
			set_elist_2(sc, wrap_string(sc, "procedure-source arg, '~S, is unbound", 37), p)));
    }

  if ((is_c_function(p)) || (is_c_macro(p)))
    return(sc->nil);

  check_method_uncopied(sc, p, sc->procedure_source_symbol, list_1(sc, p));
  if (has_closure_let(p))
    {
      s7_pointer body;
      body = closure_body(p);
      /* perhaps if this function has been removed from the heap, it would be better to use copy_body (as in s7_copy)? */
      if (is_safe_closure_body(body))
	clear_safe_closure_body(body);
      return(append_in_place(sc, list_2(sc, ((is_closure_star(p)) ||
					     (is_macro_star(p)) ||
					     (is_bacro_star(p))) ? sc->lambda_star_symbol : sc->lambda_symbol,
 					closure_args(p)), body));
    }

  if (!is_procedure(p))
    return(simple_wrong_type_argument_with_type(sc, sc->procedure_source_symbol, p,
						wrap_string(sc, "a procedure or a macro", 22)));
  return(sc->nil);
}

/* -------------------------------- funclet -------------------------------- */
s7_pointer s7_funclet(s7_scheme *sc, s7_pointer p)
{
  if (has_closure_let(p))
    return(closure_let(p));
  return(sc->rootlet);
}

static s7_pointer g_funclet(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p, e;
  #define H_funclet "(funclet func) tries to return a function's definition environment"
  #define Q_funclet s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_let_symbol, sc->is_null_symbol), \
				      s7_make_signature(sc, 2, sc->is_procedure_symbol, sc->is_macro_symbol))

  p = car(args);
  if (is_symbol(p))
    {
      p = s7_symbol_value(sc, p);
      if (p == sc->undefined)
	return(s7_error(sc, sc->wrong_type_arg_symbol,
			set_elist_2(sc, wrap_string(sc, "funclet arg, '~S, is unbound", 28), car(args)))); /* not p here */
    }
  check_method(sc, p, sc->funclet_symbol, args);

  if (!((is_procedure_or_macro(p)) || (is_c_object(p))))
    return(simple_wrong_type_argument_with_type(sc, sc->funclet_symbol, p,
						wrap_string(sc, "a procedure or a macro", 22)));
  e = find_let(sc, p);
  if ((is_null(e)) &&
      (!is_c_object(p))) /* why this complication? */
    return(sc->rootlet);

  return(e);
}

s7_pointer s7_define_function(s7_scheme *sc, const char *name, s7_function fnc,
			      s7_int required_args, s7_int optional_args, bool rest_arg, const char *doc)
{
  s7_pointer func, sym;
  func = s7_make_function(sc, name, fnc, required_args, optional_args, rest_arg, doc);
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, func);
  return(sym);
}

s7_pointer s7_define_safe_function(s7_scheme *sc, const char *name, s7_function fnc,
				   s7_int required_args, s7_int optional_args, bool rest_arg, const char *doc)
{
  /* returns (string->symbol name), not the c_proc_t func */
  s7_pointer func, sym;
  func = s7_make_safe_function(sc, name, fnc, required_args, optional_args, rest_arg, doc);
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, func);
  return(sym);
}

s7_pointer s7_define_typed_function(s7_scheme *sc, const char *name, s7_function fnc,
				    s7_int required_args, s7_int optional_args, bool rest_arg,
				    const char *doc, s7_pointer signature)
{
  /* returns (string->symbol name), not the c_proc_t func */
  s7_pointer func, sym;
  func = s7_make_typed_function(sc, name, fnc, required_args, optional_args, rest_arg, doc, signature);
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, func);
  c_function_set_marker(func, NULL);
  return(sym);
}

static s7_pointer define_bool_function(s7_scheme *sc, const char *name, s7_function fnc,
				       s7_int optional_args, const char *doc, s7_pointer signature, int32_t sym_to_type,
				       void (*marker)(s7_pointer p, s7_int top),
				       bool simple, s7_function bool_setter)
{
  s7_pointer func, sym;
  func = s7_make_typed_function(sc, name, fnc, 1, optional_args, false, doc, signature);
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, func);
  if (sym_to_type != T_FREE)
    symbol_set_type(sym, sym_to_type);
  c_function_symbol(func) = sym;
  c_function_set_marker(func, marker);
  if (simple) c_function_set_has_simple_elements(func);
  c_function_set_bool_setter(func, s7_make_function(sc, name, bool_setter, 2, 0, false, NULL));
  c_function_set_has_bool_setter(func);
  return(sym);
}

s7_pointer s7_define_unsafe_typed_function(s7_scheme *sc, const char *name, s7_function fnc,
					   s7_int required_args, s7_int optional_args, bool rest_arg,
					   const char *doc, s7_pointer signature)
{
  /* returns (string->symbol name), not the c_proc_t func */
  s7_pointer func, sym;
  func = s7_make_function(sc, name, fnc, required_args, optional_args, rest_arg, doc);
  if (signature) c_function_signature(func) = signature;
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, func);
  return(sym);
}

s7_pointer s7_define_macro(s7_scheme *sc, const char *name, s7_function fnc,
			   s7_int required_args, s7_int optional_args, bool rest_arg, const char *doc)
{
  s7_pointer func, sym;
  func = s7_make_function(sc, name, fnc, required_args, optional_args, rest_arg, doc);
  set_type(func, T_C_MACRO | T_DONT_EVAL_ARGS | T_UNHEAP); /* s7_make_function includes T_UNHEAP */
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, func);
  return(sym);
}


/* -------------------------------- macro? -------------------------------- */
bool s7_is_macro(s7_scheme *sc, s7_pointer x) {return(is_any_macro(x));}
static bool is_macro_b(s7_pointer x) {return(is_any_macro(x));}

static s7_pointer g_is_macro(s7_scheme *sc, s7_pointer args)
{
  #define H_is_macro "(macro? arg) returns #t if 'arg' is a macro or a bacro"
  #define Q_is_macro sc->pl_bt
  check_boolean_method(sc, is_any_macro, sc->is_macro_symbol, args);
}

static s7_pointer s7_macroexpand(s7_scheme *sc, s7_pointer mac, s7_pointer args)
{
  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
  sc->code = mac;
  sc->args = copy_list_with_arglist_error(sc, args);
  new_frame(sc, closure_let(sc->code), sc->envir);
  eval(sc, OP_APPLY_LAMBDA);
  return(sc->value);
}

s7_pointer s7_make_function_star(s7_scheme *sc, const char *name, s7_function fnc, const char *arglist, const char *doc)
{
  s7_pointer func, local_args, p;
  char *internal_arglist;
  s7_int i, len, n_args;
  s7_int gc_loc;
  s7_pointer *names, *defaults;
  block_t *b;

  len = safe_strlen(arglist) + 8;
  b = mallocate(sc, len);
  internal_arglist = (char *)block_data(b);
  catstrs_direct(internal_arglist, "'(", arglist, ")", NULL);
  local_args = s7_eval_c_string(sc, internal_arglist);
  gc_loc = s7_gc_protect_1(sc, local_args);
  liberate(sc, b);
  n_args = safe_list_length(local_args);  /* currently rest arg not supported, and we don't notice :allow-other-keys etc */

  func = s7_make_function(sc, name, fnc, 0, n_args, false, doc);
  set_type(func, T_C_FUNCTION_STAR | T_UNHEAP); /* unheap from s7_make_function */
  c_function_call_args(func) = NULL;

  names = (s7_pointer *)malloc(n_args * sizeof(s7_pointer));
  c_function_arg_names(func) = names;
  defaults = (s7_pointer *)malloc(n_args * sizeof(s7_pointer));
  c_function_arg_defaults(func) = defaults;
  c_func_set_simple_defaults(func);

  for (p = local_args, i = 0; i < n_args; p = cdr(p), i++)
    {
      s7_pointer arg;
      arg = car(p);
      if (is_pair(arg)) /* there is a default */
	{
	  names[i] = symbol_to_keyword(sc, car(arg));
	  defaults[i] = cadr(arg);
	  s7_remove_from_heap(sc, cadr(arg));
	  if ((is_pair(defaults[i])) ||
	      ((is_symbol(defaults[i])) && (!is_keyword(defaults[i]))))
	    {
	      c_func_clear_simple_defaults(func);
	      mark_function[T_C_FUNCTION_STAR] = mark_c_proc_star;
	    }
	}
      else
	{
	  names[i] = symbol_to_keyword(sc, arg);
	  defaults[i] = sc->F;
	}
    }
  s7_gc_unprotect_at(sc, gc_loc);
  return(func);
}

s7_pointer s7_make_safe_function_star(s7_scheme *sc, const char *name, s7_function fnc, const char *arglist, const char *doc)
{
  s7_pointer func;
  func = s7_make_function_star(sc, name, fnc, arglist, doc);
  set_type(func, typeflag(func) | T_SAFE_PROCEDURE);   /* don't step on the c_func_has_simple_defaults flag */
  c_function_call_args(func) = make_list(sc, c_function_optional_args(func), sc->F);
  s7_remove_from_heap(sc, c_function_call_args(func));
  return(func);
}

static void define_function_star_1(s7_scheme *sc, const char *name, s7_function fnc, const char *arglist, const char *doc, bool safe, s7_pointer signature)
{
  s7_pointer func, sym;
  if (safe)
    func = s7_make_safe_function_star(sc, name, fnc, arglist, doc);
  else func = s7_make_function_star(sc, name, fnc, arglist, doc);
  sym = make_symbol(sc, name);
  s7_define(sc, sc->nil, sym, func);
  if (signature) c_function_signature(func) = signature;
}

void s7_define_function_star(s7_scheme *sc, const char *name, s7_function fnc, const char *arglist, const char *doc)
{
  define_function_star_1(sc, name, fnc, arglist, doc, false, NULL);
}

void s7_define_safe_function_star(s7_scheme *sc, const char *name, s7_function fnc, const char *arglist, const char *doc)
{
  define_function_star_1(sc, name, fnc, arglist, doc, true, NULL);
}

void s7_define_typed_function_star(s7_scheme *sc, const char *name, s7_function fnc, const char *arglist, const char *doc, s7_pointer signature)
{
  define_function_star_1(sc, name, fnc, arglist, doc, true, signature);
}


/* -------------------------------- documentation -------------------------------- */
static s7_pointer funclet_entry(s7_scheme *sc, s7_pointer x, s7_pointer sym)
{
  if ((has_closure_let(x)) && (is_let(closure_let(x))))
    {
      s7_pointer val;
      val = symbol_to_local_slot(sc, sym, closure_let(x));
      if ((!is_slot(val)) && (is_let(outlet(closure_let(x)))))
	val = symbol_to_local_slot(sc, sym, outlet(closure_let(x)));
      if (is_slot(val))
	return(slot_value(val));
    }
  return(NULL);
}

const char *s7_documentation(s7_scheme *sc, s7_pointer x)
{
  s7_pointer val;
  if (is_symbol(x))
    {
      if (is_keyword(x)) return(NULL);
      if (symbol_has_help(x))
	return(symbol_help(x));
      x = s7_symbol_value(sc, x); /* this is needed by Snd */
    }

  if ((is_any_c_function(x)) ||
      (is_c_macro(x)))
    return((char *)c_function_documentation(x));

  if (is_syntax(x))
    return(syntax_documentation(x));

  val = funclet_entry(sc, x, sc->local_documentation_symbol);
  if ((val) && (is_string(val)))
    return(string_value(val));

  return(NULL);
}

static s7_pointer g_documentation(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  #define H_documentation "(documentation obj) returns obj's documentation string"
  #define Q_documentation s7_make_signature(sc, 2, sc->is_string_symbol, sc->T) /* should (documentation 1) be an error? */

  p = car(args);
  if (is_symbol(p))
    {
      if ((symbol_has_help(p)) &&
	  (is_global(p)))
	return(s7_make_string(sc, symbol_help(p)));
      p = s7_symbol_value(sc, p);
    }

  /* (documentation func) should act like (documentation abs) -- available without (openlet (funclet func)) or (openlet func)
   *   so we check that case ahead of time here, rather than going through check_method which does not
   *   call find_let unless has_active_methods(sc, func).  Adding T_HAS_METHODS to all closures causes other troubles.
   */
  if (has_closure_let(p))
    {
      s7_pointer func;
      func = funclet_entry(sc, p, sc->documentation_symbol);
      if (func)
	return(s7_apply_function(sc, func, args));
    }

  /* it would be neat if this would work (define x (let ((+documentation+ "hio")) (vector 1 2 3))) (documentation x) */
  check_method(sc, p, sc->documentation_symbol, args);
  return(s7_make_string(sc, s7_documentation(sc, p)));
}

const char *s7_set_documentation(s7_scheme *sc, s7_pointer sym, const char *new_doc)
{
  if (is_keyword(sym)) return(NULL);
  if (is_symbol(sym))
    {
      symbol_set_has_help(sym);
      symbol_set_help(sym, copy_string(new_doc));
    }
  return(new_doc);
}


/* -------------------------------- help -------------------------------- */
const char *s7_help(s7_scheme *sc, s7_pointer obj)
{
  if (is_syntax(obj))
    return(syntax_documentation(obj));

  if (is_symbol(obj))
    {
      /* here look for name */
      if (s7_documentation(sc, obj))
	return(s7_documentation(sc, obj));
      obj = s7_symbol_value(sc, obj);
    }

  if (is_procedure_or_macro(obj))
    return(s7_documentation(sc, obj));

  /* if is string, apropos? (can scan symbol table) */
  return(NULL);
}

static s7_pointer g_help(s7_scheme *sc, s7_pointer args)
{
  #define H_help "(help obj) returns obj's documentation"
  #define Q_help s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_string_symbol, sc->is_boolean_symbol), sc->T)
  const char *doc;

  check_method(sc, car(args), sc->help_symbol, args);
  doc = s7_help(sc, car(args));
  if (!doc)
    return(sc->F);
  return(s7_make_string(sc, doc));
}


/* -------------------------------- signature -------------------------------- */
static void init_signatures(s7_scheme *sc)
{
  sc->string_signature =       s7_make_signature(sc, 3, sc->is_char_symbol, sc->is_string_symbol, sc->is_integer_symbol);
  sc->byte_vector_signature =  s7_make_circular_signature(sc, 2, 3, sc->is_byte_symbol, sc->is_byte_vector_symbol, sc->is_integer_symbol);
  sc->vector_signature =       s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_vector_symbol, sc->is_integer_symbol);
  sc->float_vector_signature = s7_make_circular_signature(sc, 2, 3, sc->is_float_symbol, sc->is_float_vector_symbol, sc->is_integer_symbol);
  sc->int_vector_signature =   s7_make_circular_signature(sc, 2, 3, sc->is_integer_symbol, sc->is_int_vector_symbol, sc->is_integer_symbol);
  sc->c_object_signature =     s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_c_object_symbol, sc->T);
  sc->let_signature =          s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_let_symbol, sc->is_symbol_symbol);
  sc->hash_table_signature =   s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_hash_table_symbol, sc->T);
  sc->pair_signature =         s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_pair_symbol, sc->is_integer_symbol);
}

static s7_pointer g_signature(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  #define H_signature "(signature obj) returns obj's signature"
  #define Q_signature s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_pair_symbol, sc->is_boolean_symbol), sc->T)

  p = car(args);
  switch (type(p))
    {
    case T_C_FUNCTION:
    case T_C_FUNCTION_STAR:
    case T_C_ANY_ARGS_FUNCTION:
    case T_C_OPT_ARGS_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
    case T_C_MACRO:
      return((s7_pointer)c_function_signature(p));

    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
    case T_CLOSURE: case T_CLOSURE_STAR:
      {
	s7_pointer func;
	func = funclet_entry(sc, p, sc->local_signature_symbol);
	if (func) return(func);
	func = funclet_entry(sc, p, sc->signature_symbol);
	if (func) return(s7_apply_function(sc, func, args));
	return(sc->F);
      }

    case T_VECTOR:
      if (vector_length(p) == 0) return(sc->F); /* sig () is #f so sig #() should be #f */
      if (!is_typed_vector(p))
	return(sc->vector_signature);
      {
	s7_pointer lst;
	lst = list_3(sc, c_function_symbol(typed_vector_typer(p)), sc->is_vector_symbol, sc->is_integer_symbol);
	cdddr(lst) = cddr(lst);
	return(lst);
      }

    case T_FLOAT_VECTOR: return((vector_length(p) == 0) ? sc->F : sc->float_vector_signature);
    case T_INT_VECTOR:   return((vector_length(p) == 0) ? sc->F : sc->int_vector_signature);
    case T_BYTE_VECTOR:  return((vector_length(p) == 0) ? sc->F : sc->byte_vector_signature);
    case T_PAIR:         return(sc->pair_signature);
    case T_STRING:       return(sc->string_signature);

    case T_HASH_TABLE:
      if (is_typed_hash_table(p))
	return(list_3(sc,
		      (is_c_function(hash_table_value_typer(p))) ? c_function_symbol(hash_table_value_typer(p)) : sc->T,
		      sc->is_hash_table_symbol,
		      (is_c_function(hash_table_key_typer(p)) ? c_function_symbol(hash_table_key_typer(p)) : sc->T)));
      return(sc->hash_table_signature);

    case T_ITERATOR:
      p = iterator_sequence(p);
      if ((is_hash_table(p)) || (is_let(p)))   /* cons returned -- would be nice to include the car/cdr types if known */
	return(list_1(sc, sc->is_pair_symbol));
      p = g_signature(sc, set_plist_1(sc, p));
      if (is_pair(p))
	return(list_1(sc, car(p)));
      return(list_1(sc, sc->T));

    case T_C_OBJECT:
      check_method(sc, p, sc->signature_symbol, args);
      return(sc->c_object_signature);

    case T_LET:
      check_method(sc, p, sc->signature_symbol, args);
      return(sc->let_signature);

    case T_SYMBOL:
      /* this used to get the symbol's value and call g_signature on that */
      {
	s7_pointer slot;
	slot = symbol_to_slot(sc, p);
	if ((is_slot(slot)) && (slot_has_setter(slot)))
	  {
	    s7_pointer setter;
	    setter = slot_setter(slot);
	    p = g_signature(sc, set_plist_1(sc, setter));
	    if (is_pair(p))
	      return(list_1(sc, car(p)));
	  }
      }
      break;

    default:
      break;
    }
  return(sc->F);
}

s7_pointer s7_signature(s7_scheme *sc, s7_pointer func)
{
  return(g_signature(sc, set_plist_1(sc, func)));
}


/* -------------------------------- new types (c_objects) -------------------------------- */

static void fallback_free(void *value) {}
static void fallback_mark(void *value) {}

static s7_pointer fallback_ref(s7_scheme *sc, s7_pointer args)
{
  return(apply_error(sc, car(args), cdr(args)));
}

static s7_pointer fallback_set(s7_scheme *sc, s7_pointer args)
{
  eval_error(sc, "attempt to set ~S?", 18, car(args));
}

static s7_pointer fallback_length(s7_scheme *sc, s7_pointer obj)
{
  return(sc->F);
}

/* -------------------------------- c-object? -------------------------------- */
bool s7_is_c_object(s7_pointer p)
{
  return(is_c_object(p));
}

static s7_pointer g_is_c_object(s7_scheme *sc, s7_pointer args)
{
  #define H_is_c_object "(c-object? obj) returns #t is obj is a c-object."
  #define Q_is_c_object sc->pl_bt
  s7_pointer obj;
  obj = car(args);
  if (is_c_object(obj)) return(sc->T);
  if (!has_active_methods(sc, obj)) return(sc->F);
  return(apply_boolean_method(sc, obj, sc->is_c_object_symbol));
}


/* -------------------------------- c-object-type -------------------------------- */
s7_int s7_c_object_type(s7_pointer obj)
{
  if (is_c_object(obj))
    return(c_object_type(obj));
  return(-1);
}

static s7_pointer g_c_object_type(s7_scheme *sc, s7_pointer args)
{
  #define H_c_object_type "(c-object-type obj) returns the c_object's type tag."
  #define Q_c_object_type s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_c_object_symbol)

  s7_pointer p;
  p = car(args);
  if (is_c_object(p))
    return(make_integer(sc, c_object_type(p))); /* this is the c_object_types table index = tag */
  return(method_or_bust(sc, p, sc->c_object_type_symbol, args, T_C_OBJECT, 0));
}

static s7_pointer g_c_object_set(s7_scheme *sc, s7_pointer args) /* called in c_object_set_function */
{
  s7_pointer obj;
  obj = car(args);
  if (!is_c_object(obj))
    return(simple_wrong_type_argument(sc, make_symbol(sc, "c-object-set!"), obj, T_C_OBJECT));
  return((*(c_object_set(sc, obj)))(sc, args));
}

s7_int s7_make_c_type(s7_scheme *sc, const char *name)
{
  s7_int tag;
  tag = sc->num_c_object_types++;
  if (tag >= sc->c_object_types_size)
    {
      if (sc->c_object_types_size == 0)
	{
	  sc->c_object_types_size = 8;
	  sc->c_object_types = (c_object_t **)calloc(sc->c_object_types_size, sizeof(c_object_t *));
	}
      else
	{
	  sc->c_object_types_size = tag + 8;
	  sc->c_object_types = (c_object_t **)realloc((void *)(sc->c_object_types), sc->c_object_types_size * sizeof(c_object_t *));
	}
    }
  sc->c_object_types[tag] = (c_object_t *)calloc(1, sizeof(c_object_t));
  sc->c_object_types[tag]->type = tag;
  sc->c_object_types[tag]->scheme_name = s7_make_permanent_string(sc, name);
  sc->c_object_types[tag]->getter = sc->F;
  sc->c_object_types[tag]->setter = sc->F;

  sc->c_object_types[tag]->free = fallback_free;
#if (!DISABLE_DEPRECATED)
  sc->c_object_types[tag]->print = NULL;
#endif
  sc->c_object_types[tag]->equal = NULL;
  sc->c_object_types[tag]->mark = fallback_mark;
  sc->c_object_types[tag]->ref = fallback_ref;
  sc->c_object_types[tag]->set = fallback_set;
  sc->c_object_types[tag]->outer_type = T_C_OBJECT;
  sc->c_object_types[tag]->length = fallback_length;
  sc->c_object_types[tag]->copy = NULL;
  sc->c_object_types[tag]->reverse = NULL;
  sc->c_object_types[tag]->fill = NULL;
  sc->c_object_types[tag]->to_list = NULL;
  sc->c_object_types[tag]->to_string = NULL;

  return(tag);
}

void s7_c_type_set_free(s7_scheme *sc, s7_int tag, void (*gc_free)(void *value))
{
  sc->c_object_types[tag]->free = gc_free;
}

void s7_c_type_set_equal(s7_scheme *sc, s7_int tag, bool (*equal)(void *value1, void *value2))
{
  sc->c_object_types[tag]->equal = equal;
}

void s7_c_type_set_mark(s7_scheme *sc, s7_int tag, void (*mark)(void *value))
{
  sc->c_object_types[tag]->mark = mark;
}

void s7_c_type_set_ref(s7_scheme *sc, s7_int tag, s7_pointer (*ref)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->ref = ref;
  if (sc->c_object_types[tag]->ref != fallback_ref)
    sc->c_object_types[tag]->outer_type = (T_C_OBJECT | T_SAFE_PROCEDURE);
}

void s7_c_type_set_getter(s7_scheme *sc, s7_int tag, s7_pointer getter)
{
#if S7_DEBUGGING
  if (!is_c_function(getter)) fprintf(stderr, "%s[%d]: %p is not a c_function\n", __func__, __LINE__, getter);
#endif
  sc->c_object_types[tag]->getter = getter;
}

void s7_c_type_set_set(s7_scheme *sc, s7_int tag, s7_pointer (*set)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->set = set;
}

void s7_c_type_set_setter(s7_scheme *sc, s7_int tag, s7_pointer setter)
{
#if S7_DEBUGGING
  if (!is_c_function(setter)) fprintf(stderr, "%s[%d]: %p is not a c_function\n", __func__, __LINE__, setter);
#endif
  sc->c_object_types[tag]->setter = setter;
}

void s7_c_type_set_length(s7_scheme *sc, s7_int tag, s7_pointer (*length)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->length = length;
}

void s7_c_type_set_copy(s7_scheme *sc, s7_int tag, s7_pointer (*copy)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->copy = copy;
}

void s7_c_type_set_fill(s7_scheme *sc, s7_int tag, s7_pointer (*fill)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->fill = fill;
}

void s7_c_type_set_reverse(s7_scheme *sc, s7_int tag, s7_pointer (*reverse)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->reverse = reverse;
}

void s7_c_type_set_to_list(s7_scheme *sc, s7_int tag, s7_pointer (*to_list)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->to_list = to_list;
}

void s7_c_type_set_to_string(s7_scheme *sc, s7_int tag, s7_pointer (*to_string)(s7_scheme *sc, s7_pointer args))
{
  sc->c_object_types[tag]->to_string = to_string;
}

#if (!DISABLE_DEPRECATED)
/* for CM */
s7_int s7_new_type_1(s7_scheme *sc,
		     const char *name,
		     char *(*print)(s7_scheme *sc, void *value),
		     void (*gc_free)(void *value),
		     bool (*equal)(void *val1, void *val2),
		     void (*mark)(void *val),
		     s7_pointer (*ref)(s7_scheme *sc, s7_pointer obj, s7_pointer args), /* ignored */
		     s7_pointer (*set)(s7_scheme *sc, s7_pointer obj, s7_pointer args)) /* ignored */
{
  s7_int tag;
  tag = s7_make_c_type(sc, name);
  if (gc_free) sc->c_object_types[tag]->free = gc_free;
  if (print) sc->c_object_types[tag]->print = print;
  if (equal) sc->c_object_types[tag]->equal = equal;
  if (mark) sc->c_object_types[tag]->mark = mark;
  return(tag);
}
#endif

void *s7_c_object_value(s7_pointer obj)
{
  return(c_object_value(obj));
}

void *s7_c_object_value_checked(s7_pointer obj, s7_int type)
{
  if ((is_c_object(obj)) &&
      (c_object_type(obj) == type))
    return(c_object_value(obj));
  return(NULL);
}

s7_pointer s7_make_c_object_with_let(s7_scheme *sc, s7_int type, void *value, s7_pointer let)
{
  s7_pointer x;
  new_cell(sc, x, sc->c_object_types[type]->outer_type);

  /* c_object_info(x) = &(sc->c_object_types[type]); */
  /* that won't work because c_object_types can move when it is realloc'd and the old stuff is freed by realloc
   *   and since we're checking (for example) ref_2 existence as not null, we can't use a table of c_object_t's!
   */
  c_object_type(x) = type;
  c_object_value(x) = value;
  c_object_set_let(x, let);
  c_object_mark(x) = sc->c_object_types[type]->mark;
  add_c_object(sc, x);
  return(x);
}

s7_pointer s7_make_c_object(s7_scheme *sc, s7_int type, void *value)
{
  return(s7_make_c_object_with_let(sc, type, value, sc->nil));
}

s7_pointer s7_c_object_let(s7_pointer obj)
{
  return(c_object_let(obj));
}

s7_pointer s7_c_object_set_let(s7_pointer obj, s7_pointer e)
{
  if ((!is_immutable(obj)) &&
      (is_let(e)))
    c_object_set_let(obj, e);
  return(e);
}

static s7_pointer c_object_length(s7_scheme *sc, s7_pointer obj)
{
  if (c_object_len(sc, obj))
    return((*(c_object_len(sc, obj)))(sc, set_clist_1(sc, obj)));
  eval_error(sc, "attempt to get length of ~S?", 28, obj);
}

static s7_int c_object_length_to_int(s7_scheme *sc, s7_pointer obj)
{
  if (c_object_len(sc, obj))
    {
      s7_pointer res;
      res = (*(c_object_len(sc, obj)))(sc, set_clist_1(sc, obj));
      if (s7_is_integer(res))
	return(s7_integer(res));
    }
  return(-1);
}

static s7_pointer copy_c_object(s7_scheme *sc, s7_pointer args)
{
  s7_pointer obj;
  obj = car(args);
  check_method(sc, obj, sc->copy_symbol, args);
  if (c_object_copy(sc, obj))
    return((*(c_object_copy(sc, obj)))(sc, args));
  eval_error(sc, "attempt to copy ~S?", 19, obj);
}

static s7_pointer c_object_type_to_let(s7_scheme *sc, s7_pointer cobj)
{
  static s7_pointer name_symbol = NULL;
  if (!name_symbol)
    name_symbol = make_symbol(sc, "name");
  return(g_local_inlet(sc, 4,
		       name_symbol, c_object_scheme_name(sc, cobj),
		       sc->setter_symbol, (c_object_set(sc, cobj) != fallback_set) ? sc->c_object_set_function : sc->F));
  /* should we make new wrappers every time this is called? or save the let somewhere and reuse it? */
}

static void apply_c_object(s7_scheme *sc)  /* -------- applicable (new-type) object -------- */
{
  /* sc->value = (*(c_object_ref(sc, sc->code)))(sc, cons(sc, sc->code, sc->args)); */
  set_car(sc->u1_1, sc->code);
  set_cdr(sc->u1_1, sc->args);
  sc->value = (*(c_object_ref(sc, sc->code)))(sc, sc->u1_1);
}

static bool op_c_object_a(s7_scheme *sc)
{
  s7_pointer c;
  c = lookup_checked(sc, car(sc->code));
  if (!is_c_object(c)) {sc->last_function = c; return(false);}
  set_car(sc->t2_2, fx_call(sc, cdr(sc->code)));
  set_car(sc->t2_1, c); /* arg above might use sc->t2* */
  sc->value = (*(c_object_ref(sc, c)))(sc, sc->t2_1);
  return(true);
}


/* -------- dilambda -------- */

s7_pointer s7_dilambda(s7_scheme *sc,
		       const char *name,
		       s7_pointer (*getter)(s7_scheme *sc, s7_pointer args),
		       s7_int get_req_args, s7_int get_opt_args,
		       s7_pointer (*setter)(s7_scheme *sc, s7_pointer args),
		       s7_int set_req_args, s7_int set_opt_args,
		       const char *documentation)
{
  s7_pointer get_func, set_func;
  char *internal_set_name;
  s7_int len;

  if (!name) return(sc->F);
  len = 16 + safe_strlen(name);
  internal_set_name = (char *)malloc(len * sizeof(char));
  internal_set_name[0] = '\0';
  catstrs_direct(internal_set_name, "[set-", name, "]", NULL);

  get_func = s7_make_safe_function(sc, name, getter, get_req_args, get_opt_args, false, documentation);
  s7_define(sc, sc->nil, make_symbol(sc, name), get_func);
  set_func = s7_make_function(sc, internal_set_name, setter, set_req_args, set_opt_args, false, documentation);
  c_function_set_setter(get_func, set_func);

  return(get_func);
}

s7_pointer s7_typed_dilambda(s7_scheme *sc,
			     const char *name,
			     s7_pointer (*getter)(s7_scheme *sc, s7_pointer args),
			     s7_int get_req_args, s7_int get_opt_args,
			     s7_pointer (*setter)(s7_scheme *sc, s7_pointer args),
			     s7_int set_req_args, s7_int set_opt_args,
			     const char *documentation,
			     s7_pointer get_sig, s7_pointer set_sig)
{
  s7_pointer get_func, set_func;
  get_func = s7_dilambda(sc, name, getter, get_req_args, get_opt_args, setter, set_req_args, set_opt_args, documentation);
  set_func = c_function_setter(get_func);
  if (get_sig) c_function_signature(get_func) = get_sig;
  if (set_sig) c_function_signature(set_func) = set_sig;
  return(get_func);
}

static void op_set_dilambda_p(s7_scheme *sc)
{
  sc->code = cdr(sc->code);
  push_stack_no_args(sc, OP_SET_DILAMBDA_P_1, sc->code);
  sc->code = cadr(sc->code);
}

static void op_set_dilambda(s7_scheme *sc)
{
  sc->code = cdr(sc->code);
  sc->value = cadr(sc->code);
  if (is_symbol(sc->value))
    sc->value = lookup_checked(sc, sc->value);
}


/* -------------------------------- dilambda? -------------------------------- */
bool s7_is_dilambda(s7_pointer obj)
{
  switch (type(obj))
    {
    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
    case T_CLOSURE: case T_CLOSURE_STAR:
      return(is_any_procedure(closure_setter_or_map_list(obj))); /* type >= T_CLOSURE (excludes goto/continuation) */

    case T_C_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
    case T_C_OPT_ARGS_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
    case T_C_FUNCTION_STAR:
      return(is_any_procedure(c_function_setter(obj)));

    case T_C_MACRO:
      return(is_any_procedure(c_macro_setter(obj)));
    }
  return(false);
}

static s7_pointer g_is_dilambda(s7_scheme *sc, s7_pointer args)
{
  #define H_is_dilambda "(dilambda? obj) returns #t if obj is a procedure with setter."
  #define Q_is_dilambda sc->pl_bt
  check_boolean_method(sc, s7_is_dilambda, sc->is_dilambda_symbol, args);
}


/* -------------------------------- dilambda -------------------------------- */
static s7_pointer g_dilambda(s7_scheme *sc, s7_pointer args)
{
  #define H_dilambda "(dilambda getter setter) sets getter's setter to be setter."
  #define Q_dilambda s7_make_signature(sc, 3, sc->is_procedure_symbol, sc->is_procedure_symbol, sc->is_procedure_symbol)
  s7_pointer getter, setter;

  getter = car(args);
  if (!is_any_procedure(getter))
    return(wrong_type_argument_with_type(sc, sc->dilambda_symbol, 1, getter, wrap_string(sc, "a procedure or a macro", 22)));

  setter = cadr(args);
  if (!is_any_procedure(setter))
    return(wrong_type_argument_with_type(sc, sc->dilambda_symbol, 2, setter, wrap_string(sc, "a procedure or a macro", 22)));

  s7_set_setter(sc, getter, setter);
  return(getter);
}


/* -------------------------------- arity -------------------------------- */

static s7_pointer closure_arity_to_cons(s7_scheme *sc, s7_pointer x, s7_pointer x_args)
{
  /* x_args is unprocessed -- it is exactly the list as used in the closure[*] definition */
  int32_t len;

  if (is_symbol(x_args))                    /* any number of args is ok */
    return(s7_cons(sc, small_int(0), max_arity));

  if (closure_arity_unknown(x))
    closure_set_arity(x, s7_list_length(sc, x_args));
  len = closure_arity(x);
  if (len < 0)                               /* dotted list => rest arg, (length '(a b . c)) is -2 */
    return(s7_cons(sc, s7_make_integer(sc, -len), max_arity));
  return(s7_cons(sc, s7_make_integer(sc, len), s7_make_integer(sc, len)));
}

static void closure_star_arity_1(s7_scheme *sc, s7_pointer x, s7_pointer args)
{
  if (closure_arity_unknown(x))
    {
      if (is_null(args))
	closure_set_arity(x, 0);
      else
	{
	  if ((is_symbol(args)) || (allows_other_keys(args)))
	    closure_set_arity(x, -1);
	  else
	    {
	      s7_pointer p;
	      int32_t i;
	      for (i = 0, p = args; is_pair(p); p = cdr(p)) /* is_pair(p) so (f1 a . b) will end with b not null */
		{
		  s7_pointer arg;
		  arg = car(p);
		  if (arg == sc->key_rest_symbol)
		    break;
		  i++;
		}
	      if (is_null(p))
		closure_set_arity(x, i);
	      else closure_set_arity(x, -1); /* see below */
	    }
	}
    }
}

static s7_pointer closure_star_arity_to_cons(s7_scheme *sc, s7_pointer x, s7_pointer x_args)
{
  closure_star_arity_1(sc, x, x_args);

  if (closure_arity(x) == -1)
    return(s7_cons(sc, small_int(0), max_arity));
  return(s7_cons(sc, small_int(0), s7_make_integer(sc, closure_arity(x))));
}

static int32_t closure_arity_to_int(s7_scheme *sc, s7_pointer x)
{
  /* not lambda* here */
  if (closure_arity_unknown(x))
    {
      int32_t i;
      s7_pointer b;
      for (i = 0, b = closure_args(x); is_pair(b); i++, b = cdr(b)) {};
      if (is_null(b))
	closure_set_arity(x, i);
      else
	{
	  if (i == 0)
	    return(-1);
	  closure_set_arity(x, -i);
	}
    }
  return(closure_arity(x));
}

static int32_t closure_star_arity_to_int(s7_scheme *sc, s7_pointer x)
{
  /* not lambda here */
  closure_star_arity_1(sc, x, closure_args(x));
  return(closure_arity(x));
}

s7_pointer s7_arity(s7_scheme *sc, s7_pointer x)
{
  switch (type(x))
    {
    case T_C_OPT_ARGS_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
    case T_C_FUNCTION:
      return(s7_cons(sc, s7_make_integer(sc, c_function_required_args(x)), s7_make_integer(sc, c_function_all_args(x))));

    case T_C_ANY_ARGS_FUNCTION:
    case T_C_FUNCTION_STAR:
      return(s7_cons(sc, small_int(0), s7_make_integer(sc, c_function_all_args(x)))); /* should this be *2? */

    case T_MACRO:
    case T_BACRO:
    case T_CLOSURE:
      return(closure_arity_to_cons(sc, x, closure_args(x)));

    case T_MACRO_STAR:
    case T_BACRO_STAR:
    case T_CLOSURE_STAR:
      return(closure_star_arity_to_cons(sc, x, closure_args(x)));

    case T_C_MACRO:
      return(s7_cons(sc, s7_make_integer(sc, c_macro_required_args(x)), s7_make_integer(sc, c_macro_all_args(x))));

    case T_GOTO:
    case T_CONTINUATION:
      return(s7_cons(sc, small_int(0), max_arity));

    case T_STRING:
      if (string_length(x) == 0) return(sc->F);
      return(s7_cons(sc, small_int(1), small_int(1)));

    case T_LET:
      return(s7_cons(sc, small_int(1), small_int(1)));

    case T_C_OBJECT:
      check_method_uncopied(sc, x, sc->arity_symbol, list_1(sc, x));
      if (is_safe_procedure(x))
	return(s7_cons(sc, small_int(0), max_arity));
      return(sc->F);

    case T_VECTOR:
      if (vector_length(x) == 0) return(sc->F);
      if (has_simple_elements(x)) return(s7_cons(sc, small_int(1), make_integer(sc, vector_rank(x))));
      return(s7_cons(sc, small_int(1), max_arity));

    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
    case T_BYTE_VECTOR:
      if (vector_length(x) == 0) return(sc->F);
      return(s7_cons(sc, small_int(1), make_integer(sc, vector_rank(x))));

    case T_PAIR:
    case T_HASH_TABLE:
      return(s7_cons(sc, small_int(1), max_arity));

    case T_ITERATOR:
      return(s7_cons(sc, small_int(0), small_int(0)));

    case T_SYNTAX:
      return(s7_cons(sc, small_int(syntax_min_args(x)), (syntax_max_args(x) == -1) ? max_arity : small_int(syntax_max_args(x))));
    }
  return(sc->F);
}

static s7_pointer g_arity(s7_scheme *sc, s7_pointer args)
{
  #define H_arity "(arity obj) the min and max acceptable args for obj if it is applicable, otherwise #f."
  #define Q_arity s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_pair_symbol, sc->not_symbol), sc->T)
  /* check_method(sc, p, sc->arity_symbol, args); */
  return(s7_arity(sc, car(args)));
}


/* -------------------------------- aritable? -------------------------------- */
static bool closure_is_aritable(s7_scheme *sc, s7_pointer x, s7_pointer x_args, int32_t args)
{
  /* x_args is unprocessed -- it is exactly the list as used in the closure definition */
  s7_int len;

  if (args == 0)
    return(!is_pair(x_args));

  if (is_symbol(x_args))                    /* any number of args is ok */
    return(true);

  len = closure_arity(x);
  if (len == CLOSURE_ARITY_NOT_SET)
    {
      len = s7_list_length(sc, x_args);
      closure_set_arity(x, len);
    }
  if (len < 0)                               /* dotted list => rest arg, (length '(a b . c)) is -2 */
    return((-len) <= args);                  /*   so we have enough to take care of the required args */
  return(args == len);                       /* in a normal lambda list, there are no other possibilities */
}

static bool closure_star_is_aritable(s7_scheme *sc, s7_pointer x, s7_pointer x_args, int32_t args)
{
  if (is_symbol(x_args))
    return(true);

  closure_star_arity_1(sc, x, x_args);
  return((closure_arity(x) == -1) ||
	 (args <= closure_arity(x)));
}

bool s7_is_aritable(s7_scheme *sc, s7_pointer x, s7_int args)
{
  switch (type(x))
    {
    case T_C_RST_ARGS_FUNCTION:
    case T_C_FUNCTION:
      return((c_function_required_args(x) <= args) &&
	     (c_function_all_args(x) >= args));

    case T_C_OPT_ARGS_FUNCTION: /* any/opt req args == 0 */
    case T_C_ANY_ARGS_FUNCTION:
    case T_C_FUNCTION_STAR:
      return(c_function_all_args(x) >= args);

    case T_MACRO:
    case T_BACRO:
    case T_CLOSURE:
      return(closure_is_aritable(sc, x, closure_args(x), args));

    case T_MACRO_STAR:
    case T_BACRO_STAR:
    case T_CLOSURE_STAR:
      return(closure_star_is_aritable(sc, x, closure_args(x), args));

    case T_C_MACRO:
      return((c_macro_required_args(x) <= args) &&
	     (c_macro_all_args(x) >= args));

    case T_GOTO:
    case T_CONTINUATION:
      return(true);

    case T_STRING:
      return((args == 1) && (string_length(x) > 0)); /* ("" 0) -> error */

    case T_C_OBJECT:
      {
	s7_pointer func;
	if ((has_active_methods(sc, x)) &&
	    ((func = find_method(sc, find_let(sc, x), sc->is_aritable_symbol)) != sc->undefined))
	  return(s7_apply_function(sc, func, list_2(sc, x, s7_make_integer(sc, args))) != sc->F);
	return(is_safe_procedure(x));
      }

    case T_VECTOR: case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_BYTE_VECTOR:
      return((args > 0) &&
	     (vector_length(x) > 0) &&   /* (#() 0) -> error */
	     (args <= vector_rank(x)));

    case T_LET:
    case T_HASH_TABLE:
    case T_PAIR:
      return(args == 1);

    case T_ITERATOR:
      return(args == 0);

    case T_SYNTAX:
      return((args >= syntax_min_args(x)) && ((args <= syntax_max_args(x)) || (syntax_max_args(x) == -1)));
    }
  return(false);
}

static s7_pointer g_is_aritable(s7_scheme *sc, s7_pointer args)
{
  #define H_is_aritable "(aritable? obj num-args) returns #t if 'obj can be applied to 'num-args arguments."
  #define Q_is_aritable s7_make_signature(sc, 3, sc->is_boolean_symbol, sc->T, sc->is_integer_symbol)

  s7_pointer n;
  s7_int num;

  n = cadr(args);
  if (!s7_is_integer(n)) /* remember gmp case! */
    return(method_or_bust(sc, n, sc->is_aritable_symbol, args, T_INTEGER, 2));

  num = s7_integer(n);
  if (num < 0)
    return(out_of_range(sc, sc->is_aritable_symbol, small_int(2), n, its_negative_string));
  if (num > MAX_ARITY) num = MAX_ARITY;

  return(make_boolean(sc, s7_is_aritable(sc, car(args), num)));
}

static bool is_aritable_b_7pp(s7_scheme *sc, s7_pointer f, s7_pointer i)
{
  return(g_is_aritable(sc, set_plist_2(sc, f, i)) != sc->F);
}


/* -------------------------------- sequence? -------------------------------- */
static s7_pointer g_is_sequence(s7_scheme *sc, s7_pointer args)
{
  #define H_is_sequence "(sequence? obj) returns #t if obj is a sequence (vector, string, pair, etc)"
  #define Q_is_sequence sc->pl_bt
  check_boolean_method(sc, is_simple_sequence, sc->is_sequence_symbol, args);
}

static bool is_sequence_b(s7_pointer p) {return(is_simple_sequence(p));}


/* -------------------------------- setter ------------------------------------------------ */

#define b_simple_setter(sc, typer, args)	\
  do {						\
       if (type(cadr(args)) == typer)		\
         return(cadr(args));			\
       return(s7_error(sc, sc->wrong_type_arg_symbol, \
         set_elist_5(sc, wrap_string(sc, "set! ~S, ~S is ~A but should be ~A", 34), \
           car(args), cadr(args), prepackaged_type_names[type(cadr(args))], prepackaged_type_names[typer]))); \
     } while (0)

static s7_pointer b_is_symbol_setter(s7_scheme *sc, s7_pointer args)       {b_simple_setter(sc, T_SYMBOL, args);}
static s7_pointer b_is_syntax_setter(s7_scheme *sc, s7_pointer args)       {b_simple_setter(sc, T_SYNTAX, args);}
static s7_pointer b_is_let_setter(s7_scheme *sc, s7_pointer args)          {b_simple_setter(sc, T_LET, args);}
static s7_pointer b_is_iterator_setter(s7_scheme *sc, s7_pointer args)     {b_simple_setter(sc, T_ITERATOR, args);}
static s7_pointer b_is_c_pointer_setter(s7_scheme *sc, s7_pointer args)    {b_simple_setter(sc, T_C_POINTER, args);}
static s7_pointer b_is_input_port_setter(s7_scheme *sc, s7_pointer args)   {b_simple_setter(sc, T_INPUT_PORT, args);}
static s7_pointer b_is_output_port_setter(s7_scheme *sc, s7_pointer args)  {b_simple_setter(sc, T_OUTPUT_PORT, args);}
static s7_pointer b_is_eof_object_setter(s7_scheme *sc, s7_pointer args)   {b_simple_setter(sc, T_EOF_OBJECT, args);}
static s7_pointer b_is_random_state_setter(s7_scheme *sc, s7_pointer args) {b_simple_setter(sc, T_RANDOM_STATE, args);}
static s7_pointer b_is_char_setter(s7_scheme *sc, s7_pointer args)         {b_simple_setter(sc, T_CHARACTER, args);}
static s7_pointer b_is_string_setter(s7_scheme *sc, s7_pointer args)       {b_simple_setter(sc, T_STRING, args);}
static s7_pointer b_is_float_vector_setter(s7_scheme *sc, s7_pointer args) {b_simple_setter(sc, T_FLOAT_VECTOR, args);}
static s7_pointer b_is_int_vector_setter(s7_scheme *sc, s7_pointer args)   {b_simple_setter(sc, T_INT_VECTOR, args);}
static s7_pointer b_is_byte_vector_setter(s7_scheme *sc, s7_pointer args)  {b_simple_setter(sc, T_BYTE_VECTOR, args);}
static s7_pointer b_is_hash_table_setter(s7_scheme *sc, s7_pointer args)   {b_simple_setter(sc, T_HASH_TABLE, args);}
static s7_pointer b_is_continuation_setter(s7_scheme *sc, s7_pointer args) {b_simple_setter(sc, T_CONTINUATION, args);}
static s7_pointer b_is_null_setter(s7_scheme *sc, s7_pointer args)         {b_simple_setter(sc, T_NIL, args);}
static s7_pointer b_is_pair_setter(s7_scheme *sc, s7_pointer args)         {b_simple_setter(sc, T_PAIR, args);}
static s7_pointer b_is_boolean_setter(s7_scheme *sc, s7_pointer args)      {b_simple_setter(sc, T_BOOLEAN, args);}
static s7_pointer b_is_undefined_setter(s7_scheme *sc, s7_pointer args)    {b_simple_setter(sc, T_UNDEFINED, args);}
static s7_pointer b_is_unspecified_setter(s7_scheme *sc, s7_pointer args)  {b_simple_setter(sc, T_UNSPECIFIED, args);}
static s7_pointer b_is_c_object_setter(s7_scheme *sc, s7_pointer args)     {b_simple_setter(sc, T_C_OBJECT, args);}

#define b_setter(sc, typer, args, str, len)	\
  do {						\
       if (typer(cadr(args)))			\
	 return(cadr(args));			\
       return(s7_error(sc, sc->wrong_type_arg_symbol, \
         set_elist_5(sc, wrap_string(sc, "set! ~S, ~S is ~A but should be ~A", 34), \
           car(args), cadr(args), prepackaged_type_names[type(cadr(args))], wrap_string(sc, str, len))));\
     } while (0)

static s7_pointer b_is_number_setter(s7_scheme *sc, s7_pointer args)      {b_setter(sc, s7_is_complex, args, "a number", 8);}
static s7_pointer b_is_complex_setter(s7_scheme *sc, s7_pointer args)     {b_setter(sc, s7_is_complex, args, "a number", 8);}
static s7_pointer b_is_gensym_setter(s7_scheme *sc, s7_pointer args)      {b_setter(sc, is_gensym, args, "a gensym", 8);}
static s7_pointer b_is_keyword_setter(s7_scheme *sc, s7_pointer args)     {b_setter(sc, is_keyword, args, "a keyword", 9);}
static s7_pointer b_is_openlet_setter(s7_scheme *sc, s7_pointer args)     {b_setter(sc, has_methods, args, "an open let", 11);}
static s7_pointer b_is_macro_setter(s7_scheme *sc, s7_pointer args)       {b_setter(sc, is_any_macro, args, "a macro", 7);}
static s7_pointer b_is_integer_setter(s7_scheme *sc, s7_pointer args)     {b_setter(sc, s7_is_integer, args, "an integer", 10);}
static s7_pointer b_is_byte_setter(s7_scheme *sc, s7_pointer args)        {b_setter(sc, is_byte, args, "an unsigned byte", 16);}
static s7_pointer b_is_real_setter(s7_scheme *sc, s7_pointer args)        {b_setter(sc, is_real, args, "a real", 6);}
static s7_pointer b_is_float_setter(s7_scheme *sc, s7_pointer args)       {b_setter(sc, is_float, args, "a float", 7);}
static s7_pointer b_is_rational_setter(s7_scheme *sc, s7_pointer args)    {b_setter(sc, is_rational, args, "a rational", 10);}
static s7_pointer b_is_list_setter(s7_scheme *sc, s7_pointer args)        {b_setter(sc, is_list, args, "a list", 6);}
static s7_pointer b_is_vector_setter(s7_scheme *sc, s7_pointer args)      {b_setter(sc, is_any_vector, args, "a vector", 8);}
static s7_pointer b_is_procedure_setter(s7_scheme *sc, s7_pointer args)   {b_setter(sc, is_any_procedure, args, "a procedure", 11);}
static s7_pointer b_is_dilambda_setter(s7_scheme *sc, s7_pointer args)    {b_setter(sc, s7_is_dilambda, args, "a dilambda", 10);}
static s7_pointer b_is_sequence_setter(s7_scheme *sc, s7_pointer args)    {b_setter(sc, is_sequence, args, "a sequence", 10);}
static s7_pointer b_is_subvector_setter(s7_scheme *sc, s7_pointer args)   {b_setter(sc, is_subvector, args, "a subvector", 11);}
static s7_pointer b_is_weak_hash_table_setter(s7_scheme *sc, s7_pointer args) {b_setter(sc, is_weak_hash_table, args, "a weak hash-table", 17);}

static s7_pointer b_is_proper_list_setter(s7_scheme *sc, s7_pointer args)
{
  if (s7_is_proper_list(sc, car(args)))
    return(cadr(args));
  return(s7_error(sc, sc->wrong_type_arg_symbol,
	  set_elist_5(sc, wrap_string(sc, "set! ~S, ~S is ~A but should be ~A", 34),
	    car(args), cadr(args), prepackaged_type_names[type(cadr(args))], wrap_string(sc, "a proper list", 13))));
}

static s7_pointer g_setter(s7_scheme *sc, s7_pointer args)
{
  #define H_setter "(setter obj env) returns the setter associated with obj"
  #define Q_setter s7_make_signature(sc, 3, s7_make_signature(sc, 2, sc->not_symbol, sc->is_procedure_symbol), sc->T, sc->is_let_symbol)
  s7_pointer p, e;

  p = car(args);
  if (is_pair(cdr(args)))
    {
      e = cadr(args);
      if (!((is_let(e)) || (e == sc->rootlet) || (e == sc->nil)))
	return(wrong_type_argument(sc, sc->setter_symbol, 2, e, T_LET));
    }
  else e = sc->envir;

  switch (type(p))
    {
    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
    case T_CLOSURE: case T_CLOSURE_STAR:
      if (is_any_procedure(closure_setter(p)))                /* setter already known */
	return(closure_setter(p));
      if (!closure_no_setter(p))
	{
	  s7_pointer f;
	  f = funclet_entry(sc, p, sc->local_setter_symbol); /* look for +setter+, save value as closure_setter(p) */
	  if (f)
	    {
	      if (f == sc->F)
		{
		  closure_set_no_setter(p);
		  return(sc->F);
		}
	      if (!is_any_procedure(f))
		return(s7_wrong_type_arg_error(sc, "setter", 0, p, "a procedure or a reasonable facsimile thereof"));
	      closure_set_setter(p, f);
	      return(f);
	    }
	  /* we used to search for setter here, but that can find the built-in setter causing an infinite loop (maybe check for that??) */
	  closure_set_no_setter(p);
	}
      return(sc->F);

    case T_C_FUNCTION:
    case T_C_FUNCTION_STAR:
    case T_C_ANY_ARGS_FUNCTION:
    case T_C_OPT_ARGS_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      return(c_function_setter(p));

    case T_C_MACRO:
      return(c_macro_setter(p));

    case T_GOTO:
    case T_CONTINUATION:
      return(sc->F);

    case T_C_OBJECT:
      check_method(sc, p, sc->setter_symbol, args);
      if  (c_object_set(sc, p) != fallback_set)
	return(sc->c_object_set_function);      /* for example ((setter obj) obj 0 1.0) if s7test block */
      /* this could wrap the setter as an s7_function giving p's class-name etc */
      return(sc->F);

    case T_LET:
      check_method(sc, p, sc->setter_symbol, args);
      return(slot_value(global_slot(sc->let_set_symbol)));

    case T_ITERATOR:
      if (is_any_closure(iterator_sequence(p)))
	return(closure_setter(iterator_sequence(p)));
      return(sc->F);                            /* (set! (iter) val) doesn't fit the other setters */

    case T_PAIR:
      return(slot_value(global_slot(sc->list_set_symbol)));

    case T_HASH_TABLE:
      return(slot_value(global_slot(sc->hash_table_set_symbol)));

    case T_STRING:
      return(slot_value(global_slot(sc->string_set_symbol)));

    case T_BYTE_VECTOR:
      return(slot_value(global_slot(sc->byte_vector_set_symbol)));

    case T_VECTOR:
      return(slot_value(global_slot(sc->vector_set_symbol)));

    case T_INT_VECTOR:
      return(slot_value(global_slot(sc->int_vector_set_symbol)));

    case T_FLOAT_VECTOR:
      return(slot_value(global_slot(sc->float_vector_set_symbol)));

    case T_SLOT:
      if (slot_has_setter(p))
	return(slot_setter(p));
      return(sc->F);

    case T_SYMBOL:                             /* (setter symbol env) */
      {
	s7_pointer sym, slot;
	sym = car(args);
	if (is_keyword(sym))
	  return(sc->F);

	if ((e == sc->rootlet) || (e == sc->nil))
	  slot = global_slot(sym);
	else
	  {
	    s7_pointer old_e;
	    old_e = sc->envir;
	    sc->envir = e;
	    slot = symbol_to_slot(sc, sym);
	    sc->envir = old_e;
	  }
	if (!is_slot(slot))
	  return(sc->F);

	if (slot_has_setter(slot))
	  return(slot_setter(slot));
	return(sc->F);
      }
    }
  return(s7_wrong_type_arg_error(sc, "setter", 0, p, "something that might have a setter"));
}

s7_pointer s7_setter(s7_scheme *sc, s7_pointer obj)
{
  return(g_setter(sc, set_plist_1(sc, obj)));
}


/* -------------------------------- set-setter -------------------------------- */
static void protect_setter(s7_scheme *sc, s7_pointer sym, s7_pointer acc)
{
  s7_int loc;
  if (sc->protected_setters_size == sc->protected_setters_loc)
    {
      s7_int i, new_size, size;
      block_t *ob, *nb;

      size = sc->protected_setters_size;
      new_size = 2 * size;

      ob = vector_block(sc->protected_setters);
      nb = reallocate(sc, ob, new_size * sizeof(s7_pointer));
      block_info(nb) = NULL;
      vector_block(sc->protected_setters) = nb;
      vector_elements(sc->protected_setters) = (s7_pointer *)block_data(nb);
      vector_length(sc->protected_setters) = new_size;

      ob = vector_block(sc->protected_setter_symbols);
      nb = reallocate(sc, ob, new_size * sizeof(s7_pointer));
      vector_block(sc->protected_setter_symbols) = nb;
      vector_elements(sc->protected_setter_symbols) = (s7_pointer *)block_data(nb);
      vector_length(sc->protected_setter_symbols) = new_size;

      for (i = size; i < new_size; i++)
	{
	  vector_element(sc->protected_setters, i) = sc->unused;
	  vector_element(sc->protected_setter_symbols, i) = sc->unused;
	}
      sc->protected_setters_size = new_size;
    }
  loc = sc->protected_setters_loc++;
  vector_element(sc->protected_setters, loc) = acc;
  vector_element(sc->protected_setter_symbols, loc) = sym;
}

static s7_pointer g_set_setter(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p, setter;

  p = car(args);
  /* should we check that p != setter?
   *   (set! (setter <) <) -> <
   *   (set! (< 3 2) 3) -> #f
   *   (set! (< 1) 2) -> #t
   */

  if (is_symbol(p))
    {
      s7_pointer sym, func, slot;
      sym = p;
      if (is_keyword(sym))
	return(s7_wrong_type_arg_error(sc, "set! setter", 1, sym, "a normal symbol (a keyword can't be set)"));

      if (is_pair(cddr(args)))
	{
	  s7_pointer e, old_e;
	  e = cadr(args);
	  func = caddr(args);
	  if ((e == sc->rootlet) || (e == sc->nil))
	    slot = global_slot(sym);
	  else
	    {
	      if (!is_let(e))
		return(s7_wrong_type_arg_error(sc, "set! symbol-setter", 2, e, "a let"));
	      old_e = sc->envir;
	      sc->envir = e;
	      slot = symbol_to_slot(sc, sym);
	      sc->envir = old_e;
	    }
	}
      else
	{
	  slot = symbol_to_slot(sc, sym);
	  func = cadr(args);
	}
      if ((!is_procedure_or_macro(func)) &&
	  (func != sc->F))
	return(s7_wrong_type_arg_error(sc, "set! setter", 3, func, "a function or #f"));

      if (sym == sc->setter_symbol)
	return(immutable_object_error(sc, set_elist_2(sc, wrap_string(sc, "can't set (setter setter) to ~S", 31), func)));

      if (!is_slot(slot))
	return(sc->F);

      if (slot == global_slot(sym))
	{
	  s7_set_setter(sc, sym, func); /* special GC protection for global vars */
	  return(func);
	}

      slot_set_setter(slot, func);
      if (func != sc->F)
	{
	  slot_set_has_setter(slot);
	  if (s7_is_aritable(sc, func, 3))
	    set_has_let_arg(func);
	  symbol_set_has_setter(sym);
	}
      return(func);
    }

  setter = cadr(args);
  if ((setter != sc->F) &&
      (!is_any_procedure(setter)))
    return(s7_wrong_type_arg_error(sc, "set! setter", 2, setter, "a procedure or #f"));

  switch (type(p))
    {
    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
    case T_CLOSURE: case T_CLOSURE_STAR:
      closure_set_setter(p, setter);
      if (setter == sc->F)
	closure_set_no_setter(p);
      break;

    case T_C_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
    case T_C_OPT_ARGS_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
    case T_C_FUNCTION_STAR:
      if (p == slot_value(global_slot(sc->setter_symbol)))
	return(immutable_object_error(sc, set_elist_2(sc, wrap_string(sc, "can't set (setter setter) to ~S", 31), setter)));
      c_function_set_setter(p, setter);
      if ((is_any_closure(setter)) ||
	  (is_any_macro(setter)))
	add_setter(sc, p, setter);
      break;

    case T_C_MACRO:
      c_macro_set_setter(p, setter);
      if ((is_any_closure(setter)) ||
	  (is_any_macro(setter)))
	add_setter(sc, p, setter);
      break;

    case T_SLOT:
      slot_set_setter(p, setter);
      slot_set_has_setter(p);
      break;
    }
  return(setter);
}

s7_pointer s7_set_setter(s7_scheme *sc, s7_pointer p, s7_pointer setter)
{
  if (is_symbol(p))
    {
      if (slot_has_setter(global_slot(p)))
	{
	  s7_int index;
	  for (index = 0; index < sc->protected_setters_loc; index++)
	    if (vector_element(sc->protected_setter_symbols, index) == p)
	      {
		s7_pointer old_func;
		old_func = vector_element(sc->protected_setters, index);
		if ((is_procedure_or_macro(old_func)) && /* i.e. not #f! */
		    (is_immutable(old_func)))
		  return(setter);
		vector_element(sc->protected_setters, index) = setter;
		slot_set_setter(global_slot(p), setter);
		if ((setter != sc->F) && (s7_is_aritable(sc, setter, 3)))
		  set_has_let_arg(setter);
		return(setter);
	      }
	}
      if (setter != sc->F)
	{
	  slot_set_has_setter(global_slot(p));
	  symbol_set_has_setter(p);
	  slot_set_has_setter(global_slot(p));
	  protect_setter(sc, p, setter);
	  slot_set_setter(global_slot(p), setter);
	  if (s7_is_aritable(sc, setter, 3))
	    set_has_let_arg(setter);
	  return(setter);
	}
      slot_set_setter(global_slot(p), setter);
      return(setter);
    }
  return(g_set_setter(sc, set_plist_2(sc, p, setter)));
}

/* (let () (define xxx 23) (define (hix) (set! xxx 24)) (hix) (set! (symbol-setter 'xxx) (lambda (sym val) (format *stderr* "val: ~A~%" val) val)) (hix))
 *    so set symbol-setter before use!
 */

static s7_pointer call_setter(s7_scheme *sc, s7_pointer slot, s7_pointer old_value)
{
  s7_pointer func, new_value;
  func = slot_setter(slot);

  if (!is_procedure_or_macro(func))
    return(old_value);
  if (has_let_arg(func))
    {
      if (is_c_function(func))
	{
	  set_car(sc->t3_1, slot_symbol(slot));
	  set_car(sc->t3_2, old_value);
	  set_car(sc->t3_3, sc->envir);
	  new_value = c_function_call(func)(sc, sc->t3_1);
	}
      else
	{
	  s7_pointer args;
	  args = list_3(sc, slot_symbol(slot), old_value, sc->envir);
	  push_stack_no_let(sc, OP_GC_PROTECT, args, slot);
	  new_value = s7_apply_function(sc, func, args); /* we're called from let_set, so we can't push something and return to the eval loop */
	  unstack(sc);
	}
    }
  else
    {
      if (is_c_function(func))
	{
	  set_car(sc->t2_1, slot_symbol(slot));
	  set_car(sc->t2_2, old_value);
	  new_value = c_function_call(func)(sc, sc->t2_1);
	}
      else
	{
	  s7_pointer args;
	  args = list_2(sc, slot_symbol(slot), old_value);
	  push_stack_no_let(sc, OP_GC_PROTECT, args, slot);
	  new_value = s7_apply_function(sc, func, args);
	  unstack(sc);
	}
    }
  return(new_value);
}

static s7_pointer bind_symbol_with_setter(s7_scheme *sc, opcode_t op, s7_pointer symbol, s7_pointer new_value)
{
  s7_pointer func;
  func = g_setter(sc, set_plist_2(sc, symbol, sc->envir));
  if (is_procedure_or_macro(func))
    {
      if (is_c_function(func))
	{
	  set_car(sc->t2_1, symbol);
	  set_car(sc->t2_2, new_value);
	  new_value = c_function_call(func)(sc, sc->t2_1);
	}
      else
	{
	  sc->args = list_2(sc, symbol, new_value);
	  push_stack(sc, op, sc->args, sc->code);
	  sc->code = func;
	  return(sc->no_value); /* this means the setter in set! needs to goto APPLY to get the new value */
	}
    }
  return(new_value);
}


/* -------------------------------- hooks -------------------------------- */

s7_pointer s7_hook_functions(s7_scheme *sc, s7_pointer hook)
{
  return(s7_symbol_local_value(sc, sc->body_symbol, closure_let(hook)));
}

s7_pointer s7_hook_set_functions(s7_scheme *sc, s7_pointer hook, s7_pointer functions)
{
  if (is_list(functions))
    s7_let_set(sc, closure_let(hook), sc->body_symbol, functions);
  return(functions);
}


/* -------------------------------- eq? eqv? equal? equivalent? -------------------------------- */

bool s7_is_eq(s7_pointer obj1, s7_pointer obj2)
{
  return((obj1 == obj2) ||                                     /* so floats and NaNs might be eq? but not eqv? */
	 ((is_unspecified(obj1)) && (is_unspecified(obj2))));  /* this is needed because this function is used by s7_b_pp */
}

static s7_pointer g_is_eq(s7_scheme *sc, s7_pointer args)
{
  #define H_is_eq "(eq? obj1 obj2) returns #t if obj1 is eq to (the same object as) obj2"
  #define Q_is_eq sc->pcl_bt
  return(make_boolean(sc, ((car(args) == cadr(args)) ||
			   ((is_unspecified(car(args))) && (is_unspecified(cadr(args)))))));
  /* (eq? (apply apply apply values '(())) #<unspecified>) should return #t */
}

bool s7_is_eqv(s7_pointer a, s7_pointer b)
{
#if WITH_GMP
  if ((is_big_number(a)) || (is_big_number(b)))
    return(big_numbers_are_eqv(a, b));
#endif

  if (type(a) != type(b))
    return(false);

  if ((a == b) && (!is_number(a)))                   /* if a is NaN, a == b doesn't mean (eqv? a b) */
    return(true);                                    /* a == b means (let ((x "a")) (let ((y x)) (eqv? x y))) is #t */

  if (s7_is_number(a))
    return(numbers_are_eqv(a, b));

  if (is_unspecified(a))                             /* types are the same so we know b is also unspecified */
    return(true);

  return(false);
}

static s7_pointer g_is_eqv(s7_scheme *sc, s7_pointer args)
{
  #define H_is_eqv "(eqv? obj1 obj2) returns #t if obj1 is equivalent to obj2"
  #define Q_is_eqv sc->pcl_bt
  return(make_boolean(sc, s7_is_eqv(car(args), cadr(args))));
}

static bool s7_is_equal_1(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci);
static bool s7_is_equivalent_1(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci);

static bool floats_are_equivalent(s7_scheme *sc, s7_double x, s7_double y)
{
  s7_double diff, eps;
  if (x == y) return(true);

  if ((is_NaN(x)) || (is_NaN(y)))
    return((is_NaN(x)) && (is_NaN(y)));

  eps = sc->equivalent_float_epsilon;
  diff = fabs(x - y);
  if (diff <= eps) return(true);
  if (x < 0.0) x = -x;
  return((x > 1.0) &&
	 (diff < (x * eps)));
}

static bool eq_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return(x == y);
}

static bool symbol_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (x == y) return(true);
  if (!is_symbol(y)) return(false);                   /* (equivalent? ''(1) '(1)) */
  return((is_slot(global_slot(x))) &&                 /* the optimizer can replace the original symbol with its own */
	 (is_syntax(slot_value(global_slot(x)))) &&
	 (is_slot(global_slot(y))) &&
	 (is_syntax(slot_value(global_slot(y)))) &&
	 (syntax_symbol(slot_value(global_slot(x))) == syntax_symbol(slot_value(global_slot(y)))));
}

static bool unspecified_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return(is_unspecified(y));
}

static bool undefined_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (x == y) return(true);
  if (!is_undefined(y)) return(false);
  return(safe_strcmp(unknown_name(x), unknown_name(y)));
}

static bool c_pointer_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  shared_info *nci = ci;
  if (x == y) return(true);
  if (!s7_is_c_pointer(y)) return(false);
  if (c_pointer(x) != c_pointer(y)) return(false);
  if (c_pointer_type(x) != c_pointer_type(y))
    {
      if (!nci) nci = new_shared_info(sc);
      if (!s7_is_equivalent_1(sc, c_pointer_type(x), c_pointer_type(y), nci))
	return(false);
    }
  if (c_pointer_info(x) != c_pointer_info(y))
    {
      if (!nci) nci = new_shared_info(sc);
      if (!s7_is_equivalent_1(sc, c_pointer_info(x), c_pointer_info(y), nci))
	return(false);
    }
  return(true);
}

static bool c_pointer_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  shared_info *nci = ci;
  if (x == y) return(true);
  if (!s7_is_c_pointer(y)) return(false);
  if (c_pointer(x) != c_pointer(y)) return(false);
  if (c_pointer_type(x) != c_pointer_type(y))
    {
      if (!nci) nci = new_shared_info(sc);
      if (!s7_is_equal_1(sc, c_pointer_type(x), c_pointer_type(y), nci))
	return(false);
    }
  if (c_pointer_info(x) != c_pointer_info(y))
    {
      if (!nci) nci = new_shared_info(sc);
      if (!s7_is_equal_1(sc, c_pointer_info(x), c_pointer_info(y), nci))
	return(false);
    }
  return(true);
}

static bool string_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return((is_string(y)) && (scheme_strings_are_equal(x, y)));
}

static bool syntax_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return((is_syntax(y)) && (syntax_symbol(x) == syntax_symbol(y)));
}

static bool port_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return(x == y);
}

static bool port_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (x == y) return(true);
  if (type(x) != type(y)) return(false);
  if ((port_is_closed(x)) && (port_is_closed(y))) return(true);
  if ((port_is_closed(x)) || (port_is_closed(y))) return(false); /* if either is closed, port_port (below) might be null */
  if (port_type(x) != port_type(y)) return(false);
  switch (port_type(x))
    {
    case STRING_PORT:
      return((port_position(x) == port_position(y)) &&
	     (port_data_size(x) == port_data_size(y)) &&
	     (local_strncmp((const char *)port_data(x), (const char *)port_data(y), (is_input_port(x)) ? port_data_size(x) : port_position(x))));
    case FILE_PORT:
      return((is_input_port(x)) &&
	     (port_position(x) == port_position(y)) &&
	     (local_strncmp((const char *)port_filename(x), (const char *)port_filename(y), port_filename_length(x))));
    case FUNCTION_PORT:
      if (is_input_port(x))
	return(port_input_function(x) == port_input_function(y));
      return(port_output_function(x) == port_output_function(y));
    }
  return(false);
}

#define equal_ref(Sc, X, Y, Ci) \
  do {   \
    /* here we know x and y are pointers to the same type of structure */ \
    int32_t ref_y;							\
    ref_y = (is_collected(Y)) ? peek_shared_ref(Ci, Y) : 0;		\
    if (is_collected(X))						\
      {									\
	int32_t ref_x;							\
	ref_x = peek_shared_ref(Ci, X);					\
	if (ref_y != 0) return(ref_x == ref_y);				\
	/* try to harmonize the new guy -- there can be more than one structure equal to the current one */ \
	if (ref_x != 0) add_shared_ref(Ci, Y, ref_x);			\
      }									\
    else								\
      {									\
	if (ref_y != 0)							\
	  add_shared_ref(Ci, X, ref_y);					\
	else								\
	  {								\
	    /* assume neither x nor y is in the table, and that they should share a ref value, \
	     *   called only in equality check, not printer.		\
	     */								\
	    if (Ci->top >= Ci->size2) enlarge_shared_info(Ci);		\
	    set_collected(X);						\
	    set_collected(Y);						\
	    Ci->objs[Ci->top] = X;					\
	    Ci->refs[Ci->top++] = ++Ci->ref;				\
	    Ci->objs[Ci->top] = Y;					\
	    Ci->refs[Ci->top++] = Ci->ref;				\
	  }								\
      }									\
  } while (0)


static bool c_objects_are_equal(s7_scheme *sc, s7_pointer a, s7_pointer b, shared_info *ci)
{
  s7_pointer (*to_list)(s7_scheme *sc, s7_pointer args);
  shared_info *nci = ci;
  s7_pointer pa, pb;

  if (a == b)
    return(true);
  if (!is_c_object(b))
    return(false);
  if (c_object_type(a) != c_object_type(b))
    return(false);
  if (c_object_eql(sc, a))
    return((*(c_object_eql(sc, a)))(c_object_value(a), c_object_value(b)));

  to_list = c_object_to_list(sc, a);
  if (!to_list)
    return(false);
  if (ci)
    equal_ref(sc, a, b, ci); /* and nci == ci above */
  else nci = new_shared_info(sc);

  for (pa = to_list(sc, set_plist_1(sc, a)), pb = to_list(sc, set_plist_1(sc, b)); is_pair(pa) && (is_pair(pb)); pa = cdr(pa), pb = cdr(pb))
    if (!(s7_is_equal_1(sc, car(pa), car(pb), nci)))
      return(false);

  return(pa == pb); /* presumably both are nil if successful */
}

#define check_equivalent_method(Sc, X, Y) \
  do {						 \
      if (has_active_methods(sc, X))						\
	{								\
	  s7_pointer equal_func;					\
	  equal_func = find_method(Sc, find_let(Sc, X), Sc->is_equivalent_symbol); \
	  if (equal_func != Sc->undefined)				\
	    return(s7_boolean(Sc, s7_apply_function(Sc, equal_func, list_2(Sc, X, Y)))); \
	}}								\
    while (0)

static bool c_object_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  check_equivalent_method(sc, x, y);
  return(c_objects_are_equal(sc, x, y, ci));
}

static bool hash_table_equal_1(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci, bool equivalent)
{
  hash_entry_t **lists;
  s7_int i, len;
  shared_info *nci = ci;
  hash_check_t hf;
  bool (*eqf)(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci);

  if (x == y)
    return(true);
  if (!is_hash_table(y))
    {
      if (equivalent) 
	check_equivalent_method(sc, y, x);
      return(false);
    }
  if (ci)
    equal_ref(sc, x, y, ci);

  if (hash_table_entries(x) != hash_table_entries(y))
    return(false);
  if (hash_table_entries(x) == 0)
    return(true);
  if ((!equivalent) && ((hash_table_checker_locked(x)) || (hash_table_checker_locked(y))))
    {
      if (hash_table_checker(x) != hash_table_checker(y))
	return(false);
      if (hash_table_mapper(x) != hash_table_mapper(y))
	return(false);
    }

  len = hash_table_mask(x) + 1;
  lists = hash_table_elements(x);
  if (!nci) nci = new_shared_info(sc);

  if (equivalent)
    eqf = s7_is_equivalent_1;
  else eqf = s7_is_equal_1;

  hf = hash_table_checker(y);
  if ((hf != hash_equal) && (hf != hash_equivalent))
    {
      for (i = 0; i < len; i++)
	{
	  hash_entry_t *p;
	  for (p = lists[i]; p; p = hash_entry_next(p))
	    {
	      hash_entry_t *y_val;
	      y_val = hf(sc, y, hash_entry_key(p));
	      if (y_val == sc->unentry)
		return(false);
	      if (!eqf(sc, hash_entry_value(p), hash_entry_value(y_val), nci))
		return(false);
	    }
	}
      /* if we get here, every key/value in x has a corresponding key/value in y, and the number of entries match,
       *   so surely the tables are equal??
       * if ci not null or hash-table-checker is equal/eqivalent, can't use hf?
       */
      return(true);
    }
  
  /* we need to protect the current shared_info data (nci) here so the current hash_table_checker won't work -- 
   *   outside equal?/eqivalent? they can safely assume that they can start a new shared_info process.
   */
  for (i = 0; i < len; i++)
    {
      hash_entry_t *p;
      for (p = lists[i]; p; p = hash_entry_next(p))
	{
	  hash_entry_t *x;
	  s7_int hash, loc;
	  s7_pointer key;
  
	  key = hash_entry_key(p);
	  hash = hash_loc(sc, y, key);
	  loc = hash & hash_table_mask(y);

	  for (x = hash_table_element(y, loc); x; x = hash_entry_next(x))
	    if (hash_entry_raw_hash(x) == hash)
	      if (eqf(sc, hash_entry_key(x), key, nci))
		break;
	  if (!x)
	    return(false);
	  if (!eqf(sc, hash_entry_value(p), hash_entry_value(x), nci))
	    return(false);
	}
    }
  return(true);
}

static bool hash_table_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return(hash_table_equal_1(sc, x, y, ci, false));
}

static bool hash_table_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return(hash_table_equal_1(sc, x, y, ci, true));
}

static bool slots_match(s7_scheme *sc, s7_pointer px, s7_pointer y, shared_info *nci)
{
  s7_pointer ey, py;
  for (ey = y; (is_let(ey)) && (ey != sc->rootlet); ey = outlet(ey))
    for (py = let_slots(ey); tis_slot(py); py = next_slot(py))
      if (slot_symbol(px) == slot_symbol(py)) /* we know something will match */
	return(s7_is_equal_1(sc, slot_value(px), slot_value(py), nci));
  return(false);
}

static bool slots_equivalent_match(s7_scheme *sc, s7_pointer px, s7_pointer y, shared_info *nci)
{
  s7_pointer ey, py;
  for (ey = y; (is_let(ey)) && (ey != sc->rootlet); ey = outlet(ey))
    for (py = let_slots(ey); tis_slot(py); py = next_slot(py))
      if (slot_symbol(px) == slot_symbol(py)) /* we know something will match */
	return(s7_is_equivalent_1(sc, slot_value(px), slot_value(py), nci));
  return(false);
}

static bool let_equal_1(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci, bool equivalent)
{
  s7_pointer ex, ey, px, py;
  shared_info *nci = ci;
  int32_t x_len, y_len;

  if (!is_let(y))
    return(false);

  if ((x == sc->rootlet) || (y == sc->rootlet))
    return(false);

  if (ci)
    equal_ref(sc, x, y, ci);

  clear_symbol_list(sc);
  for (x_len = 0, ex = x; (is_let(ex)) && (ex != sc->rootlet); ex = outlet(ex))
    for (px = let_slots(ex); tis_slot(px); px = next_slot(px))
      if (!symbol_is_in_list(sc, slot_symbol(px)))
	{
	  add_symbol_to_list(sc, slot_symbol(px));
	  x_len++;
	}

  for (ey = y; (is_let(ey)) && (ey != sc->rootlet); ey = outlet(ey))
    for (py = let_slots(ey); tis_slot(py); py = next_slot(py))
      if (!symbol_is_in_list(sc, slot_symbol(py)))          /* symbol in y, not in x */
	return(false);

  for (y_len = 0, ey = y; (is_let(ey)) && (ey != sc->rootlet); ey = outlet(ey))
    for (py = let_slots(ey); tis_slot(py); py = next_slot(py))
      if (symbol_tag(slot_symbol(py)) != 0)
	{
	  y_len++;
	  symbol_set_tag(slot_symbol(py), 0);
	}

  if (x_len != y_len)                                        /* symbol in x, not in y */
    return(false);

  if (!nci) nci = new_shared_info(sc);

  for (ex = x; (is_let(ex)) && (ex != sc->rootlet); ex = outlet(ex))
    for (px = let_slots(ex); tis_slot(px); px = next_slot(px))
      if (symbol_tag(slot_symbol(px)) == 0)                  /* unshadowed */
	{
	  symbol_set_tag(slot_symbol(px), sc->syms_tag);     /* values don't match */
	  if (((!equivalent) && (!slots_match(sc, px, y, nci))) ||
	      ((equivalent) && (!slots_equivalent_match(sc, px, y, nci))))
	    return(false);
	}
  return(true);
}

static bool let_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  /* x == y if all unshadowed vars match, leaving aside the rootlet, so that for any local variable, we get the same value in either x or y. */
  if (x == y)
    return(true);
  return(let_equal_1(sc, x, y, ci, false));
}

/* what should these do if there are setters? */
static bool let_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (x == y) return(true);
  check_equivalent_method(sc, x, y);
  check_equivalent_method(sc, y, x);
  return(let_equal_1(sc, x, y, ci, true));
}

static bool closure_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (x == y)
    return(true);
  if (type(x) != type(y))
    return(false);
  if ((has_active_methods(sc, x)) &&
      (has_active_methods(sc, y)))
    {
      s7_pointer equal_func;
      equal_func = find_method(sc, closure_let(x), sc->is_equal_symbol);
      if (equal_func != sc->undefined)
	return(s7_boolean(sc, s7_apply_function(sc, equal_func, list_2(sc, x, y))));
    }
  return(false);
}

static bool closure_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (x == y)
    return(true);
  if (type(x) != type(y))
    return(false);
  if (has_active_methods(sc, y))
    check_equivalent_method(sc, x, y);
  /* not sure about this -- we can't simply check let_equal(closure_let(x), closure_let(y))
   *   because locally defined constant functions on the second pass find the outer let.
   */
  return((s7_is_equivalent_1(sc, closure_args(x), closure_args(y), ci)) &&
	 (s7_is_equivalent_1(sc, closure_body(x), closure_body(y), ci)));
}

static bool pair_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  shared_info *nci;
  s7_pointer px, py;

  if (x == y)
    return(true);
  if (!is_pair(y))
    return(false);
  if (ci)
    {
      nci = ci;
      equal_ref(sc, x, y, ci);
    }
  else nci = new_shared_info(sc);

  if (!s7_is_equal_1(sc, car(x), car(y), nci)) return(false);
  for (px = cdr(x), py = cdr(y); (is_pair(px)) && (is_pair(py)); px = cdr(px), py = cdr(py))
    {
      if (!s7_is_equal_1(sc, car(px), car(py), nci)) return(false);
      equal_ref(sc, px, py, nci);
    }
  if (px == py) /* normally nil? */
    return(true);
  return(s7_is_equal_1(sc, px, py, nci));
}

static bool pair_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  shared_info *nci;
  s7_pointer px, py;

  if (x == y)
    return(true);
  if (!is_pair(y))
    {
      check_equivalent_method(sc, y, x);
      return(false);
    }

  if (ci)
    {
      nci = ci;
      equal_ref(sc, x, y, ci);
    }
  else nci = new_shared_info(sc);

  if (!s7_is_equivalent_1(sc, car(x), car(y), nci)) return(false);
  for (px = cdr(x), py = cdr(y); (is_pair(px)) && (is_pair(py)); px = cdr(px), py = cdr(py))
    {
      if (!s7_is_equivalent_1(sc, car(px), car(py), nci)) return(false);
      equal_ref(sc, px, py, nci);
    }
  if (px == py) /* normally nil? */
    return(true);
  return(s7_is_equivalent_1(sc, px, py, nci));
}

static bool vector_rank_match(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  s7_int x_dims;
  s7_int j;

  if (vector_has_dimensional_info(x))
    x_dims = vector_ndims(x);
  else return((!vector_has_dimensional_info(y)) || (vector_ndims(y) == 1));
  if (x_dims == 1)
    return((!vector_has_dimensional_info(y)) || (vector_ndims(y) == 1));

  if ((!vector_has_dimensional_info(y)) ||
      (x_dims != vector_ndims(y)))
    return(false);

  for (j = 0; j < x_dims; j++)
    if (vector_dimension(x, j) != vector_dimension(y, j))
      return(false);

  return(true);
}

static bool iv_meq(s7_int *ex, s7_int *ey, s7_int len)
{
  s7_int i, left;
  left = len - 8;
  i = 0;
  while (i <= left)
    LOOP_8(if (ex[i] != ey[i]) return(false); i++);
  for (; i < len; i++)
    if (ex[i] != ey[i])
      return(false);
  return(true);
}

static bool byte_vector_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  s7_int i, len;
  uint8_t *xp, *yp;

  if (x == y) return(true);
  if (type(x) != type(y)) return(false);
  len = vector_length(x);
  if (len != vector_length(y)) return(false);

  xp = byte_vector_bytes(x);
  yp = byte_vector_bytes(y);
  for (i = 0; i < len; i++)
    if (xp[i] != yp[i])
      return(false);
  return(true);
}

static bool biv_meq(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  s7_int i, len;
  uint8_t *xp;
  s7_int *yp;
  len = vector_length(x);
  if (len != vector_length(y)) return(false);
  xp = byte_vector_bytes(x);
  yp = int_vector_ints(y);
  for (i = 0; i < len; i++)
    if ((s7_int)(xp[i]) != yp[i])
      return(false);
  return(true);
}

static bool vector_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  s7_int i, len;
  shared_info *nci = ci;

  if (x == y) return(true);
  if (!is_any_vector(y)) return(false);

  len = vector_length(x);
  if (len != vector_length(y)) return(false);
  if (!vector_rank_match(sc, x, y)) return(false);  /* ?? should #2d() equal #3d()? */
  if (len == 0) return(true);

  if (type(x) != type(y))
    {
      if ((is_int_vector(x)) && (is_byte_vector(y)))
	return(biv_meq(sc, y, x, NULL));
      if ((is_byte_vector(x)) && (is_int_vector(y)))
	return(biv_meq(sc, x, y, NULL));
      for (i = 0; i < len; i++)
	if (!s7_is_equal_1(sc, vector_getter(x)(sc, x, i), vector_getter(y)(sc, y, i), NULL)) /* this could be greatly optimized */
	  return(false);
      return(true);
    }

  /* types are the same, take care of the special cases first */
  if (is_float_vector(x))
    {
      for (i = 0; i < len; i++)
	{
	  s7_double z;
	  z = float_vector(x, i);
	  if ((is_NaN(z)) ||
	      (z != float_vector(y, i)))
	    return(false);
	}
      return(true);
    }
  if (is_int_vector(x))
    return(iv_meq(int_vector_ints(x), int_vector_ints(y), len));
  if (is_byte_vector(x))
    return(byte_vector_equal(sc, x, y, NULL));

  if (!has_simple_elements(x))
    {
      if (ci)
	equal_ref(sc, x, y, ci);
      else nci = new_shared_info(sc);
    }
  for (i = 0; i < len; i++)
    if (!(s7_is_equal_1(sc, vector_element(x, i), vector_element(y, i), nci)))
      return(false);
  return(true);
}

static bool vector_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  s7_int i, len;
  shared_info *nci = ci;

  if (x == y)
    return(true);
  if (!is_any_vector(y))
    {
      check_equivalent_method(sc, y, x);
      return(false);
    }
  len = vector_length(x);
  if (len != vector_length(y)) return(false);
  if (len == 0) return(true);
  if (!vector_rank_match(sc, x, y)) return(false);

  if (type(x) != type(y))
    {
      /* (equivalent? (make-int-vector 3 0) (make-vector 3 0)) -> #t
       * (equivalent? (make-float-vector 3 1.0) (vector 1 1 1)) -> #t
       */
      if ((is_int_vector(x)) && (is_byte_vector(y)))
	return(biv_meq(sc, y, x, NULL));
      if ((is_byte_vector(x)) && (is_int_vector(y)))
	return(biv_meq(sc, x, y, NULL));
      for (i = 0; i < len; i++)
	if (!s7_is_equivalent_1(sc, vector_getter(x)(sc, x, i), vector_getter(y)(sc, y, i), NULL)) /* this could be greatly optimized */
	  return(false);
      return(true);
    }

  if (is_float_vector(x))
    {
      s7_double *arr1, *arr2;
      s7_double fudge;
      arr1 = float_vector_floats(x);
      arr2 = float_vector_floats(y);
      fudge = sc->equivalent_float_epsilon;
      if (fudge == 0.0)
	{
	  for (i = 0; i < len; i++)
	    if ((arr1[i] != arr2[i]) &&
		((!is_NaN(arr1[i])) || (!is_NaN(arr2[i]))))
	      return(false);
	}
      else
	{
	  for (i = 0; i < len; i++)
	    if (!floats_are_equivalent(sc, arr1[i], arr2[i]))
	      return(false);
	}
      return(true);
    }
  if (is_int_vector(x))
    return(iv_meq(int_vector_ints(x), int_vector_ints(y), len));
  if (is_byte_vector(x))
    return(byte_vector_equal(sc, x, y, NULL));

  if (!has_simple_elements(x))
    {
      if (ci)
	equal_ref(sc, x, y, ci);
      else nci = new_shared_info(sc);
    }
  for (i = 0; i < len; i++)
    if (!(s7_is_equivalent_1(sc, vector_element(x, i), vector_element(y, i), nci)))
      return(false);
  return(true);
}

static bool iterator_equal_1(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci, bool equivalent)
{
  s7_pointer x_seq, y_seq, xs, ys;

  if (x == y) return(true);
  if (!is_iterator(y)) return(false);

  x_seq = iterator_sequence(x);
  y_seq = iterator_sequence(y);

  switch (type(x_seq))
    {
    case T_STRING:
      return((is_string(y_seq)) &&
	     (iterator_position(x) == iterator_position(y)) &&
	     (iterator_length(x) == iterator_length(y)) &&
	     (string_equal(sc, x_seq, y_seq, ci)));

    case T_VECTOR: case T_INT_VECTOR: case T_BYTE_VECTOR: case T_FLOAT_VECTOR:
      return((is_any_vector(y_seq)) &&
	     (iterator_position(x) == iterator_position(y)) &&
	     (iterator_length(x) == iterator_length(y)) &&
	     ((equivalent) ? (vector_equivalent(sc, x_seq, y_seq, ci)) : (vector_equal(sc, x_seq, y_seq, ci))));

      /* iterator_next is a function (pair_iterate, iterator_finished etc) */
    case T_PAIR:
      if (iterator_next(x) != iterator_next(y)) return(false);     /* even if seqs are equal, one might be at end */
      if (equivalent)
	{
	  if (!pair_equivalent(sc, x_seq, y_seq, ci))
	    return(false);
	}
      else
	{
	  if (!pair_equal(sc, x_seq, y_seq, ci))
	    return(false);
	}
      for (xs = x_seq, ys = y_seq; is_pair(xs) && is_pair(ys); xs = cdr(xs), ys = cdr(ys))
	if (xs == iterator_current(x))
	  return(ys == iterator_current(y));
      return(is_null(xs) && is_null(ys));

    case T_NIL:                                                    /* (make-iterator #()) works, so () should too */
      return(is_null(y_seq));   /* perhaps for equivalent case, check position in y as well as pair(seq(y))? */

    case T_C_OBJECT:
      if ((is_c_object(y_seq)) &&
	  (iterator_position(x) == iterator_position(y)) &&
	  (iterator_length(x) == iterator_length(y)))
	{
	  if (equivalent)
	    return(c_object_equivalent(sc, x_seq, y_seq, ci));
	  return(c_objects_are_equal(sc, x_seq, y_seq, ci));
	}
      return(false);

    case T_LET:
      if (!is_let(y_seq)) return(false);
      if (iterator_next(x) != iterator_next(y)) return(false);
      if (x_seq == sc->rootlet)
	return(iterator_position(x) == iterator_position(y)); /* y_seq must also be sc->rootlet since nexts are the same (rootlet_iterate) */
      if (equivalent)
	{
	  if (!let_equivalent(sc, x_seq, y_seq, ci))
	    return(false);
	}
      else
	{
	  if (!let_equal(sc, x_seq, y_seq, ci))
	    return(false);
	}
      for (xs = let_slots(x_seq), ys = let_slots(y_seq); tis_slot(xs) && tis_slot(ys); xs = next_slot(xs), ys = next_slot(ys))
	if (xs == iterator_current_slot(x))
	  return(ys == iterator_current_slot(y));
      return(is_slot_end(xs) && is_slot_end(ys));

    case T_HASH_TABLE:
      if (!is_hash_table(y_seq)) return(false);
      if (hash_table_entries(x_seq) != hash_table_entries(y_seq)) return(false);
      if (hash_table_entries(x_seq) == 0) return(true);
      if (iterator_position(x) != iterator_position(y)) return(false);
      if (!equivalent)
	return(hash_table_equal(sc, x_seq, y_seq, ci));
      return(hash_table_equivalent(sc, x_seq, y_seq, ci));

    case T_CLOSURE: case T_CLOSURE_STAR:
      return(x_seq == y_seq); /* or closure_equal/equivalent? */

    default:
      break;
    }
  return(false);
}

static bool iterator_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return(iterator_equal_1(sc, x, y, ci, false));
}

static bool iterator_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return(iterator_equal_1(sc, x, y, ci, true));
}

#if WITH_GMP
static bool bignum_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (!s7_is_number(y)) return(false);
  return(big_numbers_are_eqv(x, y));
}

static bool bignum_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  if (!s7_is_number(y)) return(false);
  return(big_equal(sc, set_plist_2(sc, x, y)) != sc->F);
  return(false);
}
#endif

static bool integer_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_numbers_are_eqv(x, y));
#endif
  if (is_t_integer(y))
    return(integer(x) == integer(y));
  return(false);
}

static bool integer_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_equal(sc, set_plist_2(sc, x, y)) != sc->F);
#endif
  if (is_t_integer(y))
    return(integer(x) == integer(y));
  if (!is_number(y))
    return(false);

  if (is_t_real(y))
    return((!is_NaN(real(y))) &&
	   (floats_are_equivalent(sc, (s7_double)integer(x), real(y))));

  if (is_t_ratio(y))
    return(floats_are_equivalent(sc, (s7_double)integer(x), (s7_double)fraction(y)));

  return((!is_NaN(real_part(y))) &&
	 (!is_NaN(imag_part(y))) &&
	 (floats_are_equivalent(sc, (s7_double)integer(x), real_part(y))) &&
	 (fabs(imag_part(y)) <= sc->equivalent_float_epsilon));
}

/* apparently ratio_equal is predefined in g++ -- name collision on mac */
static bool fraction_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_numbers_are_eqv(x, y));
#endif
  return((s7_is_ratio(y)) &&
	 (numerator(x) == numerator(y)) &&
	 (denominator(x) == denominator(y)));
}

static bool fraction_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_equal(sc, set_plist_2(sc, x, y)) != sc->F);
#endif
  if (is_t_ratio(y))
    return(floats_are_equivalent(sc, (s7_double)fraction(x), (s7_double)fraction(y)));

  if (is_t_real(y))
    return(floats_are_equivalent(sc, (s7_double)fraction(x), real(y)));

  if (is_t_integer(y))
    return(floats_are_equivalent(sc, (s7_double)fraction(x), (s7_double)integer(y)));

  if (is_t_complex(y))
    return((!is_NaN(real_part(y))) &&
	   (!is_NaN(imag_part(y))) &&
	   (floats_are_equivalent(sc, (s7_double)fraction(x), real_part(y))) &&
	   (fabs(imag_part(y)) <= sc->equivalent_float_epsilon));
  return(false);
}

static bool real_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_numbers_are_eqv(x, y));
#endif
  return((is_t_real(y)) &&
	 (real(x) == real(y)));
}

static bool real_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_equal(sc, set_plist_2(sc, x, y)) != sc->F);
#endif
  if (!is_number(y)) return(false);

  if (is_t_real(y))
    return(floats_are_equivalent(sc, real(x), real(y)));

  if (is_t_integer(y))
    return((!is_NaN(real(x))) &&
	   (floats_are_equivalent(sc, real(x), (s7_double)integer(y))));

  if (is_t_ratio(y))
    return(floats_are_equivalent(sc, real(x), (s7_double)fraction(y)));

  if (is_NaN(real(x)))
    return((is_NaN(real_part(y))) &&
	   (fabs(imag_part(y)) <= sc->equivalent_float_epsilon));

  return((!is_NaN(real(x))) &&
	 (!is_NaN(real_part(y))) &&
	 (!is_NaN(imag_part(y))) &&
	 (floats_are_equivalent(sc, real(x), real_part(y))) &&
	 (fabs(imag_part(y)) <= sc->equivalent_float_epsilon));
}

static bool complex_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_numbers_are_eqv(x, y));
#endif
  return((is_t_complex(y)) &&
	 (!is_NaN(real_part(x))) &&
	 (!is_NaN(imag_part(x))) &&
	 (real_part(x) == real_part(y)) &&
	 (imag_part(x) == imag_part(y)));
}

static bool complex_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  if (is_big_number(y))
    return(big_equal(sc, set_plist_2(sc, x, y)) != sc->F);
#endif
  if (!is_number(y)) return(false);

  if (is_t_integer(y))
    return((!is_NaN(real_part(x))) &&
	   (!is_NaN(imag_part(x))) &&
	   (floats_are_equivalent(sc, real_part(x), (s7_double)integer(y))) &&
	   (fabs(imag_part(x)) <= sc->equivalent_float_epsilon));

  if (s7_is_ratio(y))
    return((!is_NaN(real_part(x))) &&
	   (!is_NaN(imag_part(x))) &&
	   (floats_are_equivalent(sc, real_part(x), (s7_double)fraction(y))) &&
	   (fabs(imag_part(x)) <= sc->equivalent_float_epsilon));

  if (is_real(y))
    {
      if (is_NaN(imag_part(x)))
	return(false);
      if (is_NaN(real(y)))
	return((is_NaN(real_part(x))) &&
	       (fabs(imag_part(x)) <= sc->equivalent_float_epsilon));
      return((floats_are_equivalent(sc, real_part(x), real(y))) &&
	     (fabs(imag_part(x)) <= sc->equivalent_float_epsilon));
    }

  /* should (equivalent? +nan.0 (complex +nan.0 +nan.0)) be #t (it's #f above)? */
  if (is_NaN(real_part(x)))
    return((is_NaN(real_part(y))) &&
	   (((is_NaN(imag_part(x))) && (is_NaN(imag_part(y)))) ||
	    (floats_are_equivalent(sc, imag_part(x), imag_part(y)))));

  if (is_NaN(imag_part(x)))
    return((is_NaN(imag_part(y))) &&
	   (floats_are_equivalent(sc, real_part(x), real_part(y))));

  if ((is_NaN(real_part(y))) ||
      (is_NaN(imag_part(y))))
    return(false);

  return((floats_are_equivalent(sc, real_part(x), real_part(y))) &&
	 (floats_are_equivalent(sc, imag_part(x), imag_part(y))));
}

static bool rng_equal(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
#if WITH_GMP
  return(x == y);
#else
  return((x == y) ||
	 ((is_random_state(y)) &&
	  (random_seed(x) == random_seed(y)) &&
	  (random_carry(x) == random_carry(y))));
#endif
}

static bool (*equals[NUM_TYPES])(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci);
static bool (*equivalents[NUM_TYPES])(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci);

static void init_equals(void)
{
  int32_t i;
  for (i = 0; i < NUM_TYPES; i++) {equals[i] = eq_equal; equivalents[i] = eq_equal;}
  equals[T_SYMBOL] =       eq_equal;
  equals[T_C_POINTER] =    c_pointer_equal;
  equals[T_UNSPECIFIED] =  unspecified_equal;
  equals[T_UNDEFINED] =    undefined_equal;
  equals[T_STRING] =       string_equal;
  equals[T_SYNTAX] =       syntax_equal;
  equals[T_C_OBJECT] =     c_objects_are_equal;
  equals[T_RANDOM_STATE] = rng_equal;
  equals[T_ITERATOR] =     iterator_equal;
  equals[T_INPUT_PORT] =   port_equal;
  equals[T_OUTPUT_PORT] =  port_equal;
  equals[T_MACRO] =        closure_equal;
  equals[T_MACRO_STAR] =   closure_equal;
  equals[T_BACRO] =        closure_equal;
  equals[T_BACRO_STAR] =   closure_equal;
  equals[T_CLOSURE] =      closure_equal;
  equals[T_CLOSURE_STAR] = closure_equal;
  equals[T_HASH_TABLE] =   hash_table_equal;
  equals[T_LET] =          let_equal;
  equals[T_PAIR] =         pair_equal;
  equals[T_VECTOR] =       vector_equal;
  equals[T_INT_VECTOR] =   vector_equal;
  equals[T_BYTE_VECTOR] =  vector_equal;
  equals[T_FLOAT_VECTOR] = vector_equal;
  equals[T_INTEGER] =      integer_equal;
  equals[T_RATIO] =        fraction_equal;
  equals[T_REAL] =         real_equal;
  equals[T_COMPLEX] =      complex_equal;
#if WITH_GMP
  equals[T_BIG_INTEGER] =  bignum_equal;
  equals[T_BIG_RATIO] =    bignum_equal;
  equals[T_BIG_REAL] =     bignum_equal;
  equals[T_BIG_COMPLEX] =  bignum_equal;
#endif
  equivalents[T_SYMBOL] =       symbol_equivalent;
  equivalents[T_C_POINTER] =    c_pointer_equivalent;
  equivalents[T_UNSPECIFIED] =  unspecified_equal;
  equivalents[T_UNDEFINED] =    undefined_equal;
  equivalents[T_STRING] =       string_equal;
  equivalents[T_SYNTAX] =       syntax_equal;
  equivalents[T_C_OBJECT] =     c_object_equivalent;
  equivalents[T_RANDOM_STATE] = rng_equal;
  equivalents[T_ITERATOR] =     iterator_equivalent;
  equivalents[T_INPUT_PORT] =   port_equivalent;
  equivalents[T_OUTPUT_PORT] =  port_equivalent;
  equivalents[T_MACRO] =        closure_equivalent;
  equivalents[T_MACRO_STAR] =   closure_equivalent;
  equivalents[T_BACRO] =        closure_equivalent;
  equivalents[T_BACRO_STAR] =   closure_equivalent;
  equivalents[T_CLOSURE] =      closure_equivalent;
  equivalents[T_CLOSURE_STAR] = closure_equivalent;
  equivalents[T_HASH_TABLE] =   hash_table_equivalent;
  equivalents[T_LET] =          let_equivalent;
  equivalents[T_PAIR] =         pair_equivalent;
  equivalents[T_VECTOR] =       vector_equivalent;
  equivalents[T_INT_VECTOR] =   vector_equivalent;
  equivalents[T_FLOAT_VECTOR] = vector_equivalent;
  equivalents[T_BYTE_VECTOR] =  vector_equivalent;
  equivalents[T_INTEGER] =      integer_equivalent;
  equivalents[T_RATIO] =        fraction_equivalent;
  equivalents[T_REAL] =         real_equivalent;
  equivalents[T_COMPLEX] =      complex_equivalent;
#if WITH_GMP
  equivalents[T_BIG_INTEGER] =  bignum_equivalent;
  equivalents[T_BIG_RATIO] =    bignum_equivalent;
  equivalents[T_BIG_REAL] =     bignum_equivalent;
  equivalents[T_BIG_COMPLEX] =  bignum_equivalent;
#endif
}

static bool s7_is_equal_1(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return((*(equals[type(x)]))(sc, x, y, ci));
}

bool s7_is_equal(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  return(s7_is_equal_1(sc, x, y, NULL));
}

static bool s7_is_equivalent_1(s7_scheme *sc, s7_pointer x, s7_pointer y, shared_info *ci)
{
  return((*(equivalents[type(x)]))(sc, x, y, ci));
}

bool s7_is_equivalent(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  return(s7_is_equivalent_1(sc, x, y, NULL));
}

static s7_pointer g_is_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_is_equal "(equal? obj1 obj2) returns #t if obj1 is equal to obj2"
  #define Q_is_equal sc->pcl_bt
  return(make_boolean(sc, s7_is_equal(sc, car(args), cadr(args))));
}

static s7_pointer g_is_equivalent(s7_scheme *sc, s7_pointer args)
{
  #define H_is_equivalent "(equivalent? obj1 obj2) returns #t if obj1 is close enough to obj2."
  #define Q_is_equivalent sc->pcl_bt
  return(make_boolean(sc, s7_is_equivalent(sc, car(args), cadr(args))));
}

static bool is_equal_b_7pp(s7_scheme *sc, s7_pointer a, s7_pointer b) {return(s7_is_equal(sc, a, b));}
static bool is_equivalent_b_7pp(s7_scheme *sc, s7_pointer a, s7_pointer b) {return(s7_is_equivalent(sc, a, b));}

static s7_pointer is_equal_p_pp(s7_scheme *sc, s7_pointer a, s7_pointer b) {return((s7_is_equal(sc, a, b)) ? sc->T : sc->F);}
static s7_pointer is_equivalent_p_pp(s7_scheme *sc, s7_pointer a, s7_pointer b) {return((s7_is_equivalent(sc, a, b)) ? sc->T : sc->F);}


/* ---------------------------------------- length, copy, fill ---------------------------------------- */

static s7_pointer (*length_functions[256])(s7_scheme *sc, s7_pointer obj);
static s7_pointer any_length(s7_scheme *sc, s7_pointer obj) {return(sc->F);}

static s7_pointer pair_length(s7_scheme *sc, s7_pointer a)
{
  s7_int i;
  s7_pointer slow, fast;
  slow = a;
  fast = a; /* we know a is a pair, don't start with fast = cdr(a)! if a len = 3, we never match */
  i = 0;
  while (true)
    {
      LOOP_4(fast = cdr(fast); i++; if (!is_pair(fast)) return(make_integer(sc, (is_null(fast)) ? i : -i)));
      slow = cdr(slow);
      if (fast == slow)	return(real_infinity);
    }
  return(real_infinity);
}

static s7_pointer nil_length(s7_scheme *sc, s7_pointer lst)  {return(small_int(0));}
static s7_pointer v_length(s7_scheme *sc, s7_pointer v)      {return(make_integer(sc, vector_length(v)));}
static s7_pointer str_length(s7_scheme *sc, s7_pointer v)    {return(make_integer(sc, string_length(v)));}
static s7_pointer bv_length(s7_scheme *sc, s7_pointer v)     {return(make_integer(sc, byte_vector_length(v)));}
static s7_pointer h_length(s7_scheme *sc, s7_pointer lst)    {return(make_integer(sc, hash_table_mask(lst) + 1));}
static s7_pointer iter_length(s7_scheme *sc, s7_pointer lst) {return(s7_length(sc, iterator_sequence(lst)));}

static s7_pointer c_obj_length(s7_scheme *sc, s7_pointer lst)
{
  check_method_uncopied(sc, lst, sc->length_symbol, list_1(sc, lst));
  return(c_object_length(sc, lst));
}

static s7_pointer lt_length(s7_scheme *sc, s7_pointer lst)
{
  check_method_uncopied(sc, lst, sc->length_symbol, list_1(sc, lst));
  return(make_integer(sc, let_length(sc, lst)));
}

static s7_pointer fnc_length(s7_scheme *sc, s7_pointer lst)
{
  if (has_active_methods(sc, lst))
    return(make_integer(sc, closure_length(sc, lst)));
  return(sc->F);
}

static s7_pointer ip_length(s7_scheme *sc, s7_pointer port)
{
  if (port_is_closed(port))
    return(sc->F);             /* or 0? */
  if (is_string_port(port))
    return(make_integer(sc, port_data_size(port))); /* length of string we're reading */
#if (!MS_WINDOWS)
  if (is_file_port(port))
    {
      long cur_pos, len;
      cur_pos = ftell(port_file(port));
      fseek(port_file(port), 0, SEEK_END);
      len = ftell(port_file(port));
      rewind(port_file(port));
      fseek(port_file(port), cur_pos, SEEK_SET);
      return(make_integer(sc, len));
    }
#endif
  return(sc->F);
}

static s7_pointer op_length(s7_scheme *sc, s7_pointer port)
{
  if (port_is_closed(port))
    return(sc->F);             /* or 0? */
  if (is_string_port(port))
    return(make_integer(sc, port_position(port))); /* length of string we've written */
  return(sc->F);
}

static void init_length_functions(void)
{
  int32_t i;
  for (i = 0; i < 256; i++) length_functions[i] = any_length;
  length_functions[T_NIL]          = nil_length;
  length_functions[T_PAIR]         = pair_length;
  length_functions[T_VECTOR]       = v_length;
  length_functions[T_FLOAT_VECTOR] = v_length;
  length_functions[T_INT_VECTOR]   = v_length;
  length_functions[T_STRING]       = str_length;
  length_functions[T_BYTE_VECTOR]  = bv_length;
  length_functions[T_ITERATOR]     = iter_length;
  length_functions[T_HASH_TABLE]   = h_length;
  length_functions[T_C_OBJECT]     = c_obj_length;
  length_functions[T_LET]          = lt_length;
  length_functions[T_CLOSURE]      = fnc_length;
  length_functions[T_CLOSURE_STAR] = fnc_length;
  length_functions[T_INPUT_PORT]   = ip_length;
  length_functions[T_OUTPUT_PORT]  = op_length;
}

static s7_pointer s7_length(s7_scheme *sc, s7_pointer lst)
{
  return((*length_functions[unchecked_type(lst)])(sc, lst));
}

static s7_pointer g_length(s7_scheme *sc, s7_pointer args)
{
  #define H_length "(length obj) returns the length of obj, which can be a list, vector, string, input-port, or hash-table. \
The length of a dotted list does not include the final cdr, and is returned as a negative number.  A circular \
list has infinite length.  Length of anything else returns #f."
  #define Q_length s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_real_symbol, sc->not_symbol), sc->T)
  return((*length_functions[unchecked_type(car(args))])(sc, car(args)));
}

static s7_pointer length_p_p(s7_scheme *sc, s7_pointer obj) {return((*length_functions[unchecked_type(obj)])(sc, obj));}


/* -------------------------------- copy -------------------------------- */

static s7_pointer string_setter(s7_scheme *sc, s7_pointer str, s7_int loc, s7_pointer val)
{
  if (s7_is_character(val))
    {
      string_value(str)[loc] = s7_character(val);
      return(val);
    }
  set_car(sc->elist_3, wrap_string(sc, "~S: ~S is not a character", 25));
  set_caddr(sc->elist_3, val);
  return(s7_error(sc, sc->wrong_type_arg_symbol, sc->elist_3));
}

static s7_pointer string_getter(s7_scheme *sc, s7_pointer str, s7_int loc)
{
  return(s7_make_character(sc, (uint8_t)(string_value(str)[loc]))); /* cast needed else (copy (string (integer->char 255))...) is trouble */
}

static s7_pointer c_object_setter(s7_scheme *sc, s7_pointer obj, s7_int loc, s7_pointer val)
{
  set_car(sc->t3_1, obj);
  set_car(sc->t3_2, make_integer(sc, loc));
  set_car(sc->t3_3, val);
  return((*(c_object_set(sc, obj)))(sc, sc->t3_1));
}

static s7_pointer c_object_getter(s7_scheme *sc, s7_pointer obj, s7_int loc)
{
  return((*(c_object_ref(sc, obj)))(sc, set_plist_2(sc, obj, make_integer(sc, loc))));
}

static s7_pointer let_setter(s7_scheme *sc, s7_pointer e, s7_int loc, s7_pointer val)
{
  /* loc is irrelevant here
   * val has to be of the form (cons symbol value)
   * if symbol is already in e, its value is changed, otherwise a new slot is added to e
   */
  if (is_pair(val))
    {
      s7_pointer sym;
      sym = car(val);
      if (is_symbol(sym))
	{
	  s7_pointer slot;
	  slot = slot_in_let(sc, e, sym);
	  if (is_slot(slot))
	    checked_slot_set_value(sc, slot, cdr(val));
	  else make_slot_1(sc, e, sym, cdr(val));
	  return(cdr(val));
	}
    }
  set_car(sc->elist_3, wrap_string(sc, "~S: ~S is not (cons symbol value)", 33));
  set_caddr(sc->elist_3, val);
  return(s7_error(sc, sc->wrong_type_arg_symbol, sc->elist_3));
}

static s7_pointer hash_table_setter(s7_scheme *sc, s7_pointer e, s7_int loc, s7_pointer val)
{
  /* loc is irrelevant here, e is the hash-table, val has to be of the form (cons key value)
   * if key is already in e, its value is changed, otherwise a new slot is added to e
   */
  if (is_pair(val))
    return(s7_hash_table_set(sc, e, car(val), cdr(val)));

  set_car(sc->elist_3, wrap_string(sc, "~S: ~S is not (cons key value)", 30));
  set_caddr(sc->elist_3, val);
  return(s7_error(sc, sc->wrong_type_arg_symbol, sc->elist_3));
}


static s7_pointer copy_source_no_dest(s7_scheme *sc, s7_pointer caller, s7_pointer source, s7_pointer args)
{
  s7_pointer dest;
  switch (type(source))
    {
    case T_STRING:
      return(make_string_with_length(sc, string_value(source), string_length(source)));
      
    case T_C_OBJECT:
      return(copy_c_object(sc, args));
      
    case T_RANDOM_STATE:
      return(rng_copy(sc, args));
      
    case T_HASH_TABLE:              /* this has to copy nearly everything */
      {
	s7_int gc_loc;
	s7_pointer new_hash;
	new_hash = s7_make_hash_table(sc, hash_table_mask(source) + 1);
	gc_loc = s7_gc_protect_1(sc, new_hash);
	hash_table_checker(new_hash) = hash_table_checker(source);
	if (hash_chosen(source)) hash_set_chosen(new_hash);
	hash_table_mapper(new_hash) = hash_table_mapper(source);
	hash_table_set_procedures(new_hash, hash_table_procedures(source));
	hash_table_copy(sc, source, new_hash, 0, hash_table_entries(source));
	if (is_typed_hash_table(source))
	  {
	    set_typed_hash_table(new_hash);
	    if (has_simple_keys(source))
	      set_has_simple_keys(new_hash);
	    if (has_simple_values(source))
	      set_has_simple_values(new_hash);
	  }
	s7_gc_unprotect_at(sc, gc_loc);
	return(new_hash);
      }
      
    case T_ITERATOR:
      return(iterator_copy(sc, source));
      
    case T_LET:
      check_method(sc, source, sc->copy_symbol, args);
      return(let_copy(sc, source));   /* this copies only the local env and points to outer envs */
      
    case T_CLOSURE: case T_CLOSURE_STAR:
    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
      check_method(sc, source, sc->copy_symbol, args);
      return(copy_closure(sc, source));
      
    case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_VECTOR: case T_BYTE_VECTOR:
      return(s7_vector_copy(sc, source)); /* "shallow" copy */
      
    case T_PAIR:                    /* top level only, as in the other cases, last arg checks for circles */
      return(protected_list_copy(sc, source));
      
    case T_INTEGER:
      new_cell(sc, dest, T_INTEGER);
      integer(dest) = integer(source);
      return(dest);
      
    case T_RATIO:
      new_cell(sc, dest, T_RATIO);
      numerator(dest) = numerator(source);
      denominator(dest) = denominator(source);
      return(dest);
      
    case T_REAL:
      new_cell(sc, dest, T_REAL);
      set_real(dest, real(source));
      return(dest);
      
    case T_COMPLEX:
      new_cell(sc, dest, T_COMPLEX);
      set_real_part(dest, real_part(source));
      set_imag_part(dest, imag_part(source));
      return(dest);
      
#if WITH_GMP
    case T_BIG_INTEGER: return(mpz_to_big_integer(sc, big_integer(source)));
    case T_BIG_RATIO:   return(mpq_to_big_ratio(sc, big_ratio(source)));
    case T_BIG_REAL:    return(mpfr_to_big_real(sc, big_real(source)));
    case T_BIG_COMPLEX: return(mpc_to_big_complex(sc, big_complex(source)));
#endif
      
    case T_C_POINTER:
      dest = s7_make_c_pointer_with_type(sc, c_pointer(source), c_pointer_type(source), c_pointer_info(source));
      c_pointer_weak1(dest) = c_pointer_weak1(source);
      c_pointer_weak2(dest) = c_pointer_weak2(source);
      return(dest);
    }
  return(source);
}

static s7_pointer s7_copy_1(s7_scheme *sc, s7_pointer caller, s7_pointer args)
{
  #define H_copy "(copy obj) returns a copy of obj, (copy src dest) copies src into dest, (copy src dest start end) copies src from start to end."
  /* #define Q_copy s7_make_circular_signature(sc, 3, 4, sc->T, sc->is_sequence_symbol, sc->is_sequence_symbol, sc->is_integer_symbol) */
  /* this is not right when c-object types are handled in lint -- a generator or Snd object need not consider itself a sequence,
   *   but it can provide a copy method.  So, I think I'll just use #t
   */
  #define Q_copy s7_make_circular_signature(sc, 3, 4, sc->T, sc->T, sc->T, sc->is_integer_symbol)

  s7_pointer source, dest;
  s7_int i, j, dest_len, start, end, source_len;
  s7_pointer (*set)(s7_scheme *sc, s7_pointer obj, s7_int loc, s7_pointer val) = NULL;
  s7_pointer (*get)(s7_scheme *sc, s7_pointer obj, s7_int loc) = NULL;
  bool have_indices;

  source = T_Pos(car(args));
  if (is_null(cdr(args)))                  /* (copy obj) */
    return(copy_source_no_dest(sc, caller, source, args));

  dest = T_Pos(cadr(args));
  if ((is_immutable(dest)) &&
      (dest != sc->key_readable_symbol) &&
      (dest != sc->nil))                                                      /* error_hook copies with cadr(args) :readable, so it's currently NULL */
    return(s7_wrong_type_arg_error(sc, "copy", 2, dest, "a mutable object")); /*    so this segfaults if not checking for :readable */

  have_indices = (is_pair(cddr(args)));
  if ((source == dest) && (!have_indices))
    return(dest);

  switch (type(source))
    {
    case T_PAIR:
      if (dest == sc->key_readable_symbol)  /* a kludge, but I can't think of anything less stupid */
	{
	  if (have_indices)                 /* it seems to me that the start/end args here don't make any sense so... */
	    return(s7_error(sc, sc->wrong_number_of_args_symbol,
			    set_elist_3(sc, wrap_string(sc, "~S: start/end indices make no sense with :readable: ~S", 54), caller, args)));
	  return(copy_body(sc, source));
	}
      end = s7_list_length(sc, source);
      if (end == 0)
	end = circular_list_entries(source);
      else
	{
	  if (end < 0) end = -end;
	}
      break;

    case T_INT_VECTOR:  case T_FLOAT_VECTOR: case T_VECTOR: case T_BYTE_VECTOR:
      get = vector_getter(source);
      end = vector_length(source);
      break;

    case T_STRING:
      get = string_getter;
      end = string_length(source);
      break;

    case T_HASH_TABLE:
      if (source == dest) return(dest);
      end = hash_table_entries(source);
      break;

    case T_C_OBJECT:
      if (c_object_copy(sc, source))
	{
	  s7_pointer x;
	  x = (*(c_object_copy(sc, source)))(sc, args);
	  if (x == dest)
	    return(dest);
	}
      check_method(sc, source, sc->copy_symbol, args);
      get = c_object_getter;
      end = c_object_length_to_int(sc, source);
      break;

    case T_LET:
      if (source == dest) return(dest);
      check_method(sc, source, sc->copy_symbol, args);
      if (source == sc->rootlet)
	return(wrong_type_argument_with_type(sc, caller, 1, source, wrap_string(sc, "a sequence other than the rootlet", 33)));
      if ((!have_indices) && (is_let(dest)))
	{
	  s7_pointer slot;
	  if (dest == sc->rootlet) /* (copy (inlet 'a 1) (rootlet)) */
	    {
	      for (slot = let_slots(source); tis_slot(slot); slot = next_slot(slot))
		s7_make_slot(sc, dest, slot_symbol(slot), slot_value(slot));
	    }
	  else
	    {
	      if ((has_let_fallback(source)) &&
		  (has_let_fallback(dest)))
		{
		  for (slot = let_slots(source); tis_slot(slot); slot = next_slot(slot))
		    if ((slot_symbol(slot) != sc->let_ref_fallback_symbol) &&
			(slot_symbol(slot) != sc->let_set_fallback_symbol))
		      make_slot_1(sc, dest, slot_symbol(slot), slot_value(slot));
		}
	      else
		{
		  for (slot = let_slots(source); tis_slot(slot); slot = next_slot(slot))
		    make_slot_1(sc, dest, slot_symbol(slot), slot_value(slot));
		}
	    }
	  return(dest);
	}
      end = let_length(sc, source);
      break;

    case T_NIL:
      end = 0;
      if (is_sequence(dest))
	break;

    default:
      return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_4(sc, wrap_string(sc, "can't ~S ~S to ~S", 17), caller, source, dest)));
    }

  start = 0;
  if (have_indices)
    {
      s7_pointer p;
      p = start_and_end(sc, caller, args, 3, &start, &end);
      if (p != sc->unused) return(p);
    }
  if ((start == 0) && (source == dest))
    return(dest);
  source_len = end - start;
  if (source_len == 0)
    {
      if (!is_sequence(dest))
	return(wrong_type_argument_with_type(sc, caller, 2, dest, a_sequence_string));
      return(dest);
    }

  switch (type(dest))
    {
    case T_PAIR:
      dest_len = source_len;
      break;

    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
    case T_BYTE_VECTOR:
      set = vector_setter(dest);
      dest_len = vector_length(dest);
      break;

    case T_VECTOR:
      if (is_typed_vector(dest))
	set = typed_vector_setter;
      else set = vector_setter(dest);
      dest_len = vector_length(dest);
      break;

    case T_STRING:
      set = string_setter;
      dest_len = string_length(dest);
      set_cadr(sc->elist_3, caller);   /* for possible error handling in string_setter */
      break;

    case T_HASH_TABLE:
      set = hash_table_setter;
      dest_len = source_len;
      set_cadr(sc->elist_3, caller);   /* for possible error handling in hash_table_setter */
      break;

    case T_C_OBJECT:
      /* if source or dest is c_object, call its copy function before falling back on the get/set functions */
      if (c_object_copy(sc, dest))
	{
	  s7_pointer x;
	  x = (*(c_object_copy(sc, dest)))(sc, args);
	  if (x == dest)
	    return(dest);
	}
      set = c_object_setter;
      dest_len = c_object_length_to_int(sc, dest);
      break;

    case T_LET:
      if (dest == sc->rootlet)
	return(wrong_type_argument_with_type(sc, caller, 2, dest, wrap_string(sc, "a sequence other than the rootlet", 33)));
      set = let_setter;
      dest_len = source_len;          /* grows via set, so dest_len isn't relevant */
      set_cadr(sc->elist_3, caller);  /* for possible error handling in let_setter */
      break;

    case T_NIL:
      return(sc->nil);

    default:
      return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_4(sc, wrap_string(sc, "can't ~S ~S to ~S", 17), caller, source, dest)));
    }

  if (dest_len == 0)
    return(dest);

  /* end is source_len if not set explicitly */
  if (dest_len < source_len)
    {
      end = dest_len + start;
      source_len = dest_len;
    }

  if ((source != dest) &&
      ((type(source) == type(dest)) ||
       ((is_string_or_byte_vector(source)) &&
	(is_string_or_byte_vector(dest)))))
    {
      switch (type(source))
	{
	case T_PAIR:
	  {
	    s7_pointer ps, pd;

	    ps = source;
	    for (i = 0; i < start; i++)
	      ps = cdr(ps);
	    for (pd = dest; (i < end) && is_pair(ps) && is_pair(pd); i++, ps = cdr(ps), pd = cdr(pd))
	      set_car(pd, car(ps));
	    return(dest);
	  }

	case T_VECTOR:
	  if (is_typed_vector(dest))
	    {
	      for (i = start, j = 0; i < end; i++, j++)
		typed_vector_setter(sc, dest, j, get(sc, source, i));
	    }
	  else memcpy((void *)(vector_elements(dest)), (void *)((vector_elements(source)) + start), source_len * sizeof(s7_pointer));
	  return(dest);

	case T_INT_VECTOR:
	  memcpy((void *)(int_vector_ints(dest)), (void *)((int_vector_ints(source)) + start), source_len * sizeof(s7_int));
	  return(dest);

	case T_FLOAT_VECTOR:
	  memcpy((void *)(float_vector_floats(dest)), (void *)((float_vector_floats(source)) + start), source_len * sizeof(s7_double));
	  return(dest);

	case T_BYTE_VECTOR:
	  if (is_string(dest))
	    memcpy((void *)string_value(dest), (void *)((byte_vector_bytes(source)) + start), source_len * sizeof(uint8_t));
	  else memcpy((void *)byte_vector_bytes(dest), (void *)((byte_vector_bytes(source)) + start), source_len * sizeof(uint8_t));
	  return(dest);

	case T_STRING:
	  if (is_string(dest))
	    memcpy((void *)string_value(dest), (void *)((string_value(source)) + start), source_len * sizeof(char));
	  else memcpy((void *)byte_vector_bytes(dest), (void *)((string_value(source)) + start), source_len * sizeof(char));
	  return(dest);

	case T_C_OBJECT:
	  {
	    s7_pointer mi, mj;
	    s7_int gc_loc1, gc_loc2;
	    s7_pointer (*cref)(s7_scheme *sc, s7_pointer args);
	    s7_pointer (*cset)(s7_scheme *sc, s7_pointer args);

	    mi = make_mutable_integer(sc, start);
	    mj = make_mutable_integer(sc, end);
	    gc_loc1 = s7_gc_protect_1(sc, mi);
	    gc_loc2 = s7_gc_protect_1(sc, mj);
	    cref = c_object_ref(sc, source);
	    cset = c_object_set(sc, dest);

	    for (i = start, j = 0; i < end; i++, j++)
	      {
		integer(mi) = i;
		integer(mj) = j;
		set_car(sc->t2_1, source);
		set_car(sc->t2_2, mi);
		set_car(sc->t3_3, cref(sc, sc->t2_1));
		set_car(sc->t3_1, dest);
		set_car(sc->t3_2, mj);
		cset(sc, sc->t3_1);
	      }
	    s7_gc_unprotect_at(sc, gc_loc1);
	    s7_gc_unprotect_at(sc, gc_loc2);
	    free_cell(sc, mi);
	    free_cell(sc, mj);
	    return(dest);
	  }

	case T_LET:
	  break;

	case T_HASH_TABLE:
	  {
	    s7_pointer p;
	    p = hash_table_copy(sc, source, dest, start, end);
	    if ((hash_table_checker(source) != hash_table_checker(dest)) &&
		(!hash_table_checker_locked(dest)))
	      {
		if (hash_table_checker(dest) == hash_empty)
		  hash_table_checker(dest) = hash_table_checker(source);
		else
		  {
		    hash_table_checker(dest) = hash_equal;
		    hash_set_chosen(dest);
		  }
	      }
	    return(p);
	  }

	default:
	  return(dest);
	}
    }

  switch (type(source))
    {
    case T_PAIR:
      {
	s7_pointer p;
	p = source;
	if (start > 0)
	  for (i = 0; i < start; i++)
	    p = cdr(p);
	/* dest won't be a pair here if source != dest -- the pair->pair case was caught above */
	if (source == dest) /* here start != 0 (see above) */
	  {
	    s7_pointer dp;
	    for (dp = source, i = start; i < end; i++, p = cdr(p), dp = cdr(dp))
	      set_car(dp, car(p));
	  }
	else
	  {
	    for (i = start, j = 0; i < end; i++, j++, p = cdr(p))
	      set(sc, dest, j, car(p));
	  }
	return(dest);
      }

    case T_LET:
      /* implicit index can give n-way reality check (ht growth by new entries)
       * if shadowed entries are they unshadowed by reversal?
       */
      {
	/* source and dest can't be rootlet (checked above) */
	s7_pointer slot;
	slot = let_slots(source);
	for (i = 0; i < start; i++) slot = next_slot(slot);
	if (is_pair(dest))
	  {
	    s7_pointer p;
	    for (i = start, p = dest; (i < end) && (is_pair(p)); i++, p = cdr(p), slot = next_slot(slot))
	      set_car(p, cons(sc, slot_symbol(slot), slot_value(slot)));
	  }
	else
	  {
	    if (is_let(dest))
	      {
		if ((has_let_fallback(source)) &&
		    (has_let_fallback(dest)))
		  {
		    for (slot = let_slots(source); tis_slot(slot); slot = next_slot(slot))
		      if ((slot_symbol(slot) != sc->let_ref_fallback_symbol) &&
			  (slot_symbol(slot) != sc->let_set_fallback_symbol))
			make_slot_1(sc, dest, slot_symbol(slot), slot_value(slot));
		  }
		else
		  {
		    for (i = start; i < end; i++, slot = next_slot(slot))
		      make_slot_1(sc, dest, slot_symbol(slot), slot_value(slot));
		  }
	      }
	    else
	      {
		if (is_hash_table(dest))
		  {
		    for (i = start; i < end; i++, slot = next_slot(slot))
		      s7_hash_table_set(sc, dest, slot_symbol(slot), slot_value(slot));
		  }
		else
		  {
		    for (i = start, j = 0; i < end; i++, j++, slot = next_slot(slot))
		      set(sc, dest, j, cons(sc, slot_symbol(slot), slot_value(slot)));
		  }
	      }
	  }
	return(dest);
      }

    case T_HASH_TABLE:
      {
	s7_int loc, skip;
	hash_entry_t **elements;
	hash_entry_t *x = NULL;
	elements = hash_table_elements(source);
	loc = -1;

	skip = start;
	while (skip > 0)
	  {
	    while (!x) x = elements[++loc];
	    skip--;
	    x = hash_entry_next(x);
	  }

      if (is_pair(dest))
	{
	  s7_pointer p;
	  for (i = start, p = dest; (i < end) && (is_pair(p)); i++, p = cdr(p))
	    {
	      while (!x) x = elements[++loc];
	      set_car(p, cons(sc, hash_entry_key(x), hash_entry_value(x)));
	      x = hash_entry_next(x);
	    }
	}
      else
	{
	  if (is_let(dest))
	    {
	      if (has_let_fallback(dest))
		{
		  for (i = start; i < end; i++)
		    {
		      while (!x) x = elements[++loc];
		      if (!is_symbol(hash_entry_key(x)))
			return(simple_wrong_type_argument(sc, caller, hash_entry_key(x), T_SYMBOL));
		      if ((hash_entry_key(x) != sc->let_ref_fallback_symbol) &&
			  (hash_entry_key(x) != sc->let_set_fallback_symbol))
			make_slot_1(sc, dest, hash_entry_key(x), hash_entry_value(x));
		      x = hash_entry_next(x);
		    }
		}
	      else
		{
		  for (i = start; i < end; i++)
		    {
		      while (!x) x = elements[++loc];
		      if (!is_symbol(hash_entry_key(x)))
			return(simple_wrong_type_argument(sc, caller, hash_entry_key(x), T_SYMBOL));
		      make_slot_1(sc, dest, hash_entry_key(x), hash_entry_value(x));
		      x = hash_entry_next(x);
		    }
		}
	    }
	  else
	    {
	      for (i = start, j = 0; i < end; i++, j++)
		{
		  while (!x) x = elements[++loc];
		  set(sc, dest, j, cons(sc, hash_entry_key(x), hash_entry_value(x)));
		  x = hash_entry_next(x);
		}
	    }
	}
      return(dest);
      }

    case T_VECTOR:
      {
	s7_pointer *vals;
	vals = vector_elements(source);
	if (is_float_vector(dest))
	  {
	    s7_double *dst;
	    dst = float_vector_floats(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      dst[j] = real_to_double(sc, vals[i], "copy");
	    return(dest);
	  }
	if (is_int_vector(dest))
	  {
	    s7_int *dst;
	    dst = int_vector_ints(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      {
		if (!s7_is_integer(vals[i]))
		  return(simple_wrong_type_argument(sc, sc->copy_symbol, vals[i], T_INTEGER));
		dst[j] = s7_integer(vals[i]);
	      }
	    return(dest);
	  }
	if (is_string(dest))
	  {
	    char *dst;
	    dst = (char *)string_value(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      {
		if (!s7_is_character(vals[i]))
		  return(simple_wrong_type_argument(sc, sc->copy_symbol, vals[i], T_CHARACTER));
		dst[j] = character(vals[i]);
	      }
	    return(dest);
	  }
	if (is_byte_vector(dest))
	  {
	    uint8_t *dst;
	    dst = (uint8_t *)byte_vector_bytes(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      {
		s7_int byte;
		if (!s7_is_integer(vals[i]))
		  return(simple_wrong_type_argument_with_type(sc, sc->copy_symbol, vals[i], an_unsigned_byte_string));
		byte = s7_integer(vals[i]);
		if ((byte >= 0) && (byte < 256))
		  dst[j] = (uint8_t)byte;
		else return(simple_wrong_type_argument_with_type(sc, sc->copy_symbol, vals[i], an_unsigned_byte_string));
	      }
	    return(dest);
	  }
      }
      break;

    case T_FLOAT_VECTOR:
      {
	s7_double *src;
	src = float_vector_floats(source);
	if (is_int_vector(dest))
	  {
	    s7_int *dst;
	    dst = int_vector_ints(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      dst[j] = (s7_int)(src[i]);
	    return(dest);
	  }
	if ((is_normal_vector(dest)) && (!is_typed_vector(dest)))
	  {
	    s7_pointer *dst;
	    dst = vector_elements(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      dst[j] = make_real(sc, src[i]);
	    return(dest);
	  }
      }
      break;

    case T_INT_VECTOR:
      {
	s7_int *src;
	src = int_vector_ints(source);
	if (is_float_vector(dest))
	  {
	    s7_double *dst;
	    dst = float_vector_floats(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      dst[j] = (s7_double)(src[i]);
	    return(dest);
	  }
	if ((is_normal_vector(dest)) && (!is_typed_vector(dest)))
	  /* this could check that the typer is integer? (similarly elsewhere):
	   *   (typed_vector_typer(dest) != slot_value(global_slot(sc->is_integer_symbol))) ?
	   */
	  {
	    s7_pointer *dst;
	    dst = vector_elements(dest);
	    for (i = start, j = 0; i < end; i++, j++)
	      dst[j] = s7_make_integer(sc, src[i]);
	    return(dest);
	  }
	if (is_string(dest))
	  {
	    for (i = start, j = 0; i < end; i++, j++)
	      {
		if ((src[i] < 0) || (src[i] > 255))
		  return(out_of_range(sc, caller, small_int(1), wrap_integer1(sc, src[i]), an_unsigned_byte_string));
		string_value(dest)[j] = (uint8_t)(src[i]);
	      }
	    return(dest);
	  }
	if (is_byte_vector(dest))
	  {
	    for (i = start, j = 0; i < end; i++, j++)
	      {
		if ((src[i] < 0) || (src[i] > 255))
		  return(out_of_range(sc, caller, small_int(1), wrap_integer1(sc, src[i]), an_unsigned_byte_string));
		byte_vector(dest, j) = (uint8_t)(src[i]);
	      }
	    return(dest);
	  }
      }
      break;

    case T_BYTE_VECTOR:
      if ((is_normal_vector(dest)) && (!is_typed_vector(dest)))
	{
	  s7_pointer *dst;
	  dst = vector_elements(dest);
	  for (i = start, j = 0; i < end; i++, j++)
	    dst[j] = make_integer(sc, (s7_int)(byte_vector(source, i)));
	  return(dest);
	}
      if (is_int_vector(dest))
	{
	  s7_int *els;
	  els = int_vector_ints(dest);
	  for (i = start, j = 0; i < end; i++, j++)
	    els[j] = (s7_int)((uint8_t)(byte_vector(source, i)));
	  return(dest);
	}
      if (is_float_vector(dest))
	{
	  s7_double *els;
	  els = float_vector_floats(dest);
	  for (i = start, j = 0; i < end; i++, j++)
	    els[j] = (s7_double)((uint8_t)(byte_vector(source, i)));
	  return(dest);
	}
      break;

    case T_STRING:
      if ((is_normal_vector(dest))  && (!is_typed_vector(dest)))
	{
	  s7_pointer *dst;
	  dst = vector_elements(dest);
	  for (i = start, j = 0; i < end; i++, j++)
	    dst[j] = s7_make_character(sc, (uint8_t)string_value(source)[i]);
	  return(dest);
	}
      if (is_int_vector(dest))
	{
	  s7_int *els;
	  els = int_vector_ints(dest);
	  for (i = start, j = 0; i < end; i++, j++)
	    els[j] = (s7_int)((uint8_t)(string_value(source)[i]));
	  return(dest);
	}
      if (is_float_vector(dest))
	{
	  s7_double *els;
	  els = float_vector_floats(dest);
	  for (i = start, j = 0; i < end; i++, j++)
	    els[j] = (s7_double)((uint8_t)(string_value(source)[i]));
	  return(dest);
	}
      break;
    }

  if (is_pair(dest))
    {
      s7_pointer p;
      if (is_float_vector(source))
	{
	  s7_double *els;
	  els = float_vector_floats(source);
	  for (i = start, p = dest; (i < end) && (is_pair(p)); i++, p = cdr(p))
	    set_car(p, make_real(sc, els[i]));
	}
      else
	{
	  if (is_int_vector(source))
	    {
	      s7_int *els;
	      els = int_vector_ints(source);
	      for (i = start, p = dest; (i < end) && (is_pair(p)); i++, p = cdr(p))
		set_car(p, make_integer(sc, els[i]));
	    }
	  else
	    {
	      for (i = start, p = dest; (i < end) && (is_pair(p)); i++, p = cdr(p))
		set_car(p, get(sc, source, i));
	    }
	}
    }
  else
    {
      /* if source == dest here, we're moving data backwards, so this is safe in either case */
      for (i = start, j = 0; i < end; i++, j++)
	set(sc, dest, j, get(sc, source, i));
    }
  /* some choices probably should raise an error, but don't:
   *   (copy (make-hash-table) "1") ; nothing to copy (empty hash table), so no error
   */
  return(dest);
}

s7_pointer s7_copy(s7_scheme *sc, s7_pointer args)
{
  return(s7_copy_1(sc, sc->copy_symbol, args));
}

#define g_copy s7_copy


/* -------------------------------- reverse -------------------------------- */

static s7_pointer g_reverse(s7_scheme *sc, s7_pointer args)
{
  #define H_reverse "(reverse lst) returns a list with the elements of lst in reverse order.  reverse \
also accepts a string or vector argument."
  #define Q_reverse s7_make_signature(sc, 2, sc->is_sequence_symbol, sc->is_sequence_symbol)

  s7_pointer p, np;

  p = car(args);
  sc->temp3 = p;
  np = sc->nil;

  switch (type(p))
    {
    case T_NIL:
      return(sc->nil);

    case T_PAIR:
      return(s7_reverse(sc, p));

    case T_STRING:
      {
	char *source, *dest, *end;
	s7_int len;
	len = string_length(p);
	source = string_value(p);
	end = (char *)(source + len);
	np = make_empty_string(sc, len, '\0');
	dest = (char *)(string_value(np) + len);
	while (source < end) *(--dest) = *source++;
      }
      break;

    case T_BYTE_VECTOR:
      {
	uint8_t *source, *dest, *end;
	s7_int len;
	len = byte_vector_length(p);
	source = byte_vector_bytes(p);
	end = (uint8_t *)(source + len);
	np = make_simple_byte_vector(sc, len);
	dest = (uint8_t *)(byte_vector_bytes(np) + len);
	while (source < end) *(--dest) = *source++;
      }
      break;

    case T_INT_VECTOR:
      {
	s7_int *source, *dest, *end;
	s7_int len;
	len = vector_length(p);
	if (vector_rank(p) > 1)
	  np = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, p)), small_int(0)), sc->make_int_vector_symbol);
	else np = make_simple_int_vector(sc, len);
	source = int_vector_ints(p);
	end = (s7_int *)(source + len);
	dest = (s7_int *)(int_vector_ints(np) + len);
	while (source < end) *(--dest) = *source++;
      }
      break;

    case T_FLOAT_VECTOR:
      {
	s7_double *source, *dest, *end;
	s7_int len;
	len = vector_length(p);
	if (vector_rank(p) > 1)
	  np = g_make_vector_1(sc, set_plist_2(sc, g_vector_dimensions(sc, set_plist_1(sc, p)), real_zero), sc->make_float_vector_symbol);
	else np = make_simple_float_vector(sc, len);
	source = float_vector_floats(p);
	end = (s7_double *)(source + len);
	dest = (s7_double *)(float_vector_floats(np) + len);
	while (source < end) *(--dest) = *source++;
      }
      break;

    case T_VECTOR:
      {
	s7_pointer *source, *dest, *end;
	s7_int len;
	len = vector_length(p);
	if (vector_rank(p) > 1)
	  np = g_make_vector(sc, set_plist_1(sc, g_vector_dimensions(sc, set_plist_1(sc, p))));
	else np = make_simple_vector(sc, len);
	source = vector_elements(p);
	end = (s7_pointer *)(source + len);
	dest = (s7_pointer *)(vector_elements(np) + len);
	while (source < end) *(--dest) = *source++;
      }
      break;

    case T_HASH_TABLE:
      return(hash_table_reverse(sc, p));

    case T_C_OBJECT:
      check_method(sc, p, sc->reverse_symbol, args);
      if (c_object_reverse(sc, p))
	return((*(c_object_reverse(sc, p)))(sc, args));
      eval_error(sc, "attempt to reverse ~S?", 22, p);

    case T_LET:
      check_method(sc, p, sc->reverse_symbol, args);
      return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "can't reverse let: ~S", 21), p)));

    default:
      return(method_or_bust_with_type_one_arg(sc, p, sc->reverse_symbol, args, a_sequence_string));
    }
  return(np);
}

static s7_pointer g_reverse_in_place(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  #define H_reverse_in_place "(reverse! lst) reverses lst in place"
  #define Q_reverse_in_place Q_reverse

  p = car(args);
  switch (type(p))
    {
    case T_NIL:
      return(sc->nil);

    case T_PAIR:
      {
	s7_pointer np;
	if (is_immutable_pair(p))
	  return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->reverseb_symbol, p)));
	np = reverse_in_place(sc, sc->nil, p);
	if (is_null(np))
	  return(s7_wrong_type_arg_error(sc, "reverse!", 1, car(args), "a mutable, proper list"));
	return(np);
      }
      /* (reverse! p) is supposed to change p directly and lisp programmers expect reverse! to be fast
       * so in a sense this is different from the other cases: it assumes (set! p (reverse! p))
       * To make (reverse! p) direct:
       *    for (l = p, r = cdr(p); is_pair(r); l = r, r = cdr(r)) opt1(r) = l;
       *    if (!is_null(r)) return(simple_wrong_type_argument_with_type(sc, sc->reverseb_symbol, p, a_proper_list_string));
       *    for (r = l, l = p; l != r; l = cdr(l)) {t = car(l); set_car(l, car(r)); set_car(r, t); if (cdr(l) != r) r = opt1(r);}
       * immutable check is needed else (reverse! (catch #t 1 cons)) clobbers sc->wrong_type_arg_info
       */

    case T_BYTE_VECTOR:
    case T_STRING:
      {
	s7_int len;
	uint8_t *bytes;
	if (is_immutable(p))
	  return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->reverseb_symbol, p)));

	if (is_string(p))
	  {
	    len = string_length(p);
	    bytes = (uint8_t *)string_value(p);
	  }
	else
	  {
	    len = byte_vector_length(p);
	    bytes = byte_vector_bytes(p);
	  }
	if (len < 2) return(p);

#if __linux__ /* need byteswp.h */
	/* this code (from StackOverflow) is much faster: */
	if ((len & 0x1f) == 0)
	  {
	    #include <byteswap.h>
	    uint32_t *dst = (uint32_t *)(bytes + len - 4);
	    uint32_t *src = (uint32_t *)bytes;
	    while (src < dst)
	      {
		uint32_t a, b;
		LOOP_4(a = *src; b = *dst; *src++ = bswap_32(b); *dst-- = bswap_32(a));
	      }
	  }
	else
#endif
	  {
	    char *s1, *s2;
	    s1 = (char *)bytes;
	    s2 = (char *)(s1 + len - 1);
	    while (s1 < s2) {char c; c = *s1; *s1++ = *s2; *s2-- = c;}
	  }
      }
      break;

    case T_INT_VECTOR:
      {
	s7_int len;
	s7_int *s1, *s2;
	if (is_immutable_vector(p))
	  return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->reverseb_symbol, p)));
	len = vector_length(p);
	if (len < 2) return(p);
	s1 = int_vector_ints(p);
	s2 = (s7_int *)(s1 + len - 1);
	if ((len & 0xf) == 0) /* not 0x7 -- odd multiple of 8 will leave center ints unreversed */
	  {
	    while (s1 < s2)
	      {
		s7_int c;
		LOOP_8(c = *s1; *s1++ = *s2; *s2-- = c);
	      }
	  }
	else while (s1 < s2) {s7_int c; c = *s1; *s1++ = *s2; *s2-- = c;}
      }
      break;

    case T_FLOAT_VECTOR:
      {
	s7_int len;
	s7_double *s1, *s2;
	if (is_immutable_vector(p))
	  return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->reverseb_symbol, p)));
	len = vector_length(p);
	if (len < 2) return(p);
	s1 = float_vector_floats(p);
	s2 = (s7_double *)(s1 + len - 1);
	if ((len & 0xf) == 0)
	  {
	    while (s1 < s2)
	      {
		s7_double c;
		LOOP_8(c = *s1; *s1++ = *s2; *s2-- = c);
	      }
	  }
	else while (s1 < s2) {s7_double c; c = *s1; *s1++ = *s2; *s2-- = c;}
      }
      break;

    case T_VECTOR:
      {
	s7_int len;
	s7_pointer *s1, *s2;
	if (is_immutable_vector(p))
	  return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->reverseb_symbol, p)));
	len = vector_length(p);
	if (len < 2) return(p);
	s1 = vector_elements(p);
	s2 = (s7_pointer *)(s1 + len - 1);
	if ((len & 0xf) == 0)
	  {
	    while (s1 < s2)
	      {
		s7_pointer c;
		LOOP_8(c = *s1; *s1++ = *s2; *s2-- = c);
	      }
	  }
	else while (s1 < s2) {s7_pointer c; c = *s1; *s1++ = *s2; *s2-- = c;}
      }
      break;

    default:
      if (is_immutable(p))
	{
	  if (is_simple_sequence(p))
	    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->reverseb_symbol, p)));
	  return(simple_wrong_type_argument_with_type(sc, sc->reverseb_symbol, p, a_sequence_string));
	}
      if ((is_simple_sequence(p)) &&
	  (!has_active_methods(sc, p)))
	return(simple_wrong_type_argument_with_type(sc, sc->reverseb_symbol, p, wrap_string(sc, "a vector, string, or list", 25)));
      return(method_or_bust_with_type_one_arg(sc, p, sc->reverseb_symbol, list_1(sc, p), a_sequence_string));
    }
  return(p);
}


/* -------------------------------- fill! -------------------------------- */

static s7_pointer pair_fill(s7_scheme *sc, s7_pointer args)
{
  /* ambiguous ("tree-fill"?) but if it's like vector-fill, we just stomp on the top level */
  s7_pointer x, y, obj, val, p;
  s7_int i, start = 0, end, len;

  obj = car(args);
  if (is_immutable_pair(obj))
    return(immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->fill_symbol, obj)));
  if (obj == slot_value(global_slot(sc->features_symbol)))
    return(s7_error(sc, sc->error_symbol, set_elist_1(sc, wrap_string(sc, "can't fill! *features*", 22))));
  if (obj == slot_value(global_slot(sc->libraries_symbol)))
    return(s7_error(sc, sc->error_symbol, set_elist_1(sc, wrap_string(sc, "can't fill! *libraries*", 23))));

  val = cadr(args);
  len = s7_list_length(sc, obj);
  end = len;
  if (end < 0) end = -end; else {if (end == 0) end = 123123123;}
  if (!is_null(cddr(args)))
    {
      p = start_and_end(sc, sc->fill_symbol, args, 3, &start, &end);
      if (p != sc->unused) return(p);
      if (start == end) return(val);
    }
  if (len > 0)
    {
      if (end < len) len = end;
      for (i = 0, p = obj; i < start; p = cdr(p), i++);
      for (; i < len; p = cdr(p), i++) set_car(p, val);
      return(val);
    }

  for (x = obj, y = obj, i = 0; ;i++)
    {
      if ((end > 0) && (i >= end))
	return(val);
      if (i >= start) set_car(x, val);
      if (!is_pair(cdr(x)))
	{
	  if (!is_null(cdr(x)))
	    set_cdr(x, val);
	  return(val);
	}
      x = cdr(x);
      if ((i & 1) != 0) y = cdr(y);
      if (x == y)
	return(val);
    }
  return(val);
}

s7_pointer s7_fill(s7_scheme *sc, s7_pointer args)
{
  #define H_fill "(fill! obj val (start 0) end) fills obj with val"
  #define Q_fill s7_make_circular_signature(sc, 3, 4, sc->T, sc->is_sequence_symbol, sc->T, sc->is_integer_symbol)
  s7_pointer p;

  p = car(args);
  switch (type(p))
    {
    case T_STRING:
      return(g_string_fill_1(sc, sc->fill_symbol, args)); /* redundant type check here and below */

    case T_BYTE_VECTOR: case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_VECTOR:
      return(g_vector_fill_1(sc, sc->fill_symbol, args));

    case T_PAIR:
      return(pair_fill(sc, args));

    case T_NIL:
      if (!is_null(cddr(args)))  /* (fill! () 1 21 #\a)? */
	eval_error(sc, "fill! () ... includes indicies: ~S?", 35, cddr(args));
      return(cadr(args));        /* this parallels the empty vector case */

    case T_HASH_TABLE:
      return(hash_table_fill(sc, args));

    case T_LET:
      check_method(sc, p, sc->fill_symbol, args);
      return(let_fill(sc, args));

    case T_C_OBJECT:
      check_method(sc, p, sc->fill_symbol, args);
      if (c_object_fill(sc, p)) /* default is NULL (s7_make_c_type) */
	return((*(c_object_fill(sc, p)))(sc, args));
      eval_error(sc, "attempt to fill ~S?", 19, p);

    default:
      check_method(sc, p, sc->fill_symbol, args);
    }
  return(wrong_type_argument_with_type(sc, sc->fill_symbol, 1, p, a_sequence_string)); /* (fill! 1 0) */
}

#define g_fill s7_fill
/* perhaps (fill iterator obj) could fill the underlying sequence (if any) -- not let/closure
 *   similarly for length, reverse etc
 */


/* -------------------------------- append -------------------------------- */

static s7_int sequence_length(s7_scheme *sc, s7_pointer lst)
{
  switch (type(lst))
    {
    case T_PAIR:
      {
	s7_int len;
	len = s7_list_length(sc, lst);
	if (len == 0) return(-1);
	return(len);
      }
    case T_NIL:         return(0);
    case T_BYTE_VECTOR:
    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
    case T_VECTOR:      return(vector_length(lst));
    case T_STRING:      return(string_length(lst));
    case T_HASH_TABLE:  return(hash_table_entries(lst));
    case T_LET:         return(let_length(sc, lst));
    case T_C_OBJECT:
      {
	s7_pointer x;
	x = c_object_length(sc, lst);
	if (s7_is_integer(x))
	  return(s7_integer(x));
      }
    }
  return(-1);
}

static s7_int total_sequence_length(s7_scheme *sc, s7_pointer args, s7_pointer caller, uint8_t typ)
{
  s7_pointer p;
  s7_int i, len = 0;

  for (i = 1, p = args; is_pair(p); p = cdr(p), i++)
    {
      s7_pointer seq;
      s7_int n;
      seq = car(p);
      n = sequence_length(sc, seq);
      if ((n > 0) &&
	  (typ != T_FREE) &&
	  ((type(seq) == T_HASH_TABLE) ||  /* can't append hash-tables (no obvious meaning to the operation) */
	   ((type(seq) == T_LET) &&        /*   similarly for lets, unless this is a mock-string or something similar */
	    ((!has_active_methods(sc, seq)) || (find_method(sc, seq, caller) == sc->undefined)))))
	{
	  wrong_type_argument(sc, caller, i, seq, typ);
	  return(0);
	}
      if (n < 0)
	{
	  wrong_type_argument_with_type(sc, caller, i, seq, (is_pair(seq)) ? a_proper_list_string : a_sequence_string);
	  return(0);
	}
      len += n;
    }
  return(len);
}

static s7_pointer vector_append(s7_scheme *sc, s7_pointer args, uint8_t typ, s7_pointer caller)
{
  s7_pointer new_vec;
  s7_pointer *v_elements = NULL;
  s7_double *fv_elements = NULL;
  s7_int *iv_elements = NULL;
  uint8_t *byte_elements = NULL;
  s7_int len;

  push_stack_no_let_no_code(sc, OP_GC_PROTECT, args);
  len = total_sequence_length(sc, args, caller, (typ == T_VECTOR) ? T_FREE : ((typ == T_FLOAT_VECTOR) ? T_REAL : T_INTEGER));
  if (len > sc->max_vector_length)
    return(s7_error(sc, sc->out_of_range_symbol,
		    set_elist_4(sc, wrap_string(sc, "~S new vector length, ~D, is larger than (*s7* 'max-vector-length): ~D", 70),
				caller,
				wrap_integer1(sc, len),
				wrap_integer2(sc, sc->max_vector_length))));

  new_vec = make_vector_1(sc, len, (typ == T_VECTOR) ? FILLED : NOT_FILLED, typ);  /* might hit GC in loop below so we can't use NOT_FILLED here */
  add_vector(sc, new_vec);

  if (typ == T_VECTOR)
    v_elements = vector_elements(new_vec);
  else
    {
      if (typ == T_FLOAT_VECTOR)
	fv_elements = float_vector_floats(new_vec);
      else
	{
	  if (typ == T_INT_VECTOR)
	    iv_elements = int_vector_ints(new_vec);
	  else byte_elements = byte_vector_bytes(new_vec);
	}
    }

  if (len > 0)
    {
      s7_pointer p, pargs;
      s7_int i;

      pargs = list_2(sc, new_vec, new_vec);
      push_stack_no_let(sc, OP_GC_PROTECT, new_vec, pargs);

      for (i = 0, p = args; is_pair(p); p = cdr(p))
	{
	  s7_int n;
	  s7_pointer x;
	  x = car(p);
	  n = sequence_length(sc, x);
	  if (n > 0)
	    {
	      vector_length(new_vec) = n;
	      set_car(pargs, x);
	      s7_copy_1(sc, sc->append_symbol, pargs);  /* not set_plist_2 here! */
	      vector_length(new_vec) = 0;               /* so GC doesn't march off the end */
	      i += n;
	      if (typ == T_VECTOR)
		vector_elements(new_vec) = (s7_pointer *)(v_elements + i);
	      else
		{
		  if (typ == T_FLOAT_VECTOR)
		    float_vector_floats(new_vec) = (s7_double *)(fv_elements + i);
		  else
		    {
		      if (typ == T_INT_VECTOR)
			int_vector_ints(new_vec) = (s7_int *)(iv_elements + i);
		      else byte_vector_bytes(new_vec) = (uint8_t *)(byte_elements + i);
		    }
		}
	    }
	}

      unstack(sc);
      /* free_cell(sc, pargs); */ /* this is trouble if any arg is openlet with append method -- e.g. block */

      if (typ == T_VECTOR)
	vector_elements(new_vec) = v_elements;
      else
	{
	  if (typ == T_FLOAT_VECTOR)
	    float_vector_floats(new_vec) = fv_elements;
	  else
	    {
	      if (typ == T_INT_VECTOR)
		int_vector_ints(new_vec) = iv_elements;
	      else byte_vector_bytes(new_vec) = byte_elements;
	    }
	}
      vector_length(new_vec) = len;
    }
  unstack(sc);
  return(new_vec);
}

static s7_pointer hash_table_append(s7_scheme *sc, s7_pointer args)
{
  s7_pointer new_hash, p;
  new_hash = s7_make_hash_table(sc, sc->default_hash_table_length);
  push_stack_no_let(sc, OP_GC_PROTECT, args, new_hash);
  for (p = args; is_pair(p); p = cdr(p))
    s7_copy_1(sc, sc->append_symbol, set_plist_2(sc, car(p), new_hash));
  set_plist_2(sc, sc->nil, sc->nil);
  unstack(sc);
  return(new_hash);
}

static s7_pointer let_append(s7_scheme *sc, s7_pointer args)
{
  s7_pointer new_let, p, e;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, args);
  e = car(args);
  check_method(sc, e, sc->append_symbol, args);
  new_let = new_frame_in_env(sc, sc->nil);
  for (p = args; is_pair(p); p = cdr(p))
    s7_copy_1(sc, sc->append_symbol, set_plist_2(sc, car(p), new_let));
  set_plist_2(sc, sc->nil, sc->nil);
  unstack(sc);
  return(new_let);
}

static s7_pointer g_append(s7_scheme *sc, s7_pointer args)
{
  #define H_append "(append ...) returns its argument sequences appended into one sequence"
  #define Q_append s7_make_circular_signature(sc, 0, 1, sc->T)
  s7_pointer a1;

  if (is_null(args)) return(sc->nil);  /* (append) -> () */
  a1 = car(args);                      /* first arg determines result type unless all args but last are empty (sigh) */
  if (is_null(cdr(args))) return(a1);  /* (append <anything>) -> <anything> */

  args = copy_list(sc, args);
  switch (type(a1))
    {
    case T_NIL:
    case T_PAIR:
      return(g_list_append(sc, args)); /* only list case accepts any trailing arg because dotted lists are special */

    case T_VECTOR: case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_BYTE_VECTOR:
      return(vector_append(sc, args, type(a1), sc->append_symbol));

    case T_STRING:
      return(g_string_append_1(sc, args, sc->append_symbol));

    case T_HASH_TABLE:
      return(hash_table_append(sc, args));

    case T_LET:
      return(let_append(sc, args));

     default:
      check_method(sc, a1, sc->append_symbol, args);
    }
  return(wrong_type_argument_with_type(sc, sc->append_symbol, 1, a1, a_sequence_string)); /* (append 1 0) */
}

static s7_pointer append_p_pp(s7_scheme *sc, s7_pointer p1, s7_pointer p2)
{
  /* plist in use above */
  s7_pointer val;
  sc->temp7 = list_2(sc, p1, p2);
  val = g_append(sc, sc->temp7);
  sc->temp7 = sc->nil;
  return(val);
}

static s7_pointer append_p_ppp(s7_scheme *sc, s7_pointer p1, s7_pointer p2, s7_pointer p3)
{
  s7_pointer val;
  sc->temp7 = list_3(sc, p1, p2, p3);
  val = g_append(sc, sc->temp7);
  sc->temp7 = sc->nil;
  return(val);
}


/* -------------------------------- object->let -------------------------------- */

static s7_pointer byte_vector_to_list(s7_scheme *sc, const uint8_t *str, s7_int len)
{
  s7_int i;
  s7_pointer p;
  if (len == 0) return(sc->nil);
  sc->w = sc->nil;
  for (i = len - 1; i >= 0; i--)
    sc->w = cons(sc, small_int((uint32_t)(str[i])), sc->w);
  p = sc->w;
  sc->w = sc->nil;
  return(p);
}

static s7_pointer object_to_list(s7_scheme *sc, s7_pointer obj)
{
  /* used only in format_to_port_1 and (map values ...) */
  switch (type(obj))
    {
    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
    case T_VECTOR:
      return(s7_vector_to_list(sc, obj));

    case T_STRING:
      return(s7_string_to_list(sc, string_value(obj), string_length(obj)));

    case T_BYTE_VECTOR:
      return(byte_vector_to_list(sc, byte_vector_bytes(obj), byte_vector_length(obj)));

    case T_HASH_TABLE:
      if (hash_table_entries(obj) > 0)
	{
	  s7_pointer x, iterator;
	  iterator = s7_make_iterator(sc, obj);
	  sc->temp8 = iterator;
	  sc->w = sc->nil;
	  while (true)
	    {
	      x = s7_iterate(sc, iterator);
	      if (iterator_is_at_end(iterator)) break;
	      sc->w = cons(sc, x, sc->w);
	    }
	  x = sc->w;
	  sc->w = sc->nil;
	  sc->temp8 = sc->nil;
	  /* free_cell(sc, iterator); */ /* 16-Nov-18 but then 18-Dec-18 got free cell that was iterator */
	  return(x);
	}
      return(sc->nil);

    case T_LET:
#if (!WITH_PURE_S7)
      check_method_uncopied(sc, obj, sc->let_to_list_symbol, list_1(sc, obj));
#endif
      return(s7_let_to_list(sc, obj));

    case T_ITERATOR:
      {
	s7_pointer result, p = NULL;
	s7_int results = 0;
	result = sc->nil;
	while (true)
	  {
	    s7_pointer val;
	    val = s7_iterate(sc, obj);
	    if ((val == ITERATOR_END) &&
		(iterator_is_at_end(obj)))
	      {
		sc->temp8 = sc->nil;
		return(result);
	      }
	    if (sc->safety > NO_SAFETY)
	      {
		results++;
		if (results > 10000)
		  {
		    s7_warn(sc, 256, "iterator is creating a very long list!\n");
		    results = S7_LONG_MIN;
		  }
	      }
	    if (val != sc->no_value)
	      {
		if (is_null(result))
		  {
		    if (is_multiple_value(val))
		      {
			result = multiple_value(val);
			clear_multiple_value(val);
			for (p = result; is_pair(cdr(p)); p = cdr(p));
		      }
		    else
		      {
			result = cons(sc, val, sc->nil);
			p = result;
		      }
		    sc->temp8 = result;
		  }
		else
		  {
		    if (is_multiple_value(val))
		      {
			set_cdr(p, multiple_value(val));
			clear_multiple_value(val);
			for (; is_pair(cdr(p)); p = cdr(p));
		      }
		    else
		      {
			set_cdr(p, cons(sc, val, sc->nil));
			p = cdr(p);
		      }}}}
      }

    case T_C_OBJECT:
      {
	int64_t i, len;
	s7_pointer x, z, zc, result;
	s7_int gc_z;

	if (c_object_to_list(sc, obj))
	  return((*(c_object_to_list(sc, obj)))(sc, set_plist_1(sc, obj)));

	x = c_object_length(sc, obj);
	if (s7_is_integer(x))
	  len = s7_integer(x);
	else return(sc->F);

	if (len < 0)
	  return(sc->F);
	if (len == 0)
	  return(sc->nil);

	result = make_list(sc, len, sc->nil);
	sc->temp8 = result;
	z = list_2(sc, obj, sc->F);
	zc = cdr(z);
	gc_z = s7_gc_protect_1(sc, z);

	set_car(sc->z2_1, sc->x);
	set_car(sc->z2_2, sc->z);
	for (i = 0, x = result; i < len; i++, x = cdr(x))
	  {
	    set_car(zc, make_integer(sc, i));
	    set_car(x, (*(c_object_ref(sc, obj)))(sc, z));
	  }
	sc->x = car(sc->z2_1);
	sc->z = car(sc->z2_2);
	s7_gc_unprotect_at(sc, gc_z);
	sc->temp8 = sc->nil;
	return(result);
      }
    }
  return(obj);
}

static s7_pointer symbol_to_let(s7_scheme *sc, s7_pointer obj, s7_pointer args)
{
  s7_pointer let;
  let = g_local_inlet(sc, 4, sc->value_symbol, obj,
		      sc->type_symbol, (is_keyword(obj)) ? sc->is_keyword_symbol : ((is_gensym(obj)) ? sc->is_gensym_symbol : sc->is_symbol_symbol));
  if (!is_keyword(obj))
    {
      s7_pointer val;
      if (!sc->current_value_symbol)
	sc->current_value_symbol = make_symbol(sc, "current-value");
      val = s7_symbol_value(sc, obj);
      s7_varlet(sc, let, sc->current_value_symbol, val);
      s7_varlet(sc, let, sc->setter_symbol, g_setter(sc, args));
      s7_varlet(sc, let, sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable_symbol(obj)));
      if (!is_undefined(val))
	{
	  const char *doc;
	  doc = s7_documentation(sc, obj);
	  if (doc)
	    s7_varlet(sc, let, sc->local_documentation_symbol, s7_make_string(sc, doc));
	}
    }
  return(let);
}

static s7_pointer random_state_to_let(s7_scheme *sc, s7_pointer obj)
{
#if WITH_GMP
  return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_random_state_symbol));
#else
  if (!sc->seed_symbol)
    {
      sc->seed_symbol = make_symbol(sc, "seed");
      sc->carry_symbol = make_symbol(sc, "carry");
    }
  return(g_local_inlet(sc, 8, sc->value_symbol, obj,
		       sc->type_symbol, sc->is_random_state_symbol,
		       sc->seed_symbol, s7_make_integer(sc, random_seed(obj)),
		       sc->carry_symbol, s7_make_integer(sc, random_carry(obj))));
#endif
}

static s7_pointer vector_to_let(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer let;
  if (!sc->dimensions_symbol)
    sc->dimensions_symbol = make_symbol(sc, "dimensions");
  if (!sc->position_symbol)
    sc->position_symbol = make_symbol(sc, "position");
  let = g_local_inlet(sc, 10, sc->value_symbol, obj,
		      sc->type_symbol, (is_subvector(obj)) ? cons(sc, sc->is_subvector_symbol, s7_type_of(sc, subvector_vector(obj))) : s7_type_of(sc, obj),
		      sc->length_symbol, s7_length(sc, obj),
		      sc->dimensions_symbol, g_vector_dimensions(sc, set_plist_1(sc, obj)),
		      sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable_vector(obj)));
  if (is_subvector(obj))
    {
      s7_varlet(sc, let, sc->position_symbol, make_integer(sc, (s7_int)(vector_elements(obj) - vector_elements(subvector_vector(obj)))));
      s7_varlet(sc, let, sc->vector_symbol, subvector_vector(obj));
    }
  if (is_typed_vector(obj))
    s7_varlet(sc, let, sc->signature_symbol, g_signature(sc, set_plist_1(sc, obj)));
  return(let);
}

static s7_pointer hash_table_to_let(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer let;
  if (!sc->entries_symbol)
    {
      sc->entries_symbol = make_symbol(sc, "entries");
      sc->locked_symbol = make_symbol(sc, "locked");
      sc->weak_symbol = make_symbol(sc, "weak");
    }
  if (!sc->function_symbol)
    sc->function_symbol = make_symbol(sc, "function");
  let = g_local_inlet(sc, 12, sc->value_symbol, obj,
		      sc->type_symbol, sc->is_hash_table_symbol,
		      sc->length_symbol, s7_length(sc, obj),
		      sc->entries_symbol, s7_make_integer(sc, hash_table_entries(obj)),
		      sc->locked_symbol, s7_make_boolean(sc, hash_table_checker_locked(obj)),
		      sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable(obj)));
  if (is_weak_hash_table(obj))
    s7_varlet(sc, let, sc->weak_symbol, sc->T);
  if ((hash_table_checker(obj) == hash_eq) ||
      (hash_table_checker(obj) == hash_c_function) ||
      (hash_table_checker(obj) == hash_closure) ||
      (hash_table_checker(obj) == hash_equal_eq) ||
      (hash_table_checker(obj) == hash_equal_syntax) ||
      (hash_table_checker(obj) == hash_symbol))
    s7_varlet(sc, let, sc->function_symbol, sc->is_eq_symbol);
  else
    {
      if (hash_table_checker(obj) == hash_eqv)
	s7_varlet(sc, let, sc->function_symbol, sc->is_eqv_symbol);
      else
	{
	  if ((hash_table_checker(obj) == hash_equal) ||
	      (hash_table_checker(obj) == hash_empty))
	    s7_varlet(sc, let, sc->function_symbol, sc->is_equal_symbol);
	  else
	    {
	      if (hash_table_checker(obj) == hash_equivalent)
		s7_varlet(sc, let, sc->function_symbol, sc->is_equivalent_symbol);
	      else
		{
		  if ((hash_table_checker(obj) == hash_number) ||
		      (hash_table_checker(obj) == hash_int) ||
		      (hash_table_checker(obj) == hash_float) ||
		      (hash_table_checker(obj) == hash_equal_real) ||
		      (hash_table_checker(obj) == hash_equal_complex))
		    s7_varlet(sc, let, sc->function_symbol, sc->eq_symbol);
		  else
		    {
		      if (hash_table_checker(obj) == hash_string)
			s7_varlet(sc, let, sc->function_symbol, sc->string_eq_symbol);
		      else
			{
			  if (hash_table_checker(obj) == hash_char)
			    s7_varlet(sc, let, sc->function_symbol, sc->char_eq_symbol);
#if (!WITH_PURE_S7)
			  else
			    {
			      if (hash_table_checker(obj) == hash_ci_char)
				s7_varlet(sc, let, sc->function_symbol, sc->char_ci_eq_symbol);
			      else
				{
				  if (hash_table_checker(obj) == hash_ci_string)
				    s7_varlet(sc, let, sc->function_symbol, sc->string_ci_eq_symbol);
				}}
#endif
			}}}}}}
  if (is_typed_hash_table(obj))
    s7_varlet(sc, let, sc->signature_symbol, g_signature(sc, set_plist_1(sc, obj)));
  return(let);
}

static s7_pointer iterator_to_let(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer let, seq;
  if (!sc->at_end_symbol)
    {
      sc->at_end_symbol = make_symbol(sc, "at-end");
      sc->sequence_symbol = make_symbol(sc, "sequence");
    }
  seq = iterator_sequence(obj);
  let = g_local_inlet(sc, 8, sc->value_symbol, obj,
		      sc->type_symbol, sc->is_iterator_symbol,
		      sc->at_end_symbol, s7_make_boolean(sc, iterator_is_at_end(obj)),
		      sc->sequence_symbol, iterator_sequence(obj));
  if (is_pair(seq))
    s7_varlet(sc, let, sc->length_symbol, s7_length(sc, seq));
  else
    {
      if (is_hash_table(seq))
	s7_varlet(sc, let, sc->length_symbol, s7_make_integer(sc, hash_table_entries(seq)));
      else s7_varlet(sc, let, sc->length_symbol, s7_length(sc, obj));
    }
  if ((is_string(seq)) ||
      (is_any_vector(seq)) ||
      (seq == sc->rootlet) ||
      (is_c_object(seq)) ||
      (is_hash_table(seq)))
    s7_varlet(sc, let, make_symbol(sc, "position"), s7_make_integer(sc, iterator_position(obj)));
  else
    {
      if (is_pair(seq))
	s7_varlet(sc, let, make_symbol(sc, "position"), iterator_current(obj));
    }
  return(let);
}

static s7_pointer let_to_let(s7_scheme *sc, s7_pointer obj)
{
  /* how to handle setters?
   *   (display (let ((e (let ((i 0)) (set! (setter 'i) integer?) (curlet)))) (object->let e))):
   *   "(inlet 'value (inlet 'i 0) 'type let? 'length 1 'open #f 'outlet () 'immutable? #f)"
   */
  s7_pointer let;
  if (!sc->open_symbol)
    {
      sc->open_symbol = make_symbol(sc, "open");
      sc->alias_symbol = make_symbol(sc, "alias");
    }
  if (!sc->function_symbol)
    sc->function_symbol = make_symbol(sc, "function");
  if (!sc->file_symbol)
    {
      sc->file_symbol = make_symbol(sc, "file");
      sc->line_symbol = make_symbol(sc, "line");
    }
  let = g_local_inlet(sc, 12, sc->value_symbol, obj,
		      sc->type_symbol, sc->is_let_symbol,
		      sc->length_symbol, s7_length(sc, obj),
		      sc->open_symbol, s7_make_boolean(sc, has_methods(obj)),
		      sc->outlet_symbol, (obj == sc->rootlet) ? sc->nil : outlet(obj),
		      sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable(obj)));
  if (obj == sc->rootlet)
    s7_varlet(sc, let, sc->alias_symbol, sc->rootlet_symbol);
  else
    {
      if (obj == sc->owlet) /* this can't happen, I think -- owlet is always copied first */
	s7_varlet(sc, let, sc->alias_symbol, sc->owlet_symbol);
      else
	{
	  if (is_funclet(obj))
	    {
	      s7_varlet(sc, let, sc->function_symbol, funclet_function(obj));
	      if ((has_let_file(obj)) &&
		  (let_file(obj) <= (s7_int)sc->file_names_top) &&
		  (let_line(obj) > 0) &&
		  (let_line(obj) < 100000))
		{
		  s7_varlet(sc, let, sc->file_symbol, sc->file_names[let_file(obj)]);
		  s7_varlet(sc, let, sc->line_symbol, make_integer(sc, let_line(obj)));
		}
	    }
	}
    }
  if (has_active_methods(sc, obj))
    {
      s7_pointer func;
      func = find_method(sc, obj, sc->object_to_let_symbol);
      if (func != sc->undefined)
	{
	  s7_int gc_loc;
	  gc_loc = s7_gc_protect_1(sc, let);
	  s7_apply_function(sc, func, list_2(sc, obj, let));
	  s7_gc_unprotect_at(sc, gc_loc);
	}
    }
  return(let);
}

static s7_pointer c_object_to_let(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer let, clet;
  if (!sc->class_symbol)
    {
      sc->class_symbol = make_symbol(sc, "class");
      sc->c_object_length_symbol = make_symbol(sc, "c-object-length");
      sc->c_object_ref_symbol = make_symbol(sc, "c-object-ref");
      sc->c_object_let_symbol = make_symbol(sc, "c-object-let");
      sc->c_object_set_symbol = make_symbol(sc, "c-object-set!");
      sc->c_object_copy_symbol = make_symbol(sc, "c-object-copy");
      sc->c_object_fill_symbol = make_symbol(sc, "c-object-fill!");
      sc->c_object_reverse_symbol = make_symbol(sc, "c-object-reverse");
      sc->c_object_to_list_symbol = make_symbol(sc, "c-object->list");
      sc->c_object_to_string_symbol = make_symbol(sc, "c-object->string");
    }
  clet = c_object_let(obj);
  let = g_local_inlet(sc, 10, sc->value_symbol, obj,
		      sc->type_symbol, sc->is_c_object_symbol,
		      sc->c_object_type_symbol, s7_make_integer(sc, c_object_type(obj)),
		      sc->c_object_let_symbol, clet,
		      sc->class_symbol, c_object_type_to_let(sc, obj));
  
  /* not sure these are useful */
  if (c_object_len(sc, obj))   /* c_object_length is the object length, not the procedure */
    s7_varlet(sc, let, sc->c_object_length_symbol, s7_lambda(sc, c_object_len(sc, obj), 1, 0, false));
  if (c_object_ref(sc, obj))
    s7_varlet(sc, let, sc->c_object_ref_symbol, s7_lambda(sc, c_object_ref(sc, obj), 1, 0, true));
  if (c_object_set(sc, obj))
    s7_varlet(sc, let, sc->c_object_set_symbol, s7_lambda(sc, c_object_set(sc, obj), 2, 0, true));
  if (c_object_copy(sc, obj))
    s7_varlet(sc, let, sc->c_object_copy_symbol, s7_lambda(sc, c_object_copy(sc, obj), 1, 0, true));
  if (c_object_fill(sc, obj))
    s7_varlet(sc, let, sc->c_object_fill_symbol, s7_lambda(sc, c_object_fill(sc, obj), 1, 0, true));
  if (c_object_reverse(sc, obj))
    s7_varlet(sc, let, sc->c_object_reverse_symbol, s7_lambda(sc, c_object_reverse(sc, obj), 1, 0, true));
  if (c_object_to_list(sc, obj))
    s7_varlet(sc, let, sc->c_object_to_list_symbol, s7_lambda(sc, c_object_to_list(sc, obj), 1, 0, true));
  if (c_object_to_string(sc, obj))
    s7_varlet(sc, let, sc->c_object_to_string_symbol, s7_lambda(sc, c_object_to_string(sc, obj), 1, 1, false));
  
  if ((is_let(clet)) &&
      ((has_active_methods(sc, clet)) || (has_active_methods(sc, obj))))
    {
      s7_pointer func;
      func = find_method(sc, clet, sc->object_to_let_symbol);
      if (func != sc->undefined)
	{
	  s7_int gc_loc;
	  gc_loc = s7_gc_protect_1(sc, let);
	  s7_apply_function(sc, func, list_2(sc, obj, let));
	  s7_gc_unprotect_at(sc, gc_loc);
	}
    }
  return(let);
}

static s7_pointer port_to_let(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer let;
  if (!sc->function_symbol)
    sc->function_symbol = make_symbol(sc, "function");
  if (!sc->file_symbol)
    {
      sc->file_symbol = make_symbol(sc, "file");
      sc->line_symbol = make_symbol(sc, "line");
    }
  if (!sc->data_symbol)
    {
      sc->data_symbol = make_symbol(sc, "data");
      sc->port_type_symbol = make_symbol(sc, "port-type");
      sc->closed_symbol = make_symbol(sc, "closed");
      if (!sc->position_symbol) sc->position_symbol = make_symbol(sc, "position");
    }
  let = g_local_inlet(sc, 10, sc->value_symbol, obj,
		      sc->type_symbol, (is_input_port(obj)) ? sc->is_input_port_symbol : sc->is_output_port_symbol,
		      sc->port_type_symbol, (is_string_port(obj)) ? sc->string_symbol : ((is_file_port(obj)) ? sc->file_symbol : sc->function_symbol),
		      sc->closed_symbol, s7_make_boolean(sc, port_is_closed(obj)),
		      sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable_port(obj)));
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, let);
  if (is_file_port(obj))
    {
      s7_varlet(sc, let, sc->file_symbol, g_port_filename(sc, set_plist_1(sc, obj)));
      if (is_input_port(obj))
	s7_varlet(sc, let, sc->line_symbol, g_port_line_number(sc, set_plist_1(sc, obj)));
    }
  if ((is_string_port(obj)) && /* file port might not have a data buffer */
      (port_data(obj)) &&
      (port_data_size(obj) > 0))
    {
      s7_varlet(sc, let, sc->length_symbol, s7_make_integer(sc, port_data_size(obj)));
      s7_varlet(sc, let, sc->position_symbol, s7_make_integer(sc, port_position(obj)));
      /* I think port_data need not be null-terminated, but s7_make_string assumes it is:
       *   both valgrind and lib*san complain about the uninitialized data during strlen.
       */
      if (port_position(obj) < sc->max_string_length)
	s7_varlet(sc, let, sc->data_symbol, make_string_with_length(sc, (const char *)port_data(obj), port_position(obj)));
    }
  unstack(sc);
  return(let);
}

static s7_pointer closure_to_let(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer let, sig;
  const char* doc;
  s7_int gc_loc;
  if (!sc->file_symbol)
    {
      sc->file_symbol = make_symbol(sc, "file");
      sc->line_symbol = make_symbol(sc, "line");
    }
  if (!sc->source_symbol)
    sc->source_symbol = make_symbol(sc, "source");
  let = g_local_inlet(sc, 8, sc->value_symbol, obj,
		      sc->type_symbol, (is_t_procedure(obj)) ? sc->is_procedure_symbol : sc->is_macro_symbol,
		      sc->arity_symbol, s7_arity(sc, obj),
		      sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable(obj)));
  gc_loc = s7_gc_protect_1(sc, let);
  
  sig = s7_signature(sc, obj);
  if (is_pair(sig))
    s7_varlet(sc, let, sc->local_signature_symbol, sig);
  
  doc = s7_documentation(sc, obj);
  if (doc)
    s7_varlet(sc, let, sc->local_documentation_symbol, s7_make_string(sc, doc));
  
  if (is_let(closure_let(obj)))
    {
      s7_pointer flet;
      flet = closure_let(obj);
      if ((has_let_file(flet)) &&
	  (let_file(flet) <= (s7_int)sc->file_names_top) &&
	  (let_line(flet) > 0))
	{
	  s7_varlet(sc, let, sc->file_symbol, sc->file_names[let_file(flet)]);
	  s7_varlet(sc, let, sc->line_symbol, make_integer(sc, let_line(flet)));
	}
    }
  
  if (closure_setter(obj) != sc->F)
    s7_varlet(sc, let, sc->local_setter_symbol, closure_setter(obj));
  
  s7_varlet(sc, let, sc->source_symbol,
	    append_in_place(sc, list_2(sc, (is_closure_star(obj)) ? sc->lambda_star_symbol : sc->lambda_symbol,
				       closure_args(obj)),
			    closure_body(obj)));
  s7_gc_unprotect_at(sc, gc_loc);
  return(let);
}

static s7_pointer c_pointer_to_let(s7_scheme *sc, s7_pointer obj)
{
  /* c_pointer_info can be a let and might have an object->let method (see c_object below) */
  if (!sc->c_type_symbol)
    {
      sc->c_type_symbol = make_symbol(sc, "c-type");
      sc->info_symbol = make_symbol(sc, "info");
    }
  return(g_local_inlet(sc, 10, sc->value_symbol, obj,
		       sc->type_symbol, sc->is_c_pointer_symbol,
		       sc->c_pointer_symbol, s7_make_integer(sc, (s7_int)((intptr_t)c_pointer(obj))),
		       sc->c_type_symbol, c_pointer_type(obj),
		       sc->info_symbol, c_pointer_info(obj)));
}

static s7_pointer c_function_to_let(s7_scheme *sc, s7_pointer obj)
{
  s7_pointer let, sig;
  const char* doc;
  let = g_local_inlet(sc, 8, sc->value_symbol, obj,
		      sc->type_symbol, (is_t_procedure(obj)) ? sc->is_procedure_symbol : sc->is_macro_symbol,
		      sc->arity_symbol, s7_arity(sc, obj),
		      sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable(obj)));
  
  sig = c_function_signature(obj);
  if (is_pair(sig))
    s7_varlet(sc, let, sc->local_signature_symbol, sig);
  
  doc = s7_documentation(sc, obj);
  if (doc)
    s7_varlet(sc, let, sc->local_documentation_symbol, s7_make_string(sc, doc));
  
  if (c_function_setter(obj) != sc->F) /* c_macro_setter is the same underlying field */
    s7_varlet(sc, let, sc->local_setter_symbol, c_function_setter(obj));
  
  return(let);
}

static s7_pointer goto_to_let(s7_scheme *sc, s7_pointer obj)
{
  if (!sc->active_symbol)
    {
      sc->active_symbol = make_symbol(sc, "active");
      sc->goto_symbol = make_symbol(sc, "goto?");
    }
  return(g_local_inlet(sc, 6, sc->value_symbol, obj,
		       sc->type_symbol, sc->goto_symbol,
		       sc->active_symbol, s7_make_boolean(sc, call_exit_active(obj))));
}

static s7_pointer g_object_to_let(s7_scheme *sc, s7_pointer args)
{
  #define H_object_to_let "(object->let obj) returns a let (namespace) describing obj."
  #define Q_object_to_let s7_make_signature(sc, 2, sc->is_let_symbol, sc->T)

  s7_pointer obj;
  obj = car(args);

  switch (type(obj))
    {
    case T_NIL:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_null_symbol));

    case T_UNSPECIFIED:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_unspecified_symbol));

    case T_UNDEFINED:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_undefined_symbol));

    case T_SYNTAX:
      return(g_local_inlet(sc, 6, sc->value_symbol, obj,
			   sc->type_symbol, sc->is_syntax_symbol,
			   sc->documentation_symbol, s7_make_string(sc, syntax_documentation(obj))));

    case T_EOF_OBJECT:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_eof_object_symbol));

    case T_BOOLEAN:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_boolean_symbol));

    case T_CHARACTER:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_char_symbol));

    case T_INTEGER: case T_BIG_INTEGER:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_integer_symbol));

    case T_RATIO: case T_BIG_RATIO:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_rational_symbol));

    case T_REAL: case T_BIG_REAL:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_real_symbol));

    case T_COMPLEX: case T_BIG_COMPLEX:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_complex_symbol));

    case T_SYMBOL:
      return(symbol_to_let(sc, obj, args));

    case T_STRING:
      return(g_local_inlet(sc, 8, sc->value_symbol, obj,
			   sc->type_symbol, sc->is_string_symbol,
			   sc->length_symbol, s7_length(sc, obj),
			   sc->is_immutable_symbol, s7_make_boolean(sc, is_immutable_string(obj))));

    case T_PAIR:
      return(g_local_inlet(sc, 6, sc->value_symbol, obj,
			   sc->type_symbol, sc->is_pair_symbol,
			   sc->length_symbol, s7_length(sc, obj)));

    case T_RANDOM_STATE:
      return(random_state_to_let(sc, obj));

    case T_GOTO:
      return(goto_to_let(sc, obj));

    case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_BYTE_VECTOR: case T_VECTOR:
      return(vector_to_let(sc, obj));

    case T_C_POINTER:
      return(c_pointer_to_let(sc, obj));

    case T_CONTINUATION:
      return(g_local_inlet(sc, 4, sc->value_symbol, obj, sc->type_symbol, sc->is_continuation_symbol));

    case T_ITERATOR:
      return(iterator_to_let(sc, obj));

    case T_HASH_TABLE:
      return(hash_table_to_let(sc, obj));

    case T_LET:
      return(let_to_let(sc, obj));

    case T_C_OBJECT:
      return(c_object_to_let(sc, obj));

    case T_INPUT_PORT:
    case T_OUTPUT_PORT:
      return(port_to_let(sc, obj));

    case T_CLOSURE: case T_CLOSURE_STAR: case T_MACRO: case T_MACRO_STAR: case T_BACRO: case T_BACRO_STAR:
      return(closure_to_let(sc, obj));

    case T_C_MACRO: case T_C_FUNCTION_STAR: case T_C_FUNCTION: case T_C_ANY_ARGS_FUNCTION: case T_C_OPT_ARGS_FUNCTION: case T_C_RST_ARGS_FUNCTION:
      return(c_function_to_let(sc, obj));

    default:
      return(sc->F);
    }
  return(sc->F);
}


/* ---------------- stacktrace ---------------- */

static s7_pointer stacktrace_find_caller(s7_scheme *sc, s7_pointer e)
{
  if ((is_let(e)) && (e != sc->rootlet))
    {
      if (is_funclet(e))
	return(funclet_function(e));
      return(stacktrace_find_caller(sc, outlet(e)));
    }
  return(sc->F);
}

static bool stacktrace_find_let(s7_scheme *sc, int64_t loc, s7_pointer e)
{
  return((loc > 0) &&
	 ((stack_let(sc->stack, loc) == e) ||
	  (stacktrace_find_let(sc, loc - 4, e))));
}

static int64_t stacktrace_find_error_hook_quit(s7_scheme *sc)
{
  int64_t i;
  for (i = s7_stack_top(sc) - 1; i >= 3; i -= 4)
    if (stack_op(sc->stack, i) == OP_ERROR_HOOK_QUIT)
      return(i);
  return(-1);
}

static bool stacktrace_in_error_handler(s7_scheme *sc, int64_t loc)
{
  return((outlet(sc->owlet) == sc->envir) ||
	 (stacktrace_find_let(sc, loc * 4, outlet(sc->owlet))) ||
	 (stacktrace_find_error_hook_quit(sc) > 0));
}

static bool stacktrace_error_hook_function(s7_scheme *sc, s7_pointer sym)
{
  if (is_symbol(sym))
    {
      s7_pointer f;
      f = s7_symbol_value(sc, sym);
      return((is_procedure(f)) &&
	     (is_procedure(sc->error_hook)) &&
	     (hook_has_functions(sc->error_hook)) &&
	     (direct_memq(f, s7_hook_functions(sc, sc->error_hook))));
    }
  return(false);
}

static char *stacktrace_walker(s7_scheme *sc, s7_pointer code, s7_pointer e, char *notes,
			       s7_int code_cols, s7_int total_cols, s7_int notes_start_col,
			       bool as_comment, int32_t depth)
{
  if (is_symbol(code))
    {
      if ((!symbol_is_in_list(sc, code)) &&
	  (!is_slot(global_slot(code))))
	{
	  s7_pointer val;

	  add_symbol_to_list(sc, code);
	  val = s7_symbol_local_value(sc, code, e);
	  if ((val) &&
	      (val != sc->undefined) &&
	      (!is_any_macro(val)))
	    {
	      int32_t typ;

	      typ = type(val);
	      if (typ < T_CONTINUATION)
		{
		  char *objstr, *str;
		  s7_pointer objp;
		  const char *spaces;
		  s7_int new_note_len, notes_max, spaces_len;
		  bool new_notes_line = false, old_short_print;
		  s7_int old_len, objlen;

		  spaces = "                                                                                ";
		  spaces_len = 80;

		  if (notes_start_col < 0) notes_start_col = 50;
		  if (notes_start_col > total_cols) notes_start_col = 0;
		  notes_max = total_cols - notes_start_col;

		  old_short_print = sc->short_print;
		  sc->short_print = true;
		  old_len = sc->print_length;
		  if (sc->print_length > 4) sc->print_length = 4;
		  objp = s7_object_to_string(sc, val, false);
		  objstr = string_value(objp);
		  objlen = string_length(objp);
		  if ((objlen > notes_max) &&
		      (notes_max > 5))
		    {
		      objstr[notes_max - 4] = '.';
		      objstr[notes_max - 3] = '.';
		      objstr[notes_max - 2] = '.';
		      objstr[notes_max - 1] = '\0';
		      objlen = notes_max;
		    }
		  sc->short_print = old_short_print;
		  sc->print_length = old_len;

		  new_note_len = symbol_name_length(code) + 3 + objlen;
		  /* we want to append this much info to the notes, but does it need a new line? */
		  if (notes_start_col < code_cols)
		    new_notes_line = true;
		  else
		    {
		      if (notes)
			{
			  char *last_newline;
			  s7_int cur_line_len;
			  last_newline = strrchr(notes, (int)'\n'); /* returns ptr to end if none = nil if not found? */
			  if (last_newline)
			    cur_line_len = strlen(notes) - strlen(last_newline);
			  else cur_line_len = strlen(notes);
			  new_notes_line = ((cur_line_len + new_note_len) > notes_max);
			}
		    }

		  if (new_notes_line)
		    {
		      new_note_len += (4 + notes_start_col + ((notes) ? strlen(notes) : 0));
		      str = (char *)malloc(new_note_len * sizeof(char));
		      /* str[0] = '\0'; */
		      catstrs_direct(str,
			      (notes) ? notes : "",
			      "\n",
			      (as_comment) ? "; " : "",
			      (spaces_len >= notes_start_col) ? (char *)(spaces + spaces_len - notes_start_col) : "",
			      (as_comment) ? "" : " ; ",
			      symbol_name(code),
			      ": ",
			      objstr, NULL);
		    }
		  else
		    {
		      new_note_len += ((notes) ? strlen(notes) : 0) + 4;
		      str = (char *)malloc(new_note_len * sizeof(char));
		      /* str[0] = '\0'; */
		      catstrs_direct(str,
			      (notes) ? notes : "",
			      (notes) ? ", " : " ; ",
			      symbol_name(code),
			      ": ",
			      objstr, NULL);
		    }
		  if (notes) free(notes);
		  return(str);
		}
	    }
	}
      return(notes);
    }
  if ((is_pair(code)) &&
      (s7_list_length(sc, code) > 0) &&
      (depth < 32))
    {
      notes = stacktrace_walker(sc, car(code), e, notes, code_cols, total_cols, notes_start_col, as_comment, depth + 1);
      return(stacktrace_walker(sc, cdr(code), e, notes, code_cols, total_cols, notes_start_col, as_comment, depth + 2));
    }
  return(notes);
}

static block_t *stacktrace_add_func(s7_scheme *sc, s7_pointer f, s7_pointer code, char *errstr, char *notes, s7_int code_max, bool as_comment)
{
  s7_int newlen, errlen;
  char *newstr, *str;
  block_t *newp, *b;

  errlen = strlen(errstr);
  if ((is_symbol(f)) &&
      (f != car(code)))
    {
      newlen = symbol_name_length(f) + errlen + 10;
      newp = mallocate(sc, newlen);
      newstr = (char *)block_data(newp);
      /* newstr[0] = '\0'; */
      errlen = catstrs_direct(newstr, symbol_name(f), ": ", errstr, NULL);
    }
  else
    {
      newlen = errlen + 8;
      newp = mallocate(sc, newlen);
      newstr = (char *)block_data(newp);
      /* newstr[0] = '\0'; */
      if ((errlen > 2) && (errstr[2] == '('))
        errlen = catstrs_direct(newstr, "  ", errstr, NULL);
      else
	{
	  memcpy((void *)newstr, (void *)errstr, errlen);
	  newstr[errlen] = '\0';
	}
    }

  newlen = code_max + 8 + ((notes) ? strlen(notes) : 0);
  b = mallocate(sc, newlen * sizeof(char));
  str = (char *)block_data(b);
  /* str[0] = '\0'; */

  if (errlen >= code_max)
    {
      newstr[code_max - 4] = '.';
      newstr[code_max - 3] = '.';
      newstr[code_max - 2] = '.';
      newstr[code_max - 1] = '\0';
      catstrs_direct(str, (as_comment) ? "; " : "", newstr, (notes) ? notes : "", "\n", NULL);
    }
  else
    {
      /* send out newstr, pad with spaces to code_max, then notes */
      s7_int len;
      len = catstrs_direct(str, (as_comment) ? "; " : "", newstr, NULL);
      if (notes)
	{
	  s7_int i;
	  for (i = len; i < code_max - 1; i++)
	    str[i] = ' ';
	  str[i] = '\0';
	  catstrs(str, newlen, notes, "\n", NULL);
	}
    }
  liberate(sc, newp);
  return(b);
}

static s7_pointer stacktrace_1(s7_scheme *sc, s7_int frames_max, s7_int code_cols, s7_int total_cols, s7_int notes_start_col, bool as_comment)
{
  char *str = NULL;
  block_t *strp = NULL;
  int64_t loc, top, frames = 0;

  clear_symbol_list(sc);
  top = (sc->stack_end - sc->stack_start) / 4; /* (*s7* 'stack_top), not s7_stack_top! */

  if (stacktrace_in_error_handler(sc, top))
    {
      s7_pointer err_code;
      err_code = slot_value(sc->error_code);
      if ((is_pair(err_code)) &&
	  (!tree_is_cyclic(sc, err_code)))
	{
	  char *notes = NULL;
	  s7_pointer cur_env, f, errstr;

	  errstr = s7_object_to_string(sc, err_code, false);
	  cur_env = outlet(sc->owlet);
	  f = stacktrace_find_caller(sc, cur_env); /* this is a symbol */
	  if ((is_let(cur_env)) &&
	      (cur_env != sc->rootlet))
	    notes = stacktrace_walker(sc, err_code, cur_env, NULL, code_cols, total_cols, notes_start_col, as_comment, 0);
	  strp = stacktrace_add_func(sc, f, err_code, string_value(errstr), notes, code_cols, as_comment);
	  str = (char *)block_data(strp);
	}

      /* now if OP_ERROR_HOOK_QUIT is in the stack, jump past it! */
      loc = stacktrace_find_error_hook_quit(sc);
      if (loc > 0) top = (loc + 1) / 4;
    }

  for (loc = top - 1; loc > 0; loc--)
    {
      s7_pointer code;
      s7_int true_loc;

      true_loc = (loc + 1) * 4 - 1;
      code = stack_code(sc->stack, true_loc);
      if ((is_pair(code)) &&
	  (!tree_is_cyclic(sc, code)))
	{
	  s7_pointer codep;
	  codep = s7_object_to_string(sc, code, false);
	  if (string_length(codep) > 0)
	    {
	      char *codestr;
	      codestr = string_value(codep);
	      if ((!local_strcmp(codestr, "(result)")) &&
		  (!local_strcmp(codestr, "(#f)")) &&
		  (!strstr(codestr, "(stacktrace)")) &&
		  (!strstr(codestr, "(stacktrace ")))
		{
		  s7_pointer e, f;

		  e = stack_let(sc->stack, true_loc);
		  f = stacktrace_find_caller(sc, e);
		  if (!stacktrace_error_hook_function(sc, f))
		    {
		      char *notes = NULL, *newstr, *catstr;
		      block_t *newp, *catp;
		      s7_int newlen;

		      frames++;
		      if (frames > frames_max)
			return(block_to_string(sc, strp, safe_strlen((char *)block_data(strp))));

		      if ((is_let(e)) && (e != sc->rootlet))
			notes = stacktrace_walker(sc, code, e, NULL, code_cols, total_cols, notes_start_col, as_comment, 0);
		      newp = stacktrace_add_func(sc, f, code, codestr, notes, code_cols, as_comment);
		      newstr = (char *)block_data(newp);

		      if ((notes) && (notes != newstr) && (is_let(e)) && (e != sc->rootlet))
			free(notes);

		      newlen = strlen(newstr) + 1 + ((str) ? strlen(str) : 0);
		      catp = mallocate(sc, newlen * sizeof(char));
		      catstr = (char *)block_data(catp);
		      catstrs_direct(catstr, (str) ? str : "", newstr, NULL);
		      liberate(sc, newp);
		      if (strp) liberate(sc, strp);
		      strp = catp;
		      str = (char *)block_data(strp);
		    }}}}}
  if (strp)
    return(block_to_string(sc, strp, safe_strlen((char *)block_data(strp))));
  return(make_empty_string(sc, 0, 0));
}

s7_pointer s7_stacktrace(s7_scheme *sc)
{
  return(stacktrace_1(sc, 30, 45, 80, 45, false));
}

static s7_pointer g_stacktrace(s7_scheme *sc, s7_pointer args)
{
  #define H_stacktrace "(stacktrace (max-frames 30) (code-cols 50) (total-cols 80) (note-col 50) as-comment) returns \
a stacktrace as a string.  Each line has two portions, the code being evaluated and a note giving \
the value of local variables in that code.  The first argument sets how many lines are displayed. \
The next three arguments set the length and layout of those lines.  'as-comment' if #t causes each \
line to be preceded by a semicolon."
  #define Q_stacktrace s7_make_signature(sc, 6, sc->is_string_symbol, sc->is_integer_symbol, sc->is_integer_symbol, sc->is_integer_symbol, sc->is_integer_symbol, sc->is_boolean_symbol)

  s7_int max_frames = 30, code_cols = 50, total_cols = 80, notes_start_col = 50;
  bool as_comment = false;

  if (!is_null(args))
    {
      if (!s7_is_integer(car(args)))
	return(method_or_bust(sc, car(args), sc->stacktrace_symbol, args, T_INTEGER, 1));
      max_frames = s7_integer(car(args));
      if ((max_frames <= 0) || (max_frames > s7_int32_max))
	max_frames = 30;
      args = cdr(args);
      if (!is_null(args))
	{
	  if (!s7_is_integer(car(args)))
	    return(wrong_type_argument(sc, sc->stacktrace_symbol, 2, car(args), T_INTEGER));
	  code_cols = s7_integer(car(args));
	  if ((code_cols <= 8) || (code_cols > 1024))
	    code_cols = 50;
	  args = cdr(args);
	  if (!is_null(args))
	    {
	      if (!s7_is_integer(car(args)))
		return(wrong_type_argument(sc, sc->stacktrace_symbol, 3, car(args), T_INTEGER));
	      total_cols = s7_integer(car(args));
	      if ((total_cols <= code_cols) || (total_cols > s7_int32_max))
		total_cols = 80;
	      args = cdr(args);
	      if (!is_null(args))
		{
		  if (!s7_is_integer(car(args)))
		    return(wrong_type_argument(sc, sc->stacktrace_symbol, 4, car(args), T_INTEGER));
		  notes_start_col = s7_integer(car(args));
		  if ((notes_start_col <= 0) || (notes_start_col > s7_int32_max))
		    notes_start_col = 50;
		  args = cdr(args);
		  if (!is_null(args))
		    {
		      if (!s7_is_boolean(car(args)))
			return(wrong_type_argument(sc, sc->stacktrace_symbol, 5, car(args), T_BOOLEAN));
		      as_comment = s7_boolean(sc, car(args));
		    }
		}
	    }
	}
    }
  return(stacktrace_1(sc, max_frames, code_cols, total_cols, notes_start_col, as_comment));
}


/* -------- s7_history, s7_add_to_history, s7_history_enabled -------- */

s7_pointer s7_add_to_history(s7_scheme *sc, s7_pointer entry)
{
#if WITH_HISTORY
  set_current_code(sc, entry);
#endif
  return(entry);
}

s7_pointer s7_history(s7_scheme *sc)
{
  return(sc->cur_code);
}

bool s7_history_enabled(s7_scheme *sc)
{
#if WITH_HISTORY
  return(sc->cur_code != sc->history_sink);
#else
  return(false);
#endif
}

bool s7_set_history_enabled(s7_scheme *sc, bool enabled)
{
#if WITH_HISTORY
  if (enabled)
    sc->cur_code = (sc->using_history1) ? sc->eval_history1 : sc->eval_history2;
  else sc->cur_code = sc->history_sink;
  return(enabled);
#else
  return(false);
#endif
}

#if WITH_HISTORY
static s7_pointer history_cons(s7_scheme *sc, s7_pointer code, s7_pointer args)
{
  s7_pointer p;
  p = car(sc->history_pairs);
  sc->history_pairs = cdr(sc->history_pairs);
  set_car(p, code);
  set_cdr(p, args);
  return(p);
}
#else
#define history_cons(Sc, Code, Args) Code
#endif


/* -------- error handlers -------- */

static const char *make_type_name(s7_scheme *sc, const char *name, int32_t article)
{
  s7_int i, slen, len;

  slen = safe_strlen(name);
  len = slen + 8;
  if (len > sc->typnam_len)
    {
      if (sc->typnam) free(sc->typnam);
      sc->typnam = (char *)malloc(len * sizeof(char));
      sc->typnam_len = len;
    }
  if (article == INDEFINITE_ARTICLE)
    {
      i = 1;
      sc->typnam[0] = 'a';
      if ((name[0] == 'a') || (name[0] == 'e') || (name[0] == 'i') || (name[0] == 'o') || (name[0] == 'u'))
	sc->typnam[i++] = 'n';
      sc->typnam[i++] = ' ';
    }
  else i = 0;
  memcpy((void *)(sc->typnam + i), (void *)name, slen);
  sc->typnam[i + slen] = '\0';
  return(sc->typnam);
}

static const char *type_name_from_type(int32_t typ, int32_t article)
{
  static const char *frees[2] =          {"free-cell",          "a free cell"};
  static const char *nils[2] =           {"nil",                "nil"};
  static const char *unuseds[2] =        {"#<unused>",          "the unused object"};
  static const char *eofs[2] =           {"#<eof>",             "the end-of-file object"};
  static const char *unspecs[2] =        {"#<unspecified>",     "the unspecified object"};
  static const char *undefs[2] =         {"undefined",          "an undefined object"};
  static const char *booleans[2] =       {"boolean",            "boolean"};
  static const char *strings[2] =        {"string",             "a string"};
  static const char *byte_vectors[2] =   {"byte-vector",        "a byte-vector"};
  static const char *symbols[2] =        {"symbol",             "a symbol"};
  static const char *syntaxes[2] =       {"syntax",             "syntactic"};
  static const char *pairs[2] =          {"pair",               "a pair"};
  static const char *gotos[2] =          {"goto",               "a goto (from call-with-exit)"};
  static const char *continuations[2] =  {"continuation",       "a continuation"};
  static const char *c_funcs[2] =        {"c-function",         "a c-function"};
  static const char *c_funcs_star[2] =   {"c-function*",        "a c-function*"};
  static const char *macros[2] =         {"macro",              "a macro"};
  static const char *c_macros[2] =       {"c-macro",            "a c-macro"};
  static const char *bacros[2] =         {"bacro",              "a bacro"};
  static const char *vectors[2] =        {"vector",             "a vector"};
  static const char *int_vectors[2] =    {"int-vector",         "an int-vector"};
  static const char *float_vectors[2] =  {"float-vector",       "a float-vector"};
  static const char *c_pointers[2] =     {"c-pointer",          "a raw C pointer"};
  static const char *counters[2] =       {"internal-counter",   "an internal counter"};
  static const char *baffles[2] =        {"baffle",             "a baffle"};
  static const char *slots[2] =          {"slot",               "a slot (variable binding)"};
  static const char *characters[2] =     {"character",          "a character"};
  static const char *catches[2] =        {"catch",              "a catch"};
  static const char *dynamic_winds[2] =  {"dynamic-wind",       "a dynamic-wind"};
  static const char *hash_tables[2] =    {"hash-table",         "a hash-table"};
  static const char *iterators[2] =      {"iterator",           "an iterator"};
  static const char *lets[2] =           {"let",                "a let"};
  static const char *integers[2] =       {"integer",            "an integer"};
  static const char *big_integers[2] =   {"big-integer",        "a big integer"};
  static const char *ratios[2] =         {"ratio",              "a ratio"};
  static const char *big_ratios[2] =     {"big-ratio",          "a big ratio"};
  static const char *reals[2] =          {"real",               "a real"};
  static const char *big_reals[2] =      {"big-real",           "a big real"};
  static const char *complexes[2] =      {"complex-number",     "a complex number"};
  static const char *big_complexes[2] =  {"big-complex-number", "a big complex number"};
  static const char *functions[2] =      {"function",           "a function"};
  static const char *function_stars[2] = {"function*",          "a function*"};
  static const char *rngs[2] =           {"random-state",       "a random-state"};
  static const char *inputs[2] =         {"input-port",         "an input port"};
  static const char *outputs[2] =        {"output-port",        "an output port"};
  static const char *c_objects[2] =      {"c-object",           "a c_object"};
  static const char *stacks[2] =         {"stack",              "a stack"};

  switch (typ)
    {
    case T_FREE:            return(frees[article]);
    case T_NIL:             return(nils[article]);
    case T_UNUSED:          return(unuseds[article]);
    case T_EOF_OBJECT:      return(eofs[article]);
    case T_UNSPECIFIED:     return(unspecs[article]);
    case T_UNDEFINED:       return(undefs[article]);
    case T_BOOLEAN:         return(booleans[article]);
    case T_STRING:          return(strings[article]);
    case T_BYTE_VECTOR:     return(byte_vectors[article]);
    case T_SYMBOL:          return(symbols[article]);
    case T_SYNTAX:          return(syntaxes[article]);
    case T_PAIR:            return(pairs[article]);
    case T_GOTO:            return(gotos[article]);
    case T_CONTINUATION:    return(continuations[article]);
    case T_C_OPT_ARGS_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
    case T_C_FUNCTION:      return(c_funcs[article]);
    case T_C_FUNCTION_STAR: return(c_funcs_star[article]);
    case T_CLOSURE:         return(functions[article]);
    case T_CLOSURE_STAR:    return(function_stars[article]);
    case T_C_MACRO:         return(c_macros[article]);
    case T_C_POINTER:       return(c_pointers[article]);
    case T_CHARACTER:       return(characters[article]);
    case T_VECTOR:          return(vectors[article]);
    case T_INT_VECTOR:      return(int_vectors[article]);
    case T_FLOAT_VECTOR:    return(float_vectors[article]);
    case T_MACRO_STAR:
    case T_MACRO:           return(macros[article]);
    case T_BACRO_STAR:
    case T_BACRO:           return(bacros[article]);
    case T_CATCH:           return(catches[article]);
    case T_STACK:           return(stacks[article]);
    case T_DYNAMIC_WIND:    return(dynamic_winds[article]);
    case T_HASH_TABLE:      return(hash_tables[article]);
    case T_ITERATOR:        return(iterators[article]);
    case T_LET:             return(lets[article]);
    case T_COUNTER:         return(counters[article]);
    case T_BAFFLE:          return(baffles[article]);
    case T_RANDOM_STATE:    return(rngs[article]);
    case T_SLOT:            return(slots[article]);
    case T_INTEGER:         return(integers[article]);
    case T_RATIO:           return(ratios[article]);
    case T_REAL:            return(reals[article]);
    case T_COMPLEX:         return(complexes[article]);
    case T_BIG_INTEGER:     return(big_integers[article]);
    case T_BIG_RATIO:       return(big_ratios[article]);
    case T_BIG_REAL:        return(big_reals[article]);
    case T_BIG_COMPLEX:     return(big_complexes[article]);
    case T_INPUT_PORT:      return(inputs[article]);
    case T_OUTPUT_PORT:     return(outputs[article]);
    case T_C_OBJECT:        return(c_objects[article]);
    }
  return(NULL);
}

static const char *type_name(s7_scheme *sc, s7_pointer arg, int32_t article)
{
  switch (unchecked_type(arg))
    {
    case T_C_OBJECT:
      return(make_type_name(sc, string_value(c_object_scheme_name(sc, arg)), article));

    case T_INPUT_PORT:
      return(make_type_name(sc, (is_file_port(arg)) ? "input file port" : ((is_string_port(arg)) ? "input string port" : "input port"), article));

    case T_OUTPUT_PORT:
      return(make_type_name(sc, (is_file_port(arg)) ? "output file port" : ((is_string_port(arg)) ? "output string port" : "output port"), article));

    case T_LET:
      if (has_active_methods(sc, arg))
	{
	  s7_pointer class_name;
	  class_name = find_method(sc, arg, sc->class_name_symbol);
	  if (is_symbol(class_name))
	    return(make_type_name(sc, symbol_name(class_name), article));
	}

    default:
      {
	const char *str;
	str = type_name_from_type(unchecked_type(arg), article);
	if (str) return(str);
      }
    }
  return("messed up object");
}

static s7_pointer prepackaged_type_name(s7_scheme *sc, s7_pointer x)
{
  s7_pointer p;
  uint8_t typ;

  if (has_active_methods(sc, x))
    {
      p = find_method(sc, find_let(sc, x), sc->class_name_symbol);
      if (is_symbol(p))
	return(symbol_name_cell(p));
    }
  typ = type(x);
  switch (typ)
    {
    case T_C_OBJECT:    return(c_object_scheme_name(sc, x));
    case T_INPUT_PORT:  return((is_file_port(x)) ? an_input_file_port_string : ((is_string_port(x)) ? an_input_string_port_string : an_input_port_string));
    case T_OUTPUT_PORT: return((is_file_port(x)) ? an_output_file_port_string : ((is_string_port(x)) ? an_output_string_port_string : an_output_port_string));
    default:
      p = prepackaged_type_names[type(x)];
      if (is_string(p)) return(p);
    }
  return(wrap_string(sc, "unknown type!", 13));
}

static s7_pointer type_name_string(s7_scheme *sc, s7_pointer arg)
{
  if (type(arg) < NUM_TYPES)
    {
      s7_pointer p;
      p = prepackaged_type_names[type(arg)]; /* these use INDEFINITE_ARTICLE */
      if (is_string(p)) return(p);
    }
  return(s7_make_string_wrapper(sc, type_name(sc, arg, INDEFINITE_ARTICLE)));
}

static s7_pointer wrong_type_arg_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg_n, s7_pointer arg, s7_pointer typnam, s7_pointer descr)
{
  /* info list is '(format_string caller arg_n arg type_name descr) */
  s7_pointer p;
  p = cdr(sc->wrong_type_arg_info);  /* info list is '(format_string caller arg_n arg type_name descr) */
  set_car(p, caller);  p = cdr(p);
  set_car(p, arg_n);   p = cdr(p);
  set_car(p, arg);     p = cdr(p);
  set_car(p, (typnam == sc->unused) ? prepackaged_type_name(sc, arg) : typnam);
  p = cdr(p);
  set_car(p, descr);
  return(s7_error(sc, sc->wrong_type_arg_symbol, sc->wrong_type_arg_info));
}

static s7_pointer simple_wrong_type_arg_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg, s7_pointer typnam, s7_pointer descr)
{
  set_wlist_4(cdr(sc->simple_wrong_type_arg_info), caller, arg, (typnam == sc->unused) ? prepackaged_type_name(sc, arg) : typnam, descr);
  return(s7_error(sc, sc->wrong_type_arg_symbol, sc->simple_wrong_type_arg_info));
}

s7_pointer s7_wrong_type_arg_error(s7_scheme *sc, const char *caller, s7_int arg_n, s7_pointer arg, const char *descr)
{
  if (arg_n > 0)
    return(wrong_type_arg_error_prepackaged(sc, wrap_string(sc, caller, safe_strlen(caller)), wrap_integer1(sc, arg_n),
					    arg, type_name_string(sc, arg), wrap_string(sc, descr, safe_strlen(descr))));
  return(simple_wrong_type_arg_error_prepackaged(sc, wrap_string(sc, caller, safe_strlen(caller)), arg,
						 type_name_string(sc, arg), wrap_string(sc, descr, safe_strlen(descr))));
}

static s7_pointer out_of_range_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg_n, s7_pointer arg, s7_pointer descr)
{
  set_wlist_4(cdr(sc->out_of_range_info), caller, arg_n, arg, descr);
  return(s7_error(sc, sc->out_of_range_symbol, sc->out_of_range_info));
}

static s7_pointer simple_out_of_range_error_prepackaged(s7_scheme *sc, s7_pointer caller, s7_pointer arg, s7_pointer descr)
{
  set_wlist_3(cdr(sc->simple_out_of_range_info), caller, arg, descr);
  return(s7_error(sc, sc->out_of_range_symbol, sc->simple_out_of_range_info));
}

s7_pointer s7_out_of_range_error(s7_scheme *sc, const char *caller, s7_int arg_n, s7_pointer arg, const char *descr)
{
  if (arg_n > 0)
    return(out_of_range_error_prepackaged(sc, wrap_string(sc, caller, safe_strlen(caller)), wrap_integer1(sc, arg_n), arg,
					  wrap_string(sc, descr, safe_strlen(descr))));
  return(simple_out_of_range_error_prepackaged(sc, wrap_string(sc, caller, safe_strlen(caller)),
					       arg, wrap_string(sc, descr, safe_strlen(descr))));
}

s7_pointer s7_wrong_number_of_args_error(s7_scheme *sc, const char *caller, s7_pointer args)
{
  return(s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_2(sc, s7_make_string_wrapper(sc, caller), args))); /* "caller" includes the format directives */
}

static s7_pointer division_by_zero_error(s7_scheme *sc, s7_pointer caller, s7_pointer arg)
{
  return(s7_error(sc, sc->division_by_zero_symbol, set_elist_3(sc, wrap_string(sc, "~A: division by zero, ~S", 24), caller, arg)));
}

static s7_pointer file_error(s7_scheme *sc, const char *caller, const char *descr, const char *name)
{
  return(s7_error(sc, sc->io_error_symbol,
		  set_elist_4(sc, wrap_string(sc, "~A: ~A ~S", 9),
				  s7_make_string_wrapper(sc, caller),
				  s7_make_string_wrapper(sc, descr),
				  s7_make_string_wrapper(sc, name))));
}


/* -------------------------------- dynamic-wind -------------------------------- */
static s7_pointer closure_or_f(s7_scheme *sc, s7_pointer p)
{
  s7_pointer body;
  if (!is_closure(p)) return(p);
  body = closure_body(p);
  if (is_pair(cdr(body))) return(p);
  if (!is_pair(car(body))) return(sc->F);
  if (caar(body) == sc->quote_symbol) return(sc->F);
  return(p);
}

static s7_pointer make_baffled_closure(s7_scheme *sc, s7_pointer inp)
{
  /* for dynamic-wind to protect initial and final functions from call/cc */
  s7_pointer nclo, frame;
  nclo = make_closure(sc, sc->nil, closure_body(inp), type(inp), 0);
  frame = new_frame_in_env(sc, closure_let(inp)); /* outlet(frame) = closure_let(inp) */
  make_slot_1(sc, frame, sc->baffle_symbol, make_baffle(sc));
  closure_set_let(nclo, frame);
  return(nclo);
}

static bool is_dwind_thunk(s7_scheme *sc, s7_pointer x)
{
  switch (type(x))
    {
    case T_MACRO: case T_BACRO: case T_CLOSURE: case T_MACRO_STAR: case T_BACRO_STAR:  case T_CLOSURE_STAR:
      return(is_null(closure_args(x))); /* this is the case that does not match is_aritable -- it could be loosened -- arity=0 below would need fixup */

    case T_C_RST_ARGS_FUNCTION: case T_C_FUNCTION:
      return((c_function_required_args(x) <= 0) && (c_function_all_args(x) >= 0));

    case T_C_OPT_ARGS_FUNCTION: case T_C_ANY_ARGS_FUNCTION: case T_C_FUNCTION_STAR:
      return(c_function_all_args(x) >= 0);

    case T_C_MACRO:
      return((c_macro_required_args(x) <= 0) && (c_macro_all_args(x) >= 0));

    case T_GOTO: case T_CONTINUATION:
      return(true);
    }
  return(false);
}

static s7_pointer g_dynamic_wind(s7_scheme *sc, s7_pointer args)
{
  #define H_dynamic_wind "(dynamic-wind init body finish) calls init, then body, then finish, \
each a function of no arguments, guaranteeing that finish is called even if body is exited"
  #define Q_dynamic_wind s7_make_circular_signature(sc, 1, 2, sc->values_symbol, sc->is_procedure_symbol)

  s7_pointer p, inp, outp;

  if (!is_dwind_thunk(sc, car(args)))
    return(method_or_bust_with_type(sc, car(args), sc->dynamic_wind_symbol, args, a_thunk_string, 1));
  if (!is_thunk(sc, cadr(args)))
    return(method_or_bust_with_type(sc, cadr(args), sc->dynamic_wind_symbol, args, a_thunk_string, 2));
  if (!is_dwind_thunk(sc, caddr(args)))
    return(method_or_bust_with_type(sc, caddr(args), sc->dynamic_wind_symbol, args, a_thunk_string, 3));

  /* this won't work:
       (let ((final (lambda (a b c) (list a b c))))
         (dynamic-wind
           (lambda () #f)
           (lambda () (set! final (lambda () (display "in final"))))
           final))
   * but why not?  'final' is a thunk by the time it is evaluated. catch (the error handler) is similar.
   * It can't work here because we set up the dynamic_wind_out slot below and
   *   even if the thunk check was removed, we'd still be trying to apply the original function.
   */
  new_cell(sc, p, T_DYNAMIC_WIND);                          /* don't mark car/cdr, don't copy */
  dynamic_wind_in(p) = closure_or_f(sc, car(args));
  dynamic_wind_body(p) = cadr(args);
  dynamic_wind_out(p) = closure_or_f(sc, caddr(args));

  inp = dynamic_wind_in(p);
  if ((is_any_closure(inp)) && (!is_safe_closure(inp)))    /* wrap this use of inp in a with-baffle */
    dynamic_wind_in(p) = make_baffled_closure(sc, inp);

  outp = dynamic_wind_out(p);
  if ((is_any_closure(outp)) && (!is_safe_closure(outp)))
    dynamic_wind_out(p) = make_baffled_closure(sc, outp);

  /* since we don't care about the in and out results, and they are thunks, if the body is not a pair,
   *   or is a quoted thing, we just ignore that function.
   */
  push_stack(sc, OP_DYNAMIC_WIND, sc->nil, p);          /* args will be the saved result, code = s7_dynwind_t obj */
  if (inp != sc->F)
    {
      dynamic_wind_state(p) = DWIND_INIT;
      push_stack(sc, OP_APPLY, sc->nil, dynamic_wind_in(p));
    }
  else
    {
      dynamic_wind_state(p) = DWIND_BODY;
      push_stack(sc, OP_APPLY, sc->nil, dynamic_wind_body(p));
    }
  return(sc->F);
}

s7_pointer s7_dynamic_wind(s7_scheme *sc, s7_pointer init, s7_pointer body, s7_pointer finish)
{
  /* this is essentially s7_call with a dynamic-wind wrapper around "body" */
  s7_pointer p;
  declare_jump_info();

  sc->temp1 = ((init == sc->F) ? finish : init);
  sc->temp2 = body;

  store_jump_info(sc);
  set_jump_info(sc, DYNAMIC_WIND_SET_JUMP);
  if (jump_loc != NO_JUMP)
    {
      if (jump_loc != ERROR_JUMP)
	eval(sc, sc->cur_op);
    }
  else
    {
      push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
      sc->args = sc->nil;

      new_cell(sc, p, T_DYNAMIC_WIND);
      dynamic_wind_in(p) = T_Pos(init);
      dynamic_wind_body(p) = T_Pos(body);
      dynamic_wind_out(p) = T_Pos(finish);
      push_stack(sc, OP_DYNAMIC_WIND, sc->nil, p);
      if (init != sc->F)
	{
	  dynamic_wind_state(p) = DWIND_INIT;
	  sc->code = init;
	}
      else
	{
	  dynamic_wind_state(p) = DWIND_BODY;
	  sc->code = body;
	}
      eval(sc, OP_APPLY);
    }
  restore_jump_info(sc);
  sc->temp1 = sc->nil;
  sc->temp2 = sc->nil;

  if (is_multiple_value(sc->value))
    sc->value = splice_in_values(sc, multiple_value(sc->value));
 return(sc->value);
}


/* -------------------------------- catch -------------------------------- */
static s7_pointer g_catch(s7_scheme *sc, s7_pointer args)
{
  #define H_catch "(catch tag thunk handler) evaluates thunk; if an error occurs that matches the tag (#t matches all), the handler is called"
  #define Q_catch s7_make_signature(sc, 4, sc->values_symbol, s7_make_signature(sc, 2, sc->is_symbol_symbol, sc->is_boolean_symbol), sc->is_procedure_symbol, sc->is_procedure_symbol)

  s7_pointer p, proc, err;

  /* Guile sets up the catch before looking for arg errors:
   *   (catch #t log (lambda args "hiho")) -> "hiho"
   * which is consistent in that (catch #t (lambda () (log))...) should probably be the same as (catch #t log ...)
   * but what if the error handler arg is messed up?  Weird to handle args in reverse order with an intervening frame etc.
   */

  proc = cadr(args);
  err = caddr(args);
  /* if (is_let(err)) check_method(sc, err, sc->catch_symbol, args); */ /* causes exit from s7! */

  new_cell(sc, p, T_CATCH);
  catch_tag(p) = car(args);
  catch_goto_loc(p) = s7_stack_top(sc);
  catch_op_loc(p) = (int32_t)(sc->op_stack_now - sc->op_stack);
  catch_set_handler(p, err);

  if (is_any_macro(err))
    push_stack(sc, OP_CATCH_2, args, p);
  else push_stack(sc, OP_CATCH, args, p);      /* args ignored but maybe safer for GC? */

  /* not sure about these error checks -- they can be omitted */
  if (!is_thunk(sc, proc))
    return(wrong_type_argument_with_type(sc, sc->catch_symbol, 2, proc, a_thunk_string));

  if (!is_applicable(err))
    return(wrong_type_argument_with_type(sc, sc->catch_symbol, 3, err, something_applicable_string));

  /* should we check here for (aritable? err 2)?
   *  (catch #t (lambda () 1) "hiho") -> 1
   * currently this is checked only if the error handler is called
   */

  if (is_closure(proc))                        /* not also lambda* here because we need to handle the arg defaults */
    {
      /* is_thunk above checks is_aritable(proc, 0), but if it's (lambda args ...) we have to set up the frame with args=()
       *    the case that caught this: (catch #t make-hook ...)
       */
      sc->code = closure_body(proc);
      if (is_symbol(closure_args(proc)))
	new_frame_with_slot(sc, closure_let(proc), sc->envir, closure_args(proc), sc->nil);
      else new_frame(sc, closure_let(proc), sc->envir);
      push_stack_no_args(sc, sc->begin_op, T_Pair(sc->code));
    }
  else push_stack(sc, OP_APPLY, sc->nil, proc);

  return(sc->F);
}

static void op_c_catch(s7_scheme *sc)
{
  /* (catch #t (lambda () (set! ("hi") #\a)) (lambda args args))
   *    code is (catch #t (lambda () ....) (lambda args ....))
   */
  s7_pointer p, f, args, tag;
  set_current_code(sc, sc->code);
  args = cddr(sc->code);

  /* defer making the error lambda */
  /* check catch tag */
  f = cadr(sc->code);
  if (!is_pair(f))                     /* (catch #t ...) or (catch sym ...) */
    {
      if (is_symbol(f))
	tag = lookup_checked(sc, f);
      else tag = f;
    }
  else tag = cadr(f);                  /* (catch 'sym ...) */

  new_cell(sc, p, T_CATCH);            /* the catch object sitting on the stack */
  catch_tag(p) = tag;
  catch_goto_loc(p) = s7_stack_top(sc);
  catch_op_loc(p) = sc->op_stack_now - sc->op_stack;
  catch_set_handler(p, cdadr(args));       /* not yet a closure... */

  push_stack(sc, OP_CATCH_1, sc->code, p); /* code ignored here, except by GC */
  new_frame(sc, sc->envir, sc->envir);
  sc->code = T_Pair(cddar(args));
}


/* -------------------------------- owlet -------------------------------- */
/* error reporting info -- save filename and line number */

static s7_pointer init_owlet(s7_scheme *sc)
{
  s7_pointer e;
  e = new_frame_in_env(sc, sc->rootlet);
  sc->temp3 = e;
  sc->error_type = make_slot_1(sc, e, make_symbol(sc, "error-type"), sc->F);  /* the error type or tag ('division-by-zero) */
  sc->error_data = make_slot_1(sc, e, make_symbol(sc, "error-data"), sc->F);  /* the message or information passed by the error function */
  sc->error_code = make_slot_1(sc, e, make_symbol(sc, "error-code"), sc->F);  /* the code that s7 thinks triggered the error */
  sc->error_line = make_slot_1(sc, e, make_symbol(sc, "error-line"), sc->F);  /* the line number of that code */
  sc->error_file = make_slot_1(sc, e, make_symbol(sc, "error-file"), sc->F);  /* the file name of that code */
#if WITH_HISTORY
  sc->error_history = make_slot_1(sc, e, make_symbol(sc, "error-history"), sc->F); /* buffer of previous evaluations */
#endif
  sc->temp3 = sc->nil;
  return(e);
}

static bool type_is_bad(s7_pointer p)
{
  return((is_free(p)) || (unchecked_type(p) >= NUM_TYPES)); /* type is unsigned */
}

static s7_pointer g_owlet(s7_scheme *sc, s7_pointer args)
{
#if WITH_HISTORY
  #define H_owlet "(owlet) returns the environment at the point of the last error. \
It has the additional local variables: error-type, error-data, error-code, error-line, error-file, and error-history."
#else
  #define H_owlet "(owlet) returns the environment at the point of the last error. \
It has the additional local variables: error-type, error-data, error-code, error-line, and error-file."
#endif
  #define Q_owlet s7_make_signature(sc, 1, sc->is_let_symbol)
  /* if owlet is not copied, (define e (owlet)), e changes as owlet does! */

  s7_pointer e, x;
  s7_int gc_loc;

  /* since error-data et al can be set at any time, and owlet can be called at any time, these fields
   *   can be free cells (or anything) without that representing an error. So, before copying, we need
   *   to check that all cells (that will be copied) look ok.
   */
  for (x = let_slots(sc->owlet); tis_slot(x); x = next_slot(x))
    {
      s7_pointer val;
      val = unchecked_slot_value(x);
      if (type_is_bad(val))
	slot_set_value(x, sc->F);
    }

  e = let_copy(sc, sc->owlet);
  gc_loc = s7_gc_protect_1(sc, e);

  for (x = let_slots(e); tis_slot(x); x = next_slot(x))
    {
      s7_pointer val;
      val = unchecked_slot_value(x);
      if (type_is_bad(val))
	slot_set_value(x, sc->F);
      else
	{
	  if (is_pair(val))
	    {
	      s7_pointer slow;
	      slow = val;
	      while (true)
		{
		  if ((type_is_bad(car(val))) ||
		      (type_is_bad(cdr(val))))
		    {
		      slot_set_value(x, sc->F);
		      break;
		    }
		  val = cdr(val);
		  if (type_is_bad(val))
		    {
		      slot_set_value(x, sc->F);
		      break;
		    }
		  if (is_pair(val))
		    {
		      if ((type_is_bad(car(val))) ||
			  (type_is_bad(cdr(val))))
			{
			  slot_set_value(x, sc->F);
			  break;
			}
		      slow = cdr(slow);
		      if (slow == val)
			break;
		      val = cdr(val);
		    }
		  else break;
		}
	    }
	}
    }

  /* make sure the pairs/reals/strings/integers are copied: should be error-data, error-code, and possibly error-history */
  sc->gc_off = true;

  for (x = let_slots(e); tis_slot(x); x = next_slot(x))
    if (is_pair(slot_value(x)))
      {
	s7_pointer new_list, p, sp;
	new_list = protected_list_copy(sc, slot_value(x));
	slot_set_value(x, new_list);
	for (p = new_list, sp = p; is_pair(p); p = cdr(p), sp = cdr(sp))
	  {
	    s7_pointer val;
	    val = car(p);
	    if (is_t_real(val))
	      set_car(p, make_real(sc, real(val)));
	    else
	      {
		if (is_string(val))
		  set_car(p, make_string_with_length(sc, string_value(val), string_length(val)));
		else
		  {
		    if (is_t_integer(val))
		      set_car(p, make_integer(sc, integer(val)));
		  }
	      }
	    p = cdr(p);
	    if ((!is_pair(p)) || (p == sp)) break;
	    val = car(p);
	    if (is_t_real(val))
	      set_car(p, make_real(sc, real(val)));
	    else
	      {
		if (is_string(val))
		  set_car(p, make_string_with_length(sc, string_value(val), string_length(val)));
	      }
	  }
      }
  sc->gc_off = false;
  s7_gc_unprotect_at(sc, gc_loc);
  return(e);
}

static s7_pointer active_catches(s7_scheme *sc)
{
  int64_t i;
  s7_pointer x, lst;
  lst = sc->nil;
  for (i = s7_stack_top(sc) - 1; i >= 3; i -= 4)
    switch (stack_op(sc->stack, i))
      {
      case OP_CATCH_ALL:
	lst = cons(sc, sc->T, lst);
	break;

      case OP_CATCH_2:
      case OP_CATCH_1:
      case OP_CATCH:
	x = stack_code(sc->stack, i);
	lst = cons(sc, catch_tag(x), lst);
	break;
      }
  return(reverse_in_place_unchecked(sc, sc->nil, lst));
}

static s7_pointer stack_entries(s7_scheme *sc, s7_pointer stack, int64_t top)
{
  int64_t i;
  s7_pointer lst;
  lst = sc->nil;
  for (i = top - 1; i >= 3; i -= 4)
    {
      s7_pointer func, args, e;
      opcode_t op;
      func = stack_code(stack, i);
      args = stack_args(stack, i);
      e = stack_let(stack, i);
      op = stack_op(stack, i);
      if ((s7_is_valid(sc, func)) &&
	  (s7_is_valid(sc, args)) &&
	  (s7_is_valid(sc, e)) &&
	  (op < OP_MAX_DEFINED))
	{
#if S7_DEBUGGING
	  if (op < OP_MAX_DEFINED_1)
	    lst = cons(sc, list_4(sc, func, args, e, s7_make_string_wrapper(sc, op_names[op])), lst);
	  else lst = cons(sc, list_4(sc, func, args, e, make_integer(sc, op)), lst);
#else
	  lst = cons(sc, list_4(sc, func, args, e, make_integer(sc, op)), lst);
#endif
	  sc->w = lst;
	}
    }
  return(reverse_in_place_unchecked(sc, sc->nil, lst));
}


/* catch handlers */
/* here and below, don't free the catcher */

static bool catch_all_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  s7_pointer catcher;
  catcher = stack_let(sc->stack, i);
  sc->value = stack_args(sc->stack, i);
  sc->op_stack_now = (s7_pointer *)(sc->op_stack + catch_all_op_loc(catcher));
  sc->stack_end = (s7_pointer *)(sc->stack_start + catch_all_goto_loc(catcher));
  pop_stack(sc);
  if (is_pair(sc->value))
    {
      if (car(sc->value) == sc->quote_symbol)
	sc->value = cadr(sc->value);
      else sc->value = type;
    }
  else
    {
      if (is_symbol(sc->value))
	sc->value = type;
    }
  return(true);
}

static bool catch_2_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  /* this is the macro-error-handler case from g_catch
   *    (let () (define-macro (m . args) (apply (car args) (cadr args))) (catch #t (lambda () (error abs -1)) m))
   */
  s7_pointer x;
  x = stack_code(sc->stack, i);
  if ((catch_tag(x) == sc->T) ||
      (catch_tag(x) == type) ||
      (type == sc->T))
    {
      int64_t loc;
      loc = catch_goto_loc(x);
      sc->op_stack_now = (s7_pointer *)(sc->op_stack + catch_op_loc(x));
      sc->stack_end = (s7_pointer *)(sc->stack_start + loc);
      sc->code = catch_handler(x);

      if (needs_copied_args(sc->code))
	sc->args = list_2(sc, type, info);
      else           /* very unlikely: need c_macro as error catcher: (catch #t (lambda () (error 'oops)) require) */
	{
	  set_car(sc->t2_1, type);
	  set_car(sc->t2_2, info);
	  sc->args = sc->t2_1;
	}
      sc->cur_op = OP_APPLY;
      return(true);
    }
  return(false);
}

static bool catch_1_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  s7_pointer x;
  x = stack_code(sc->stack, i);
  if ((catch_tag(x) == sc->T) ||
      (catch_tag(x) == type) ||
      (type == sc->T))
    {
      uint64_t loc;
      opcode_t op;
      s7_pointer catcher, error_func, error_body, error_args;

      op = stack_op(sc->stack, i);
      sc->temp4 = stack_let(sc->stack, i); /* GC protect this, since we're moving the stack top below */
      catcher = x;
      loc = catch_goto_loc(catcher);
      sc->op_stack_now = (s7_pointer *)(sc->op_stack + catch_op_loc(catcher));
      sc->stack_end = (s7_pointer *)(sc->stack_start + loc);
      error_func = catch_handler(catcher);

      /* very often the error handler just returns either a constant ('error or #f), or
       *   the args passed to it, so there's no need to laboriously make a closure,
       *   and apply it -- just set sc->value to the closure body (or the args) and return.
       * so first examine closure_body(error_func)
       *   if it is a constant, or quoted symbol, return that,
       *   if it is the args symbol, return (list type info)
       */

      /* if OP_CATCH_1, we deferred making the error handler until it is actually needed */
      if (op == OP_CATCH_1)
	{
	  error_body = cdr(error_func);
	  error_args = car(error_func);
	}
      else
	{
	  if (is_closure(error_func))
	    {
	      error_body = closure_body(error_func);
	      error_args = closure_args(error_func);
	    }
	  else
	    {
	      error_body = NULL;
	      error_args = NULL;
	    }
	}

      if ((error_body) && (is_null(cdr(error_body))))
	{
	  s7_pointer y = NULL;
	  error_body = car(error_body);
	  if (is_pair(error_body))
	    {
	      if (car(error_body) == sc->quote_symbol)
		y = cadr(error_body);
	      else
		{
		  if ((car(error_body) == sc->car_symbol) &&
		      (cadr(error_body) == error_args))
		    y = type;
		}
	    }
	  else
	    {
	      if (is_symbol(error_body))
		{
		  if (error_body == error_args)
		    y = list_2(sc, type, info);
		  else
		    {
		      if ((is_pair(error_args)) &&
			  (error_body == car(error_args)))
			y = type;
		    }
		}
	      else y = error_body; /* not pair or symbol */
	    }
	  if (y)
	    {
	      if (loc > 4)
		pop_stack(sc);
	      /* we're at OP_CATCH, normally we want to pop that away, but (handwaving...) if we're coming
	       *   from s7_eval (indirectly perhaps through s7_eval_c_string), we might push the OP_EVAL_DONE
	       *   to end that call, but it's pushed at the precatch stack end (far beyond the catch loc).
	       *   If we catch an error, catch unwinds to its starting point, and the pop_stack above
	       *   puts us at the bottom of the stack (i.e. stack_end == stack_start), OP_EVAL_DONE.
	       *   Now we return true, ending up back in eval, because the error handler jumped out of eval,
	       *   back to wherever we were in eval when we hit the error.  eval jumps back to the start
	       *   of its loop, and pops the stack to see what to do next!  So the (loc > 4) at least
	       *   protects against stack underflow, but ideally we'd know we came from OP_CATCH+s7_eval.
	       *   We can't do anything fancy here because we have to unwind the C stack as well as s7's stack.
	       *   s7_eval doesn't know anything about the catches on the stack.  We can't look back for
	       *   OP_EVAL_DONE -- segfault in OP_BEGIN.  Hmmmm.  Perhaps catch should not unwind until the
	       *   end?  But we want the error handler to run as a part of the calling expression, and
	       *   in any case the OP_EVAL_DONE is not useful (it marks the end of the no-error case).
	       */
	      sc->value = y;
	      sc->temp4 = sc->nil;

	      if (loc == 4)
		sc->code = cons(sc, sc->value, sc->nil); /* if we end up at op_begin, give it something it can handle */

	      return(true);
	    }
	}
      if (op == OP_CATCH_1)
	{
	  s7_pointer p;
	  new_cell(sc, p, T_CLOSURE | T_COPY_ARGS); /* never a safe_closure, apparently */
	  closure_set_args(p, car(error_func));
	  closure_set_body(p, cdr(error_func));
	  closure_set_setter(p, sc->F);
	  closure_set_arity(p, CLOSURE_ARITY_NOT_SET);
	  closure_set_let(p, sc->temp4);
	  sc->code = p;
	}
      else sc->code = error_func;
      sc->temp4 = sc->nil;

      /* if user (i.e. yers truly!) copies/pastes the preceding lambda () into the
       *   error handler portion of the catch, he gets the inexplicable message:
       *       ;(): too many arguments: (a1 ())
       *   when this apply tries to call the handler.  So, we need a special case error check here!
       */

      if (!s7_is_aritable(sc, sc->code, 2))
	s7_wrong_number_of_args_error(sc, "catch error handler should accept 2 args: ~S", sc->code);

      sc->args = list_2(sc, type, info); /* almost never able to skip this -- costs more to check! */
      sc->cur_op = OP_APPLY;
      /* explicit eval needed if s7_call called into scheme where a caught error occurred (ex6 in exs7.c)
       *  but putting it here (via eval(sc, OP_APPLY)) means the C stack is not cleared correctly in non-s7-call cases,
       *  so defer it until s7_call
       */
      return(true);
    }
  return(false);
}

static bool catch_dw_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  s7_pointer x;
  x = stack_code(sc->stack, i);
  if (dynamic_wind_state(x) == DWIND_BODY)
    {
      dynamic_wind_state(x) = DWIND_FINISH;    /* make sure an uncaught error in the exit thunk doesn't cause us to loop */
      if (dynamic_wind_out(x) != sc->F)
	{
	  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
	  sc->code = dynamic_wind_out(x);
	  sc->args = sc->nil;
	  eval(sc, OP_APPLY);                  /* I guess this means no call/cc out of the exit thunk in an error-catching context */
	}
    }
  return(false);
}

static bool catch_out_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  s7_pointer x;
  x = stack_code(sc->stack, i);                /* "code" = port that we opened */
  s7_close_output_port(sc, x);
  x = stack_args(sc->stack, i);                /* "args" = port that we shadowed, if not #<unused> */
  if (x != sc->unused)
    sc->output_port = x;
  return(false);
}

static bool catch_in_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  s7_close_input_port(sc, stack_code(sc->stack, i)); /* "code" = port that we opened */
  sc->input_port = stack_args(sc->stack, i);         /* "args" = port that we shadowed */
  return(false);
}

static bool catch_read_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  pop_input_port(sc);
  return(false);
}

static bool catch_eval_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  s7_close_input_port(sc, sc->input_port);
  pop_input_port(sc);
  return(false);
}

static bool catch_barrier_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  if (is_input_port(stack_args(sc->stack, i)))      /* (eval-string "'(1 .)") */
    {
      if (sc->input_port == stack_args(sc->stack, i))
	pop_input_port(sc);
      s7_close_input_port(sc, stack_args(sc->stack, i));
    }
  return(false);
}

static bool catch_hook_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  sc->error_hook = stack_code(sc->stack, i);
  /* apparently there was an error during *error-hook* evaluation, but Rick wants the hook re-established anyway */
  (*reset_hook) = true;
  /* avoid infinite loop -- don't try to (re-)evaluate (buggy) *error-hook*! */
  return(false);
}

static bool catch_goto_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  call_exit_active(stack_args(sc->stack, i)) = false;
  return(false);
}

static bool catch_let_temporarily_function(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook)
{
  let_temp_done(sc, stack_args(sc->stack, i), stack_code(sc->stack, i), stack_let(sc->stack, i));
  return(false);
}

typedef bool (*catch_function)(s7_scheme *sc, s7_int i, s7_pointer type, s7_pointer info, bool *reset_hook);
static catch_function catchers[OP_MAX_DEFINED + 1];

static void init_catchers(void)
{
  int32_t i;
  for (i = 0; i <= OP_MAX_DEFINED; i++) catchers[i] = NULL;
  catchers[OP_CATCH_ALL] =         catch_all_function;
  catchers[OP_CATCH_2] =           catch_2_function;
  catchers[OP_CATCH_1] =           catch_1_function;
  catchers[OP_CATCH] =             catch_1_function;
  catchers[OP_DYNAMIC_WIND] =      catch_dw_function;
  catchers[OP_GET_OUTPUT_STRING] = catch_out_function;
  catchers[OP_UNWIND_OUTPUT] =     catch_out_function;
  catchers[OP_UNWIND_INPUT] =      catch_in_function;
  catchers[OP_READ_DONE] =         catch_read_function;      /* perhaps an error during (read) */
  catchers[OP_EVAL_STRING] =       catch_eval_function;
  catchers[OP_BARRIER] =           catch_barrier_function;
  catchers[OP_DEACTIVATE_GOTO] =   catch_goto_function;
  catchers[OP_LET_TEMP_DONE] =     catch_let_temporarily_function;
  catchers[OP_ERROR_HOOK_QUIT] =   catch_hook_function;
}

/* -------------------------------- throw -------------------------------- */
static s7_pointer g_throw(s7_scheme *sc, s7_pointer args)
{
  #define H_throw "(throw tag . info) is like (error ...) but it does not affect the owlet. \
It looks for an existing catch with a matching tag, and jumps to it if found.  Otherwise it raises an error."
  #define Q_throw s7_make_circular_signature(sc, 1, 2, sc->values_symbol, sc->T)

  bool ignored_flag = false;
  int64_t i;
  s7_pointer type, info;

  type = car(args);
  info = cdr(args);

  /* look for a catcher */
  for (i = s7_stack_top(sc) - 1; i >= 3; i -= 4)
    {
      catch_function catcher;
      catcher = catchers[stack_op(sc->stack, i)];
      if ((catcher) &&
	  (catcher(sc, i, type, info, &ignored_flag)))
	{
	  if (sc->longjmp_ok) longjmp(sc->goto_start, THROW_JUMP);
	  return(sc->value);
	}
    }
  if (is_let(car(args)))
    check_method(sc, car(args), sc->throw_symbol, args);
  return(s7_error(sc, make_symbol(sc, "uncaught-throw"),
		  set_elist_3(sc, wrap_string(sc, "no catch found for (throw ~W~{~^ ~S~})", 38), type, info)));
}

static void s7_warn(s7_scheme *sc, s7_int len, const char *ctrl, ...) /* len = max size of output string (for vsnprintf) */
{
  if (sc->error_port != sc->F)
    {
      va_list ap;
      s7_pointer warning;
      char *str;

      warning = make_empty_string(sc, len * sizeof(char), 0);
      string_value(warning)[0] = '\0';
      str = (char *)string_value(warning);
      va_start(ap, ctrl);
      vsnprintf(str, len, ctrl, ap);
      va_end(ap);

      if (port_is_closed(sc->error_port))
	sc->error_port = sc->standard_error;
      s7_display(sc, warning, sc->error_port);
    }
}

static void fill_error_location(s7_scheme *sc)
{
  if (in_reader(sc))
    {
      slot_set_value(sc->error_line, wrap_integer3(sc, port_line_number(sc->input_port)));
      slot_set_value(sc->error_file, wrap_string(sc, port_filename(sc->input_port), port_filename_length(sc->input_port)));
    }
  else
    {
      slot_set_value(sc->error_line, sc->F);
      slot_set_value(sc->error_file, sc->F);
    }
}

s7_pointer s7_error(s7_scheme *sc, s7_pointer type, s7_pointer info)
{
  bool reset_error_hook = false;
  s7_pointer cur_code;

  /* type is a symbol normally, and info is compatible with format: (apply format #f info) --
   *    car(info) is the control string, cdr(info) its args
   *    type/range errors have cadr(info)=caller, caddr(info)=offending arg number
   *    null info can mean symbol table is locked so make-symbol uses s7_error to get out
   *
   * set up (owlet), look for a catch that matches 'type', if found
   *   call its error-handler, else if *error-hook* is bound, call it,
   *   else send out the error info ourselves.
   */
  sc->format_depth = -1;
  sc->gc_off = false;             /* this is in case we were triggered from the sort function -- clumsy! */
  sc->object_out_locked = false;  /* possible error in obj->str method after object_out has set this flag */
  sc->has_openlets = true;        /*   same problem -- we need a cleaner way to handle this */

  if (sc->current_safe_list > 0)
    {
      clear_list_in_use(sc->safe_lists[sc->current_safe_list]);
      sc->current_safe_list = 0;
    }
  slot_set_value(sc->error_type, type);
  slot_set_value(sc->error_data, info);

  if ((unchecked_type(sc->envir) != T_LET) &&
      (sc->envir != sc->nil))
    sc->envir = sc->nil;          /* in reader, the envir frame is mostly ignored so it can be (and usually is) garbage */

  set_outlet(sc->owlet, sc->envir);

  cur_code = current_code(sc);
  slot_set_value(sc->error_code, cur_code);
#if WITH_HISTORY
  slot_set_value(sc->error_history, sc->cur_code);
  sc->cur_code = (sc->using_history1) ? sc->eval_history2 : sc->eval_history1;
  sc->using_history1 = (!sc->using_history1);
#endif

  if ((is_pair(cur_code)) &&     /* can be () if unexpected close paren read error */
      (has_line_number(cur_code)))
    {
      int32_t line;
      line = (int32_t)pair_line(cur_code); /* cast to int32_t (from uint32_t) for sc->last_error_line */
      if (line != sc->last_error_line)
	{
	  int32_t file;
	  sc->last_error_line = line;
	  file = (int32_t)pair_file(cur_code);
#if S7_DEBUGGING
	  if (file > sc->file_names_top)
	    {
	      char *s;
	      fprintf(stderr, "line_number file: %d (top: %d), bits: %s\n", file, sc->file_names_top, s = describe_type_bits(sc, cur_code));
	      free(s);
	      if (stop_at_error) abort();
	    }
#endif
	  if ((line > 0) &&
	      (file >= 0) &&
	      (file <= sc->file_names_top))
	    {
	      slot_set_value(sc->error_line, wrap_integer3(sc, line));
	      slot_set_value(sc->error_file, sc->file_names[file]);
	    }
	  else fill_error_location(sc);
	}
    }
  else fill_error_location(sc);

  { /* look for a catcher */
    int64_t i;
    /* top is 1 past actual top, top - 1 is op, if op = OP_CATCH, top - 4 is the cell containing the catch struct */
    for (i = s7_stack_top(sc) - 1; i >= 3; i -= 4)
      {
	catch_function catcher;
	/* fprintf(stderr, "catch %s\n", op_names[stack_op(sc->stack, i)]); */
	catcher = catchers[stack_op(sc->stack, i)];
	if ((catcher) &&
	    (catcher(sc, i, type, info, &reset_error_hook)))
	  {
	    if (sc->longjmp_ok) longjmp(sc->goto_start, CATCH_JUMP);
	    /* all the rest of the code expects s7_error to jump, not return, so presumably if we get here, we're in trouble */
#if S7_DEBUGGING
	    fprintf(stderr, "fall through in s7_error!\n");
#endif
	  }
      }
  }

  /* error not caught */
  /* (set! *error-hook* (list (lambda (hook) (apply format #t (hook 'args))))) */

  if ((!reset_error_hook) &&
      (is_procedure(sc->error_hook)) &&
      (hook_has_functions(sc->error_hook)))
    {
      s7_pointer error_hook_func;
      /* (set! (hook-functions *error-hook*) (list (lambda (h) (format *stderr* "got error ~A~%" (h 'args))))) */

      error_hook_func = sc->error_hook;
      sc->error_hook = sc->nil;
      /* if the *error-hook* functions trigger an error, we had better not have *error-hook* still set! */

      push_stack(sc, OP_ERROR_HOOK_QUIT, sc->nil, error_hook_func); /* restore *error-hook* upon successful (or any!) evaluation */
      sc->code = error_hook_func;
      sc->args = list_2(sc, type, info);

      /* if we drop into the longjmp below, the hook functions are not called!
       *   OP_ERROR_HOOK_QUIT performs the longjmp, so it should be safe to go to eval.
       */
      eval(sc, OP_APPLY);
    }
  else
    {
      s7_int op;
      op = sc->print_length;
      if (op < 32) sc->print_length = 32;

      if ((!is_output_port(sc->error_port)) || /* error-port can be #f */
	  (port_is_closed(sc->error_port)))
	sc->error_port = sc->standard_error;
      /* if info is not a list, send object->string to current error port,
       *   else assume car(info) is a format control string, and cdr(info) are its args
       * if at all possible, get some indication of where we are!
       */
      if ((!is_list(info)) ||
	  (!is_string(car(info))))
	format_to_port(sc, sc->error_port, "\n;~S ~S", set_plist_2(sc, type, info), NULL, false, 7);
      else
	{
	  /* it's possible that the error string is just a string -- not intended for format */
	  if ((type != sc->format_error_symbol) &&      /* avoid an infinite loop of format errors */
	      (strchr(string_value(car(info)), '~')))
	    {
	      char *errstr;
	      block_t *b;
	      s7_int len, str_len;
	      len = string_length(car(info)) + 8;
	      b = mallocate(sc, len);
	      errstr = (char *)block_data(b);
	      str_len = catstrs_direct(errstr, "\n;", string_value(car(info)), NULL);
	      format_to_port(sc, sc->error_port, errstr, cdr(info), NULL, false, str_len);
	      liberate(sc, b);
	    }
	  else format_to_port(sc, sc->error_port, "\n;~S ~S", set_plist_2(sc, type, info), NULL, false, 7); /* 7 = ctrl str len */
	}
      if (op < 32) sc->print_length = op;

      /* now display location at end */

      if ((is_input_port(sc->input_port)) &&
	  (port_file(sc->input_port) != stdin) &&
	  (!port_is_closed(sc->input_port)))
	{
	  const char *filename;
	  int32_t line;

	  filename = port_filename(sc->input_port);
	  line = port_line_number(sc->input_port);

	  if (filename)
	    format_to_port(sc, sc->error_port, "\n;  ~A[~D]",
			   set_plist_2(sc, wrap_string(sc, filename, port_filename_length(sc->input_port)),
				       wrap_integer3(sc, line)), NULL, false, 10);
	  else
	    {
	      if ((line > 0) &&
		  (slot_value(sc->error_line) != sc->F))
		format_to_port(sc, sc->error_port, "\n;  line ~D", set_plist_1(sc, wrap_integer3(sc, line)), NULL, false, 11);
	      else
		{
		  if (is_pair(sc->input_port_stack))
		    {
		      s7_pointer p;
		      p = car(sc->input_port_stack);
		      if ((is_input_port(p)) &&
			  (port_file(p) != stdin) &&
			  (!port_is_closed(p)))
			{
			  filename = port_filename(p);
			  line = port_line_number(p);
			  if (filename)
			    format_to_port(sc, sc->error_port, "\n;  ~A[~D]",
					   set_plist_2(sc, wrap_string(sc, filename, port_filename_length(sc->input_port)),
						       wrap_integer3(sc, line)), NULL, false, 10);
			}}}}
	}
      else
	{
	  const char *call_name;
	  call_name = sc->s7_call_name;
	  if (call_name)
	    {
	      sc->s7_call_name = NULL;
	      if ((sc->s7_call_file) &&
		  (sc->s7_call_line >= 0))
		{
		  format_to_port(sc, sc->error_port, "\n;  ~A ~A[~D]",
				 set_plist_3(sc,
					     s7_make_string_wrapper(sc, call_name),
					     s7_make_string_wrapper(sc, sc->s7_call_file),
					     make_integer(sc, sc->s7_call_line)),
				 NULL, false, 13);
		}
	    }
	}
      s7_newline(sc, sc->error_port);

      if (is_string(slot_value(sc->error_file)))
	{
	  format_to_port(sc, sc->error_port, ";    ~S, line ~D",
			 set_plist_2(sc, slot_value(sc->error_file),	slot_value(sc->error_line)),
			 NULL, false, 16);
	  s7_newline(sc, sc->error_port);
	}

      /* look for __func__ in the error environment etc */
      if (sc->error_port != sc->F)
	{
	  s7_pointer errp;
	  errp = stacktrace_1(sc,
			      s7_integer(car(sc->stacktrace_defaults)),
			      s7_integer(cadr(sc->stacktrace_defaults)),
			      s7_integer(caddr(sc->stacktrace_defaults)),
			      s7_integer(cadddr(sc->stacktrace_defaults)),
			      s7_boolean(sc, s7_list_ref(sc, sc->stacktrace_defaults, 4)));
	  if (string_length(errp) > 0)
	    {
	      port_write_string(sc->error_port)(sc, ";\n", 2, sc->error_port);
	      port_write_string(sc->error_port)(sc, string_value(errp), string_length(errp), sc->error_port);
	      port_write_character(sc->error_port)(sc, '\n', sc->error_port);
	    }
	}
      else
	{
	  if (is_pair(slot_value(sc->error_code)))
	    {
	      format_to_port(sc, sc->error_port, ";    ~S", set_plist_1(sc, slot_value(sc->error_code)), NULL, false, 7);
	      s7_newline(sc, sc->error_port);
	    }
	}

      /* if (is_continuation(type))
       *   go into repl here with access to continuation?  Or expect *error-handler* to deal with it?
       */
      sc->value = type;
      /* stack_reset(sc); */
      sc->cur_op = OP_ERROR_QUIT;
    }

  if (sc->longjmp_ok) longjmp(sc->goto_start, ERROR_JUMP);
  return(type);
}

static s7_pointer apply_error(s7_scheme *sc, s7_pointer obj, s7_pointer args)
{
  /* the operator type is needed here else the error message is confusing:
   *    (apply '+ (list 1 2))) -> ;attempt to apply + to (1 2)?
   */
  if (is_null(obj))
    return(s7_error(sc, sc->syntax_error_symbol,
		    set_elist_3(sc, wrap_string(sc, "attempt to apply nil to ~S in ~S?", 33),
				args, current_code(sc))));
  return(s7_error(sc, sc->syntax_error_symbol,
		  set_elist_5(sc, wrap_string(sc, "attempt to apply ~A ~S to ~S in ~S?", 35),
			      type_name_string(sc, obj), obj, args, current_code(sc))));
}

static s7_pointer read_error_1(s7_scheme *sc, const char *errmsg, bool string_error)
{
  /* reader errors happen before the evaluator gets involved, so forms such as:
   *   (catch #t (lambda () (car '( . ))) (lambda arg 'error))
   * do not catch the error if we simply signal an error when we encounter it.
   */
  char *msg;
  s7_int len;
  s7_pointer pt;

  pt = sc->input_port;
  if (!string_error)
    {
      /* make an heroic effort to find where we slid off the tracks */

      if (is_string_port(sc->input_port))
	{
          #define QUOTE_SIZE 40
	  s7_int i, j, start = 0, end, slen, size;
	  char *recent_input = NULL;
	  s7_pointer p;

	  /* we can run off the end in cases like (eval-string "(. . ,.)") or (eval-string " (@ . ,.)") */
	  if (port_position(pt) >= port_data_size(pt))
	    port_position(pt) = port_data_size(pt) - 1;

	  /* start at current position and look back a few chars */
	  for (i = port_position(pt), j = 0; (i > 0) && (j < QUOTE_SIZE); i--, j++)
	    if ((port_data(pt)[i] == '\0') ||
		(port_data(pt)[i] == '\n') ||
		(port_data(pt)[i] == '\r'))
	      break;
	  start = i;

	  /* start at current position and look ahead a few chars */
	  size = port_data_size(pt);
	  for (i = port_position(pt), j = 0; (i < size) && (j < QUOTE_SIZE); i++, j++)
	    if ((port_data(pt)[i] == '\0') ||
		(port_data(pt)[i] == '\n') ||
		(port_data(pt)[i] == '\r'))
	      break;

	  end = i;
	  slen = end - start;
	  /* hopefully this is more or less the current line where the read error happened */

	  if (slen > 0)
	    {
	      recent_input = (char *)calloc((slen + 9), sizeof(char));
	      for (i = 0; i < (slen + 8); i++) recent_input[i] = '.';
	      recent_input[3] = ' ';
	      recent_input[slen + 4] = ' ';
	      for (i = 0; i < slen; i++) recent_input[i + 4] = port_data(pt)[start + i];
	    }

	  if ((port_line_number(pt) > 0) &&
	      (port_filename(pt)))
	    {
	      len = safe_strlen(recent_input) + safe_strlen(errmsg) + port_filename_length(pt) + safe_strlen(sc->current_file) + 64;
	      p = make_empty_string(sc, len, '\0');
	      msg = string_value(p);
	      len = snprintf(msg, len, "%s: %s %s[%u], last top-level form at: %s[%" print_s7_int "]",
			     errmsg, (recent_input) ? recent_input : "", port_filename(pt), port_line_number(pt),
			     sc->current_file, sc->current_line);
	    }
	  else
	    {
	      len = safe_strlen(recent_input) + safe_strlen(errmsg) + safe_strlen(sc->current_file) + 64;
	      p = make_empty_string(sc, len, '\0');
	      msg = string_value(p);
	      if ((sc->current_file) &&
		  (sc->current_line >= 0))
		len = snprintf(msg, len, "%s: %s, last top-level form at %s[%" print_s7_int "]",
			       errmsg, (recent_input) ? recent_input : "",
			       sc->current_file, sc->current_line);
	      else len = snprintf(msg, len, "%s: %s", errmsg, (recent_input) ? recent_input : "");
	    }

	  string_length(p) = len;
	  if (recent_input) free(recent_input);
	  return(s7_error(sc, sc->read_error_symbol, set_elist_1(sc, p)));
	}
    }

  if ((port_line_number(pt) > 0) &&
      (port_filename(pt)))
    {
      s7_pointer p;
      len = safe_strlen(errmsg) + port_filename_length(pt) + safe_strlen(sc->current_file) + 128;
      p = make_empty_string(sc, len, '\0');
      msg = string_value(p);
      if (string_error)
	len = snprintf(msg, len, "%s %s[%u],\n;  possible culprit: \"%s...\"\n;  last top-level form at %s[%" print_s7_int "]",
		       errmsg, port_filename(pt), port_line_number(pt),
		       sc->strbuf, sc->current_file, sc->current_line);
      else len = snprintf(msg, len, "%s %s[%u], last top-level form at %s[%" print_s7_int "]",
			  errmsg, port_filename(pt), port_line_number(pt),
			  sc->current_file, sc->current_line);
      string_length(p) = len;
      return(s7_error(sc, sc->read_error_symbol, set_elist_1(sc, p)));
    }
  return(s7_error(sc, (string_error) ? sc->string_read_error_symbol : sc->read_error_symbol, set_elist_1(sc, s7_make_string_wrapper(sc, (char *)errmsg))));
}

static s7_pointer read_error(s7_scheme *sc, const char *errmsg)
{
  return(read_error_1(sc, errmsg, false));
}

static s7_pointer string_read_error(s7_scheme *sc, const char *errmsg)
{
  return(read_error_1(sc, errmsg, true));
}

static s7_pointer g_error(s7_scheme *sc, s7_pointer args)
{
  #define H_error "(error type ...) signals an error.  The 'type' can be used with catch to trap \
particular errors.  If the error is not caught, s7 treats the second argument as a format control string, \
and applies it to the rest of the arguments."
  #define Q_error s7_make_circular_signature(sc, 1, 2, sc->values_symbol, sc->T)

  if (is_not_null(args))
    {
      if (is_string(car(args)))                     /* CL-style error? -- use tag = 'no-catch */
	{
	  s7_error(sc, sc->no_catch_symbol, args);  /* this can have trailing args (implicit format) */
	  return(sc->unspecified);
	}
      return(s7_error(sc, car(args), cdr(args)));
    }
  return(s7_error(sc, sc->nil, sc->nil));
}

static char *truncate_string(char *form, s7_int len, use_write_t use_write)
{
  uint8_t *f;
  f = (uint8_t *)form;

  if (use_write != P_DISPLAY)
    {
      /* I guess we need to protect the outer double quotes in this case */
      s7_int i;
      for (i = len - 5; i >= (len / 2); i--)
	if (is_white_space((int32_t)f[i]))
	  {
	    form[i] = '.'; form[i + 1] = '.'; form[i + 2] = '.'; form[i + 3] = '"'; form[i + 4] = '\0';
	    return(form);
	  }
      i = len - 5;
      if (i > 0)
	{
	  form[i] = '.'; form[i + 1] = '.'; form[i + 2] = '.'; form[i + 3] = '"'; form[i + 4] = '\0';
	}
      else
	{
	  if (len >= 2)
	    {
	      form[len - 1] = '"'; form[len] = '\0';
	    }
	}
    }
  else
    {
      s7_int i;
      for (i = len - 4; i >= (len / 2); i--)
	if (is_white_space((int32_t)f[i]))
	  {
	    form[i] = '.'; form[i + 1] = '.'; form[i + 2] = '.'; form[i + 3] = '\0';
	    return(form);
	  }
      i = len - 4;
      if (i >= 0)
	{
	  form[i] = '.'; form[i + 1] = '.'; form[i + 2] = '.'; form[i + 3] = '\0';
	}
      else form[len] = '\0';
    }
  return(form);
}

static s7_pointer object_to_truncated_string(s7_scheme *sc, s7_pointer p, s7_int len)
{
  char *s;
  s7_int s_len;
  s7_pointer strp;
  sc->objstr_max_len = len + 2;
  strp = s7_object_to_string(sc, p, false);
  s = string_value(strp);
  sc->objstr_max_len = s7_int_max;
  s_len = string_length(strp);
  if (s_len > len)
    truncate_string(s, len, P_DISPLAY);
  return(strp);
}

static s7_pointer tree_descend(s7_scheme *sc, s7_pointer p, uint32_t line)
{
  s7_pointer tp;
  if (!is_pair(p)) return(NULL);
  if (has_line_number(p))
    {
      uint32_t x;
      x = (uint32_t)pair_line(p);
      if (x > 0)
	{
	  if (line == 0) /* first line number we encounter will be the current reader location (i.e. the end of the form) */
	    line = x;
	  else
	    {
	      if (x < line)
		return(p);
	    }
	}
    }
  tp = tree_descend(sc, car(p), line);
  if (tp) return(tp);
  return(tree_descend(sc, cdr(p), line));
}

static s7_pointer missing_close_paren_error(s7_scheme *sc)
{
  s7_int len;
  char *msg, *syntax_msg = NULL;
  s7_pointer pt;

  if ((unchecked_type(sc->envir) != T_LET) &&
      (sc->envir != sc->nil))
    sc->envir = sc->nil;

  pt = sc->input_port;

  /* check *missing-close-paren-hook* */
  if (hook_has_functions(sc->missing_close_paren_hook))
    {
      s7_pointer result;
      if ((port_line_number(pt) > 0) &&
	  (port_filename(pt)))
	{
	  slot_set_value(sc->error_line, wrap_integer3(sc, port_line_number(pt)));
	  slot_set_value(sc->error_file, wrap_string(sc, port_filename(pt), port_filename_length(pt)));
	}
      result = s7_call(sc, sc->missing_close_paren_hook, sc->nil);
      if (result != sc->unspecified)
	return(g_throw(sc, list_1(sc, result)));
    }

  if (is_pair(sc->args))
    {
      s7_pointer p;
      p = tree_descend(sc, sc->args, 0);
      if ((p) && (is_pair(p)) &&
	  (has_line_number(p)))
	{
	  s7_int msg_len, form_len;
	  s7_pointer strp;
	  char *form;
	  strp = object_to_truncated_string(sc, p, 40);
	  form = string_value(strp);
	  form_len = string_length(strp);
	  msg_len = form_len + 128;
	  syntax_msg = (char *)malloc(msg_len * sizeof(char));
	  snprintf(syntax_msg, msg_len, ";  current form awaiting a close paren starts around line %u: %s", pair_line(p), form);
	}
    }

  if ((port_line_number(pt) > 0) &&
      (port_filename(pt)))
    {
      s7_pointer p;
      len = port_filename_length(pt) + safe_strlen(sc->current_file) + safe_strlen(syntax_msg) + 128;
      p = make_empty_string(sc, len, '\0');
      msg = string_value(p);
      if (syntax_msg)
	{
	  len = snprintf(msg, len, "missing close paren, %s[%u], last top-level form at %s[%" print_s7_int "]\n%s",
			 port_filename(pt), port_line_number(pt),
			 sc->current_file, sc->current_line, syntax_msg);
	  free(syntax_msg);
	}
      else len = snprintf(msg, len, "missing close paren, %s[%u], last top-level form at %s[%" print_s7_int "]",
			  port_filename(pt), port_line_number(pt),
			  sc->current_file, sc->current_line);
      string_length(p) = len;
      return(s7_error(sc, sc->read_error_symbol, set_elist_1(sc, p)));
    }

  if (syntax_msg)
    {
      s7_pointer p;
      len = safe_strlen(syntax_msg) + 128;
      p = make_empty_string(sc, len, '\0');
      msg = string_value(p);
      len = catstrs(msg, len, "missing close paren\n", syntax_msg, "\n", NULL);
      free(syntax_msg);
      string_length(p) = len;
      return(s7_error(sc, sc->read_error_symbol, set_elist_1(sc, p)));
    }

  if ((is_input_port(pt)) &&
      (!port_is_closed(pt)) &&
      (port_data(pt)) &&
      (port_position(pt) > 0))
    {
      s7_pointer p;
      s7_int start, pos;

      p = make_empty_string(sc, 128, '\0');
      msg = string_value(p);
      memcpy((void *)msg, (void *)"missing close paren: ", 21);

      pos = port_position(pt);
      start = pos - 40;
      if (start < 0) start = 0;
      memcpy((void *)(msg + 21), (void *)(port_data(pt) + start), pos - start);
      string_length(p) = 21 + pos - start;
      return(s7_error(sc, sc->read_error_symbol, set_elist_1(sc, p)));
    }
  return(s7_error(sc, sc->read_error_symbol, set_elist_1(sc, wrap_string(sc, "missing close paren", 19))));
}

static void improper_arglist_error(s7_scheme *sc)
{
  /* sc->code is the last (dotted) arg, sc->args is the arglist reversed not including sc->code
   *   the original was `(,@(reverse args) . ,code) essentially
   */
  if (sc->args == sc->nil)               /* (abs . 1) */
    s7_error(sc, sc->syntax_error_symbol, set_elist_1(sc, wrap_string(sc, "function call is a dotted list?", 31)));
  else s7_error(sc, sc->syntax_error_symbol,
		set_elist_2(sc, wrap_string(sc, "improper list of arguments: ~S", 30),
				append_in_place(sc, sc->args = safe_reverse_in_place(sc, sc->args), sc->code)));
}


/* -------------------------------- leftovers -------------------------------- */

void (*s7_begin_hook(s7_scheme *sc))(s7_scheme *sc, bool *val)
{
  return(sc->begin_hook);
}

void s7_set_begin_hook(s7_scheme *sc, void (*hook)(s7_scheme *sc, bool *val))
{
  sc->begin_hook = hook;
  sc->begin_op = (hook) ? OP_BEGIN0 : OP_BEGIN1;
}

static bool call_begin_hook(s7_scheme *sc)
{
  bool result = false;
  /* originally begin_hook was bool (*hook)(s7_scheme *sc): the value was returned directly,
   *   rather than going through a *bool arg (&result below).  That works in gcc (Linux/OSX),
   *   but does not work in MS Visual C++.  In the latter, the compiler apparently completely
   *   eliminates any local, returning (for example) a thread-relative stack-allocated value
   *   directly, but then by the time we get here, that variable has vanished, and we get
   *   garbage.  We had to thwart the optimization by adding if ((flag) && (!flag)) fprintf(...);
   *   So, in the new form (26-Jun-13), the value is passed directly into an s7 variable
   *   that I hope can't be optimized out of existence.
   */
  opcode_t op;
  op = sc->cur_op;

  push_stack(sc, OP_BARRIER, sc->args, sc->code);
  sc->begin_hook(sc, &result);
  if (result)
    {
      /* set (owlet) in case we were interrupted and need to see why something was hung */
      slot_set_value(sc->error_type, sc->F);
      slot_set_value(sc->error_data, sc->value); /* was sc->F but we now clobber this below */
      slot_set_value(sc->error_code, current_code(sc));
      slot_set_value(sc->error_line, sc->F);
      slot_set_value(sc->error_file, sc->F);
#if WITH_HISTORY
      slot_set_value(sc->error_history, sc->F);
#endif
      set_outlet(sc->owlet, sc->envir);

      sc->value = make_symbol(sc, "begin-hook-interrupt");
      /* otherwise the evaluator returns whatever random thing is in sc->value (normally #<closure>)
       *   which makes debugging unnecessarily difficult.
       */
      s7_quit(sc);     /* don't call gc here -- perhaps at restart somehow? */
      return(true);
    }
  pop_stack_no_op(sc);
  sc->cur_op = op;         /* for better error handling.  otherwise we get "barrier" as the offending function name in eval_error */
  return(false);
}


/* -------------------------------- apply -------------------------------- */
static s7_pointer apply_list_star(s7_scheme *sc, s7_pointer d)
{
  s7_pointer p, q;
  /* we check this ahead of time: if (is_null(cdr(d))) return(car(d)); */
  p = cons(sc, car(d), cdr(d));
  q = p;
  while (is_not_null(cddr(p)))
    {
      d = cdr(d);
      set_cdr(p, cons(sc, car(d), cdr(d)));
      if (is_not_null(cdr(d)))
	p = cdr(p);
    }
  set_cdr(p, cadr(p));
  return(q);
}

static s7_pointer apply_list_error(s7_scheme *sc, s7_pointer lst)
{
  return(s7_error(sc, sc->wrong_type_arg_symbol,
		  set_elist_2(sc, wrap_string(sc, "apply's last argument should be a proper list: ~S", 49), lst)));
}

static s7_pointer g_apply(s7_scheme *sc, s7_pointer args)
{
  #define H_apply "(apply func ...) applies func to the rest of the arguments"
  #define Q_apply s7_make_circular_signature(sc, 2, 3, sc->values_symbol, s7_make_signature(sc, 2, sc->is_procedure_symbol, sc->is_sequence_symbol), sc->T)

  /* can apply always be replaced with apply values?
   *   (apply + '(1 2 3)) is the same as (+ (apply values '(1 2 3)))
   * not if apply* in disguise, I think:
   *   (apply + 1 2 ()) -> 3
   *   (apply + 1 2 (apply values ())) -> error
   */
  sc->code = car(args);
  if (is_null(cdr(args)))
    {
      sc->args = sc->nil;
      push_stack(sc, OP_APPLY, sc->args, sc->code);
      return(sc->nil);
    }

  if (is_safe_procedure(sc->code))
    {
      s7_pointer p, q;

      for (q = args, p = cdr(args); is_not_null(cdr(p)); q = p, p = cdr(p));
      /* the last arg is supposed to be a list, it will be spliced onto the end of the previous arg list (if any) below */

      if (!s7_is_proper_list(sc, car(p)))        /* (apply + #f) etc */
	return(apply_list_error(sc, args));
      set_cdr(q, car(p));
      /* this would work: if (is_c_function(sc->code)) return(c_function_call(sc->code)(sc, cdr(args)));
       *   but it omits the arg number check, but if we copy the APPLY table here (returning sc->value)
       *   the overhead from the now non-inline function calls is greater than the fewer-eval-jumps savings.
       */
      push_stack(sc, OP_APPLY, cdr(args), sc->code);
      return(sc->nil);
    }

  /* here we may have to copy the arg list */
  if (is_null(cddr(args)))
    sc->args = cadr(args);
  else sc->args = apply_list_star(sc, cdr(args));
  if (!s7_is_proper_list(sc, sc->args))
    return(apply_list_error(sc, args));

  push_stack(sc, OP_APPLY, (needs_copied_args(sc->code)) ? copy_list(sc, sc->args) : sc->args, sc->code);
  return(sc->nil);
}

s7_pointer s7_apply_function(s7_scheme *sc, s7_pointer fnc, s7_pointer args)
{
  TRACK(sc);
#if S7_DEBUGGING
  {
    s7_pointer p;
    int32_t argnum;
    T_Pos(fnc);       /* not T_App here: (length (openlet (inlet 'length 8))) should raise an error */
    for (argnum = 0, p = T_Pos(args); is_pair(p); argnum++, p = T_Pos(cdr(p)))
      T_Pos(car(p));
  }
#endif

  set_current_code(sc, history_cons(sc, fnc, args));
  if (is_c_function(fnc))
    return(c_function_call(fnc)(sc, args));

  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
  sc->code = fnc;
  sc->args = (needs_copied_args(sc->code)) ? copy_list(sc, args) : args;
  eval(sc, OP_APPLY);
  /* we're limited in choices here -- the caller might be (say) car(sc->t1_1) = c_call(...) where the c_call
   *   happens to fallback on a method -- we can't just push OP_APPLY and drop back into the evaluator normally.
   */
  return(sc->value);
}


static s7_pointer implicit_index(s7_scheme *sc, s7_pointer obj, s7_pointer indices)
{
  /* (let ((lst '("12" "34"))) (lst 0 1)) -> #\2
   * (let ((lst (list #(1 2) #(3 4)))) (lst 0 1)) -> 2
   *
   * this can get tricky:
   *   ((list (lambda (a) (+ a 1)) (lambda (b) (* b 2))) 1 2) -> 4
   * but what if func takes rest/optional args, etc?
   *   ((list (lambda args (car args))) 0 "hi" 0)
   *   should this return #\h or "hi"?? currently it is "hi" which is consistent with ((lambda args (car args)) "hi" 0)
   * but ((lambda (arg) arg) "hi" 0) is currently an error (too many arguments)
   * maybe it should be (((lambda (arg) arg) "hi") 0) -> #\h
   *
   * implicit_index applies to non-homogeneous cases, so float|int-vectors don't get here
   */

  switch (type(obj))
    {
    case T_VECTOR:                       /* (#(#(1 2) #(3 4)) 1 1) -> 4 */
      return(vector_ref_1(sc, obj, indices));

    case T_FLOAT_VECTOR:
      set_car(sc->u1_1, obj);
      set_cdr(sc->u1_1, indices);
      return(univect_ref(sc, sc->u1_1, sc->float_vector_ref_symbol, T_FLOAT_VECTOR));

    case T_INT_VECTOR:
      set_car(sc->u1_1, obj);
      set_cdr(sc->u1_1, indices);
      return(univect_ref(sc, sc->u1_1, sc->int_vector_ref_symbol, T_INT_VECTOR));

    case T_BYTE_VECTOR:
      set_car(sc->u1_1, obj);
      set_cdr(sc->u1_1, indices);
      return(univect_ref(sc, sc->u1_1, sc->byte_vector_ref_symbol, T_BYTE_VECTOR));

    case T_STRING:                       /* (#("12" "34") 0 1) -> #\2 */
      if (is_null(cdr(indices)))
	{
	  if (!is_t_integer(car(indices)))
	    return(wrong_type_argument(sc, sc->string_ref_symbol, 2, car(indices), T_INTEGER));
	  return(string_ref_p_pi_direct(sc, obj, integer(car(indices))));
	}
      return(s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, obj, indices)));

    case T_PAIR:                         /* (#((1 2) (3 4)) 1 0) -> 3, (#((1 (2 3))) 0 1 0) -> 2 */
      obj = list_ref_1(sc, obj, car(indices));
      if (is_pair(cdr(indices)))
	return(implicit_index(sc, obj, cdr(indices)));
      return(obj);

    case T_HASH_TABLE:                   /* ((vector (hash-table '(a . 1) '(b . 2))) 0 'a) -> 1 */
      obj = s7_hash_table_ref(sc, obj, car(indices));
      if (is_pair(cdr(indices)))
	return(implicit_index(sc, obj, cdr(indices)));
      return(obj);

    case T_C_OBJECT:
      /* return((*(c_object_ref(sc, obj)))(sc, cons(sc, obj, indices))); */
      set_car(sc->u1_1, obj);
      set_cdr(sc->u1_1, indices);
      return((*(c_object_ref(sc, obj)))(sc, sc->u1_1));

    case T_LET:
      obj = s7_let_ref(sc, obj, car(indices));
      if (is_pair(cdr(indices)))
	return(implicit_index(sc, obj, cdr(indices)));
      return(obj);

    case T_ITERATOR: /* indices is not nil, so this is an error */
      return(s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, obj, indices)));

    default:                             /* (#(a b c) 0 1) -> error, but ((list (lambda (x) x)) 0 "hi") -> "hi" */
      if (is_applicable(obj))            /* (apply (list cons cons) (list 1 2)) needs the argnum check mentioned below */
	{
	  if ((is_c_function(obj)) &&
	      (is_safe_procedure(obj)))
	    {
	      s7_int len;
	      len = safe_list_length(indices);
	      if ((c_function_required_args(obj) <= len) &&
		  (c_function_all_args(obj) >= len))
		return(c_function_call(obj)(sc, indices));
	    }
	  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
	  sc->code = obj;
	  sc->args = (needs_copied_args(obj)) ? copy_list(sc, indices) : indices;
	  eval(sc, OP_APPLY);
	  return(sc->value);
	  /* return(s7_apply_function(sc, obj, indices)); -- needs argnum check */ /* was g_apply 23-Jan-19 which assumes we're not in map */
	}
      return(s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, obj, indices)));
    }
}

static inline void fill_star_defaults(s7_scheme *sc, s7_pointer func, int32_t start_arg, int32_t n_args, s7_pointer par)
{
  int32_t i;
  s7_pointer *df;
  df = c_function_arg_defaults(func);

  if (c_func_has_simple_defaults(func))
    {
      for (i = start_arg; i < n_args; i++, par = cdr(par))
	set_car(par, df[i]);
    }
  else
    {
      for (i = start_arg; i < n_args; i++, par = cdr(par))
	{
	  s7_pointer defval;
	  defval = df[i];
	  if (is_symbol(defval))
	    set_car(par, lookup_checked(sc, defval));
	  else
	    {
	      if (is_pair(defval))
		set_car(par, s7_eval(sc, defval, sc->nil));
	      else set_car(par, defval);
	    }
	}
    }
}

static s7_pointer set_c_function_star_args(s7_scheme *sc)
{
  int32_t i, j, n_args;
  s7_pointer arg, par, call_args, func;
  s7_pointer *df;

  func = sc->code;
  n_args = c_function_all_args(func);     /* not counting keywords, I think */
  if (is_safe_procedure(func))
    call_args = c_function_call_args(func);
  else call_args = protected_make_list(sc, c_function_optional_args(func), sc->F);

  /* assume at the start that there are no keywords */
  for (i = 0, arg = sc->args, par = call_args; (i < n_args) && (is_pair(arg)); i++, arg = cdr(arg), par = cdr(par))
    {
      if (!is_keyword(car(arg)))
	set_car(par, car(arg));
      else
	{
	  s7_pointer kpar, karg;
	  int32_t ki;
	  /* oops -- there are keywords, change scanners (much duplicated code...)
	   *   setting checked on the call_args here rather than parsing the parameters to use add_symbol_to_list
	   */
	  for (kpar = call_args; kpar != par; kpar = cdr(kpar))
	    set_checked(kpar);
	  for (; is_pair(kpar); kpar = cdr(kpar))
	    clear_checked(kpar);
	  df = c_function_arg_names(func);
	  for (ki = i, karg = arg, kpar = par; (ki < n_args) && (is_pair(karg)); ki++, karg = cdr(karg), kpar = cdr(kpar))
	    {
	      if (!is_keyword(car(karg)))
		{
		  if (is_checked(kpar))
		    return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, parameter_set_twice_string, car(kpar), sc->args)));
		  set_checked(kpar);
		  set_car(kpar, car(karg));
		}
	      else
		{
		  s7_pointer p;
		  for (j = 0, p = call_args; j < n_args; j++, p = cdr(p))
		    if (df[j] == car(karg))
		      break;
		  if (j == n_args)
		    return(s7_error(sc, sc->wrong_type_arg_symbol,
				    set_elist_2(sc, wrap_string(sc, "~A: not a parameter name?", 25), car(karg))));
		  if (is_checked(p))
		    return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, parameter_set_twice_string, car(p), sc->args)));
		  if (!is_pair(cdr(karg)))
		    return(s7_error(sc, sc->error_symbol, set_elist_3(sc, value_is_missing_string, func, car(karg))));
		  set_checked(p);
		  karg = cdr(karg);
		  set_car(p, car(karg));
		}
	    }
	  if (!is_null(karg))
	    return(s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, func, sc->args)));
	  if (ki < n_args)
	    {
	      df = c_function_arg_defaults(func);
	      if (c_func_has_simple_defaults(func))
		{
		  for (ki = i, kpar = par; ki < n_args; ki++, kpar = cdr(kpar))
		    if (!is_checked(kpar))
		      set_car(kpar, df[ki]);
		}
	      else
		{
		  for (ki = i, kpar = par; ki < n_args; ki++, kpar = cdr(kpar))
		    if (!is_checked(kpar))
		      {
			s7_pointer defval;
			defval = df[ki];
			if (is_symbol(defval))
			  set_car(kpar, lookup_checked(sc, defval));
			else
			  {
			    if (is_pair(defval))
			      set_car(kpar, s7_eval(sc, defval, sc->nil));
			    else set_car(kpar, defval);
			  }}}}
	  return(call_args);
	}
    }
  if (!is_null(arg))
    return(s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, func, sc->args)));
  if (i < n_args)
    fill_star_defaults(sc, func, i, n_args, par);
  return(call_args);
}

static s7_pointer set_c_function_star_defaults(s7_scheme *sc, int32_t num)
{
  s7_pointer call_args, func, par;
  int32_t n_args;

  func = sc->code;
  n_args = c_function_all_args(func);

  if (is_safe_procedure(func))
    call_args = c_function_call_args(func);
  else call_args = protected_make_list(sc, n_args, sc->F);

  par = call_args;
  if (num == 1)
    {
      set_car(par, car(sc->args));
      par = cdr(par);
    }
  fill_star_defaults(sc, func, num, n_args, par);
  return(call_args);
}

#define apply_c_function_star(Sc) Sc->value = c_function_call(Sc->code)(Sc, set_c_function_star_args(Sc))
#define apply_c_function_star_fill_defaults(Sc, Num) Sc->value = c_function_call(Sc->code)(Sc, set_c_function_star_defaults(Sc, Num))

s7_pointer s7_apply_function_star(s7_scheme *sc, s7_pointer fnc, s7_pointer args)
{
  TRACK(sc);
  set_current_code(sc, history_cons(sc, fnc, args));

  if (is_c_function_star(fnc))
    {
      sc->w = sc->args;
      sc->z = sc->code;
      sc->args = T_Pos(args);
      sc->code = fnc;
      apply_c_function_star(sc);
      sc->args = sc->w;
      sc->code = sc->z;
      return(sc->value);
    }
  push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
  sc->code = fnc;
  sc->args = (needs_copied_args(sc->code)) ? copy_list(sc, args) : args;
  eval(sc, OP_APPLY);
  return(sc->value);
}

/* -------------------------------- eval -------------------------------- */
s7_pointer s7_eval(s7_scheme *sc, s7_pointer code, s7_pointer e)
{
  declare_jump_info();
  TRACK(sc);

  if (sc->safety > NO_SAFETY)
    {
      if (!s7_is_valid(sc, code))
	s7_warn(sc, 256, "bad code arg to %s: %p\n", __func__, code);
      if (!s7_is_valid(sc, e))
	s7_warn(sc, 256, "bad environment arg to %s: %p\n", __func__, e);
    }

  store_jump_info(sc);
  set_jump_info(sc, EVAL_SET_JUMP);
  if (jump_loc != NO_JUMP)
    {
      if (jump_loc != ERROR_JUMP)
	eval(sc, sc->cur_op);
    }
  else
    {
      push_stack(sc, OP_EVAL_DONE, sc->args, sc->code);
      sc->code = code;
      if ((e != sc->rootlet) &&
	  (is_let(e)))
	sc->envir = e;
      else sc->envir = sc->nil;
      eval(sc, OP_EVAL);
    }
  restore_jump_info(sc);

  if (is_multiple_value(sc->value))
    sc->value = splice_in_values(sc, multiple_value(sc->value));
  return(sc->value);
}


static s7_pointer g_eval(s7_scheme *sc, s7_pointer args)
{
  #define H_eval "(eval code (env (curlet))) evaluates code in the environment env. 'env' \
defaults to the curlet; to evaluate something in the top-level environment instead, \
pass (rootlet):\n\
\n\
  (define x 32) \n\
  (let ((x 3))\n\
    (eval 'x (rootlet)))\n\
\n\
  returns 32"
  #define Q_eval s7_make_signature(sc, 3, sc->values_symbol, sc->T, sc->is_let_symbol)

  if (is_not_null(cdr(args)))
    {
      s7_pointer e;
      e = cadr(args);
      if (!is_let(e))
	return(wrong_type_argument_with_type(sc, sc->eval_symbol, 2, e, a_let_string));
      if (e == sc->rootlet)
	sc->envir = sc->nil;
      else sc->envir = e;
    }
  sc->code = car(args);

  if ((sc->safety > NO_SAFETY) &&
      (is_pair(sc->code)))
    {
      check_heap_size(sc, 8192);
      sc->code = copy_body(sc, sc->code);
    }
  else
   {
     if (is_optimized(sc->code))
       clear_all_optimizations(sc, sc->code);
   }

  if (s7_stack_top(sc) < 12)
    push_stack_op(sc, OP_BARRIER);
  push_stack(sc, OP_EVAL, sc->args, sc->code);

  return(sc->nil);
}

#define SHOW_EVAL_OPS 0

#if SHOW_EVAL_OPS
#define safe_print(Code) \
  {						\
    bool old_open;				\
    old_open = sc->has_openlets;		\
    sc->has_openlets = false;			\
    Code;					\
    sc->has_openlets = old_open;		\
  }
#endif

s7_pointer s7_call(s7_scheme *sc, s7_pointer func, s7_pointer args)
{
  declare_jump_info();
  TRACK(sc);
  set_current_code(sc, history_cons(sc, func, args));

#if SHOW_EVAL_OPS
  safe_print(fprintf(stderr, "%s: %s %s\n", __func__, DISPLAY(func), DISPLAY_80(args)));
#endif

  if (is_c_function(func))
    return(c_function_call(func)(sc, args));         /* no check for wrong-number-of-args -- is that reasonable? */

  sc->temp1 = T_App(func);                           /* this is feeble GC protection */
  sc->temp2 = T_Lst(args);

  store_jump_info(sc);
  set_jump_info(sc, S7_CALL_SET_JUMP);
  if (jump_loc != NO_JUMP)
    {
      if (jump_loc != ERROR_JUMP)
	eval(sc, sc->cur_op);

      if ((jump_loc == CATCH_JUMP) &&                /* we're returning (back to eval) from an error in catch */
	  (sc->stack_end == sc->stack_start))
	push_stack_op(sc, OP_ERROR_QUIT);
    }
  else
    {
      if (sc->safety > NO_SAFETY)
	check_list_validity(sc, "s7_call", args);

      push_stack(sc, OP_EVAL_DONE, sc->args, sc->code); /* this saves the current evaluation and will eventually finish this (possibly) nested call */
      sc->code = func;
      sc->args = (needs_copied_args(func)) ? copy_list(sc, args) : args;
      /* besides a closure, "func" can also be an object (T_C_OBJECT) -- in Snd, a generator for example  */
      eval(sc, OP_APPLY);
    }
  restore_jump_info(sc);
  /* don't clear temp1 or temp2 here -- lots of (Snd) code calls s7_call repeatedly and assumes the "func" arg is protected between calls. */
  return(sc->value);
}

s7_pointer s7_call_with_location(s7_scheme *sc, s7_pointer func, s7_pointer args, const char *caller, const char *file, s7_int line)
{
  s7_pointer result;

  if (caller)
    {
      sc->s7_call_name = caller;
      sc->s7_call_file = file;
      sc->s7_call_line = line;
    }
  result = s7_call(sc, func, args);
  if (caller)
    {
      sc->s7_call_name = NULL;
      sc->s7_call_file = NULL;
      sc->s7_call_line = -1;
    }
  return(result);
}


/* -------------------------------- type-of -------------------------------- */

static inline bool gen_type_match(s7_scheme *sc, s7_pointer val, uint8_t typ)  /* opt3_con = uint8_t */
{
  return((type(val) == typ) ||
	 ((has_active_methods(sc, val)) &&
	  (apply_boolean_method(sc, val, sc->type_to_typers[typ]) != sc->F)));
}

static void init_typers(s7_scheme *sc)
{
  sc->type_to_typers[T_FREE] =                sc->F;
  sc->type_to_typers[T_PAIR] =                sc->is_pair_symbol;
  sc->type_to_typers[T_NIL] =                 sc->is_null_symbol;
  sc->type_to_typers[T_EOF_OBJECT] =          sc->is_eof_object_symbol;
  sc->type_to_typers[T_UNDEFINED] =           sc->is_undefined_symbol;
  sc->type_to_typers[T_UNSPECIFIED] =         sc->is_unspecified_symbol;
  sc->type_to_typers[T_BOOLEAN] =             sc->is_boolean_symbol;
  sc->type_to_typers[T_CHARACTER] =           sc->is_char_symbol;
  sc->type_to_typers[T_SYMBOL] =              sc->is_symbol_symbol;      /* and keyword? */
  sc->type_to_typers[T_SYNTAX] =              sc->is_syntax_symbol;
  sc->type_to_typers[T_INTEGER] =             sc->is_integer_symbol;
  sc->type_to_typers[T_RATIO] =               sc->is_rational_symbol;
  sc->type_to_typers[T_REAL] =                sc->is_float_symbol;
  sc->type_to_typers[T_COMPLEX] =             sc->is_complex_symbol;
  sc->type_to_typers[T_BIG_INTEGER] =         sc->is_integer_symbol;
  sc->type_to_typers[T_BIG_RATIO] =           sc->is_rational_symbol;
  sc->type_to_typers[T_BIG_REAL] =            sc->is_float_symbol;
  sc->type_to_typers[T_BIG_COMPLEX] =         sc->is_complex_symbol;
  sc->type_to_typers[T_STRING] =              sc->is_string_symbol;
  sc->type_to_typers[T_BYTE_VECTOR] =         sc->is_byte_vector_symbol;
  sc->type_to_typers[T_C_OBJECT] =            sc->is_c_object_symbol;
  sc->type_to_typers[T_VECTOR] =              sc->is_vector_symbol;
  sc->type_to_typers[T_INT_VECTOR] =          sc->is_int_vector_symbol;
  sc->type_to_typers[T_FLOAT_VECTOR] =        sc->is_float_vector_symbol;
  sc->type_to_typers[T_CATCH] =               sc->F;
  sc->type_to_typers[T_DYNAMIC_WIND] =        sc->F;
  sc->type_to_typers[T_HASH_TABLE] =          sc->is_hash_table_symbol;
  sc->type_to_typers[T_LET] =                 sc->is_let_symbol;
  sc->type_to_typers[T_ITERATOR] =            sc->is_iterator_symbol;
  sc->type_to_typers[T_STACK] =               sc->F;
  sc->type_to_typers[T_COUNTER] =             sc->F;
  sc->type_to_typers[T_SLOT] =                sc->F;
  sc->type_to_typers[T_C_POINTER] =           sc->is_c_pointer_symbol;
  sc->type_to_typers[T_OUTPUT_PORT] =         sc->is_output_port_symbol;
  sc->type_to_typers[T_INPUT_PORT] =          sc->is_input_port_symbol;
  sc->type_to_typers[T_BAFFLE] =              sc->F;
  sc->type_to_typers[T_RANDOM_STATE] =        sc->is_random_state_symbol;
  sc->type_to_typers[T_GOTO] =                sc->F;                       /* (continuation? goto) -> #f -- we need a type indicator for this */
  sc->type_to_typers[T_CONTINUATION] =        sc->is_continuation_symbol;
  sc->type_to_typers[T_CLOSURE] =             sc->is_procedure_symbol;
  sc->type_to_typers[T_CLOSURE_STAR] =        sc->is_procedure_symbol;
  sc->type_to_typers[T_C_MACRO] =             sc->is_macro_symbol;
  sc->type_to_typers[T_MACRO] =               sc->is_macro_symbol;
  sc->type_to_typers[T_MACRO_STAR] =          sc->is_macro_symbol;
  sc->type_to_typers[T_BACRO] =               sc->is_macro_symbol;
  sc->type_to_typers[T_BACRO_STAR] =          sc->is_macro_symbol;
  sc->type_to_typers[T_C_FUNCTION] =          sc->is_procedure_symbol;
  sc->type_to_typers[T_C_FUNCTION_STAR] =     sc->is_procedure_symbol;
  sc->type_to_typers[T_C_ANY_ARGS_FUNCTION] = sc->is_procedure_symbol;
  sc->type_to_typers[T_C_OPT_ARGS_FUNCTION] = sc->is_procedure_symbol;
  sc->type_to_typers[T_C_RST_ARGS_FUNCTION] = sc->is_procedure_symbol;
}

s7_pointer s7_type_of(s7_scheme *sc, s7_pointer arg) {return(sc->type_to_typers[type(arg)]);}

static s7_pointer g_type_of(s7_scheme *sc, s7_pointer args)
{
  #define H_type_of "(type-of obj) returns a symbol describing obj's type"
  #define Q_type_of s7_make_signature(sc, 2, s7_make_signature(sc, 2, sc->is_symbol_symbol, sc->not_symbol), sc->T)

  return(sc->type_to_typers[type(car(args))]);
}


/* -------------------------------- s7-version -------------------------------- */
static s7_pointer g_s7_version(s7_scheme *sc, s7_pointer args)
{
  #define H_s7_version "(s7-version) returns some string describing the current s7"
  #define Q_s7_version sc->pcl_s
  return(s7_make_string(sc, "s7 " S7_VERSION ", " S7_DATE));
}

static s7_pointer s7_version_p(s7_scheme *sc) {return(s7_make_string(sc, "s7 " S7_VERSION ", " S7_DATE));}


/* -------------------------------- exit emergency-exit -------------------------------- */
void s7_quit(s7_scheme *sc)
{
  sc->longjmp_ok = false;
  pop_input_port(sc);
  stack_reset(sc);
  push_stack_op_let(sc, OP_EVAL_DONE);
}

static s7_pointer g_emergency_exit(s7_scheme *sc, s7_pointer args)
{
  #define H_emergency_exit "(emergency-exit obj) exits s7 immediately"
  #define Q_emergency_exit s7_make_signature(sc, 2, sc->T, sc->T)

  s7_pointer obj;
#ifndef EXIT_SUCCESS
  #define EXIT_SUCCESS 0
  #define EXIT_FAILURE 1
#endif

  if (is_null(args))
    _exit(EXIT_SUCCESS);          /* r7rs spec says use _exit here */
  obj = car(args);
  if (obj == sc->F)
    _exit(EXIT_FAILURE);
  if ((obj == sc->T) || (!s7_is_integer(obj)))
    _exit(EXIT_SUCCESS);
  _exit((int)s7_integer(obj));
  return(sc->F);
}

static s7_pointer g_exit(s7_scheme *sc, s7_pointer args)
{
  #define H_exit "(exit obj) exits s7"
  #define Q_exit s7_make_signature(sc, 2, sc->T, sc->T)

  s7_quit(sc);
  return(g_emergency_exit(sc, args));
}

#if WITH_GCC
static s7_pointer g_abort(s7_scheme *sc, s7_pointer args) {abort();}
#endif


/* -------------------------------- optimizer stuff -------------------------------- */

static s7_function fx_function[OPT_MAX_DEFINED];

static bool aa_is_fx_safe(s7_scheme *sc, s7_pointer p)
{
  s7_pointer arg1, arg2;
  arg1 = cadr(p);
  arg2 = caddr(p);
  return(((!is_pair(arg1)) || (is_fxa_op(optimize_op(arg1))) || (car(arg1) == sc->quote_symbol)) &&
	 ((!is_pair(arg2)) || (is_fxa_op(optimize_op(arg2))) || (car(arg2) == sc->quote_symbol)));
}

static bool opaaq_opaaq_is_fx_safe(s7_scheme *sc, s7_pointer p)
{
  return((is_pair(cadr(p))) && (optimize_op(cadr(p)) == HOP_SAFE_C_AA) &&
	 (is_pair(caddr(p))) && (optimize_op(caddr(p)) == HOP_SAFE_C_AA) &&
	 (aa_is_fx_safe(sc, cadr(p))) &&
	 (aa_is_fx_safe(sc, caddr(p))));
}

static bool aaa_is_fx_safe(s7_scheme *sc, s7_pointer p)
{
  s7_pointer arg1, arg2, arg3;
  arg1 = cadr(p);
  arg2 = caddr(p);
  arg3 = cadddr(p);
  return(((!is_pair(arg1)) || (is_fxa_op(optimize_op(arg1))) || (car(arg1) == sc->quote_symbol)) &&
	 ((!is_pair(arg2)) || (is_fxa_op(optimize_op(arg2))) || (car(arg2) == sc->quote_symbol)) &&
	 ((!is_pair(arg3)) || (is_fxa_op(optimize_op(arg3))) || (car(arg3) == sc->quote_symbol)));
}

static bool is_fx_safe(s7_scheme *sc, s7_pointer p)
{
  if (!is_pair(p)) return(true);
  if (is_optimized(p))
    {
#if S7_DEBUGGING
      if (optimize_op(p) >= OPT_MAX_DEFINED)
	{
	  char *s;
	  fprintf(stderr, "%s opt: %d %s\n", DISPLAY(p), optimize_op(p), s = describe_type_bits(sc, p));
	  free(s);
	  if (optimize_op(p) < OP_MAX_DEFINED_1)
	    fprintf(stderr, "    op name: %s\n", op_names[optimize_op(p)]);
	  abort();
	}
#endif
      if (fx_function[optimize_op(p)])   /* includes the single A cases */
	return(true);
      if (optimize_op(p) == HOP_SAFE_C_AA)
	return(aa_is_fx_safe(sc, p) || opaaq_opaaq_is_fx_safe(sc, p));
      if (optimize_op(p) == HOP_SAFE_C_AAA)
	return(aaa_is_fx_safe(sc, p));
      if (optimize_op(p) == HOP_SAFE_C_opAAq)
	return(aa_is_fx_safe(sc, cadr(p)));

      if (optimize_op(p) == HOP_SAFE_C_FX)
	{
	  s7_pointer e;
	  for (e = cdr(p); is_pair(e); e = cdr(e))
	    if ((is_pair(car(e))) && (!is_fxa_op(optimize_op(car(e)))) && (caar(e) != sc->quote_symbol))
	      break;
	  return(is_null(e));
	}
    }
  return(is_proper_quote(sc, p));
}

static int32_t fx_count(s7_scheme *sc, s7_pointer x)
{
  int32_t count = 0;
  s7_pointer p;
  for (p = cdr(x); is_pair(p); p = cdr(p))
    if (is_fx_safe(sc, car(p)))
      count++;
  return(count);
}

#if S7_DEBUGGING
static void check_let_slots(s7_scheme *sc, const char* func, s7_pointer expr, s7_pointer var)
{
  if (let_slots(sc->envir) != symbol_to_slot(sc, var))
    {
      fprintf(stderr, "%s %s is out of date (%s in %s)\n", func, DISPLAY(expr), DISPLAY(var), DISPLAY(sc->envir));
      if (stop_at_error) abort();
    }
}

static void check_next_let_slot(s7_scheme *sc, const char* func, s7_pointer expr, s7_pointer var)
{
  if (next_slot(let_slots(sc->envir)) != symbol_to_slot(sc, var))
    {
      fprintf(stderr, "%s %s is out of date (%s in %s)\n", func, DISPLAY(expr), DISPLAY(var), DISPLAY(sc->envir));
      if (stop_at_error) abort();
    }
}
#else
#define check_let_slots(Sc, Func, Expr, Var)
#define check_next_let_slot(Sc, Func, Expr, Var)
#endif

/* arg here is the full expression */
static s7_pointer fx_c(s7_scheme *sc, s7_pointer arg)       {return(arg);}
static s7_pointer fx_q(s7_scheme *sc, s7_pointer arg)       {return(cadr(arg));}
static s7_pointer fx_unsafe_s(s7_scheme *sc, s7_pointer arg){return(lookup_checked(sc, arg));}
static s7_pointer fx_s(s7_scheme *sc, s7_pointer arg)       {return(lookup(sc, arg));}
static s7_pointer fx_c_d(s7_scheme *sc, s7_pointer arg)     {return(d_call(sc, arg));}
static s7_pointer fx_not_c_d(s7_scheme *sc, s7_pointer arg) {return(make_boolean(sc, is_false(sc, d_call(sc, cadr(arg)))));}

#if (!WITH_GMP)
static s7_pointer fx_c_equal_s_ic_1(s7_scheme *sc, s7_pointer args, s7_pointer val, s7_int y)
{
  switch (type(val))
    {
    case T_INTEGER: return(make_boolean(sc, integer(val) == y));
    case T_RATIO:   return(sc->F);
    case T_REAL:    return(make_boolean(sc, real(val) == y));
    case T_COMPLEX: return(sc->F);
    default: return(method_or_bust_with_type(sc, val, sc->eq_symbol, args, a_number_string, 1));
    }
  return(sc->T);
}

static s7_pointer fx_c_equal_s_ic(s7_scheme *sc, s7_pointer arg)
{
  s7_int y;
  s7_pointer val, args;
  args = cdr(arg);
  val = lookup(sc, car(args));
  y = integer(cadr(args));
  if (is_t_integer(val))
    return(make_boolean(sc, integer(val) == y));
  return(fx_c_equal_s_ic_1(sc, args, val, y));
}

static s7_pointer fx_c_equal_t_ic(s7_scheme *sc, s7_pointer arg)
{
  s7_int y;
  s7_pointer val, args;
  args = cdr(arg);
  check_let_slots(sc, __func__, arg, cadr(arg));
  val = slot_value(let_slots(sc->envir));
  y = integer(cadr(args));
  if (is_t_integer(val))
    return(make_boolean(sc, integer(val) == y));
  return(fx_c_equal_s_ic_1(sc, args, val, y));
}

static s7_pointer fx_c_equal_u_ic(s7_scheme *sc, s7_pointer arg)
{
  s7_int y;
  s7_pointer val, args;
  args = cdr(arg);
  check_next_let_slot(sc, __func__, arg, cadr(arg));
  val = slot_value(next_slot(let_slots(sc->envir)));
  y = integer(cadr(args));
  if (is_t_integer(val))
    return(make_boolean(sc, integer(val) == y));
  return(fx_c_equal_s_ic_1(sc, args, val, y));
}
#endif

static s7_pointer fx_c_add_s1(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x;
  x = lookup(sc, cadr(arg));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + 1));
  return(g_add_s1_1(sc, x, cdr(arg))); /* arg=(+ x 1) */
}

static s7_pointer fx_c_add_t1(s7_scheme *sc, s7_pointer arg) /* sub_t1 was not useful */
{
  s7_pointer x;
  x = slot_value(let_slots(sc->envir));
  check_let_slots(sc, __func__, arg, cadr(arg));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + 1));
  return(g_add_s1_1(sc, x, cdr(arg)));
}

static s7_pointer fx_c_add_u1(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x;
  check_next_let_slot(sc, __func__, arg, cadr(arg));
  x = slot_value(next_slot(let_slots(sc->envir)));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + 1));
  return(g_add_s1_1(sc, x, cdr(arg)));
}

#if (!WITH_GMP)
static s7_pointer fx_c_add_tf(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return(g_add_sfs(sc, slot_value(let_slots(sc->envir)), real(caddr(arg))));
}
#endif

static s7_pointer fx_c_sub_s1(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x;
  x = lookup(sc, cadr(arg));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) - 1));
  return(minus_c1(sc, x));
}

static s7_pointer fx_c_sub_t1(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x;
  check_let_slots(sc, __func__, arg, cadr(arg));
  x = slot_value(let_slots(sc->envir));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) - 1));
  return(minus_c1(sc, x));
}

static s7_pointer fx_c_add_si(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x;
  x = lookup(sc, cadr(arg));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + integer(caddr(arg))));
  return(add_p_pp(sc, x, caddr(arg)));
}

static s7_pointer fx_c_add_ti(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x;
  check_let_slots(sc, __func__, arg, cadr(arg));
  x = slot_value(let_slots(sc->envir));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) + integer(caddr(arg))));
  return(add_p_pp(sc, x, caddr(arg)));
}

static s7_pointer fx_c_sub_si(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x;
  x = lookup(sc, cadr(arg));
  if (is_t_integer(x))
    return(make_integer(sc, integer(x) - integer(caddr(arg))));
  return(subtract_p_pp(sc, x, caddr(arg)));
}

static s7_pointer fx_c_char_eq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer c;
  c = lookup(sc, cadr(arg));
  if (c == caddr(arg))
    return(sc->T);
  if (s7_is_character(c))
    return(sc->F);
  return(method_or_bust(sc, c, sc->char_eq_symbol, set_plist_2(sc, c, caddr(arg)), T_CHARACTER, 1));
}

static s7_pointer fx_is_eq_car_q(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer lst, a;
  a = cdr(arg);
  lst = lookup(sc, opt2_sym(a));
  if (is_pair(lst))
    return(make_boolean(sc, car(lst) == opt3_any(a)));
  return(make_boolean(sc, s7_is_eq(g_car(sc, set_plist_1(sc, lst)), opt3_any(a))));
}

static s7_pointer fx_not_is_eq_car_q(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer lst, a;
  a = opt2_pair(cdr(arg));
  lst = lookup(sc, opt2_sym(a));
  if (is_pair(lst))
    return(make_boolean(sc, car(lst) != opt3_any(a)));
  return(make_boolean(sc, !s7_is_eq(g_car(sc, set_plist_1(sc, lst)), opt3_any(a))));
}

static s7_pointer fx_is_pair_cdr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  p = lookup(sc, opt2_sym(cdr(arg)));
  if (is_pair(p))
    return(make_boolean(sc, is_pair(cdr(p))));
  return(g_is_pair(sc, set_plist_1(sc, g_cdr(sc, set_plist_1(sc, p)))));
}

static s7_pointer fx_is_pair_cdr_t(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  check_let_slots(sc, __func__, arg, cadadr(arg));
  p = slot_value(let_slots(sc->envir));
  if (is_pair(p))
    return(make_boolean(sc, is_pair(cdr(p))));
  return(g_is_pair(sc, set_plist_1(sc, g_cdr(sc, set_plist_1(sc, p)))));
}

static s7_pointer fx_is_pair_cddr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  p = lookup(sc, opt2_sym(cdr(arg)));
  if ((is_pair(p)) && (is_pair(cdr(p))))
    return(make_boolean(sc, is_pair(cddr(p))));
  return(g_is_pair(sc, set_plist_1(sc, g_cddr(sc, set_plist_1(sc, p)))));
}

static s7_pointer fx_is_null_cddr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  p = lookup(sc, opt2_sym(cdr(arg)));
  if ((is_pair(p)) && (is_pair(cdr(p))))
    return(make_boolean(sc, is_null(cddr(p))));
  return(g_is_null(sc, set_plist_1(sc, g_cddr(sc, set_plist_1(sc, p)))));
}

static s7_pointer fx_is_null_cadr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  p = lookup(sc, opt2_sym(cdr(arg)));
  if ((is_pair(p)) && (is_pair(cdr(p))))
    return(make_boolean(sc, is_null(cadr(p))));
  return(g_is_null(sc, set_plist_1(sc, g_cadr(sc, set_plist_1(sc, p)))));
}

static s7_pointer fx_is_symbol_cadr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  p = lookup(sc, opt2_sym(cdr(arg)));
  if ((is_pair(p)) && (is_pair(cdr(p))))
    return(make_boolean(sc, is_symbol(cadr(p))));
  return(g_is_symbol(sc, set_plist_1(sc, g_cadr(sc, set_plist_1(sc, p)))));
}

static s7_pointer fx_c_s(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t1_1, lookup(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_t(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  set_car(sc->t1_1, slot_value(let_slots(sc->envir)));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_o_p_p_s(s7_scheme *sc, s7_pointer arg)
{
  return(((s7_p_p_t)opt2_direct_x_call(cdr(arg)))(sc, lookup(sc, cadr(arg))));
}

static s7_pointer fx_length_s(s7_scheme *sc, s7_pointer arg)
{
  return(s7_length(sc, lookup(sc, cadr(arg))));
}

static s7_pointer fx_cdr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, cadr(arg));
  return((is_pair(val)) ? cdr(val) : g_cdr(sc, set_plist_1(sc, val)));
}

static s7_pointer fx_cdr_t(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  check_let_slots(sc, __func__, arg, cadr(arg));
  val = slot_value(let_slots(sc->envir));
  return((is_pair(val)) ? cdr(val) : g_cdr(sc, set_plist_1(sc, val)));
}

static s7_pointer fx_cdr_u(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  check_next_let_slot(sc, __func__, arg, cadr(arg));
  val = slot_value(next_slot(let_slots(sc->envir)));
  return((is_pair(val)) ? cdr(val) : g_cdr(sc, set_plist_1(sc, val)));
}

static s7_pointer fx_car_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, cadr(arg));
  return((is_pair(val)) ? car(val) : g_car(sc, set_plist_1(sc, val)));
}

static s7_pointer fx_car_t(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  check_let_slots(sc, __func__, arg, cadr(arg));
  val = slot_value(let_slots(sc->envir));
  return((is_pair(val)) ? car(val) : g_car(sc, set_plist_1(sc, val)));
}

static s7_pointer fx_cadr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, cadr(arg));
  return(((is_pair(val)) && (is_pair(cdr(val)))) ? cadr(val) : g_cadr(sc, set_plist_1(sc, val)));
}

static s7_pointer fx_is_null_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_null(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_null_t(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return((is_null(slot_value(let_slots(sc->envir)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_symbol_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_symbol(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_symbol_t(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return((is_symbol(slot_value(let_slots(sc->envir)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_type_s(s7_scheme *sc, s7_pointer arg)
{
  return(make_boolean(sc, (uint8_t)(opt3_con(cdr(arg))) == type(lookup(sc, cadr(arg)))));
}

static s7_pointer fx_is_type_t(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return(make_boolean(sc, (uint8_t)(opt3_con(cdr(arg))) == type(slot_value(let_slots(sc->envir)))));
}

static s7_pointer fx_is_integer_s(s7_scheme *sc, s7_pointer arg)
{
#if WITH_GMP
  return((s7_is_integer(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
#else
  return((is_t_integer(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
#endif
}

static s7_pointer fx_is_string_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_string(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_procedure_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_procedure(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_pair_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_pair(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_pair_t(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return((is_pair(slot_value(let_slots(sc->envir)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_keyword_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_keyword(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_vector_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_any_vector(lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_is_proper_list_s(s7_scheme *sc, s7_pointer arg)
{
  return((s7_is_proper_list(sc, lookup(sc, cadr(arg)))) ? sc->T : sc->F);
}

static s7_pointer fx_not_s(s7_scheme *sc, s7_pointer arg)
{
  return(make_boolean(sc, is_false(sc, lookup(sc, cadr(arg)))));
}

static s7_pointer fx_not_t(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return(make_boolean(sc, is_false(sc, slot_value(let_slots(sc->envir)))));
}

static s7_pointer fx_not_is_pair_s(s7_scheme *sc, s7_pointer arg)
{
  return((is_pair(lookup(sc, opt3_sym(arg)))) ? sc->F : sc->T);
}

static s7_pointer fx_not_is_pair_t(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, opt3_sym(arg));
  return((is_pair(slot_value(let_slots(sc->envir)))) ? sc->F : sc->T);
}

static s7_pointer fx_c_sc(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  set_car(sc->t2_2, opt2_con(cdr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_tc(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  set_car(sc->t2_1, slot_value(let_slots(sc->envir)));
  set_car(sc->t2_2, opt2_con(cdr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_cs(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t2_1, opt1_con(cdr(arg))); /* cadr(arg) or cadadr */
  set_car(sc->t2_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_ct(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, caddr(arg));
  set_car(sc->t2_1, opt1_con(cdr(arg))); /* cadr(arg) or cadadr */
  set_car(sc->t2_2, slot_value(let_slots(sc->envir)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_ss(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(arg))));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_st(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, opt2_sym(cdr(arg)));
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  set_car(sc->t2_2, slot_value(let_slots(sc->envir)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_ts(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  set_car(sc->t2_1, slot_value(let_slots(sc->envir)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(arg))));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_cons_ss(s7_scheme *sc, s7_pointer arg)
{
  return(cons(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_add_ss(s7_scheme *sc, s7_pointer arg)
{
  return(add_p_pp(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_add_ts(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return(add_p_pp(sc, slot_value(let_slots(sc->envir)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_add_us(s7_scheme *sc, s7_pointer arg)
{
  check_next_let_slot(sc, __func__, arg, cadr(arg));
  return(add_p_pp(sc, slot_value(next_slot(let_slots(sc->envir))), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_subtract_ss(s7_scheme *sc, s7_pointer arg)
{
  return(subtract_p_pp(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

#if (!WITH_GMP)
static s7_pointer fx_multiply_ss(s7_scheme *sc, s7_pointer arg)
{
  return(multiply_p_pp(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_geq_ss(s7_scheme *sc, s7_pointer arg)
{
  return(geq_p_pp(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_geq_ts(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return(geq_p_pp(sc, slot_value(let_slots(sc->envir)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_geq_tu(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  check_next_let_slot(sc, __func__, arg, caddr(arg));
  return(geq_p_pp(sc, slot_value(let_slots(sc->envir)), slot_value(next_slot(let_slots(sc->envir)))));
}

static s7_pointer fx_gt_ss(s7_scheme *sc, s7_pointer arg)
{
  return(gt_p_pp(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_leq_ss(s7_scheme *sc, s7_pointer arg)
{
  return(leq_p_pp(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_lt_ss(s7_scheme *sc, s7_pointer arg)
{
  return(lt_p_pp(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_equal_ss(s7_scheme *sc, s7_pointer arg)
{
  return(c_equal_2(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_equal_ts(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  return(c_equal_2(sc, slot_value(let_slots(sc->envir)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_equal_tu(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, cadr(arg));
  check_next_let_slot(sc, __func__, arg, caddr(arg));
  return(c_equal_2(sc, slot_value(let_slots(sc->envir)), slot_value(next_slot(let_slots(sc->envir)))));
}

static s7_pointer fx_equal_us(s7_scheme *sc, s7_pointer arg)
{
  check_next_let_slot(sc, __func__, arg, cadr(arg));
  return(c_equal_2(sc, slot_value(next_slot(let_slots(sc->envir))), lookup(sc, opt2_sym(cdr(arg)))));
}
#endif

static s7_pointer fx_is_eq_ss(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x, y;
  x = lookup(sc, cadr(arg));
  y = lookup(sc, opt2_sym(cdr(arg)));
  return(make_boolean(sc, (x == y) || ((is_unspecified(x)) && (is_unspecified(y)))));
}

static s7_pointer fx_is_eq_ts(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer x, y;
  check_let_slots(sc, __func__, arg, cadr(arg));
  x = slot_value(let_slots(sc->envir));
  y = lookup(sc, opt2_sym(cdr(arg)));
  return(make_boolean(sc, (x == y) || ((is_unspecified(x)) && (is_unspecified(y)))));
}

static s7_pointer x_c_hash_table_ref_ss(s7_scheme *sc, s7_pointer table, s7_pointer key)
{
  hash_entry_t *x;
  if (!is_hash_table(table))
    return(g_hash_table_ref(sc, set_plist_2(sc, table, key)));
  x = (*hash_table_checker(table))(sc, table, key);
  return(hash_entry_value(x));
}

static s7_pointer fx_c_hash_table_ref_ss(s7_scheme *sc, s7_pointer arg)
{
  return(x_c_hash_table_ref_ss(sc, lookup(sc, cadr(arg)), lookup(sc, opt2_sym(cdr(arg)))));
}

static s7_pointer fx_c_hash_table_ref_car(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer table, lst;
  hash_entry_t *x;

  table = lookup(sc, cadr(arg));
  lst = lookup(sc, opt3_sym(cdr(arg)));
  if (!is_pair(lst))
    return(simple_wrong_type_argument(sc, sc->car_symbol, lst, T_PAIR));

  if (!is_hash_table(table))
    return(g_hash_table_ref(sc, set_plist_2(sc, table, car(lst))));

  x = (*hash_table_checker(table))(sc, table, car(lst));
  return(hash_entry_value(x));
}

static s7_pointer fx_c_lint_let_ref(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer lt, sym, y;
  check_let_slots(sc, __func__, arg, cadadr(arg));
  lt = cdr(slot_value(let_slots(sc->envir)));
  if (!is_let(lt))
    return(wrong_type_argument_with_type(sc, sc->let_ref_symbol, 1, lt, a_let_string));
  sym = opt3_sym(cdr(arg));                              /* cadaddr(arg); */
  for (y = let_slots(lt); tis_slot(y); y = next_slot(y))
    if (slot_symbol(y) == sym)
      return(slot_value(y));
  return(lint_let_ref_1(sc, outlet(lt), sym));
}

static s7_pointer fx_memq_sq_2(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p, obj;
  obj = lookup(sc, cadr(arg));
  p = opt2_con(cdr(arg));
  if (obj == car(p)) return(p);
  if (obj == cadr(p)) return(cdr(p));
  return(sc->F);
}

static s7_pointer fx_c_cq(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t2_1, cadr(arg));
  set_car(sc->t2_2, opt2_con(cdr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_sss(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_1, lookup(sc, cadr(arg)));
  set_car(sc->t3_2, lookup(sc, opt1_sym(cdr(arg)))); /* caddr(arg) */
  set_car(sc->t3_3, lookup(sc, opt2_sym(cdr(arg)))); /* cadddr(arg) */
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_scs(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_1, lookup(sc, cadr(arg)));
  set_car(sc->t3_3, lookup(sc, opt2_sym(cdr(arg)))); /* cadddr(arg) */
  set_car(sc->t3_2, opt1_con(cdr(arg)));             /* caddr(arg) */
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_scc(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_1, lookup(sc, cadr(arg)));
  set_car(sc->t3_2, opt1_con(cdr(arg))); /* caddr(arg) */
  set_car(sc->t3_3, opt2_con(cdr(arg))); /* cadddr(arg) */
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_css(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_2, lookup(sc, opt1_sym(cdr(arg)))); /* caddr(arg) */
  set_car(sc->t3_3, lookup(sc, opt2_sym(cdr(arg)))); /* cadddr(arg) */
  set_car(sc->t3_1, cadr(arg));
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_csc(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_2, lookup(sc, opt1_sym(cdr(arg)))); /* caddr(arg) */
  set_car(sc->t3_1, cadr(arg));
  set_car(sc->t3_3, opt2_con(cdr(arg)));             /* cadddr(arg) */
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_ccs(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_3, lookup(sc, opt1_sym(cdr(arg)))); /* cadddr */
  set_car(sc->t3_1, cadr(arg));
  set_car(sc->t3_2, opt2_con(cdr(arg)));             /* caddr(arg) */
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_ssc(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_1, lookup(sc, cadr(arg)));
  set_car(sc->t3_2, lookup(sc, opt1_sym(cdr(arg)))); /* caddr(arg) */
  set_car(sc->t3_3, opt2_con(cdr(arg)));             /* cadddr(arg) */
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_sssc(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->a4_1, lookup(sc, cadr(arg)));
  set_car(sc->a4_2, lookup(sc, opt1_sym(cdr(arg)))); /* caddr(arg) */
  set_car(sc->a4_3, lookup(sc, opt3_sym(cdr(arg)))); /* cadddr(arg) */
  set_car(sc->a4_4, opt2_con(cdr(arg)));             /* caddddr(arg) */
  return(c_call(arg)(sc, sc->a4_1));
}

static s7_pointer fx_c_opdq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t1_1, d_call(sc, largs));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_s_opdq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_2, d_call(sc, largs));
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_c_opdq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_2, d_call(sc, largs));
  set_car(sc->t2_1, cadr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opdq_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, d_call(sc, largs));
  set_car(sc->t2_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opdq_c(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, d_call(sc, largs));
  set_car(sc->t2_2, caddr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opdq_opdq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cadr(arg);
  sc->t_temps[tx] = d_call(sc, largs);
  largs = caddr(arg);
  set_car(sc->t2_2, d_call(sc, largs));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  set_car(sc->t1_1, c_call(largs)(sc, sc->t1_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_car_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, opt2_sym(cdr(arg)));
  set_car(sc->t1_1, (is_pair(val)) ? car(val) : g_car(sc, set_plist_1(sc, val)));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_cdr_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, opt2_sym(cdr(arg)));
  set_car(sc->t1_1, (is_pair(val)) ? cdr(val) : g_cdr(sc, set_plist_1(sc, val)));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_is_type_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, opt2_sym(cdr(arg)));
  set_car(sc->t1_1, val);
  return(make_boolean(sc, (uint8_t)(opt3_con(cdr(arg))) == type(c_call(cadr(arg))(sc, sc->t1_1))));
}

static s7_pointer fx_c_is_type_car_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, opt2_sym(cdr(arg)));
  if (is_pair(val))
    return(make_boolean(sc, (uint8_t)(opt3_con(cdr(arg))) == type(car(val))));
  return(make_boolean(sc, (uint8_t)(opt3_con(cdr(arg))) == type(g_car(sc, set_plist_1(sc, val)))));
}

static s7_pointer fx_c_weak1_type(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, opt2_sym(cdr(arg)));
  if (is_c_pointer(val))                /* (let? (c-pointer-weak1 val)) etc */
    return(make_boolean(sc, (uint8_t)(opt3_con(cdr(arg))) == type(c_pointer_weak1(val))));
  return(make_boolean(sc, (uint8_t)(opt3_con(cdr(arg))) == type(c_pointer_weak1_p_p(sc, val))));
}

static s7_pointer fx_not_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  if (c_call(largs)(sc, sc->t1_1) == sc->F) return(sc->T);
  return(sc->F);
}

static s7_pointer fx_c_opssq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs)))); /* caddr(largs) */
  set_car(sc->t1_1, c_call(largs)(sc, sc->t2_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_opstq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  check_let_slots(sc, __func__, arg, caddr(largs));
  set_car(sc->t2_2, slot_value(let_slots(sc->envir)));
  set_car(sc->t1_1, c_call(largs)(sc, sc->t2_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_opstq_direct(s7_scheme *sc, s7_pointer arg)
{
  return(((s7_p_p_t)opt2_direct_x_call(cdr(arg)))(sc,
            ((s7_p_pp_t)opt3_direct_x(cdr(arg)))(sc, lookup(sc, cadadr(arg)), slot_value(let_slots(sc->envir)))));
}

static s7_pointer fx_not_opssq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs))));
  if (c_call(largs)(sc, sc->t2_1) == sc->F) return(sc->T);
  return(sc->F);
}

static s7_pointer fx_c_opscq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, opt2_con(cdr(largs)));
  set_car(sc->t1_1, c_call(largs)(sc, sc->t2_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_opcsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_2, lookup(sc, caddr(largs)));
  set_car(sc->t2_1, opt1_con(cdr(largs)));  /* cadr(largs) or cadadr */
  set_car(sc->t1_1, c_call(largs)(sc, sc->t2_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_opcsq_c(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_2, lookup(sc, caddr(largs)));
  set_car(sc->t2_1, opt1_con(cdr(largs))); /* cadr(largs) or cadadr */
  set_car(sc->t2_1, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_2, caddr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opcsq_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_2, lookup(sc, caddr(largs)));
  set_car(sc->t2_1, opt1_con(cdr(largs))); /* cadr(largs) or cadadr */
  set_car(sc->t2_1, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opssq_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs))));
  set_car(sc->t2_1, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opssq_s_direct(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cdadr(arg);
  return(((s7_p_pp_t)opt2_direct_x_call(cdr(arg)))(sc,
	   ((s7_p_pp_t)opt3_direct_x(cdr(arg)))(sc, lookup(sc, car(largs)), lookup(sc, opt2_sym(largs))),
	   lookup(sc, caddr(arg))));
}

static s7_pointer fx_c_opscq_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, opt2_con(cdr(largs)));
  set_car(sc->t2_1, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opscq_c(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, opt2_con(cdr(largs)));
  set_car(sc->t2_1, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_2, caddr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opssq_c(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs))));
  set_car(sc->t2_1, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_2, caddr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_car_s_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, opt1_sym(cdr(arg))); /* cadadr(arg)); */
  set_car(sc->t2_1, (is_pair(val)) ? car(val) : g_car(sc, set_plist_1(sc, val)));
  set_car(sc->t2_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opsq_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = cadr(arg);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_1, c_call(largs)(sc, sc->t1_1));
  set_car(sc->t2_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opsq_cs(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t1_1, lookup(sc, opt3_sym(cdr(arg))));  /* cadadr(arg); */
  set_car(sc->t3_1, c_call(cadr(arg))(sc, sc->t1_1));
  set_car(sc->t3_2, opt1_con(cdr(arg)));              /* caddr(arg) or cadr(caddr(arg)) */
  set_car(sc->t3_3, lookup(sc, opt2_sym(cdr(arg))));  /* cadddr(arg); */
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_opsq_c(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t1_1, lookup(sc, opt1_con(cdr(arg))));
  set_car(sc->t2_1, c_call(cadr(arg))(sc, sc->t1_1));
  set_car(sc->t2_2, opt2_con(cdr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_optq_c(s7_scheme *sc, s7_pointer arg)
{
  check_let_slots(sc, __func__, arg, opt1_con(cdr(arg)));
  set_car(sc->t1_1, slot_value(let_slots(sc->envir)));
  set_car(sc->t2_1, c_call(cadr(arg))(sc, sc->t1_1));
  set_car(sc->t2_2, opt2_con(cdr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_opssq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs))));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_opssq_direct(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  arg = cdr(arg);
  largs = cdadr(arg);
  return(((s7_p_pp_t)opt2_direct_x_call(arg))(sc, lookup(sc, car(arg)),
	   ((s7_p_pp_t)opt3_direct_x(arg))(sc, lookup(sc, car(largs)), lookup(sc, opt2_sym(largs)))));
}

#if (!WITH_GMP)
static s7_pointer fx_equal_add_ss(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs, x, y, z;
  largs = cdaddr(arg);
  x = lookup(sc, car(largs));
  y = lookup(sc, cadr(largs));
  z = lookup(sc, cadr(arg));
  if ((is_t_integer(x)) && (is_t_integer(y)) && (is_t_integer(z)))
    return(make_boolean(sc, (integer(x) + integer(y)) == integer(z)));
  return(c_equal_2(sc, z, add_p_pp(sc, x, y)));
}
#endif

static s7_pointer fx_c_c_opssq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs))));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, cadr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer direct_x_c_c_opssq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  s7_double x2;
  arg = cdr(arg);
  largs = cdadr(arg);
  x2 = ((s7_d_pd_t)opt3_direct_x(cdr(arg)))(lookup(sc, car(largs)),
					    real_to_double(sc, lookup(sc, opt2_sym(largs)), "number_to_double"));
  return(((s7_p_dd_t)opt2_direct_x_call(arg))(sc, real_to_double(sc, car(arg), "*"), x2));
}

static s7_pointer fx_c_s_opscq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, opt2_con(cdr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t1_1));
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_car(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val;
  val = lookup(sc, opt2_sym(cdr(arg)));
  set_car(sc->t2_2, (is_pair(val)) ? car(val) : g_car(sc, set_plist_1(sc, val)));
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_add_s_car(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer val1, val2;
  val2 = lookup(sc, opt2_sym(cdr(arg)));
  val2 = (is_pair(val2)) ? car(val2) : g_car(sc, set_plist_1(sc, val2));
  val1 = lookup(sc, cadr(arg));
  if ((is_t_integer(val1)) && (is_t_integer(val2)))
    return(make_integer(sc, integer(val1) + integer(val2)));
  return(add_p_pp(sc, val1, val2));
}

static s7_pointer fx_c_op_s_opsq_q(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer outer, args;
  outer = cadr(arg);
  args = caddr(outer);
  set_car(sc->t1_1, lookup(sc, cadr(args)));
  set_car(sc->t2_2, c_call(args)(sc, sc->t1_1));
  set_car(sc->t2_1, lookup(sc, cadr(outer)));
  set_car(sc->t1_1, c_call(outer)(sc, sc->t2_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_op_opsq_s_q(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer outer, args;
  outer = cadr(arg);
  args = cadr(outer);
  set_car(sc->t1_1, lookup(sc, cadr(args)));
  set_car(sc->t2_1, c_call(args)(sc, sc->t1_1));
  set_car(sc->t2_2, lookup(sc, caddr(outer)));
  set_car(sc->t1_1, c_call(outer)(sc, sc->t2_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_c_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t1_1));
  set_car(sc->t2_1, cadr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer direct_x_c_opsq_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_double x1, x2;
  s7_pointer p;
  p = cdr(arg);
  x1 = ((s7_d_p_t)opt3_direct_x(p))(lookup(sc, cadar(p)));
  x2 = ((s7_d_p_t)opt3_direct_x(cdr(p)))(lookup(sc, cadadr(p)));
  return(((s7_p_dd_t)opt2_direct_x_call(p))(sc, x1, x2));
}

static s7_pointer fx_c_opsq_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  set_car(sc->t1_1, lookup(sc, cadar(largs)));
  sc->t_temps[tx] = c_call(car(largs))(sc, sc->t1_1);
  largs = cadr(largs);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t1_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opdq_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  sc->t_temps[tx] = d_call(sc, car(largs));
  largs = cadr(largs);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t1_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opdq_opssq(s7_scheme *sc, s7_pointer arg)
{
  /* args: (/ (+ bn 1) (+ bn an)) */
  int32_t tx;
  s7_pointer args;
  tx = next_tx(sc);
  args = cdr(arg);
  sc->t_temps[tx] = d_call(sc, car(args));
  args = cadr(args);
  set_car(sc->t2_1, lookup(sc, cadr(args)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(args)))); /* caddr(args) */
  set_car(sc->t2_2, c_call(args)(sc, sc->t2_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  sc->t_temps[tx] = sc->F;
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opsq_opdq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  set_car(sc->t1_1, lookup(sc, cadar(largs)));
  sc->t_temps[tx] = c_call(car(largs))(sc, sc->t1_1);
  largs = cadr(largs);
  set_car(sc->t2_2, d_call(sc, largs));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opsq_opssq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  set_car(sc->t1_1, lookup(sc, cadar(largs)));
  sc->t_temps[tx] = c_call(car(largs))(sc, sc->t1_1);
  largs = cadr(largs);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs)))); /* caddr(largs) */
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opssq_opsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  set_car(sc->t2_1, lookup(sc, cadar(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdar(largs))));
  sc->t_temps[tx] = c_call(car(largs))(sc, sc->t2_1);
  largs = cadr(largs);
  set_car(sc->t1_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t1_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opssq_opdq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  set_car(sc->t2_1, lookup(sc, cadar(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdar(largs))));
  sc->t_temps[tx] = c_call(car(largs))(sc, sc->t2_1);
  largs = cadr(largs);
  set_car(sc->t2_2, d_call(sc, largs));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opssq_opssq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  set_car(sc->t2_1, lookup(sc, cadar(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdar(largs))));
  sc->t_temps[tx] = c_call(car(largs))(sc, sc->t2_1);
  largs = cadr(largs);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(largs))));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opscq_opscq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  int32_t tx;
  tx = next_tx(sc);
  largs = cdr(arg);
  set_car(sc->t2_1, lookup(sc, cadar(largs)));
  set_car(sc->t2_2, opt2_con(cdar(largs)));
  sc->t_temps[tx] = c_call(car(largs))(sc, sc->t2_1);
  largs = cadr(largs);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, opt2_con(cdr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_op_opssq_q_c(s7_scheme *sc, s7_pointer code)
{
  s7_pointer arg;
  arg = cadadr(code);
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(arg))));
  set_car(sc->t1_1, c_call(arg)(sc, sc->t2_1));
  set_car(sc->t2_1, c_call(cadr(code))(sc, sc->t1_1));
  set_car(sc->t2_2, caddr(code));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_op_opsq_q(s7_scheme *sc, s7_pointer code)
{
  s7_pointer arg;
  arg = cadadr(code);
  set_car(sc->t1_1, lookup(sc, cadr(arg)));
  set_car(sc->t1_1, c_call(arg)(sc, sc->t1_1));
  set_car(sc->t1_1, c_call(cadr(code))(sc, sc->t1_1));
  return(c_call(code)(sc, sc->t1_1));
}

static s7_pointer fx_c_s_op_s_opsqq(s7_scheme *sc, s7_pointer code)
{
  s7_pointer args, val, val1;
  args = caddr(code);
  val1 = caddr(args);
  val = lookup(sc, cadr(args));
  set_car(sc->t1_1, lookup(sc, cadr(val1)));
  set_car(sc->t2_2, c_call(val1)(sc, sc->t1_1));
  set_car(sc->t2_1, val);
  set_car(sc->t2_2, c_call(args)(sc, sc->t2_1));
  set_car(sc->t2_1, lookup(sc, cadr(code)));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_op_opsq_cq(s7_scheme *sc, s7_pointer code)
{
  s7_pointer args, val, val1;
  args = caddr(code);
  val1 = cadr(args);
  val = lookup(sc, cadr(val1));
  set_car(sc->t1_1, val);
  set_car(sc->t2_1, c_call(val1)(sc, sc->t1_1));
  set_car(sc->t2_2, opt2_con(cdr(args)));                 /* caddr(args) E_C_PC in combine_ops */
  set_car(sc->t2_2, c_call(args)(sc, sc->t2_1));
  set_car(sc->t2_1, lookup(sc, cadr(code)));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_op_s_opssqq(s7_scheme *sc, s7_pointer code)
{
  s7_pointer args, val, val1;
  args = caddr(code);
  val1 = caddr(args);
  val = lookup(sc, cadr(args));
  set_car(sc->t2_1, lookup(sc, cadr(val1)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(val1))));
  set_car(sc->t2_2, c_call(val1)(sc, sc->t2_1));
  set_car(sc->t2_1, val);
  set_car(sc->t2_2, c_call(args)(sc, sc->t2_1));
  set_car(sc->t2_1, lookup(sc, cadr(code)));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_op_opsq_q_s(s7_scheme *sc, s7_pointer code)
{
  s7_pointer arg;
  arg = cadadr(code);
  set_car(sc->t1_1, lookup(sc, cadr(arg)));
  set_car(sc->t1_1, c_call(arg)(sc, sc->t1_1));
  set_car(sc->t2_1, c_call(cadr(code))(sc, sc->t1_1));
  set_car(sc->t2_2, lookup(sc, caddr(code)));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_op_opsq_q_c(s7_scheme *sc, s7_pointer code)
{
  s7_pointer arg;
  arg = cadadr(code);
  set_car(sc->t1_1, lookup(sc, cadr(arg)));
  set_car(sc->t1_1, c_call(arg)(sc, sc->t1_1));
  set_car(sc->t2_1, c_call(cadr(code))(sc, sc->t1_1));
  set_car(sc->t2_2, caddr(code));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_a(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t1_1, fx_call(sc, cdr(arg)));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_not_a(s7_scheme *sc, s7_pointer arg)
{
  return((fx_call(sc, cdr(arg)) == sc->F) ? sc->T : sc->F);
}

static s7_pointer fx_c_ssa(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_3, fx_call(sc, cdddr(arg)));
  set_car(sc->t3_1, lookup(sc, cadr(arg)));
  set_car(sc->t3_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_sas(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_2, fx_call(sc, cddr(arg)));
  set_car(sc->t3_1, lookup(sc, cadr(arg)));
  set_car(sc->t3_3, lookup(sc, cadddr(arg)));
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_sca(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_3, fx_call(sc, cdddr(arg)));
  set_car(sc->t3_1, lookup(sc, cadr(arg)));
  set_car(sc->t3_2, caddr(arg));
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_csa(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_3, fx_call(sc, cdddr(arg)));
  set_car(sc->t3_1, cadr(arg));
  set_car(sc->t3_2, lookup(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_cac(s7_scheme *sc, s7_pointer arg)
{
  set_car(sc->t3_2, fx_call(sc, cddr(arg)));
  set_car(sc->t3_1, cadr(arg));
  set_car(sc->t3_3, cadddr(arg));
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_aa(s7_scheme *sc, s7_pointer arg)
{
  /* here neither "a" can involve a nested "a" */
  int32_t tx;
  tx = next_tx(sc);
  sc->t_temps[tx] = fx_call(sc, cdr(arg));
  set_car(sc->t2_2, fx_call(sc, cddr(arg)));
  set_car(sc->t2_1, sc->t_temps[tx]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_add_aa(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer a1, a2;
  a1 = cdr(arg);
  a2 = cdr(a1);
  return(add_p_pp(sc, fx_call(sc, a1), fx_call(sc, a2)));
}

static s7_pointer fx_subtract_aa(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer a1, a2;
  a1 = cdr(arg);
  a2 = cdr(a1);
  return(subtract_p_pp(sc, fx_call(sc, a1), fx_call(sc, a2)));
}

static s7_pointer fx_number_to_string_aa(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer a1, a2;
  a1 = cdr(arg);
  a2 = cdr(a1);
  return(number_to_string_p_pp(sc, fx_call(sc, a1), fx_call(sc, a2)));
}

static s7_pointer fx_c_aaa(s7_scheme *sc, s7_pointer arg)
{
  /* here none of the "a"s can involve a nested "a", fx_c_aaaa was not hit much (see tmp) */
  int32_t tx1, tx2;
  s7_pointer p;
  tx1 = next_tx(sc);
  tx2 = next_tx(sc);
  p = cdr(arg);
  sc->t_temps[tx1] = fx_call(sc, p);
  p = cdr(p);
  sc->t_temps[tx2] = fx_call(sc, p);
  p = cdr(p);
  set_car(sc->t3_3, fx_call(sc, p));
  set_car(sc->t3_2, sc->t_temps[tx2]);
  set_car(sc->t3_1, sc->t_temps[tx1]);
  return(c_call(arg)(sc, sc->t3_1));
}

static s7_pointer fx_c_opaq_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer arg2;
  arg2 = cdadr(arg);
  set_car(sc->t1_1, fx_call(sc, arg2));
  set_car(sc->t2_1, c_call(cadr(arg))(sc, sc->t1_1));
  set_car(sc->t2_2, lookup_checked(sc, caddr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_opaq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer arg2;
  arg2 = cdaddr(arg);
  set_car(sc->t1_1, fx_call(sc, arg2));
  set_car(sc->t2_2, c_call(caddr(arg))(sc, sc->t1_1));
  set_car(sc->t2_1, lookup_checked(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_opaq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  p = cadr(arg);
  set_car(sc->t1_1, fx_call(sc, cdr(p)));
  set_car(sc->t1_1, c_call(p)(sc, sc->t1_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_opaaq(s7_scheme *sc, s7_pointer arg)
{
  int32_t tx1;
  s7_pointer p;
  tx1 = next_tx(sc);
  p = cadr(arg);
  sc->t_temps[tx1] = fx_call(sc, cdr(p));
  set_car(sc->t2_2, fx_call(sc, cddr(p)));
  set_car(sc->t2_1, sc->t_temps[tx1]);
  set_car(sc->t1_1, c_call(p)(sc, sc->t2_1));
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_c_opaaq_opaaq(s7_scheme *sc, s7_pointer arg)
{
  /* none of the "a" involve nested "a", this is used heavily (12G) in tbig.scm */
  int32_t tx1, tx2;
  s7_pointer p1, p2, arg11, arg12, arg21, arg22;

  p1 = cadr(arg);
  arg11 = cdr(p1);
  arg12 = cddr(p1);
  p2 = caddr(arg);
  arg21 = cdr(p2);
  arg22 = cddr(p2);

  tx1 = next_tx(sc);
  tx2 = next_tx(sc);

  sc->t_temps[tx1] = fx_call(sc, arg11);
  set_car(sc->t2_2, fx_call(sc, arg12));
  set_car(sc->t2_1, sc->t_temps[tx1]);
  sc->t_temps[tx1] = c_call(p1)(sc, sc->t2_1);

  sc->t_temps[tx2] = fx_call(sc, arg21);
  set_car(sc->t2_2, fx_call(sc, arg22));
  set_car(sc->t2_1, sc->t_temps[tx2]);

  set_car(sc->t2_2, c_call(p2)(sc, sc->t2_1));
  set_car(sc->t2_1, sc->t_temps[tx1]);
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_c_opscq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_1, lookup(sc, cadr(largs)));
  set_car(sc->t2_2, opt2_con(cdr(largs)));
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, cadr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_c_opcsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_2, lookup(sc, caddr(largs)));
  set_car(sc->t2_1, opt1_con(cdr(largs))); /* cadr(largs) or cadadr */
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, cadr(arg));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_opcsq(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer largs;
  largs = caddr(arg);
  set_car(sc->t2_2, lookup(sc, caddr(largs)));
  set_car(sc->t2_1, opt1_con(cdr(largs))); /* cadr(largs) or cadadr */
  set_car(sc->t2_2, c_call(largs)(sc, sc->t2_1));
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  return(c_call(arg)(sc, sc->t2_1));
}

static s7_pointer fx_c_op_opssq_q_s(s7_scheme *sc, s7_pointer code)
{
  s7_pointer arg;
  arg = opt3_pair(code); /* cadadr(code); */
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(arg))));
  set_car(sc->t1_1, c_call(arg)(sc, sc->t2_1));
  set_car(sc->t2_1, c_call(cadr(code))(sc, sc->t1_1));
  set_car(sc->t2_2, lookup(sc, caddr(code)));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_op_opssq_sq_s(s7_scheme *sc, s7_pointer code)
{
  s7_pointer arg;
  arg = opt3_pair(code); /* cadadr(code); */
  set_car(sc->t2_1, lookup(sc, cadr(arg)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(arg))));
  set_car(sc->t2_1, c_call(arg)(sc, sc->t2_1));
  set_car(sc->t2_2, lookup(sc, caddr(cadr(code))));
  set_car(sc->t2_1, c_call(cadr(code))(sc, sc->t2_1));
  set_car(sc->t2_2, lookup(sc, caddr(code)));
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_s_op_opssq_opssqq(s7_scheme *sc, s7_pointer code)
{
  s7_pointer args, op1, op2;
  int32_t tx;
  tx = next_tx(sc);
  args = caddr(code);
  op1 = cadr(args);
  op2 = caddr(args);
  set_car(sc->t2_1, lookup(sc, cadr(op1)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(op1))));
  sc->t_temps[tx] = c_call(op1)(sc, sc->t2_1);
  set_car(sc->t2_1, lookup(sc, cadr(op2)));
  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(op2))));
  set_car(sc->t2_2, c_call(op2)(sc, sc->t2_1));
  set_car(sc->t2_1, sc->t_temps[tx]);
  set_car(sc->t2_2, c_call(args)(sc, sc->t2_1));
  set_car(sc->t2_1, lookup(sc, cadr(code)));
  sc->t_temps[tx] = sc->F;
  return(c_call(code)(sc, sc->t2_1));
}

static s7_pointer fx_c_all_s(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer args, p;
  int32_t tx;
  tx = next_tx(sc);
  sc->t_temps[tx] = safe_list_if_possible(sc, integer(opt3_arglen(arg)));
  for (args = cdr(arg), p = sc->t_temps[tx]; is_pair(args); args = cdr(args), p = cdr(p))
    set_car(p, lookup(sc, car(args)));
  clear_list_in_use(sc->t_temps[tx]);
  sc->current_safe_list = 0;
  return(c_call(arg)(sc, sc->t_temps[tx]));
}

static s7_pointer fx_c_fx(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer args, p;
  int32_t tx;
  tx = next_tx(sc);
  sc->t_temps[tx] = safe_list_if_possible(sc, integer(opt3_arglen(arg)));
  for (args = cdr(arg), p = sc->t_temps[tx]; is_pair(args); args = cdr(args), p = cdr(p))
    set_car(p, fx_call(sc, args));
  clear_list_in_use(sc->t_temps[tx]);
  sc->current_safe_list = 0;
  return(c_call(arg)(sc, sc->t_temps[tx]));
}

static s7_pointer fx_if_a_aa(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  p = cdr(arg);
  if (is_true(sc, fx_call(sc, p)))
    p = cdr(p);
  else p = cddr(p);
  return(fx_call(sc, p));
}

static s7_pointer fx_and_2(s7_scheme *sc, s7_pointer arg)
{
  /* arg is the full expr: (and ...) */
  s7_pointer p, val;
  p = cdr(arg);
  val = fx_call(sc, p);
  if (val == sc->F) return(val);
  p = cdr(p);
  return(fx_call(sc, p));
}

static s7_pointer fx_and_3(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p, val;
  p = cdr(arg);
  val = fx_call(sc, p);
  if (val == sc->F) return(val);
  p = cdr(p);
  val = fx_call(sc, p);
  if (val == sc->F) return(val);
  p = cdr(p);
  return(fx_call(sc, p));
}

static s7_pointer fx_and_n(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p, x;
  x = sc->T;
  for (p = cdr(arg); is_pair(p); p = cdr(p))
    {
      x = fx_call(sc, p);
      if (is_false(sc, x))
	return(x);
    }
  return(x);
}

static s7_pointer fx_or_2(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p, val;
  p = cdr(arg);
  val = fx_call(sc, p);
  if (val != sc->F) return(val);
  p = cdr(p);
  return(fx_call(sc, p));
}

static s7_pointer fx_or_and_2(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p, val;
  p = cdr(arg);
  val = fx_call(sc, p);
  if (val != sc->F) return(val);
  p = cdadr(p);
  val = fx_call(sc, p);
  if (val == sc->F) return(val);
  p = cdr(p);
  return(fx_call(sc, p));
}

static s7_pointer fx_or_and_3(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p, val;
  p = cdr(arg);
  val = fx_call(sc, p);
  if (val != sc->F) return(val);
  p = cdadr(p);
  val = fx_call(sc, p);
  if (val == sc->F) return(val);
  p = cdr(p);
  val = fx_call(sc, p);
  if (val == sc->F) return(val);
  p = cdr(p);
  return(fx_call(sc, p));
}

static s7_pointer fx_or_3(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p, val;
  p = cdr(arg);
  val = fx_call(sc, p);
  if (val != sc->F) return(val);
  p = cdr(p);
  val = fx_call(sc, p);
  if (val != sc->F) return(val);
  p = cdr(p);
  return(fx_call(sc, p));
}

static s7_pointer fx_or_n(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer p;
  for (p = cdr(arg); is_pair(p); p = cdr(p))
    {
      s7_pointer x;
      x = fx_call(sc, p);
      if (is_true(sc, x))
	return(x);
    }
  return(sc->F);
}

static s7_pointer fx_thunk_a(s7_scheme *sc, s7_pointer code)
{
  s7_pointer f, result, old_e;
  old_e = sc->envir;
  f = opt1_lambda(code);
  sc->envir = closure_let(f);
  code = closure_body(f);
  result = fx_call(sc, code);
  sc->envir = old_e;
  return(result);
}

static s7_pointer fx_closure_s_a(s7_scheme *sc, s7_pointer code)
{
  s7_pointer result, old_e;
  old_e = sc->envir;
  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(code)), lookup(sc, opt2_sym(code)));
  code = closure_body(opt1_lambda(code));
  result = fx_call(sc, code);
  sc->envir = old_e;
  return(result);
}

static s7_pointer fx_c_closure_s_a(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer old_e, clo_arg;
  clo_arg = cadr(arg);
  old_e = sc->envir;
  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(clo_arg)), lookup(sc, opt2_sym(clo_arg)));
  clo_arg = closure_body(opt1_lambda(clo_arg));
  set_car(sc->t1_1, fx_call(sc, clo_arg));
  sc->envir = old_e;
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_closure_s_d(s7_scheme *sc, s7_pointer code)
{
  s7_pointer result, old_e;
  old_e = sc->envir;
  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(code)), lookup(sc, opt2_sym(code)));
  code = closure_body(opt1_lambda(code));
  result = d_call(sc, car(code));
  sc->envir = old_e;
  return(result);
}

static s7_pointer fx_c_closure_s_d(s7_scheme *sc, s7_pointer arg)
{
  s7_pointer old_e, clo_arg;
  clo_arg = cadr(arg);
  old_e = sc->envir;
  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(clo_arg)), lookup(sc, opt2_sym(clo_arg)));
  clo_arg = closure_body(opt1_lambda(clo_arg));
  set_car(sc->t1_1, d_call(sc, car(clo_arg)));
  sc->envir = old_e;
  return(c_call(arg)(sc, sc->t1_1));
}

static s7_pointer fx_and_2_closure_s(s7_scheme *sc, s7_pointer code) /* safe_closure_s_a where "a" is g_and_2 */
{
  s7_pointer result, old_e;
  old_e = sc->envir;
  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(code)), lookup(sc, opt2_sym(code)));
  code = cdar(closure_body(opt1_lambda(code)));
  result = fx_call(sc, code);
  if (result != sc->F)
    result = fx_call(sc, cdr(code));
  sc->envir = old_e;
  return(result);
}

static s7_pointer fx_and_pair_closure_s(s7_scheme *sc, s7_pointer code) /* safe_closure_s_a where "a" is g_and_2 with is_pair as first clause */
{
  s7_pointer result, old_e;
  old_e = sc->envir;
  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(code)), lookup(sc, opt2_sym(code)));
  code = cdar(closure_body(opt1_lambda(code)));
  if (is_pair(slot_value(let_slots(sc->envir)))) /* pair? arg = func par, pair? is global, symbol_id=0 */
    result = fx_call(sc, cdr(code));
  else result = sc->F;
  sc->envir = old_e;
  return(result);
}

static s7_pointer fx_closure_a_a(s7_scheme *sc, s7_pointer code)
{
  s7_pointer result, old_e;
  old_e = sc->envir;
  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(code)), fx_call(sc, cdr(code)));
  code = closure_body(opt1_lambda(code));
  result = fx_call(sc, code);
  sc->envir = old_e;
  return(result);
}

static s7_pointer fx_closure_ss_a(s7_scheme *sc, s7_pointer code)
{
  s7_pointer result, old_e;
  old_e = sc->envir;
  sc->envir = old_frame_with_two_slots(sc, closure_let(opt1_lambda(code)),
				       lookup(sc, cadr(code)),
				       lookup(sc, opt2_sym(code)));
  code = closure_body(opt1_lambda(code));
  result = fx_call(sc, code);
  sc->envir = old_e;
  return(result);
}

static void fx_function_init(void)
{
  int32_t i;
  for (i = 0; i < OPT_MAX_DEFINED; i++)
    fx_function[i] = NULL;

  fx_function[HOP_SAFE_C_D] = fx_c_d;
  fx_function[HOP_SAFE_C_OR2] = fx_or_2;
  fx_function[HOP_SAFE_C_AND2] = fx_and_2;
  fx_function[HOP_SAFE_C_A] = fx_c_a;
  fx_function[HOP_SAFE_C_S] = fx_c_s;
  fx_function[HOP_SAFE_CAR_S] = fx_car_s;
  fx_function[HOP_SAFE_CDR_S] = fx_cdr_s;
  fx_function[HOP_SAFE_CADR_S] = fx_cadr_s;
  fx_function[HOP_SAFE_IS_PAIR_S] = fx_is_pair_s;
  fx_function[HOP_SAFE_IS_NULL_S] = fx_is_null_s;
  fx_function[HOP_SAFE_IS_SYMBOL_S] = fx_is_symbol_s;

  fx_function[HOP_SAFE_C_opDq] = fx_c_opdq;
  fx_function[HOP_SAFE_C_opSq] = fx_c_opsq;
  fx_function[HOP_SAFE_C_opSSq] = fx_c_opssq;
  fx_function[HOP_SAFE_C_opSCq] = fx_c_opscq;
  fx_function[HOP_SAFE_C_opCSq] = fx_c_opcsq;

  fx_function[HOP_SAFE_C_SC] = fx_c_sc;
  fx_function[HOP_SAFE_C_CS] = fx_c_cs;
  fx_function[HOP_SAFE_C_CQ] = fx_c_cq;
  fx_function[HOP_SAFE_C_SS] = fx_c_ss;

  fx_function[HOP_SAFE_C_opSq_S] = fx_c_opsq_s;
  fx_function[HOP_SAFE_C_CAR_S_S] = fx_c_car_s_s;
  fx_function[HOP_SAFE_C_opSq_C] = fx_c_opsq_c;
  fx_function[HOP_SAFE_C_opSq_CS] = fx_c_opsq_cs;
  fx_function[HOP_SAFE_C_S_opSq] = fx_c_s_opsq;
  fx_function[HOP_SAFE_C_S_opDq] = fx_c_s_opdq;
  fx_function[HOP_SAFE_C_opDq_S] = fx_c_opdq_s;
  fx_function[HOP_SAFE_C_opDq_C] = fx_c_opdq_c;
  fx_function[HOP_SAFE_C_C_opSq] = fx_c_c_opsq;
  fx_function[HOP_SAFE_C_C_opDq] = fx_c_c_opdq;
  fx_function[HOP_SAFE_C_opCSq_C] = fx_c_opcsq_c;
  fx_function[HOP_SAFE_C_opCSq_S] = fx_c_opcsq_s;
  fx_function[HOP_SAFE_C_C_opCSq] = fx_c_c_opcsq;
  fx_function[HOP_SAFE_C_S_opCSq] = fx_c_s_opcsq;
  fx_function[HOP_SAFE_C_opSSq_C] = fx_c_opssq_c;
  fx_function[HOP_SAFE_C_opSCq_S] = fx_c_opscq_s;
  fx_function[HOP_SAFE_C_opSCq_C] = fx_c_opscq_c;
  fx_function[HOP_SAFE_C_opSSq_S] = fx_c_opssq_s;
  fx_function[HOP_SAFE_C_S_opSSq] = fx_c_s_opssq;
  fx_function[HOP_SAFE_C_C_opSSq] = fx_c_c_opssq;
  fx_function[HOP_SAFE_C_S_opSCq] = fx_c_s_opscq;
  fx_function[HOP_SAFE_C_C_opSCq] = fx_c_c_opscq;
  fx_function[HOP_SAFE_C_opSq_opSq] = fx_c_opsq_opsq;
  fx_function[HOP_SAFE_C_opSq_opDq] = fx_c_opsq_opdq;
  fx_function[HOP_SAFE_C_opDq_opSq] = fx_c_opdq_opsq;
  fx_function[HOP_SAFE_C_opDq_opSSq] = fx_c_opdq_opssq;
  fx_function[HOP_SAFE_C_opSq_opSSq] = fx_c_opsq_opssq;
  fx_function[HOP_SAFE_C_opDq_opDq] = fx_c_opdq_opdq;
  fx_function[HOP_SAFE_C_opSSq_opSq] = fx_c_opssq_opsq;
  fx_function[HOP_SAFE_C_opSSq_opDq] = fx_c_opssq_opdq;
  fx_function[HOP_SAFE_C_opSSq_opSSq] = fx_c_opssq_opssq;
  fx_function[HOP_SAFE_C_opSCq_opSCq] = fx_c_opscq_opscq;
  fx_function[HOP_SAFE_C_op_opSSq_q_C] = fx_c_op_opssq_q_c;
  fx_function[HOP_SAFE_C_op_opSq_q] = fx_c_op_opsq_q;
  fx_function[HOP_SAFE_C_op_opSq_q_S] = fx_c_op_opsq_q_s;
  fx_function[HOP_SAFE_C_op_opSq_q_C] = fx_c_op_opsq_q_c;
  fx_function[HOP_SAFE_C_op_S_opSq_q] = fx_c_op_s_opsq_q;
  fx_function[HOP_SAFE_C_op_opSq_S_q] = fx_c_op_opsq_s_q;
  fx_function[HOP_SAFE_C_S_op_S_opSqq] = fx_c_s_op_s_opsqq;
  fx_function[HOP_SAFE_C_S_op_S_opSSqq] = fx_c_s_op_s_opssqq;
  fx_function[HOP_SAFE_C_S_op_opSq_Cq] = fx_c_s_op_opsq_cq;
  fx_function[HOP_SAFE_C_op_opSSq_q_S] = fx_c_op_opssq_q_s;
  fx_function[HOP_SAFE_C_op_opSSq_Sq_S] = fx_c_op_opssq_sq_s;
  fx_function[HOP_SAFE_C_S_op_opSSq_opSSqq] = fx_c_s_op_opssq_opssqq;
  fx_function[HOP_SAFE_C_CAC] = fx_c_cac;
  fx_function[HOP_SAFE_C_CSA] = fx_c_csa;
  fx_function[HOP_SAFE_C_SCA] = fx_c_sca;
  fx_function[HOP_SAFE_C_SAS] = fx_c_sas;
  fx_function[HOP_SAFE_C_SSA] = fx_c_ssa;
  fx_function[HOP_SAFE_C_SSC] = fx_c_ssc;
  fx_function[HOP_SAFE_C_SSS] = fx_c_sss;
  fx_function[HOP_SAFE_C_SCS] = fx_c_scs;
  fx_function[HOP_SAFE_C_SCC] = fx_c_scc;
  fx_function[HOP_SAFE_C_CSS] = fx_c_css;
  fx_function[HOP_SAFE_C_CSC] = fx_c_csc;
  fx_function[HOP_SAFE_C_CCS] = fx_c_ccs;
  fx_function[HOP_SAFE_C_SSSC] = fx_c_sssc;
  fx_function[HOP_SAFE_C_ALL_S] = fx_c_all_s;
  fx_function[HOP_SAFE_C_opAq] = fx_c_opaq;
  fx_function[HOP_SAFE_C_opAq_S] = fx_c_opaq_s;
  fx_function[HOP_SAFE_C_S_opAq] = fx_c_s_opaq;
  fx_function[HOP_SAFE_THUNK_A] = fx_thunk_a;
  fx_function[HOP_SAFE_CLOSURE_S_A] = fx_closure_s_a;
  fx_function[HOP_SAFE_CLOSURE_A_A] = fx_closure_a_a;
  fx_function[HOP_SAFE_CLOSURE_SS_A] = fx_closure_ss_a;
  /* safe_closure_c|aa_a do not happen often */
}

static s7_pointer g_not_c_c(s7_scheme *sc, s7_pointer args);
static s7_pointer g_not_is_pair_s(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_pair_cdr_s(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_pair_cddr_s(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_null_cddr_s(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_null_cadr_s(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_symbol_cadr_s(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_eq_car(s7_scheme *sc, s7_pointer args);
static s7_pointer g_is_eq_car_q(s7_scheme *sc, s7_pointer args);
static s7_pointer g_if_a_aa(s7_scheme *sc, s7_pointer args);
static s7_pointer g_and_2(s7_scheme *sc, s7_pointer args);
static s7_pointer g_and_3(s7_scheme *sc, s7_pointer args);
static s7_pointer g_and_n(s7_scheme *sc, s7_pointer args);
static s7_pointer g_or_2(s7_scheme *sc, s7_pointer args);
static s7_pointer g_or_3(s7_scheme *sc, s7_pointer args);
static s7_pointer g_or_n(s7_scheme *sc, s7_pointer args);
static inline s7_pointer check_quote(s7_scheme *sc, s7_pointer code);

static s7_p_p_t s7_p_p_function(s7_pointer f);
static s7_p_pp_t s7_p_pp_function(s7_pointer f);

static s7_function fx_choose(s7_scheme *sc, s7_pointer holder, s7_pointer e, safe_sym_t *checker)
{
  s7_pointer arg;
  arg = car(holder);
  if (is_pair(arg))
    {
      if (is_optimized(arg))
	{
	  switch (optimize_op(arg))
	    {
	    case HOP_SAFE_C_D:
	      if (is_global(sc->is_pair_symbol))
		{
		  if (c_callee(arg) == g_not_is_pair_s)
		    {
		      set_opt3_sym(arg, cadadr(arg));
		      return(fx_not_is_pair_s);
		    }
		  if (c_callee(arg) == g_is_pair_cdr_s)
		    {
		      set_opt2_sym(cdr(arg), cadadr(arg));
		      return(fx_is_pair_cdr_s);
		    }
		  if (c_callee(arg) == g_is_pair_cddr_s)
		    {
		      set_opt2_sym(cdr(arg), cadadr(arg));
		      return(fx_is_pair_cddr_s);
		    }
		}
	      if (is_global(sc->is_null_symbol))
		{
		  if (c_callee(arg) == g_is_null_cadr_s)
		    {
		      set_opt2_sym(cdr(arg), cadadr(arg));
		      return(fx_is_null_cadr_s);
		    }
		  if (c_callee(arg) == g_is_null_cddr_s)
		    {
		      set_opt2_sym(cdr(arg), cadadr(arg));
		      return(fx_is_null_cddr_s);
		    }
		}
	      if (is_global(sc->is_symbol_symbol))
		{
		  if (c_callee(arg) == g_is_symbol_cadr_s)
		    {
		      set_opt2_sym(cdr(arg), cadadr(arg));
		      return(fx_is_symbol_cadr_s);
		    }
		}
	      if (c_callee(arg) == g_add_cs1) return(fx_c_add_s1);
	      if (c_callee(arg) == g_subtract_cs1) return(fx_c_sub_s1);
	      if (c_callee(arg) == g_if_a_aa) return(fx_if_a_aa);
	      if (c_callee(arg) == g_and_2) return(fx_and_2);
	      if (c_callee(arg) == g_and_3) return(fx_and_3);
	      if (c_callee(arg) == g_and_n) return(fx_and_n);
	      if (c_callee(arg) == g_or_2) 
		{
		  if (c_callee(cddr(arg)) == fx_and_2) return(fx_or_and_2);
		  if (c_callee(cddr(arg)) == fx_and_3) return(fx_or_and_3);
		  return(fx_or_2);
		}
	      if (c_callee(arg) == g_or_3) return(fx_or_3);
	      if (c_callee(arg) == g_or_n) return(fx_or_n);
	      if ((c_callee(arg) == g_add_si) &&
		  (checker(sc, cadr(arg), e)))
		return(fx_c_add_si);
	      if ((c_callee(arg) == g_subtract_csn) &&
		  (checker(sc, cadr(arg), e)))
		return(fx_c_sub_si);
	      if ((c_callee(arg) == g_char_equal_s_ic) &&
		  (checker(sc, cadr(arg), e)))
		return(fx_c_char_eq);
#if (!WITH_GMP)
	      if ((c_callee(arg) == g_equal_s_ic) &&
		  (checker(sc, cadr(arg), e)))
		return(fx_c_equal_s_ic);
#endif
	      if (c_callee(arg) == g_is_eq_car_q) return(fx_is_eq_car_q);
	      if (c_callee(arg) == g_not_c_c)
		{
		  if (c_callee(cadr(arg)) == g_is_eq_car_q)
		    {
		      set_opt2_pair(cdr(arg), cdadr(arg));
		      return(fx_not_is_eq_car_q);
		    }
		  return(fx_not_c_d);
		}
	      if (c_callee(arg) == g_hash_table_ref_ss)
		return(fx_c_hash_table_ref_ss);
	      if (c_callee(arg) == g_hash_table_ref_car)
		return(fx_c_hash_table_ref_car);
	      return(fx_c_d);

	    case HOP_SAFE_C_OR2:
	      if (c_callee(cddr(arg)) == fx_and_2) return(fx_or_and_2);
	      if (c_callee(cddr(arg)) == fx_and_3) return(fx_or_and_3);
	      return(fx_or_2);

	    case HOP_SAFE_C_S:
	      if (car(arg) == sc->cdr_symbol) return(fx_cdr_s);
	      if (car(arg) == sc->car_symbol) return(fx_car_s);
	      if (car(arg) == sc->cadr_symbol) return(fx_cadr_s);
	      if (is_global(car(arg))) /* guard against (op arg) where arg is a let with an op method */
		{
		  uint8_t typ;
		  if (car(arg) == sc->is_null_symbol) return(fx_is_null_s);
		  if (car(arg) == sc->is_pair_symbol) return(fx_is_pair_s);
		  if (car(arg) == sc->is_symbol_symbol) return(fx_is_symbol_s);
		  if (car(arg) == sc->is_integer_symbol) return(fx_is_integer_s);
		  if (car(arg) == sc->is_string_symbol) return(fx_is_string_s);
		  if (car(arg) == sc->not_symbol) return(fx_not_s);
		  if (car(arg) == sc->is_proper_list_symbol) return(fx_is_proper_list_s);
		  if (car(arg) == sc->is_vector_symbol) return(fx_is_vector_s);
		  if (car(arg) == sc->is_keyword_symbol) return(fx_is_keyword_s);
		  if (car(arg) == sc->is_procedure_symbol) return(fx_is_procedure_s);
		  if (car(arg) == sc->length_symbol) return(fx_length_s);
		  typ = symbol_type(car(arg));
		  if (typ > 0)
		    {
		      set_opt3_con(cdr(arg), typ);
		      return(fx_is_type_s);
		    }
		}
	      if (symbol_id(car(arg)) == 0)
		{
		  s7_p_p_t f;
		  f = s7_p_p_function(slot_value(global_slot(car(arg))));
		  if (f)
		    {
		      set_direct_x_opt(arg);
		      set_opt2_direct_x_call(cdr(arg), (s7_pointer)f);
		      return(fx_o_p_p_s);
		    }
		}
	      return(fx_c_s);

	    case HOP_SAFE_C_SS:
	      if (c_callee(arg) == g_cons) return(fx_cons_ss);
#if (!WITH_GMP)
	      if (car(arg) == sc->eq_symbol) return(fx_equal_ss);
	      if (c_callee(arg) == g_geq_2) return(fx_geq_ss);
	      if (c_callee(arg) == g_greater_2) return(fx_gt_ss);
	      if (c_callee(arg) == g_leq_2) return(fx_leq_ss);
	      if (c_callee(arg) == g_less_2) return(fx_lt_ss);
	      if (c_callee(arg) == g_multiply_2) return(fx_multiply_ss);
#endif
	      if (c_callee(arg) == g_is_eq) return(fx_is_eq_ss);
	      if (c_callee(arg) == g_add_2) return(fx_add_ss);
	      if (c_callee(arg) == g_subtract_2) return(fx_subtract_ss);
	      return(fx_c_ss);

	    case HOP_SAFE_C_S_opSSq:
#if (!WITH_GMP)
	      if ((car(arg) == sc->eq_symbol) &&
		  (caaddr(arg) == sc->add_symbol))
		return(fx_equal_add_ss);
#endif
	      if ((s7_p_pp_function(slot_value(global_slot(car(arg))))) &&
		  (s7_p_pp_function(slot_value(global_slot(caaddr(arg))))))
		{
		  set_direct_x_opt(arg);
		  set_opt2_direct_x_call(cdr(arg), (s7_pointer)(s7_p_pp_function(slot_value(global_slot(car(arg))))));
		  set_opt3_direct_x(cdr(arg), (s7_pointer)(s7_p_pp_function(slot_value(global_slot(caaddr(arg))))));
		  return(fx_c_s_opssq_direct);
		}
	      return(fx_c_s_opssq);

	    case HOP_SAFE_C_opSSq_S:
	      if ((s7_p_pp_function(slot_value(global_slot(car(arg))))) &&
		  (s7_p_pp_function(slot_value(global_slot(caadr(arg))))))
		{
		  set_direct_x_opt(arg);
		  set_opt2_direct_x_call(cdr(arg), (s7_pointer)(s7_p_pp_function(slot_value(global_slot(car(arg))))));
		  set_opt3_direct_x(cdr(arg), (s7_pointer)(s7_p_pp_function(slot_value(global_slot(caadr(arg))))));
		  return(fx_c_opssq_s_direct);
		}
	      return(fx_c_opssq_s);

	    case HOP_SAFE_C_opSq:
	      if (car(arg) == sc->not_symbol) return(fx_not_opsq);
	      if (is_global(car(arg))) /* (? (op arg)) where (op arg) might return a let with a ? method etc */
		{                      /*    other possibility: fx_c_a */
		  uint8_t typ;
		  typ = symbol_type(car(arg));
		  if (typ > 0) /* h_safe_c here so the type checker isn't shadowed */
		    {
		      set_opt2_sym(cdr(arg), cadadr(arg));
		      set_opt3_con(cdr(arg), typ);
		      if (c_callee(cadr(arg)) == (s7_function)g_c_pointer_weak1)
			return(fx_c_weak1_type);
		      if (caadr(arg) == sc->car_symbol)
			return(fx_c_is_type_car_s);
		      return(fx_c_is_type_opsq);
		    }
		}
	      if (caadr(arg) == sc->car_symbol)
		{
		  set_opt2_sym(cdr(arg), cadadr(arg));
		  return(fx_c_car_s);
		}
	      if (caadr(arg) == sc->cdr_symbol)
		{
		  set_opt2_sym(cdr(arg), cadadr(arg));
		  return(fx_c_cdr_s);
		}
	      return(fx_c_opsq);

	    case HOP_SAFE_C_SC:
	      if ((c_callee(arg) == g_memq_2) && (is_pair(caddr(arg)))) return(fx_memq_sq_2);
	      return(fx_c_sc);

	    case HOP_SAFE_C_S_opSq:
	      if (car(caddr(arg)) == sc->car_symbol)
		{
		  set_opt2_sym(cdr(arg), cadr(caddr(arg)));
		  if (car(arg) == sc->add_symbol) return(fx_add_s_car);
		  return(fx_c_s_car);
		}
	      return(fx_c_s_opsq);

	    case HOP_SAFE_C_opSSq:
	      if (car(arg) == sc->not_symbol) return(fx_not_opssq);
	      return(fx_c_opssq);

	    case HOP_SAFE_C_C_opSSq:
	      if (has_direct_x_opt(arg)) return(direct_x_c_c_opssq);
	      return(fx_c_c_opssq);

	    case HOP_SAFE_C_opSq_opSq:
	      if (has_direct_x_opt(arg)) return(direct_x_c_opsq_opsq);
	      return(fx_c_opsq_opsq);

	    case HOP_SAFE_C_A:
	      if (car(arg) == sc->not_symbol) return(fx_not_a);
	      if (c_callee(cdr(arg)) == fx_closure_s_d) return(fx_c_closure_s_d);
	      if (c_callee(cdr(arg)) == fx_closure_s_a) return(fx_c_closure_s_a);
	      return(fx_c_a);

	    case HOP_SAFE_C_AA:
	      if (aa_is_fx_safe(sc, arg))
		{
		  if (c_callee(arg) == g_add_2) return(fx_add_aa);
		  if (c_callee(arg) == g_subtract_2) return(fx_subtract_aa);
		  if (c_callee(arg) == g_number_to_string) return(fx_number_to_string_aa);
		  return(fx_c_aa);
		}
	      if (opaaq_opaaq_is_fx_safe(sc, arg)) return(fx_c_opaaq_opaaq);
	      return(NULL);

	    case HOP_SAFE_C_AAA:
	      if (aaa_is_fx_safe(sc, arg)) return(fx_c_aaa);
	      return(NULL);

	    case HOP_SAFE_C_opAAq:
	      if (aa_is_fx_safe(sc, cadr(arg))) return(fx_c_opaaq);
	      return(NULL);

	    case HOP_SAFE_C_FX:
	      if (is_fx_safe(sc, arg)) return(fx_c_fx);
	      return(NULL);

	    case HOP_SAFE_CLOSURE_S_A:
	      {
		s7_pointer body;
		body = car(closure_body(opt1_lambda(arg)));
		if ((is_pair(body)) &&
		    (is_h_safe_c_d(body)))
		  {
		    if (c_callee(body) == g_and_2)
		      {
			if ((caadr(body) == sc->is_pair_symbol) &&
			    (symbol_id(sc->is_pair_symbol) == 0) &&
			    (cadadr(body) == car(closure_args(opt1_lambda(arg)))))
			  return(fx_and_pair_closure_s);
			return(fx_and_2_closure_s);
		      }
		    return(fx_closure_s_d);
		  }
	      }
	      
	    default:
	      /* if ((!fx_function[optimize_op(arg)]) && (is_h_optimized(arg))) fprintf(stderr, "fx_choose %s %s\n", DISPLAY(arg), op_names[optimize_op(arg)]); */
	      return(fx_function[optimize_op(arg)]);
	    }
	} /* is_optimized */
      if (car(arg) == sc->quote_symbol)
	{
	  check_quote(sc, arg);
	  return(fx_q);
	}
      return(NULL);
    }
  if (is_symbol(arg))
    {
      if ((is_keyword(arg)) ||
	  ((arg == sc->else_symbol) &&
	   (is_global(arg))))
	return(fx_c);
      if (checker(sc, arg, e))
	return(fx_s);
      return(fx_unsafe_s);
    }
  return(fx_c);
}


/* -------------------------------------------------------------------------------- */

enum {o_d_v, o_d_vd, o_d_vdd, o_d_vid, o_d_id, o_d_7pi, o_d_7pii, o_d_7piid,
      o_d_ip, o_d_pd, o_d_7pid, o_d, o_d_d, o_d_dd, o_d_7dd, o_d_ddd, o_d_dddd,
      o_i_i, o_i_7i, o_i_ii, o_i_7ii, o_i_iii, o_i_7pi, o_i_7pii, o_i_7piii, o_d_p,
      o_b_p, o_b_p_direct, o_b_7p, o_b_pp, o_b_7pp, o_b_pp_direct, o_b_pi, o_b_ii, o_b_dd,
      o_p, o_p_p, o_p_ii, o_p_d, o_p_dd, o_i_7d, o_i_7p, o_d_7d, o_d_7p,
      o_p_pp, o_p_pp_direct, o_p_ppp, o_p_ppp_direct, o_p_pi, o_p_pi_direct,
      o_p_ppi, o_p_i, o_p_pii, o_p_pip, o_p_pip_direct, o_p_piip, o_b_i, o_b_d};

#if S7_DEBUGGING
static const char *o_names[] = {"o_d_v", "o_d_vd", "o_d_vdd", "o_d_vid", "o_d_id", "o_d_7pi", "o_d_7pii", "o_d_7piid",
				"o_d_ip", "o_d_pd", "o_d_7pid",	"o_d", "o_d_d", "o_d_dd", "o_d_7dd", "o_d_ddd", "o_d_dddd",
				"o_i_i", "o_i_7i", "o_i_ii", "o_i_7ii", "o_i_iii", "o_i_7pi", "o_i_7pii", "o_i_7_piii", "o_d_p",
				"o_b_p", "o_b_p_direct", "o_b_7p", "o_b_pp", "o_b_7pp", "o_b_pp_direct", "o_b_pi", "o_b_ii", "o_b_dd",
				"o_p", "o_p_p", "o_p_ii", "o_p_d", "o_p_dd", "o_i_7d", "o_i_7p", "o_d_7d", "o_d_7p",
				"o_p_pp", "o_p_pp_direct", "o_p_ppp", "o_p_ppp_direct", "o_p_pi", "o_p_pi_direct",
				"o_p_ppi", "o_p_i", "o_p_pii", "o_p_pip", "o_p_pip_direct", "o_p_piip", "o_b_i", "o_b_d"};
#endif

static void add_opt_func(s7_pointer f, int32_t typ, void *func)
{
  if (is_c_function(f))
    {
      opt_funcs *op;
#if S7_DEBUGGING
      if (c_function_opt_data(f))
	{
	  opt_funcs *p;
	  for (p = c_function_opt_data(f); p; p = p->next)
	    {
	      if (p->typ == typ)
		fprintf(stderr, "%s[%d]: %s has a function of type %d (%s)\n",
			__func__, __LINE__, s7_object_to_c_string(cur_sc, f), typ, o_names[typ]);
	      if (p->func == func)
		fprintf(stderr, "%s[%d]: %s already has this function as type %d %s (current: %d %s)\n",
			__func__, __LINE__, s7_object_to_c_string(cur_sc, f), p->typ, o_names[p->typ], typ, o_names[typ]);
	    }
	}
#endif
      op = (opt_funcs *)malloc(sizeof(opt_funcs));
      op->typ = typ;
      op->func = func;
      op->next = c_function_opt_data(f);
      c_function_opt_data(f) = op;
    }
#if S7_DEBUGGING
  else
    {
      fprintf(stderr, "%s[%d]: 'f' is not a c_function\n", __func__, __LINE__);
      if (stop_at_error) abort();
    }
#endif
}

static void *opt_func(s7_pointer f, int32_t typ)
{
  if (is_c_function(f))
    {
      opt_funcs *p;
      for (p = c_function_opt_data(f); p; p = p->next)
	if (p->typ == typ)
	  return(p->func);
    }
#if S7_DEBUGGING
  else fprintf(stderr, "%s[%d]: 'f' is not a c_function\n", __func__, __LINE__);
#endif
  return(NULL);
}

/* clm2xen.c */
void s7_set_d_function(s7_pointer f, s7_d_t df) {add_opt_func(f, o_d, (void *)df);}
s7_d_t s7_d_function(s7_pointer f) {return((s7_d_t)opt_func(f, o_d));}

void s7_set_d_d_function(s7_pointer f, s7_d_d_t df) {add_opt_func(f, o_d_d, (void *)df);}
s7_d_d_t s7_d_d_function(s7_pointer f) {return((s7_d_d_t)opt_func(f, o_d_d));}

void s7_set_d_dd_function(s7_pointer f, s7_d_dd_t df) {add_opt_func(f, o_d_dd, (void *)df);}
s7_d_dd_t s7_d_dd_function(s7_pointer f) {return((s7_d_dd_t)opt_func(f, o_d_dd));}

void s7_set_d_v_function(s7_pointer f, s7_d_v_t df) {add_opt_func(f, o_d_v, (void *)df);}
s7_d_v_t s7_d_v_function(s7_pointer f) {return((s7_d_v_t)opt_func(f, o_d_v));}

void s7_set_d_vd_function(s7_pointer f, s7_d_vd_t df) {add_opt_func(f, o_d_vd, (void *)df);}
s7_d_vd_t s7_d_vd_function(s7_pointer f) {return((s7_d_vd_t)opt_func(f, o_d_vd));}

void s7_set_d_vdd_function(s7_pointer f, s7_d_vdd_t df) {add_opt_func(f, o_d_vdd, (void *)df);}
s7_d_vdd_t s7_d_vdd_function(s7_pointer f) {return((s7_d_vdd_t)opt_func(f, o_d_vdd));}

void s7_set_d_vid_function(s7_pointer f, s7_d_vid_t df) {add_opt_func(f, o_d_vid, (void *)df);}
s7_d_vid_t s7_d_vid_function(s7_pointer f) {return((s7_d_vid_t)opt_func(f, o_d_vid));}

void s7_set_d_id_function(s7_pointer f, s7_d_id_t df) {add_opt_func(f, o_d_id, (void *)df);}
s7_d_id_t s7_d_id_function(s7_pointer f) {return((s7_d_id_t)opt_func(f, o_d_id));}

void s7_set_d_7pid_function(s7_pointer f, s7_d_7pid_t df) {add_opt_func(f, o_d_7pid, (void *)df);}
s7_d_7pid_t s7_d_7pid_function(s7_pointer f) {return((s7_d_7pid_t)opt_func(f, o_d_7pid));}

void s7_set_d_ip_function(s7_pointer f, s7_d_ip_t df) {add_opt_func(f, o_d_ip, (void *)df);}
s7_d_ip_t s7_d_ip_function(s7_pointer f) {return((s7_d_ip_t)opt_func(f, o_d_ip));}

void s7_set_d_pd_function(s7_pointer f, s7_d_pd_t df) {add_opt_func(f, o_d_pd, (void *)df);}
s7_d_pd_t s7_d_pd_function(s7_pointer f) {return((s7_d_pd_t)opt_func(f, o_d_pd));}

void s7_set_d_p_function(s7_pointer f, s7_d_p_t df) {add_opt_func(f, o_d_p, (void *)df);}
s7_d_p_t s7_d_p_function(s7_pointer f) {return((s7_d_p_t)opt_func(f, o_d_p));}

void s7_set_b_p_function(s7_pointer f, s7_b_p_t df) {add_opt_func(f, o_b_p, (void *)df);}
s7_b_p_t s7_b_p_function(s7_pointer f) {return((s7_b_p_t)opt_func(f, o_b_p));}

void s7_set_d_7pi_function(s7_pointer f, s7_d_7pi_t df) {add_opt_func(f, o_d_7pi, (void *)df);}
s7_d_7pi_t s7_d_7pi_function(s7_pointer f) {return((s7_d_7pi_t)opt_func(f, o_d_7pi));}

static void s7_set_d_7pii_function(s7_pointer f, s7_d_7pii_t df) {add_opt_func(f, o_d_7pii, (void *)df);}
static s7_d_7pii_t s7_d_7pii_function(s7_pointer f) {return((s7_d_7pii_t)opt_func(f, o_d_7pii));}

void s7_set_i_7p_function(s7_pointer f, s7_i_7p_t df) {add_opt_func(f, o_i_7p, (void *)df);}
s7_i_7p_t s7_i_7p_function(s7_pointer f) {return((s7_i_7p_t)opt_func(f, o_i_7p));}

/* cload.scm */
void s7_set_d_ddd_function(s7_pointer f, s7_d_ddd_t df) {add_opt_func(f, o_d_ddd, (void *)df);}
s7_d_ddd_t s7_d_ddd_function(s7_pointer f) {return((s7_d_ddd_t)opt_func(f, o_d_ddd));}

void s7_set_d_dddd_function(s7_pointer f, s7_d_dddd_t df) {add_opt_func(f, o_d_dddd, (void *)df);}
s7_d_dddd_t s7_d_dddd_function(s7_pointer f) {return((s7_d_dddd_t)opt_func(f, o_d_dddd));}

void s7_set_i_i_function(s7_pointer f, s7_i_i_t df) {add_opt_func(f, o_i_i, (void *)df);}
s7_i_i_t s7_i_i_function(s7_pointer f) {return((s7_i_i_t)opt_func(f, o_i_i));}

void s7_set_i_ii_function(s7_pointer f, s7_i_ii_t df) {add_opt_func(f, o_i_ii, (void *)df);}
s7_i_ii_t s7_i_ii_function(s7_pointer f) {return((s7_i_ii_t)opt_func(f, o_i_ii));}

void s7_set_i_7d_function(s7_pointer f, s7_i_7d_t df) {add_opt_func(f, o_i_7d, (void *)df);}
s7_i_7d_t s7_i_7d_function(s7_pointer f) {return((s7_i_7d_t)opt_func(f, o_i_7d));}

/* s7test.scm */
void s7_set_p_d_function(s7_pointer f, s7_p_d_t df) {add_opt_func(f, o_p_d, (void *)df);}
s7_p_d_t s7_p_d_function(s7_pointer f) {return((s7_p_d_t)opt_func(f, o_p_d));}

static void s7_set_d_7dd_function(s7_pointer f, s7_d_7dd_t df) {add_opt_func(f, o_d_7dd, (void *)df);}
static s7_d_7dd_t s7_d_7dd_function(s7_pointer f) {return((s7_d_7dd_t)opt_func(f, o_d_7dd));}

#if (!WITH_GMP)
static void s7_set_i_7i_function(s7_pointer f, s7_i_7i_t df) {add_opt_func(f, o_i_7i, (void *)df);}
#endif
static s7_i_7i_t s7_i_7i_function(s7_pointer f) {return((s7_i_7i_t)opt_func(f, o_i_7i));}

static void s7_set_i_7ii_function(s7_pointer f, s7_i_7ii_t df) {add_opt_func(f, o_i_7ii, (void *)df);}
static s7_i_7ii_t s7_i_7ii_function(s7_pointer f) {return((s7_i_7ii_t)opt_func(f, o_i_7ii));}

static void s7_set_i_iii_function(s7_pointer f, s7_i_iii_t df) {add_opt_func(f, o_i_iii, (void *)df);}
s7_i_iii_t s7_i_iii_function(s7_pointer f) {return((s7_i_iii_t)opt_func(f, o_i_iii));}

static void s7_set_p_pi_function(s7_pointer f, s7_p_pi_t df) {add_opt_func(f, o_p_pi, (void *)df);}
static s7_p_pi_t s7_p_pi_function(s7_pointer f) {return((s7_p_pi_t)opt_func(f, o_p_pi));}

static void s7_set_p_ppi_function(s7_pointer f, s7_p_ppi_t df) {add_opt_func(f, o_p_ppi, (void *)df);}
static s7_p_ppi_t s7_p_ppi_function(s7_pointer f) {return((s7_p_ppi_t)opt_func(f, o_p_ppi));}

static void s7_set_i_7pi_function(s7_pointer f, s7_i_7pi_t df) {add_opt_func(f, o_i_7pi, (void *)df);}
static s7_i_7pi_t s7_i_7pi_function(s7_pointer f) {return((s7_i_7pi_t)opt_func(f, o_i_7pi));}

static void s7_set_i_7pii_function(s7_pointer f, s7_i_7pii_t df) {add_opt_func(f, o_i_7pii, (void *)df);}
static s7_i_7pii_t s7_i_7pii_function(s7_pointer f) {return((s7_i_7pii_t)opt_func(f, o_i_7pii));}

static void s7_set_i_7piii_function(s7_pointer f, s7_i_7piii_t df) {add_opt_func(f, o_i_7piii, (void *)df);}
static s7_i_7piii_t s7_i_7piii_function(s7_pointer f) {return((s7_i_7piii_t)opt_func(f, o_i_7piii));}

static void s7_set_b_d_function(s7_pointer f, s7_b_d_t df) {add_opt_func(f, o_b_d, (void *)df);}
static s7_b_d_t s7_b_d_function(s7_pointer f) {return((s7_b_d_t)opt_func(f, o_b_d));}

static void s7_set_b_i_function(s7_pointer f, s7_b_i_t df) {add_opt_func(f, o_b_i, (void *)df);}
static s7_b_i_t s7_b_i_function(s7_pointer f) {return((s7_b_i_t)opt_func(f, o_b_i));}

static void s7_set_b_p_direct_function(s7_pointer f, s7_b_p_t df) {add_opt_func(f, o_b_p_direct, (void *)df);}
static s7_b_p_t s7_b_p_direct_function(s7_pointer f) {return((s7_b_p_t)opt_func(f, o_b_p_direct));}

void s7_set_b_7p_function(s7_pointer f, s7_b_7p_t df) {add_opt_func(f, o_b_7p, (void *)df);}
s7_b_7p_t s7_b_7p_function(s7_pointer f) {return((s7_b_7p_t)opt_func(f, o_b_7p));}

static void s7_set_b_pp_function(s7_pointer f, s7_b_pp_t df) {add_opt_func(f, o_b_pp, (void *)df);}
static s7_b_pp_t s7_b_pp_function(s7_pointer f) {return((s7_b_pp_t)opt_func(f, o_b_pp));}

static void s7_set_b_7pp_function(s7_pointer f, s7_b_7pp_t df) {add_opt_func(f, o_b_7pp, (void *)df);}
static s7_b_7pp_t s7_b_7pp_function(s7_pointer f) {return((s7_b_7pp_t)opt_func(f, o_b_7pp));}

static void s7_set_d_7d_function(s7_pointer f, s7_d_7d_t df) {add_opt_func(f, o_d_7d, (void *)df);}
static s7_d_7d_t s7_d_7d_function(s7_pointer f) {return((s7_d_7d_t)opt_func(f, o_d_7d));}

#if (!WITH_GMP)
static void s7_set_b_pi_function(s7_pointer f, s7_b_pi_t df) {add_opt_func(f, o_b_pi, (void *)df);}
#endif
static s7_b_pi_t s7_b_pi_function(s7_pointer f) {return((s7_b_pi_t)opt_func(f, o_b_pi));}

static void s7_set_b_ii_function(s7_pointer f, s7_b_ii_t df) {add_opt_func(f, o_b_ii, (void *)df);}
static s7_b_ii_t s7_b_ii_function(s7_pointer f) {return((s7_b_ii_t)opt_func(f, o_b_ii));}

static void s7_set_b_dd_function(s7_pointer f, s7_b_dd_t df) {add_opt_func(f, o_b_dd, (void *)df);}
static s7_b_dd_t s7_b_dd_function(s7_pointer f) {return((s7_b_dd_t)opt_func(f, o_b_dd));}

static void s7_set_p_p_function(s7_pointer f, s7_p_p_t df) {add_opt_func(f, o_p_p, (void *)df);}
static s7_p_p_t s7_p_p_function(s7_pointer f) {return((s7_p_p_t)opt_func(f, o_p_p));}

static void s7_set_p_function(s7_pointer f, s7_p_t df) {add_opt_func(f, o_p, (void *)df);}
static s7_p_t s7_p_function(s7_pointer f) {return((s7_p_t)opt_func(f, o_p));}

static void s7_set_p_pp_function(s7_pointer f, s7_p_pp_t df) {add_opt_func(f, o_p_pp, (void *)df);}
static s7_p_pp_t s7_p_pp_function(s7_pointer f) {return((s7_p_pp_t)opt_func(f, o_p_pp));}

static void s7_set_p_ppp_function(s7_pointer f, s7_p_ppp_t df) {add_opt_func(f, o_p_ppp, (void *)df);}
static s7_p_ppp_t s7_p_ppp_function(s7_pointer f) {return((s7_p_ppp_t)opt_func(f, o_p_ppp));}

static void s7_set_p_pip_function(s7_pointer f, s7_p_pip_t df) {add_opt_func(f, o_p_pip, (void *)df);}
static s7_p_pip_t s7_p_pip_function(s7_pointer f) {return((s7_p_pip_t)opt_func(f, o_p_pip));}

static void s7_set_p_pii_function(s7_pointer f, s7_p_pii_t df) {add_opt_func(f, o_p_pii, (void *)df);}
static s7_p_pii_t s7_p_pii_function(s7_pointer f) {return((s7_p_pii_t)opt_func(f, o_p_pii));}

static void s7_set_p_piip_function(s7_pointer f, s7_p_piip_t df) {add_opt_func(f, o_p_piip, (void *)df);}
static s7_p_piip_t s7_p_piip_function(s7_pointer f) {return((s7_p_piip_t)opt_func(f, o_p_piip));}

static void s7_set_p_pi_direct_function(s7_pointer f, s7_p_pi_t df) {add_opt_func(f, o_p_pi_direct, (void *)df);}
static s7_p_pi_t s7_p_pi_direct_function(s7_pointer f) {return((s7_p_pi_t)opt_func(f, o_p_pi_direct));}

static void s7_set_p_pip_direct_function(s7_pointer f, s7_p_pip_t df) {add_opt_func(f, o_p_pip_direct, (void *)df);}
static s7_p_pip_t s7_p_pip_direct_function(s7_pointer f) {return((s7_p_pip_t)opt_func(f, o_p_pip_direct));}

static void s7_set_p_pp_direct_function(s7_pointer f, s7_p_pp_t df) {add_opt_func(f, o_p_pp_direct, (void *)df);}
static s7_p_pp_t s7_p_pp_direct_function(s7_pointer f) {return((s7_p_pp_t)opt_func(f, o_p_pp_direct));}

static void s7_set_p_ppp_direct_function(s7_pointer f, s7_p_ppp_t df) {add_opt_func(f, o_p_ppp_direct, (void *)df);}
static s7_p_ppp_t s7_p_ppp_direct_function(s7_pointer f) {return((s7_p_ppp_t)opt_func(f, o_p_ppp_direct));}

static void s7_set_b_pp_direct_function(s7_pointer f, s7_b_pp_t df) {add_opt_func(f, o_b_pp_direct, (void *)df);}
static s7_b_pp_t s7_b_pp_direct_function(s7_pointer f) {return((s7_b_pp_t)opt_func(f, o_b_pp_direct));}

static void s7_set_p_i_function(s7_pointer f, s7_p_i_t df) {add_opt_func(f, o_p_i, (void *)df);}
static s7_p_i_t s7_p_i_function(s7_pointer f) {return((s7_p_i_t)opt_func(f, o_p_i));}

static void s7_set_p_ii_function(s7_pointer f, s7_p_ii_t df) {add_opt_func(f, o_p_ii, (void *)df);}
static s7_p_ii_t s7_p_ii_function(s7_pointer f) {return((s7_p_ii_t)opt_func(f, o_p_ii));}

static void s7_set_d_7piid_function(s7_pointer f, s7_d_7piid_t df) {add_opt_func(f, o_d_7piid, (void *)df);}
static s7_d_7piid_t s7_d_7piid_function(s7_pointer f) {return((s7_d_7piid_t)opt_func(f, o_d_7piid));}

#if (!WITH_GMP)
static void s7_set_p_dd_function(s7_pointer f, s7_p_dd_t df) {add_opt_func(f, o_p_dd, (void *)df);}
#endif
static s7_p_dd_t s7_p_dd_function(s7_pointer f) {return((s7_p_dd_t)opt_func(f, o_p_dd));}

enum {OO_P, OO_I, OO_D, OO_V, OO_IV, OO_FV, OO_PV, OO_R, OO_H, OO_S, OO_BV, OO_L, OO_E, OO_AV, OO_TV};

#define oo_slots(p) p->slots
#define oo_size(p)  p->size

#if S7_DEBUGGING
#if OPT_INFO_DEBUGGING
  static const char *oo_types[15] = {"OO_P", "OO_I", "OO_D", "OO_V", "OO_IV", "OO_FV", "OO_PV", "OO_R", "OO_H", "OO_S", "OO_BV", "OO_L", "OO_E", "OO_AV", "OO_TV"};
#endif

#define oo_func(p) p->func
#define oo_line(p) p->line

static const s7_int oo_to_s7[15] = {-1, 1LL << T_INTEGER, 1LL << T_REAL, 1LL << T_C_OBJECT, 1LL << T_INT_VECTOR,
				    1LL << T_FLOAT_VECTOR, 1LL << T_VECTOR, (1LL << T_REAL) + (1LL << T_RATIO) + (1LL << T_INTEGER),
				    1LL << T_HASH_TABLE, 1LL << T_STRING, 1LL << T_BYTE_VECTOR, 1LL << T_PAIR, 1LL << T_LET,
				    (1LL << T_VECTOR) + (1LL << T_INT_VECTOR) + (1LL << T_FLOAT_VECTOR) + (1LL << T_BYTE_VECTOR),
				    1LL << T_VECTOR};

static bool check_slot_type(s7_scheme *sc, s7_pointer slot, opt_info *o, int32_t i, const char *func, int line)
{
  s7_pointer val;
  uint8_t recorded_val_type;

  recorded_val_type = o->types[i] & 0xf;
  if (recorded_val_type == OO_P) return(true);
  val = slot_value(slot);
  if (!s7_is_valid(sc, val)) return(false);
  if ((oo_to_s7[recorded_val_type] & (1 << type(val))) == 0)
    {
#if OPT_INFO_DEBUGGING
      fprintf(stderr, "%s[%d] -> %s[%d]: %s (slot %d) wants %s but got %s, expr: %s\n",
	      oo_func(o), oo_line(o), func, line,
	      symbol_name(slot_symbol(slot)), i, oo_types[recorded_val_type],
	      DISPLAY(g_type_of(sc, set_plist_1(sc, val))),
	      DISPLAY(o->vexpr));
#endif
      return(false);
    }
  if (((recorded_val_type == OO_TV) && (!is_typed_vector(val))) ||
      ((recorded_val_type == OO_PV) && (is_typed_vector(val))))
    {
      fprintf(stderr, "typed vector mismatch\n");
      return(false);
    }
  return(true);
}

#define oo_check(Sc, O) oo_check_1(Sc, O, __func__, __LINE__)
static void oo_check_1(s7_scheme *sc, opt_info *o, const char *func, int32_t line)
{
  int32_t i, slots, size;
  size = oo_size(o);
  if ((size <= 0) || (size > NUM_VUNIONS))
    fprintf(stderr, "%s[%d]: oo_size: %d (%s[%d]\n", func, line, size, oo_func(o), oo_line(o));
  slots = oo_slots(o);
  if ((slots < 0) || (slots >= size))
    fprintf(stderr, "%s[%d]: oo_slots: %d, size: %d\n", func, line, slots, size);
  for (i = 0; i < slots; i++)
    {
      s7_pointer slot = NULL;
      int32_t p_addr, obj_addr;
      p_addr = o->addrs[i] & 0xf;
      obj_addr = (o->addrs[i] >> 4) & 0xf;
      if (p_addr >= size)
	fprintf(stderr, "%s[%d]: v[%d].p but size = %d\n", func, line, p_addr, size);
      else
	{
	  slot = o->v[p_addr].p;
	  if (!slot)
	    fprintf(stderr, "%s[%d]: v[%d].p is null\n", func, line, p_addr);
	  else
	    {
	      if (!s7_is_valid(sc, slot))
		fprintf(stderr, "%s[%d]: v[%d].p is not valid\n", func, line, p_addr);
	      else
		{
		  if (!is_slot(slot))
		    fprintf(stderr, "%s[%d]: v[%d].p is not a slot\n", func, line, p_addr);
		  else check_slot_type(sc, slot, o, i, func, line);
		}
	    }
	}
      if ((slot) && (obj_addr > 0))
	{
	  if (obj_addr >= size)
	    fprintf(stderr, "%s[%d]: v[%d].obj but size = %d\n", func, line, obj_addr, size);
	  else
	    {
	      s7_pointer obj, value;
	      obj = slot_value(slot);
              value = o->v[obj_addr].obj;
	      if (!obj)
		fprintf(stderr, "%s[%d]: v[%d].obj is null\n", func, line, obj_addr);
	      else
		{
		  if (!s7_is_valid(sc, obj))
		    fprintf(stderr, "%s[%d]: v[%d].obj is not valid\n", func, line, obj_addr);
		  else
		    {
		      if (!is_c_object(obj))
			fprintf(stderr, "%s[%d]: v[%d].obj is not a c_object\n", func, line, obj_addr);
		      else
			{
			  if (value != c_object_value(obj))
			    fprintf(stderr, "%s[%d]: c_object value does not match\n", func, line);
			}}}}}}
}

#define oo_rcheck(Sc, O, Size, Slots) oo_rcheck_1(Sc, O, Size, Slots, __func__, __LINE__)
static void oo_rcheck_1(s7_scheme *sc, opt_info *o, int size, int slots, const char *func, int32_t line)
{
  int32_t i;
  if ((oo_size(o) < size) || (oo_size(o) >= NUM_VUNIONS))
    fprintf(stderr, "%s[%d]: o[%s[%d]] size: %d, desired: %d\n", func, line, oo_func(o), oo_line(o), oo_size(o), size);
  if ((oo_slots(o) < slots) || (oo_slots(o) >= NUM_VUNIONS))
    fprintf(stderr, "%s[%d]: o[%s[%d]] slots: %d, desired: %d\n", func, line, oo_func(o), oo_line(o), oo_slots(o), slots);
  for (i = 0; i < slots; i++)
    {
      int32_t p_addr;
      s7_pointer slot;
      p_addr = o->addrs[i] & 0xf;
      slot = o->v[p_addr].p;
      if (!slot)
	fprintf(stderr, "%s[%d]: o[%s[%d]] slot[%d] is null\n", func, line, oo_func(o), oo_line(o), i);
      if (is_slot(slot))
	check_slot_type(sc, slot, o, i, func, line);
      else fprintf(stderr, "%s[%d]: slot: %s\n", func, line, DISPLAY(slot));
    }
}

static void oo_clear(opt_info *o)
{
#if OPT_INFO_DEBUGGING
  memset((void *)o, 0, sizeof(opt_info));
  o->sc = cur_sc;
#else
  int32_t i;
  for (i = oo_size(o); i < NUM_VUNIONS; i++)
    o->v[i].p = NULL;
#endif
}

static void check_oo_type(int typ, int slot, int num, const char *func, int line)
{
  if ((typ < 0) || (typ > OO_TV)) fprintf(stderr, "%s[%d]: type%d: %d\n", func, line, typ, num);
}

#define oo_save_func(p, func, line) do {oo_func(p) = func; oo_line(p) = line; oo_check(cur_sc, p);} while (0)

#else
#define oo_check(sc, p)
#define oo_rcheck(sc, p, size, slots)
#define oo_clear(p)
#define oo_func(p)
#define oo_line(p)

#define check_oo_type(A, B, C, D, E)
#define oo_save_func(p, func, line)
#endif

static void oo_store_slot(opt_info *p, int offset, int slot, int type)
{
#if S7_DEBUGGING
  p->addrs[offset] = slot;
#endif
  p->types[offset] = type;
}

#define oo_set_type_0(P, Size) oo_set_type_0_0(P, Size, __func__, __LINE__)
static bool oo_set_type_0_0(opt_info *p, int size, const char *func, int line)
{
  oo_slots(p) = 0;
  oo_size(p) = size;
  oo_save_func(p, func, line);
  return(true);
}

#define oo_set_type_1(P, Size, Slot, Type) oo_set_type_1_1(P, Size, Slot, Type, __func__, __LINE__)
static bool oo_set_type_1_1(opt_info *p, int size, int slot1, int type1, const char *func, int line)
{
  check_oo_type(type1, slot1, 1, func, line);
  oo_slots(p) = 1;
  oo_size(p) = size;
  oo_store_slot(p, 0, slot1, type1);
  oo_save_func(p, func, line);
  return(true);
}

#define oo_set_type_2(P, Size, Slot1, Slot2, Type1, Type2) oo_set_type_2_2(P, Size, Slot1, Slot2, Type1, Type2, __func__, __LINE__)
static bool oo_set_type_2_2(opt_info *p, int size, int slot1, int slot2, int type1, int type2, const char *func, int line)
{
  check_oo_type(type1, slot1, 1, func, line);
  check_oo_type(type2, slot2, 2, func, line);
  oo_slots(p) = 2;
  oo_size(p) = size;
  oo_store_slot(p, 0, slot1, type1);
  oo_store_slot(p, 1, slot2, type2);
  oo_save_func(p, func, line);
  return(true);
}

#define oo_set_type_3(P, Size, Slot1, Slot2, Slot3, Type1, Type2, Type3) oo_set_type_3_1(P, Size, Slot1, Slot2, Slot3, Type1, Type2, Type3, __func__, __LINE__)
static bool oo_set_type_3_1(opt_info *p, int size, int slot1, int slot2, int slot3, int type1, int type2, int type3, const char *func, int line)
{
  check_oo_type(type1, slot1, 1, func, line);
  check_oo_type(type2, slot2, 2, func, line);
  check_oo_type(type3, slot3, 3, func, line);
  oo_slots(p) = 3;
  oo_size(p) = size;
  oo_store_slot(p, 0, slot1, type1);
  oo_store_slot(p, 1, slot2, type2);
  oo_store_slot(p, 2, slot3, type3);
  oo_save_func(p, func, line);
  return(true);
}

#define oo_set_type_4(P, Size, Slot1, Slot2, Slot3, Slot4, Type1, Type2, Type3, Type4) \
  oo_set_type_4_1(P, Size, Slot1, Slot2, Slot3, Slot4, Type1, Type2, Type3, Type4, __func__, __LINE__)
static bool oo_set_type_4_1(opt_info *p, int size, int slot1, int slot2, int slot3, int slot4, int type1, int type2, int type3, int type4, const char *func, int line)
{
  check_oo_type(type1, slot1, 1, func, line);
  check_oo_type(type2, slot2, 2, func, line);
  check_oo_type(type3, slot3, 3, func, line);
  check_oo_type(type4, slot4, 4, func, line);
  oo_slots(p) = 4;
  oo_size(p) = size;
  oo_store_slot(p, 0, slot1, type1);
  oo_store_slot(p, 1, slot2, type2);
  oo_store_slot(p, 2, slot3, type3);
  oo_store_slot(p, 3, slot4, type4);
  oo_save_func(p, func, line);
  return(true);
}

static void oo_resize(opt_info *o, int32_t new_size)
{
  oo_size(o) = new_size;
}

static void make_optlist(s7_scheme *sc)
{
  opt_info *os;
  int32_t i;
  os = (opt_info *)calloc(OPTS_SIZE, sizeof(opt_info));
  for (i = 0; i < OPTS_SIZE; i++)
    {
      opt_info *o;
      o = &os[i];
      sc->opts[i] = o;
      o->sc = sc;
    }
}

#if S7_DEBUGGING
#define alloc_opo(Sc, Expr) alloc_opo_2(Sc, Expr, __func__, __LINE__)
static opt_info *alloc_opo_2(s7_scheme *sc, s7_pointer expr, const char *func, int line)
#else
#define alloc_opo(Sc, Expr) alloc_opo_1(Sc)
static opt_info *alloc_opo_1(s7_scheme *sc)
#endif
{
  opt_info *o;
  if (sc->pc >= OPTS_SIZE)
    {
#if S7_DEBUGGING
      fprintf(stderr, "opts overflow: %s (pc: %d)\n", DISPLAY(expr), sc->pc);
#endif
      longjmp(sc->opt_exit, 1);
    }
#if S7_DEBUGGING
  if (sc->pc < 0)
    {
      fprintf(stderr, "sc->pc: %d\n", sc->pc);
      abort();
    }
#endif
  o = sc->opts[sc->pc++];
  oo_clear(o);
  o->v[7].fd = NULL;
#if S7_DEBUGGING
  o->vexpr = expr;
  o->func = func;
  o->line = line;
#endif
  return(o);
}

#define backup_pc(sc) sc->pc--

#define OPT_PRINT 0

#if OPT_PRINT
static bool return_false(s7_scheme *sc, s7_pointer expr, const char *func, int32_t line)
{
  if (expr)
    fprintf(stderr, "   %s%s[%d]%s: %s\n", BOLD_TEXT, func, line, UNBOLD_TEXT, DISPLAY_80(expr));
  else fprintf(stderr, "   %s%s[%d]%s: false\n", BOLD_TEXT, func, line, UNBOLD_TEXT);
  return(false);
}
#else
#define return_false(Sc, Expr, Func, Line) false
#endif

#define is_opt_int(p) is_t_integer(p)

static s7_pointer opt_integer_symbol(s7_scheme *sc, s7_pointer sym)
{
  if (is_symbol(sym))
    {
      s7_pointer p;
      p = symbol_to_slot(sc, sym);
      if ((is_slot(p)) &&
	  (is_opt_int(slot_value(p))))
	return(p);
    }
  return(NULL);
}

static s7_pointer opt_real_symbol(s7_scheme *sc, s7_pointer sym)
{
  if (is_symbol(sym))
    {
      s7_pointer p;
      p = symbol_to_slot(sc, sym);
      if ((is_slot(p)) &&
	  (is_real(slot_value(p))))
	return(p);
    }
  return(NULL);
}

static s7_pointer opt_float_symbol(s7_scheme *sc, s7_pointer sym)
{
  if (is_symbol(sym))
    {
      s7_pointer p;
      p = symbol_to_slot(sc, sym);
      if ((is_slot(p)) &&
	  (is_float(slot_value(p))))
	return(p);
    }
  return(NULL);
}

static s7_pointer opt_simple_symbol(s7_scheme *sc, s7_pointer sym)
{
  s7_pointer p;
  p = symbol_to_slot(sc, sym);
  if ((is_slot(p)) &&
      (!has_methods(slot_value(p))))
    return(p);
  return(NULL);
}

static s7_pointer opt_types_match(s7_scheme *sc, s7_pointer check, s7_pointer sym)
{
  s7_pointer slot, checker;
  checker = s7_symbol_value(sc, check);
  slot = symbol_to_slot(sc, sym);
  if (is_slot(slot))
    {
      s7_pointer obj;
      obj = slot_value(slot);
      if (s7_apply_function(sc, checker, set_plist_1(sc, obj)) == sc->T)
	return(slot);
    }
  return(NULL);
}

static s7_double opt_float_any(s7_scheme *sc, s7_pointer expr)
{
  /* caller for s7_float_optimize */
  sc->pc = 0;
  return(sc->opts[0]->v[0].fd(sc->opts[0]));
}

static s7_pointer opt_bool_any(s7_scheme *sc, s7_pointer expr)
{
  /* caller for s7_bool_optimize */
  sc->pc = 0;
  return((sc->opts[0]->v[0].fb(sc->opts[0])) ? sc->T : sc->F);
}

static s7_pointer opt_float_any_nr(s7_scheme *sc, s7_pointer expr)
{
  sc->pc = 0;
  sc->opts[0]->v[0].fd(sc->opts[0]);
  return(NULL);
}

static s7_pointer opt_int_any_nr(s7_scheme *sc, s7_pointer expr)
{
  sc->pc = 0;
  sc->opts[0]->v[0].fi(sc->opts[0]);
  return(NULL);
}

static s7_pointer opt_cell_any_nr(s7_scheme *sc, s7_pointer expr)
{
  sc->pc = 0;
  return(sc->opts[0]->v[0].fp(sc->opts[0])); /* faster than returning NULL */
}

static s7_pointer opt_bool_any_nr(s7_scheme *sc, s7_pointer expr)
{
  sc->pc = 0;
  sc->opts[0]->v[0].fb(sc->opts[0]);
  return(NULL);
}


/* callers for s7_optimize */
static s7_pointer opt_wrap_float(s7_scheme *sc, s7_pointer expr) {sc->pc = 0; return(make_real(sc,    sc->opts[0]->v[0].fd(sc->opts[0])));}
static s7_pointer opt_wrap_int(s7_scheme *sc, s7_pointer expr)   {sc->pc = 0; return(make_integer(sc, sc->opts[0]->v[0].fi(sc->opts[0])));}
static s7_pointer opt_wrap_cell(s7_scheme *sc, s7_pointer expr)  {sc->pc = 0; return(                 sc->opts[0]->v[0].fp(sc->opts[0]));}
static s7_pointer opt_wrap_bool(s7_scheme *sc, s7_pointer expr)  {sc->pc = 0; return((                sc->opts[0]->v[0].fb(sc->opts[0])) ? sc->T : sc->F);}

static s7_pointer b_to_p(void *p)    {opt_info *o = (opt_info *)p; return((o->v[7].fb(o)) ? o->sc->T : o->sc->F);}
static bool p_to_b(void *p)          {opt_info *o = (opt_info *)p; return(o->v[7].fp(o) != o->sc->F);}
static s7_pointer d_to_p(void *p)    {opt_info *o = (opt_info *)p; return(make_real(o->sc, o->v[7].fd(o)));}
static s7_pointer d_to_p_nr(void *p) {opt_info *o = (opt_info *)p; o->v[7].fd(o); return(NULL);}
static s7_pointer i_to_p(void *p)    {opt_info *o = (opt_info *)p; return(make_integer(o->sc, o->v[7].fi(o)));}
static s7_pointer i_to_p_nr(void *p) {opt_info *o = (opt_info *)p; o->v[7].fi(o); return(NULL);}


/* -------------------------------- int opts -------------------------------- */

static bool int_optimize(s7_scheme *sc, s7_pointer expr);
static bool float_optimize(s7_scheme *sc, s7_pointer expr);

static s7_int opt_i_c(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, p, 2, 0); return(o->v[1].i);}
static s7_int opt_i_s(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, p, 2, 1); return(integer(slot_value(o->v[1].p)));}

static bool opt_int_not_pair(s7_scheme *sc, s7_pointer car_x)
{
  opt_info *opc;
  s7_pointer p;
  if (is_opt_int(car_x))
    {
      opc = alloc_opo(sc, car_x);
      opc->v[1].i = integer(car_x);
      opc->v[0].fi = opt_i_c;
      return(oo_set_type_0(opc, 2));
    }
  p = opt_integer_symbol(sc, car_x);
  if (p)
    {
      opc = alloc_opo(sc, car_x);
      opc->v[1].p = p;
      opc->v[0].fi = opt_i_s;
      return(oo_set_type_1(opc, 2, 1, OO_I));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- i_i|d|p -------- */
static s7_int opt_i_i_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].i_i_f(o->v[1].i));
}

static s7_int opt_i_i_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].i_i_f(integer(slot_value(o->v[1].p))));
}

static s7_int opt_i_i_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++(o->sc->pc)];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].i_i_f(o1->v[0].fi(o1)));
}

static s7_int opt_i_7i_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].i_7i_f(o->sc, o->v[1].i));
}

static s7_int opt_i_7i_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].i_7i_f(o->sc, integer(slot_value(o->v[1].p))));
}

static s7_int opt_i_7i_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++(o->sc->pc)];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].i_7i_f(o->sc, o1->v[0].fi(o1)));
}

static s7_int opt_i_d_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].i_7d_f(o->sc, o->v[1].x));
}

static s7_int opt_i_d_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].i_7d_f(o->sc, real(slot_value(o->v[1].p))));
}

static s7_int opt_i_7d_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].i_7d_f(o->sc, o1->v[0].fd(o1)));
}

static s7_int opt_i_7p_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].i_7p_f(o->sc, o1->v[0].fp(o1)));
}

static bool i_idp_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_i_i_t func;
  s7_i_7i_t func7 = NULL;
  s7_i_7d_t idf;
  s7_i_7p_t ipf;
  s7_pointer p;
  int32_t start;
  start = sc->pc;

  func = s7_i_i_function(s_func);
  if (!func)
    func7 = s7_i_7i_function(s_func);
  if ((func) || (func7))
    {
      if (func)
	opc->v[2].i_i_f = func;
      else opc->v[2].i_7i_f = func7;
      if (is_opt_int(cadr(car_x)))
	{
	  opc->v[1].i = integer(cadr(car_x));
	  if (func)
	    opc->v[0].fi = opt_i_i_c;
	  else opc->v[0].fi = opt_i_7i_c;
	  return(oo_set_type_0(opc, 3));
	}
      p = opt_integer_symbol(sc, cadr(car_x));
      if (p)
	{
	  opc->v[1].p = p;
	  if (func)
	    opc->v[0].fi = opt_i_i_s;
	  else opc->v[0].fi = opt_i_7i_s;
	  return(oo_set_type_1(opc, 3, 1, OO_I));
	}
      if (int_optimize(sc, cdr(car_x)))
	{
	  if (func)
	    opc->v[0].fi = opt_i_i_f;
	  else opc->v[0].fi = opt_i_7i_f;
	  return(oo_set_type_0(opc, 3));
	}
      pc_fallback(sc, start);
    }
  idf = s7_i_7d_function(s_func);
  if (idf)
    {
      opc->v[2].i_7d_f = idf;
      if (is_real(cadr(car_x)))
	{
	  opc->v[1].x = s7_number_to_real(sc, cadr(car_x));
	  opc->v[0].fi = opt_i_d_c;
	  return(oo_set_type_0(opc, 3));
	}
      p = opt_float_symbol(sc, cadr(car_x));
      if (p)
	{
	  opc->v[1].p = p;
	  opc->v[0].fi = opt_i_d_s;
	  return(oo_set_type_1(opc, 3, 1, OO_D));
	}
      if (float_optimize(sc, cdr(car_x)))
	{
	  opc->v[0].fi = opt_i_7d_f;
	  return(oo_set_type_0(opc, 3));
	}
      pc_fallback(sc, start);
    }
  ipf = s7_i_7p_function(s_func);
  if (ipf)
    {
      opc->v[2].i_7p_f = ipf;
      if (cell_optimize(sc, cdr(car_x)))
	{
	  opc->v[0].fi = opt_i_7p_f;
	  return(oo_set_type_0(opc, 3));
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- i_pi -------- */

static s7_int opt_i_7pi_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].i_7pi_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p))));
}

static s7_int ivref_7pi_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(int_vector(slot_value(o->v[1].p), integer(slot_value(o->v[2].p))));
}

static s7_int opt_i_7pi_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_7pi_f(o->sc, slot_value(o->v[1].p), o1->v[0].fi(o1)));
}

static bool i_7pi_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_i_7pi_t pfunc;
  pfunc = s7_i_7pi_function(s_func);
  if (pfunc)
    {
      s7_pointer sig;
      sig = c_function_signature(s_func);
      if (is_pair(sig))
	{
	  s7_pointer arg1, arg2, slot;
	  int32_t start;
	  start = sc->pc;
	  arg1 = cadr(car_x);
	  arg2 = caddr(car_x);

	  if ((is_symbol(cadr(sig))) &&
	      (is_symbol(arg1)) &&
	      (slot = opt_types_match(sc, cadr(sig), arg1)))
	    {
	      s7_pointer p;
	      opc->v[1].p = slot;
	      if ((car(car_x) == sc->int_vector_ref_symbol) &&
		  ((!is_int_vector(slot_value(slot))) ||
		   (vector_rank(slot_value(slot)) > 1)))
		return(return_false(sc, car_x, __func__, __LINE__));

	      opc->v[3].i_7pi_f = pfunc;
	      p = opt_integer_symbol(sc, arg2);
	      if (p)
		{
		  opc->v[2].p = p;
		  opc->v[0].fi = opt_i_7pi_ss;
		  if ((car(car_x) == sc->int_vector_ref_symbol) &&
		      (is_step_end(opc->v[2].p)) &&
		      (denominator(slot_value(opc->v[2].p)) <= vector_length(slot_value(opc->v[1].p))))
		    {
		      opc->v[0].fi = ivref_7pi_ss;
		      opc->v[3].i_7pi_f = int_vector_ref_unchecked;
		    }
		  return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_I));
		}
	      if (int_optimize(sc, cddr(car_x)))
		{
		  opc->v[0].fi = opt_i_7pi_sf;
		  return(oo_set_type_1(opc, 4, 1, OO_P));
		}
	      pc_fallback(sc, start);
	    }
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- i_ii -------- */
static s7_int opt_i_ii_cc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_ii_f(o->v[1].i, o->v[2].i));
}

static s7_int opt_i_ii_cs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_ii_f(o->v[1].i, integer(slot_value(o->v[2].p))));
}

static s7_int opt_i_ii_cs_mul(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[1].i * integer(slot_value(o->v[2].p)));
}

static s7_int opt_i_ii_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_ii_f(integer(slot_value(o->v[1].p)), o->v[2].i));
}

static s7_int opt_i_ii_sc_add(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(integer(slot_value(o->v[1].p)) + o->v[2].i);
}

static s7_int opt_i_ii_sc_sub(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(integer(slot_value(o->v[1].p)) - o->v[2].i);
}

static s7_int opt_i_ii_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].i_ii_f(integer(slot_value(o->v[1].p)), integer(slot_value(o->v[2].p))));
}

static s7_int opt_i_ii_ss_add(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(integer(slot_value(o->v[1].p)) + integer(slot_value(o->v[2].p)));
}

static s7_pointer opt_p_ii_ss_add(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(make_integer(o->sc, integer(slot_value(o->v[1].p)) + integer(slot_value(o->v[2].p))));
}

static s7_int opt_i_ii_cf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_ii_f(o->v[1].i, o1->v[0].fi(o1)));
}

static s7_int opt_i_ii_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_ii_f(integer(slot_value(o->v[1].p)), o1->v[0].fi(o1)));
}

static s7_int opt_i_ii_sf_add(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(integer(slot_value(o->v[1].p)) + o1->v[0].fi(o1));
}

static s7_int opt_i_ii_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_ii_f(i1, o1->v[0].fi(o1)));
}

static s7_int opt_i_ii_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_ii_f(o1->v[0].fi(o1), o->v[2].i));
}

static s7_int opt_i_ii_fc_add(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o1->v[0].fi(o1) + o->v[2].i);
}

static s7_pointer opt_p_ii_fc_add(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(make_integer(o->sc, o1->v[0].fi(o1) + o->v[2].i));
}

static s7_int opt_i_7ii_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_7ii_f(o->sc, o1->v[0].fi(o1), o->v[2].i));
}

static s7_int opt_i_ii_fco(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].i_ii_f(o->v[4].i_7pi_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p))), o->v[5].i));
}

static s7_int opt_i_ii_fco_add(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[4].i_7pi_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p))) + o->v[5].i);
}

static s7_int opt_i_7ii_fco(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].i_7ii_f(o->sc, o->v[4].i_7pi_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p))), o->v[5].i));
}

static bool i_ii_fc_combinable(s7_scheme *sc, opt_info *opc, s7_i_ii_t func)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if ((o1->v[0].fi == opt_i_7pi_ss) || (o1->v[0].fi == ivref_7pi_ss))
	{
	  opc->v[5].i = opc->v[2].i; /* move v2.i ("c" in fc = arg2) out of the symbols' way */
	  opc->v[4].i_7pi_f = o1->v[3].i_7pi_f;
	  opc->v[1].p = o1->v[1].p;
	  opc->v[2].p = o1->v[2].p;
	  if (func)
	    {
	      if (opc->v[3].i_ii_f == add_i_ii)
		opc->v[0].fi = opt_i_ii_fco_add;
	      else opc->v[0].fi = opt_i_ii_fco;
	    }
	  else opc->v[0].fi = opt_i_7ii_fco;
	  backup_pc(sc);
	  return(oo_set_type_2(opc, 6, 1, 2, OO_P, OO_I));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static s7_int opt_i_7ii_cc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_7ii_f(o->sc, o->v[1].i, o->v[2].i));
}

static s7_int opt_i_7ii_cs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_7ii_f(o->sc, o->v[1].i, integer(slot_value(o->v[2].p))));
}

static s7_int opt_i_7ii_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_7ii_f(o->sc, integer(slot_value(o->v[1].p)), o->v[2].i));
}

static s7_int opt_i_7ii_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].i_7ii_f(o->sc, integer(slot_value(o->v[1].p)), integer(slot_value(o->v[2].p))));
}

static s7_int opt_i_7ii_cf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4,0);
  return(o->v[3].i_7ii_f(o->sc, o->v[1].i, o1->v[0].fi(o1)));
}

static s7_int opt_i_7ii_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_7ii_f(o->sc, integer(slot_value(o->v[1].p)), o1->v[0].fi(o1)));
}

static s7_int opt_i_7ii_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_7ii_f(o->sc, i1, o1->v[0].fi(o1)));
}

static bool i_ii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_i_ii_t ifunc;
  s7_i_7ii_t ifunc7 = NULL;
  s7_pointer p;
  ifunc = s7_i_ii_function(s_func);
  if (!ifunc) ifunc7 = s7_i_7ii_function(s_func);
  if ((ifunc) || (ifunc7))
    {
      s7_pointer sig;
      sig = c_function_signature(s_func);
      if (is_pair(sig))
	{
	  s7_pointer arg1, arg2;
	  int32_t start;
	  start = sc->pc;
	  arg1 = cadr(car_x);
	  arg2 = caddr(car_x);

	  if (ifunc)
	    opc->v[3].i_ii_f = ifunc;
	  else opc->v[3].i_7ii_f = ifunc7;
	  oo_set_type_0(opc, 4);

	  if (is_opt_int(arg1))
	    {
	      opc->v[1].i = integer(arg1);
	      if (is_opt_int(arg2))
		{
		  opc->v[2].i = integer(arg2);
		  if (ifunc)
		    opc->v[0].fi = opt_i_ii_cc;
		  else opc->v[0].fi = opt_i_7ii_cc;
		  return(oo_set_type_0(opc, 4));
		}
	      p = opt_integer_symbol(sc, arg2);
	      if (p)
		{
		  opc->v[2].p = p;
		  if (ifunc)
		    {
		      if (opc->v[3].i_ii_f == multiply_i_ii)
			opc->v[0].fi = opt_i_ii_cs_mul;
		      else opc->v[0].fi = opt_i_ii_cs;
		    }
		  else opc->v[0].fi = opt_i_7ii_cs;
		  return(oo_set_type_1(opc, 4, 2, OO_I));
		}
	      if (int_optimize(sc, cddr(car_x)))
		{
		  if (ifunc)
		    opc->v[0].fi = opt_i_ii_cf;
		  else opc->v[0].fi = opt_i_7ii_cf;
		  return(oo_set_type_0(opc, 4));
		}
	      pc_fallback(sc, start);
	    }
	  else
	    {
	      p = opt_integer_symbol(sc, arg1);
	      if (p)
		{
		  opc->v[1].p = p;
		  if (is_opt_int(arg2))
		    {
		      opc->v[2].i = integer(arg2);
		      if (ifunc)
			{
			  if (opc->v[3].i_ii_f == add_i_ii)
			    opc->v[0].fi = opt_i_ii_sc_add;
			  else
			    {
			      if (opc->v[3].i_ii_f == subtract_i_ii)
				opc->v[0].fi = opt_i_ii_sc_sub;
			      else opc->v[0].fi = opt_i_ii_sc;
			    }
			}
		      else opc->v[0].fi = opt_i_7ii_sc;
#if (!WITH_GMP)
		      if ((car(car_x) == sc->modulo_symbol) &&
			  (integer(arg2) > 1))
			opc->v[3].i_ii_f = modulo_i_ii_direct;
		      else
			{
			  if (car(car_x) == sc->ash_symbol)
			    {
			      if (opc->v[2].i < 0)
				{
				  if (opc->v[2].i == -1)
				    opc->v[3].i_ii_f = rsh_i_i2_direct;
				  else opc->v[3].i_ii_f = rsh_i_ii_direct;
				  opc->v[0].fi = opt_i_ii_sc;
				}
			      else
				{
				  if (opc->v[2].i < s7_int_bits)
				    {
				      opc->v[3].i_ii_f = lsh_i_ii_direct;
				      opc->v[0].fi = opt_i_ii_sc;
				    }
				}
			    }
			  else
			    {
			      if (opc->v[2].i > 0)
				{
				  /* these assume vunion is a union, not a struct; i_7ii_f otherwise might be leftover from a previous use */
#if OPT_INFO_DEBUGGING
				  if ((!ifunc) && (opc->v[3].i_7ii_f == quotient_i_7ii))
#else
				  if (opc->v[3].i_7ii_f == quotient_i_7ii)
#endif
				    {
				      opc->v[3].i_ii_f = quotient_i_ii_direct;
				      opc->v[0].fi = opt_i_ii_sc;
				    }
				  else
				    {
				      if (opc->v[2].i > 1)
					{
#if OPT_INFO_DEBUGGING
				          if ((!ifunc) && (opc->v[3].i_7ii_f == remainder_i_7ii))
#else
					  if (opc->v[3].i_7ii_f == remainder_i_7ii)
#endif
					    {
					      opc->v[3].i_ii_f = remainder_i_ii_direct;
					      opc->v[0].fi = opt_i_ii_sc;
					    }}}}}}
#endif
		      return(oo_set_type_1(opc, 4, 1, OO_I));
		    } /* opt_int arg2 */
		  p = opt_integer_symbol(sc, arg2);
		  if (p)
		    {
		      opc->v[2].p = p;
		      if (ifunc)
			{
			  if (opc->v[3].i_ii_f == add_i_ii)
			    opc->v[0].fi = opt_i_ii_ss_add;
			  else opc->v[0].fi = opt_i_ii_ss;
			}
		      else opc->v[0].fi = opt_i_7ii_ss;
		      return(oo_set_type_2(opc, 4, 1, 2, OO_I, OO_I));
		    }
		  if (int_optimize(sc, cddr(car_x)))
		    {
		      if (ifunc)
			{
			  if (opc->v[3].i_ii_f == add_i_ii)
			    opc->v[0].fi = opt_i_ii_sf_add;
			  else opc->v[0].fi = opt_i_ii_sf;
			}
		      else opc->v[0].fi = opt_i_7ii_sf;
		      return(oo_set_type_1(opc, 4, 1, OO_I));
		    }
		  pc_fallback(sc, start);
		}
	      else
		{
		  if (is_opt_int(arg2))
		    {
		      opc->v[2].i = integer(arg2);
		      if (int_optimize(sc, cdr(car_x)))
			{
			  if (!i_ii_fc_combinable(sc, opc, ifunc))
			    {
			      if (ifunc)
				{
				  if (opc->v[3].i_ii_f == add_i_ii)
				    opc->v[0].fi = opt_i_ii_fc_add;
				  else opc->v[0].fi = opt_i_ii_fc;
				}
			      else opc->v[0].fi = opt_i_7ii_fc;
#if (!WITH_GMP)
			      if (opc->v[2].i > 0)
				{
				  if (opc->v[3].i_7ii_f == quotient_i_7ii)
				    {
				      opc->v[3].i_ii_f = quotient_i_ii_direct;
				      opc->v[0].fi = opt_i_ii_fc;
				    }
				  else
				    {
				      if (opc->v[2].i > 1)
					{
					  if (opc->v[3].i_7ii_f == remainder_i_7ii)
					    {
					      opc->v[3].i_ii_f = remainder_i_ii_direct;
					      opc->v[0].fi = opt_i_ii_fc;
					    }
					}
				    }
				}
#endif
			    }
			  oo_check(sc, opc);
			  return(true);
			}
		      pc_fallback(sc, start);
		    }
		  else
		    {
		      if ((int_optimize(sc, cdr(car_x))) &&
			  (int_optimize(sc, cddr(car_x))))
			{
			  if (ifunc)
			    opc->v[0].fi = opt_i_ii_ff;
			  else opc->v[0].fi = opt_i_7ii_ff;
			  oo_check(sc, opc);
			  return(true);
			}
		      pc_fallback(sc, start);
		    }}}}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- i_iii -------- */
static s7_int opt_i_iii_fff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1, i2;
  s7_scheme *sc;
  sc = o->sc;
  o1 = sc->opts[++sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  i2 = o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].i_iii_f(i1, i2, o1->v[0].fi(o1)));
}

static bool i_iii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_i_iii_t ifunc;
  ifunc = s7_i_iii_function(s_func);
  if (ifunc)
    {
      int32_t start;
      start = sc->pc;
      if ((int_optimize(sc, cdr(car_x))) &&
	  (int_optimize(sc, cddr(car_x))) &&
	  (int_optimize(sc, cdddr(car_x))))
	{
	  opc->v[3].i_iii_f = ifunc;
	  opc->v[0].fi = opt_i_iii_fff;
	  return(oo_set_type_0(opc, 4));
	}
      pc_fallback(sc, start);
      return(return_false(sc, car_x, __func__, __LINE__));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- i_7pii -------- */
static s7_int opt_i_7pii_ssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].i_7pii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o1->v[0].fi(o1)));
}

static s7_int opt_i_7pii_ssc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[3].i_7pii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o->v[4].i));
}

static s7_int opt_i_7pii_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].i_7pii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p))));
}

static s7_int opt_i_7pii_sff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_int i1;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o2 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].i_7pii_f(o->sc, slot_value(o->v[1].p), i1, o2->v[0].fi(o2)));
}


/* -------- i_7piii -------- */
static s7_int opt_i_7piii_sssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[5].i_7piii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)), o1->v[0].fi(o1)));
}

static s7_int opt_i_7piii_sssc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[5].i_7piii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)), o->v[4].i));
}

static s7_int opt_i_7piii_ssss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[5].i_7piii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)), integer(slot_value(o->v[4].p))));
}

static s7_int opt_i_7piii_sfff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1, i2;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  i2 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 1);
  return(o->v[5].i_7piii_f(o->sc, slot_value(o->v[1].p), i1, i2, o1->v[0].fi(o1)));
}

static bool opt_i_7piii_args(s7_scheme *sc, opt_info *opc, int32_t otype, s7_pointer indexp1, s7_pointer indexp2, s7_pointer valp)
{
  s7_pointer slot;
  slot = opt_integer_symbol(sc, car(indexp2));
  if (slot)
    {
      opc->v[3].p = slot;
      slot = opt_integer_symbol(sc, car(indexp1));
      if (slot)
	{
	  opc->v[2].p = slot;
	  if (is_t_integer(car(valp)))
	    {
	      opc->v[0].fi = opt_i_7piii_sssc;
	      opc->v[4].i = integer(car(valp));
	      return(oo_set_type_3(opc, 6, 1, 2, 3, otype, OO_I, OO_I));
	    }
	  slot = opt_integer_symbol(sc, car(valp));
	  if (slot)
	    {
	      opc->v[4].p = slot;
	      opc->v[0].fi = opt_i_7piii_ssss;
	      return(oo_set_type_4(opc, 6, 1, 2, 3, 4, otype, OO_I, OO_I, OO_I));
	    }
	  if (int_optimize(sc, valp))
	    {
	      opc->v[0].fi = opt_i_7piii_sssf;
	      return(oo_set_type_3(opc, 6, 1, 2, 3, otype, OO_I, OO_I));
	    }
	}
      return(return_false(sc, NULL, __func__, __LINE__));
    }
  if ((int_optimize(sc, indexp1)) &&
      (int_optimize(sc, indexp2)) &&
      (int_optimize(sc, valp)))
    {
      opc->v[0].fi = opt_i_7piii_sfff;
      return(oo_set_type_1(opc, 6, 1, otype));
    }
  return(return_false(sc, indexp1, __func__, __LINE__));
}

static bool opt_int_vector_set(s7_scheme *sc, int32_t v_type, opt_info *opc, s7_pointer v, s7_pointer indexp1, s7_pointer indexp2, s7_pointer valp)
{
  s7_pointer settee;
  settee = symbol_to_slot(sc, v);
  if ((is_slot(settee)) &&
      (!is_immutable(slot_value(settee))))
    {
      bool int_case;
      s7_pointer vect, slot;
      vect = slot_value(settee);
      int_case = (is_int_vector(vect));
      opc->v[1].p = settee;
      if ((int_case) || (is_byte_vector(vect)))
	{
	  int32_t otype;
	  otype = (((int_case) ? OO_IV : OO_BV));
	  if ((otype != v_type) && (v_type != OO_AV))  /* (int-vector-set! byte-vect ...) */
	    return(return_false(sc, indexp1, __func__, __LINE__));
	  if ((!indexp2) &&
	      (vector_rank(vect) == 1))
	    {
	      opc->v[3].i_7pii_f = (int_case) ? int_vector_set_i_7pii : byte_vector_set_i_7pii;
	      slot = opt_integer_symbol(sc, car(indexp1));
	      if (slot)
		{
		  opc->v[2].p = slot;
		  if ((is_step_end(opc->v[2].p)) &&
		      (denominator(slot_value(opc->v[2].p)) <= vector_length(vect)))
		    opc->v[3].i_7pii_f = (int_case) ? int_vector_set_unchecked : byte_vector_set_unchecked;
		  if ((is_pair(valp)) &&
		      (is_null(cdr(valp))) &&
		      (is_t_integer(car(valp))))
		    {
		      opc->v[4].i = integer(car(valp));
		      opc->v[0].fi = opt_i_7pii_ssc;
		      return(oo_set_type_2(opc, 5, 1, 2, otype, OO_I));
		    }
		  if (int_optimize(sc, valp))
		    {
		      opc->v[0].fi = opt_i_7pii_ssf;
		      return(oo_set_type_2(opc, 4, 1, 2, otype, OO_I));
		    }
		  return(return_false(sc, NULL, __func__, __LINE__));
		}
	      if ((int_optimize(sc, indexp1)) &&
		  (int_optimize(sc, valp)))
		{
		  opc->v[0].fi = opt_i_7pii_sff;
		  return(oo_set_type_1(opc, 4, 1, otype));
		}
	      return(return_false(sc, NULL, __func__, __LINE__));
	    }

	  if ((indexp2) &&
	      (vector_rank(vect) == 2))
	    {
	      opc->v[5].i_7piii_f = (int_case) ? int_vector_set_i_7piii : byte_vector_set_i_7piii;
	      return(opt_i_7piii_args(sc, opc, otype, indexp1, indexp2, valp));
	    }
	}
    }
  return(return_false(sc, v, __func__, __LINE__));
}

static bool i_7pii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_i_7pii_t pfunc;
  pfunc = s7_i_7pii_function(s_func);
  if (pfunc)
    {
      s7_pointer sig;
      sig = c_function_signature(s_func);
      if ((is_pair(sig)) &&
	  (is_symbol(cadr(car_x))))
	{
	  s7_pointer fname, slot;
	  fname = car(car_x);

	  if ((fname == sc->int_vector_set_symbol) || (fname == sc->byte_vector_set_symbol))
	    return(opt_int_vector_set(sc, (fname == sc->int_vector_set_symbol) ? OO_IV : OO_BV, opc, cadr(car_x), cddr(car_x), NULL, cdddr(car_x)));

	  slot = opt_types_match(sc, cadr(sig), cadr(car_x));
	  if (slot)
	    {
	      s7_pointer arg2, p;
	      int32_t start;
	      start = sc->pc;
	      opc->v[1].p = slot;

	      if (((fname == sc->int_vector_ref_symbol) || (fname == sc->byte_vector_ref_symbol)) &&
		  (vector_rank(slot_value(slot)) != 2))
		return(return_false(sc, car_x, __func__, __LINE__));

	      arg2 = caddr(car_x);
	      p = opt_integer_symbol(sc, arg2);
	      if (p)
		{
		  opc->v[2].p = p;
		  p = opt_integer_symbol(sc, cadddr(car_x));
		  if (p)
		    {
		      opc->v[3].p = p;
		      opc->v[4].i_7pii_f = pfunc;
		      opc->v[0].fi = opt_i_7pii_sss;
		      return(oo_set_type_3(opc, 5, 1, 2, 3, OO_P, OO_I, OO_I));
		    }
		  if (int_optimize(sc, cdddr(car_x)))
		    {
		      opc->v[3].i_7pii_f = pfunc;
		      opc->v[0].fi = opt_i_7pii_ssf;
		      return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_I));
		    }
		  return(return_false(sc, car_x, __func__, __LINE__));
		}
	      if ((int_optimize(sc, cddr(car_x))) &&
		  (int_optimize(sc, cdddr(car_x))))
		{
		  opc->v[3].i_7pii_f = pfunc;
		  opc->v[0].fi = opt_i_7pii_sff;
		  return(oo_set_type_1(opc, 4, 1, OO_P));
		}
	      pc_fallback(sc, start);
	    }
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool i_7piii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_i_7piii_t f;
  f = s7_i_7piii_function(s_func);
  if ((f) &&
      (is_symbol(cadr(car_x))))
    {
      s7_pointer settee;
      if ((car(car_x) == sc->int_vector_set_symbol) || (car(car_x) == sc->byte_vector_set_symbol))
	return(opt_int_vector_set(sc, (car(car_x) == sc->int_vector_set_symbol) ? OO_IV : OO_BV, opc, cadr(car_x), cddr(car_x), cdddr(car_x), cddddr(car_x)));

      settee = symbol_to_slot(sc, cadr(car_x));
      if (is_slot(settee))
	{
	  s7_pointer vect;
	  vect = slot_value(settee);
	  if ((is_int_vector(vect)) && (vector_rank(vect) == 3))
	    {
	      opc->v[5].i_7piii_f = f;
	      opc->v[1].p = settee;
	      return(opt_i_7piii_args(sc, opc, OO_IV, cddr(car_x), cdddr(car_x), cddddr(car_x)));
	    }
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- i_add|multiply_any -------- */
static s7_int opt_i_add_any_f(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_int sum = 0;
  int32_t i;
  oo_rcheck(o->sc, o, 2, 0);
  for (i = 0; i < o->v[1].i; i++)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      sum += o1->v[0].fi(o1);
    }
  return(sum);
}

static s7_int opt_i_add2(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int sum;
  o1 = o->sc->opts[++o->sc->pc];
  sum = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  return(sum + o1->v[0].fi(o1));
}

static s7_int opt_i_mul2(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int sum;
  o1 = o->sc->opts[++o->sc->pc];
  sum = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  return(sum * o1->v[0].fi(o1));
}

static s7_int opt_i_add3(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int sum;
  s7_scheme *sc;
  sc = o->sc;
  o1 = sc->opts[++sc->pc];
  sum = o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  sum += o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  return(sum + o1->v[0].fi(o1));
}

static s7_int opt_i_mul3(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int sum;
  s7_scheme *sc;
  sc = o->sc;
  o1 = sc->opts[++sc->pc];
  sum = o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  sum *= o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  return(sum * o1->v[0].fi(o1));
}

static s7_int opt_i_add4(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int sum;
  s7_scheme *sc;
  sc = o->sc;
  o1 = sc->opts[++sc->pc];
  sum = o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  sum += o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  sum += o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  return(sum + o1->v[0].fi(o1));
}

static s7_int opt_i_mul4(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int sum;
  s7_scheme *sc;
  sc = o->sc;
  o1 = sc->opts[++sc->pc];
  sum = o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  sum *= o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  sum *= o1->v[0].fi(o1);
  o1 = sc->opts[++sc->pc];
  return(sum * o1->v[0].fi(o1));
}

static s7_int opt_i_multiply_any_f(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_int sum = 1;
  int32_t i;
  for (i = 0; i < o->v[1].i; i++)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      sum *= o1->v[0].fi(o1);
    }
  return(sum);
}

static bool i_add_any_ok(s7_scheme *sc, opt_info *opc, s7_pointer car_x)
{
  s7_pointer p, head;
  int32_t cur_len, start;
  start = sc->pc;
  head = car(car_x);
  for (cur_len = 0, p = cdr(car_x); is_pair(p); p = cdr(p), cur_len++)
    if (!int_optimize(sc, p))
      break;
  if (is_null(p))
    {
      opc->v[1].i = cur_len;
      if (cur_len == 2)
	opc->v[0].fi = (head == sc->add_symbol) ? opt_i_add2 : opt_i_mul2;
      else
	{
	  if (cur_len == 3)
	    opc->v[0].fi = (head == sc->add_symbol) ? opt_i_add3 : opt_i_mul3;
	  else
	    {
	      if (cur_len == 4)
		opc->v[0].fi = (head == sc->add_symbol) ? opt_i_add4 : opt_i_mul4;
	      else opc->v[0].fi = (head == sc->add_symbol) ? opt_i_add_any_f : opt_i_multiply_any_f;
	    }
	}
      /* all v[1].i = cur_len */
      return(oo_set_type_0(opc, 2));
    }
  pc_fallback(sc, start);
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- set_i_i -------- */
static s7_int opt_set_i_i_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int x;
  oo_rcheck(o->sc, o, 2, 1);
  o1 = o->sc->opts[++o->sc->pc];
  x = o1->v[0].fi(o1);
  slot_set_value(o->v[1].p, make_integer(o->sc, x));
  return(x);
}

static s7_int opt_set_i_i_fm(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int x;
  oo_rcheck(o->sc, o, 2, 1);
  o1 = o->sc->opts[++o->sc->pc];
  x = o1->v[0].fi(o1);
  integer(slot_value(o->v[1].p)) = x;
  return(x);
}

static s7_int opt_set_i_i_fo(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_int x;
  oo_rcheck(o->sc, o, 5, 2);
  x = integer(slot_value(o->v[3].p)) + o->v[2].i;
  slot_set_value(o->v[1].p, make_integer(o->sc, x));
  return(x);
}

static bool set_i_i_f_combinable(s7_scheme *sc, opt_info *opc)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fi == opt_i_ii_sc_add)
	{
	  /* opc->v[4].i_ii_f = o1->v[3].i_ii_f; */
	  opc->v[3].p = o1->v[1].p;
	  opc->v[2].i = o1->v[2].i;
	  opc->v[0].fi = opt_set_i_i_fo;
	  backup_pc(sc);
	  return(oo_set_type_2(opc, 5, 1, 3, OO_I, OO_I)); /* ii_sc v[1].p is a slot */
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool i_syntax_ok(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  if ((car(car_x) == sc->set_symbol) &&
      (len == 3))
    {
      opt_info *opc;
      opc = alloc_opo(sc, car_x);
      if (is_symbol(cadr(car_x)))  /* (set! i 3) */
	{
	  s7_pointer settee;
	  if ((is_immutable(cadr(car_x))) ||
	      (symbol_has_setter(cadr(car_x))))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  settee = symbol_to_slot(sc, cadr(car_x));
	  if ((is_slot(settee)) &&
	      (!is_immutable(settee)))
	    {
	      opc->v[1].p = settee;
	      if ((is_t_integer(slot_value(settee))) &&
		  (int_optimize(sc, cddr(car_x))))
		{
		  if (set_i_i_f_combinable(sc, opc))
		    return(true);

		  if (is_mutable(slot_value(opc->v[1].p)))
		    opc->v[0].fi = opt_set_i_i_fm;
		  else opc->v[0].fi = opt_set_i_i_f;
		  return(oo_set_type_1(opc, 2, 1, OO_P)); /* or OO_I? */
		}
	    }
	}
      else
	{
	  if ((is_pair(cadr(car_x))) &&    /* if is_pair(settee) get setter */
	      (is_symbol(caadr(car_x))) &&
	      (is_pair(cdadr(car_x))))
	    {
	      if (is_null(cddadr(car_x)))
		return(opt_int_vector_set(sc, OO_AV, opc, caadr(car_x), cdadr(car_x), NULL, cddr(car_x)));
	      if (is_null(cdddr(cadr(car_x))))
		return(opt_int_vector_set(sc, OO_AV, opc, caadr(car_x), cdadr(car_x), cddadr(car_x), cddr(car_x)));
	    }
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool i_implicit_ok(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  s7_pointer s_slot, head;
  head = car(car_x);
  s_slot = symbol_to_slot(sc, head);
  if ((is_slot(s_slot)) &&
      ((is_int_vector(slot_value(s_slot))) || (is_byte_vector(slot_value(s_slot)))))
    {
      bool int_case;
      s7_pointer slot;
      int_case = (is_int_vector(slot_value(s_slot)));

      if ((len == 2) &&
	  (vector_rank(slot_value(s_slot)) == 1))
	{
	  /* implicit int|byte-vector-ref */
	  opt_info *opc;
	  opc = alloc_opo(sc, car_x);
	  opc->v[1].p = s_slot;
	  slot = opt_integer_symbol(sc, cadr(car_x));
	  if (slot)
	    {
	      opc->v[0].fi = opt_i_7pi_ss;
	      opc->v[3].i_7pi_f = (int_case) ? int_vector_ref_i_7pi : byte_vector_ref_i_7pi;
	      opc->v[2].p = slot;
	      if ((is_step_end(opc->v[2].p)) &&
		  (denominator(slot_value(opc->v[2].p)) <= vector_length(slot_value(opc->v[1].p))))
		{
		  opc->v[3].i_7pi_f = (int_case) ? int_vector_ref_unchecked : byte_vector_ref_unchecked;
		  /* opc->v[0].fi = ivref_7pi_ss; */ /* this causes a huge slowdown in dup.scm?? */
		}
	      return(oo_set_type_2(opc, 4, 1, 2, (int_case) ? OO_IV : OO_BV, OO_I));

	    }
	  if (int_optimize(sc, cdr(car_x)))
	    {
	      opc->v[0].fi = opt_i_7pi_sf;
	      opc->v[3].i_7pi_f = (int_case) ? int_vector_ref_i_7pi : byte_vector_ref_i_7pi;
	      return(oo_set_type_1(opc, 4, 1, (int_case) ? OO_IV : OO_BV));
	    }
	  return(return_false(sc, car_x, __func__, __LINE__));
	}

      if ((len == 3) &&
	  (vector_rank(slot_value(s_slot)) == 2))
	{
	  opt_info *opc;
	  opc = alloc_opo(sc, car_x);
	  opc->v[1].p = s_slot;

	  slot = opt_integer_symbol(sc, cadr(car_x));
	  if (slot)
	    {
	      opc->v[2].p = slot;
	      slot = opt_integer_symbol(sc, caddr(car_x));
	      if (slot)
		{
		  opc->v[4].i_7pii_f = (int_case) ? int_vector_ref_i_7pii : byte_vector_ref_i_7pii;
		  opc->v[3].p = slot;
		  opc->v[0].fi = opt_i_7pii_sss;
		  return(oo_set_type_3(opc, 5, 1, 2, 3, (int_case) ? OO_IV : OO_BV, OO_I, OO_I));
		}
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }

	  if ((int_optimize(sc, cdr(car_x))) &&
	      (int_optimize(sc, cddr(car_x))))
	    {
	      opc->v[3].i_7pii_f = (int_case) ? int_vector_ref_i_7pii : byte_vector_ref_i_7pii;
	      opc->v[0].fi = opt_i_7pii_sff;
	      return(oo_set_type_1(opc, 5, 1, (int_case) ? OO_IV : OO_BV));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* ------------------------------------- float opts ------------------------------------------- */

static s7_double opt_d_c(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 0); return(o->v[1].x);}
static s7_double opt_D_s(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 1); return(s7_number_to_real(o->sc, slot_value(o->v[1].p)));}
static s7_double opt_d_s(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 1); return(real(slot_value(o->v[1].p)));}

static bool opt_float_not_pair(s7_scheme *sc, s7_pointer car_x)
{
  opt_info *opc;
  s7_pointer p;
  if (is_real(car_x))
    {
      if ((s7_is_ratio(car_x)) ||
	  (!is_real(car_x)))
	return(return_false(sc, car_x, __func__, __LINE__));
      opc = alloc_opo(sc, car_x);
      opc->v[1].x = s7_number_to_real(sc, car_x);
      opc->v[0].fd = opt_d_c;
      return(oo_set_type_0(opc, 2));
    }
  p = opt_real_symbol(sc, car_x);
  if (p)
    {
      if (s7_is_ratio(slot_value(p)))
	return(return_false(sc, car_x, __func__, __LINE__));
      opc = alloc_opo(sc, car_x);
      opc->v[1].p = p;
      opc->v[0].fd = (is_float(slot_value(p))) ? opt_d_s : opt_D_s;
      return(oo_set_type_1(opc, 2, 1, OO_R));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d -------- */
static s7_double opt_d_f(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 1); return(o->v[1].d_f());}

static bool d_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func)
{
  s7_d_t func;                   /* (f): (mus-srate) */
  func = s7_d_function(s_func);
  if (func)
    {
      opc->v[0].fd = opt_d_f;
      opc->v[1].d_f = func;
      oo_check(sc, opc);
      return(true);
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

/* -------- d_d -------- */
static s7_double opt_d_d_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].d_d_f(o->v[1].x));
}

static s7_double opt_d_d_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_d_f(real(slot_value(o->v[1].p))));
}

static s7_double opt_d_d_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_d_f(o1->v[0].fd(o1)));
}

static s7_double opt_d_7d_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].d_7d_f(o->sc, o->v[1].x));
}

static s7_double opt_d_7d_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_7d_f(o->sc, real(slot_value(o->v[1].p))));
}

static s7_double opt_d_7d_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_7d_f(o->sc, o1->v[0].fd(o1)));
}

static bool d_d_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_d_t func;
  s7_d_7d_t func7 = NULL;
  int32_t start;
  start = sc->pc;

  func = s7_d_d_function(s_func);
  if (!func) func7 = s7_d_7d_function(s_func);
  if ((func) || (func7))
    {
      s7_pointer p;
      if (func)
	opc->v[3].d_d_f = func;
      else opc->v[3].d_7d_f = func7;
      if (is_real(cadr(car_x)))
	{
	  if ((!is_float(cadr(car_x))) &&                          /* (random 1) != (random 1.0) */
	      ((car(car_x) == sc->random_symbol) ||
	       (car(car_x) == sc->sin_symbol) ||
	       (car(car_x) == sc->cos_symbol)))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  opc->v[1].x = s7_number_to_real(sc, cadr(car_x));
	  if (func)
	    opc->v[0].fd = opt_d_d_c;
	  else opc->v[0].fd = opt_d_7d_c;
	  return(oo_set_type_0(opc, 4));
	}
      p = opt_float_symbol(sc, cadr(car_x));
      if ((p) &&
	  (!has_methods(slot_value(p))))
	{
	  opc->v[1].p = p;
	  if (func)
	    opc->v[0].fd = opt_d_d_s;
	  else opc->v[0].fd = opt_d_7d_s;
	  return(oo_set_type_1(opc, 4, 1, OO_D));
	}
      if (float_optimize(sc, cdr(car_x)))
	{
	  if (func)
	    opc->v[0].fd = opt_d_d_f;
	  else opc->v[0].fd = opt_d_7d_f;
	  return(oo_set_type_0(opc, 4));
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_v -------- */
static s7_double opt_d_v(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 0);
  return(o->v[3].d_v_f(o->v[5].obj));
}

static bool d_v_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_v_t flt_func;
  flt_func = s7_d_v_function(s_func);
  if (flt_func)
    {
      s7_pointer sig;
      sig = c_function_signature(s_func);
      if ((is_pair(sig)) &&
	  (is_symbol(cadr(sig))) &&
	  (is_symbol(cadr(car_x))))           /* look for (oscil g) */
	{
	  s7_pointer slot;
	  slot = opt_types_match(sc, cadr(sig), cadr(car_x));
	  if (slot)
	    {
	      opc->v[1].p = slot;
	      opc->v[5].obj = (void *)c_object_value(slot_value(slot));
	      opc->v[3].d_v_f = flt_func;
	      opc->v[0].fd = opt_d_v;
	      return(oo_set_type_1(opc, 6, 1 + (5 << 4), OO_V));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_p -------- */
static s7_double opt_d_p_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_p_f(slot_value(o->v[1].p)));
}

static s7_double opt_d_p_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_p_f(o1->v[0].fp(o1)));
}

static bool d_p_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_p_t dpf;
  int32_t start;
  start = sc->pc;
  dpf = s7_d_p_function(s_func);
  if (dpf)
    {
      opc->v[3].d_p_f = dpf;
      if (is_symbol(cadr(car_x)))
	{
	  s7_pointer slot;
	  slot = opt_simple_symbol(sc, cadr(car_x));
	  if (slot)
	    {
	      opc->v[1].p = slot;
	      opc->v[0].fd = opt_d_p_s;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	  return(return_false(sc, car_x, __func__, __LINE__));
	}
      if (cell_optimize(sc, cdr(car_x)))
	{
	  opc->v[0].fd = opt_d_p_f;
	  return(oo_set_type_0(opc, 4));
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_7pi -------- */

static s7_double opt_d_7pi_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_7pi_f(o->sc, slot_value(o->v[1].p), o->v[2].i));
}

static s7_double opt_d_7pi_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].d_7pi_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p))));
}

static s7_double opt_d_7pi_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_7pi_f(o->sc, slot_value(o->v[1].p), o1->v[0].fi(o1)));
}

static s7_double opt_d_7pi_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer seq;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  seq = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_7pi_f(o->sc, seq, o1->v[0].fi(o1)));
}

static s7_pointer opt_arg_type(s7_scheme *sc, s7_pointer argp);

static bool d_7pi_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  /* float-vector-ref is checked for a 1D float-vector arg, but other callers should do type checking */
  s7_d_7pi_t ifunc;
  ifunc = s7_d_7pi_function(s_func);
  if (ifunc)
    {
      int32_t start;
      start = sc->pc;
      opc->v[3].d_7pi_f = ifunc;
      if (is_symbol(cadr(car_x)))  /* (float-vector-ref v i) */
	{
	  s7_pointer arg2, p, obj;
	  opc->v[1].p = symbol_to_slot(sc, cadr(car_x));
	  if (!is_slot(opc->v[1].p))
	    return(return_false(sc, car_x, __func__, __LINE__));

	  obj = slot_value(opc->v[1].p);
	  if ((car(car_x) == sc->float_vector_ref_symbol) &&
	      ((!is_float_vector(obj)) ||
	       (vector_rank(obj) > 1)))
	    return(return_false(sc, car_x, __func__, __LINE__));

	  arg2 = caddr(car_x);
	  if (!is_pair(arg2))
	    {
	      if (is_opt_int(arg2))
		{
		  opc->v[2].i = integer(arg2);
		  opc->v[0].fd = opt_d_7pi_sc;
		  return(oo_set_type_1(opc, 4, 1, OO_P));
		}
	      p = opt_integer_symbol(sc, arg2);
	      if (p)
		{
		  opc->v[2].p = p;
		  opc->v[0].fd = opt_d_7pi_ss;
		  if ((car(car_x) == sc->float_vector_ref_symbol) &&
		      (is_step_end(opc->v[2].p)) &&
		      (denominator(slot_value(opc->v[2].p)) <= vector_length(slot_value(opc->v[1].p))))
		    {
		      opc->v[3].d_7pi_f = float_vector_ref_unchecked;
		      return(oo_set_type_2(opc, 4, 1, 2, OO_FV, OO_I));
		    }
		  return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_I));
		}
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }
	  if (int_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fd = opt_d_7pi_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	  pc_fallback(sc, start);
	  return(return_false(sc, car_x, __func__, __LINE__));
	}

      if ((car(car_x) == sc->float_vector_ref_symbol) &&
	  ((!is_float_vector(cadr(car_x))) ||
	   (vector_rank(cadr(car_x)) > 1)))          /* (float-vector-ref  #r2d((.1 .2) (.3 .4)) 3) */
	return(return_false(sc, car_x, __func__, __LINE__));

      if ((cell_optimize(sc, cdr(car_x))) &&
	  (int_optimize(sc, cddr(car_x))))
	{
	  opc->v[0].fd = opt_d_7pi_ff;
	  return(oo_set_type_0(opc, 4));
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_ip -------- */
static s7_double opt_d_ip_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].d_ip_f(integer(slot_value(o->v[1].p)), slot_value(o->v[2].p)));
}

static bool d_ip_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_ip_t pfunc;
  pfunc = s7_d_ip_function(s_func);
  if ((pfunc) &&
      (is_symbol(caddr(car_x))))
    {
      s7_pointer p;
      p = opt_integer_symbol(sc, cadr(car_x));
      if (p)
	{
	  opc->v[3].d_ip_f = pfunc;
	  opc->v[1].p = p;
	  opc->v[2].p = symbol_to_slot(sc, caddr(car_x));
	  if (is_slot(opc->v[2].p))
	    {
	      /* (with-sound (:reverb jc-reverb) (fm-violin 0 .1 440 .4 :reverb-amount .5)) */
	      opc->v[0].fd = opt_d_ip_ss;
	      return(oo_set_type_2(opc, 4, 1, 2, OO_I, OO_P));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_pd -------- */
static s7_double opt_d_pd_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_pd_f(slot_value(o->v[1].p), o1->v[0].fd(o1)));
}

static s7_double opt_d_pd_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].d_pd_f(slot_value(o->v[1].p), real(slot_value(o->v[2].p))));
}

static bool d_pd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  if (is_symbol(cadr(car_x)))
    {
      s7_d_pd_t func;
      func = s7_d_pd_function(s_func);
      if (func)
	{
	  s7_pointer arg2, p;
	  int32_t start;
	  start = sc->pc;
	  arg2 = caddr(car_x);
	  opc->v[3].d_pd_f = func;
	  opc->v[1].p = symbol_to_slot(sc, cadr(car_x));
	  if (!is_slot(opc->v[1].p))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  p = opt_float_symbol(sc, arg2);
	  if (p)
	    {
	      opc->v[2].p = p;
	      opc->v[0].fd = opt_d_pd_ss;
	      return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_D));
	    }
	  if (float_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fd = opt_d_pd_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	  pc_fallback(sc, start);
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_vd -------- */
static s7_double opt_d_vd_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 0);
  return(o->v[3].d_vd_f(o->v[5].obj, o->v[2].x));
}

static s7_double opt_d_vd_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 1);
  return(o->v[3].d_vd_f(o->v[5].obj, real(slot_value(o->v[2].p))));
}

static s7_double opt_d_vd_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_vd_f(o->v[5].obj, o1->v[0].fd(o1)));
}

static s7_double opt_d_vd_o(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 0);
  return(o->v[3].d_vd_f(o->v[5].obj, o->v[4].d_v_f(o->v[6].obj)));
}

static s7_double opt_d_vd_o1_mul(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 1);
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  return(o->v[3].d_vd_f(o->v[5].obj, real(slot_value(o->v[2].p)) * o1->v[0].fd(o1)));
}

static s7_double opt_d_vd_o1(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 1);
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  return(o->v[3].d_vd_f(o->v[5].obj, o->v[4].d_dd_f(real(slot_value(o->v[2].p)), o1->v[0].fd(o1))));
}

static s7_double opt_d_vd_o2(void *p)
{
  opt_info *o = (opt_info *)p; /* v[1].p = v6 obj slot */
  oo_rcheck(o->sc, o, 7, 1);
  return(o->v[4].d_vd_f(o->v[6].obj, o->v[5].d_vd_f(o->v[2].obj, real(slot_value(o->v[3].p)))));
}

static s7_double opt_d_vd_o3(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 7, 1);
  return(o->v[3].d_vd_f(o->v[5].obj, o->v[4].d_dd_f(o->v[6].x, real(slot_value(o->v[2].p)))));
}

static s7_double opt_d_vd_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  oo_rcheck(o->sc, o, 6, 0);
  return(o->v[3].d_vd_f(o->v[5].obj, o->v[2].d_vd_f(o->v[4].obj, o1->v[0].fd(o1))));
}

static s7_double opt_d_dd_cs(void *p);
static s7_double opt_d_dd_sf_mul(void *p);
static s7_double opt_d_dd_sf(void *p);

static bool d_vd_f_combinable(s7_scheme *sc, int32_t start)
{
  opt_info *opc, *o1;
  opc = sc->opts[start - 1];
  o1 = sc->opts[start];
  if (o1->v[0].fd == opt_d_v)
    {
      opc->v[2].p = o1->v[1].p;
      opc->v[6].obj = o1->v[5].obj;
      opc->v[4].d_v_f = o1->v[3].d_v_f;
      opc->v[0].fd = opt_d_vd_o;
      backup_pc(sc);
      return(oo_set_type_2(opc, 7, 1 + (5 << 4), 2 + (6 << 4), OO_V, OO_V));
    }
  if (o1->v[0].fd == opt_d_vd_s)
    {
      opc->v[6].obj = opc->v[5].obj;
      opc->v[4].d_vd_f = opc->v[3].d_vd_f; /* room for symbols */
      opc->v[2].obj = o1->v[5].obj;
      opc->v[5].d_vd_f = o1->v[3].d_vd_f;
      opc->v[3].p = o1->v[2].p;
      opc->v[7].p = o1->v[1].p;
      opc->v[0].fd = opt_d_vd_o2;
      backup_pc(sc);
      return(oo_set_type_3(opc, 8, 1 + (6 << 4), 3, 7 + (2 << 4), OO_V, OO_D, OO_V));
    }
  if (o1->v[0].fd == opt_d_dd_cs)
    {
      opc->v[4].d_dd_f = o1->v[3].d_dd_f;
      opc->v[6].x = o1->v[2].x;
      opc->v[2].p = o1->v[1].p;
      opc->v[0].fd = opt_d_vd_o3;
      backup_pc(sc);
      return(oo_set_type_2(opc, 7, 1 + (5 << 4), 2, OO_V, OO_D));
    }
  if ((o1->v[0].fd == opt_d_dd_sf_mul) || (o1->v[0].fd == opt_d_dd_sf))
    {
      opc->v[2].p = o1->v[1].p;
      opc->v[4].d_dd_f = o1->v[3].d_dd_f;
      if (o1->v[0].fd == opt_d_dd_sf_mul)
	opc->v[0].fd = opt_d_vd_o1_mul;
      else opc->v[0].fd = opt_d_vd_o1;
      return(oo_set_type_2(opc, 6, 1 + (5 << 4), 2, OO_V, OO_D));
    }
  if (o1->v[0].fd == opt_d_vd_f)
    {
      opc->v[2].d_vd_f = o1->v[3].d_vd_f;
      opc->v[4].obj = o1->v[5].obj;
      opc->v[6].p = o1->v[1].p;
      opc->v[0].fd = opt_d_vd_ff;
      return(oo_set_type_2(opc, 7, 1 + (5 << 4), 6 + ((4 << 4)), OO_V, OO_V));
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}


static bool d_vd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  if (is_symbol(cadr(car_x)))
    {
      s7_d_vd_t vfunc;
      vfunc = s7_d_vd_function(s_func);
      if (vfunc)
	{
	  s7_pointer sig;
	  sig = c_function_signature(s_func);
	  if ((is_pair(sig)) &&
	      (is_symbol(cadr(sig))))
	    {
	      s7_pointer slot;
	      slot = opt_types_match(sc, cadr(sig), cadr(car_x));
	      if (slot)
		{
		  s7_pointer arg2;
		  int32_t start;
		  start = sc->pc;
		  arg2 = caddr(car_x);
		  opc->v[3].d_vd_f = vfunc;
		  if (!is_pair(arg2))
		    {
		      opc->v[1].p = slot;
		      opc->v[5].obj = (void *)c_object_value(slot_value(slot));
		      if (is_real(arg2))
			{
			  opc->v[2].x = s7_number_to_real(sc, arg2);
			  opc->v[0].fd = opt_d_vd_c;
			  return(oo_set_type_1(opc, 6, 1 + (5 << 4), OO_V));
			}
		      opc->v[2].p = symbol_to_slot(sc, arg2);
		      if (is_slot(opc->v[2].p))
			{
			  if (is_float(slot_value(opc->v[2].p)))
			    {
			      opc->v[0].fd = opt_d_vd_s;
			      return(oo_set_type_2(opc, 6, 1 + (5 << 4), 2, OO_V, OO_D));
			    }
			  if (float_optimize(sc, cddr(car_x)))
			    {
			      if (d_vd_f_combinable(sc, start))
				return(true);
			      opc->v[0].fd = opt_d_vd_f;
			      return(oo_set_type_2(opc, 6, 1 + (5 << 4), 2, OO_V, OO_P));
			    }
			  return(return_false(sc, car_x, __func__, __LINE__));
			}
		    }
		  else /* is pair arg2 */
		    {
		      if (float_optimize(sc, cddr(car_x)))
			{
			  opc->v[1].p = slot;
			  opc->v[5].obj = (void *)c_object_value(slot_value(slot));
			  if (d_vd_f_combinable(sc, start))
			    return(true);
			  opc->v[0].fd = opt_d_vd_f;
			  return(oo_set_type_1(opc, 6, 1 + (5 << 4), OO_V));
			}
		      pc_fallback(sc, start);
		    }}}}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_id -------- */
static s7_double opt_d_id_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_id_f(integer(slot_value(o->v[1].p)), o1->v[0].fd(o1)));
}

static s7_double opt_d_id_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_id_f(integer(slot_value(o->v[1].p)), o->v[2].x));
}

static s7_double opt_d_id_sfo(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 7, 2);
  return(o->v[4].d_id_f(integer(slot_value(o->v[1].p)), o->v[5].d_vd_f(o->v[6].obj, real(slot_value(o->v[3].p)))));
}

static s7_double opt_d_id_sfo1(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 1);
  return(o->v[3].d_id_f(integer(slot_value(o->v[1].p)), o->v[5].d_v_f(o->v[2].obj)));
}

static bool d_id_sf_combinable(s7_scheme *sc, opt_info *opc)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fd == opt_d_vd_s)
	{
	  opc->v[4].d_id_f = opc->v[3].d_id_f;
	  opc->v[2].p = o1->v[1].p;
	  opc->v[6].obj = o1->v[5].obj;
	  opc->v[5].d_vd_f = o1->v[3].d_vd_f;
	  opc->v[3].p = o1->v[2].p;
	  opc->v[0].fd = opt_d_id_sfo;
	  backup_pc(sc);
	  return(oo_set_type_3(opc, 7, 1, 2 + (6 << 4), 3, OO_I, OO_V, OO_D));
	}
      if (o1->v[0].fd == opt_d_v)
	{
	  opc->v[6].p = o1->v[1].p;
	  opc->v[2].obj = o1->v[5].obj;
	  opc->v[5].d_v_f = o1->v[3].d_v_f;
	  opc->v[0].fd = opt_d_id_sfo1;
	  backup_pc(sc);
	  return(oo_set_type_2(opc, 7, 1, 6 + (2 << 4), OO_I, OO_V));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool d_id_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_id_t flt_func;
  flt_func = s7_d_id_function(s_func);
  if (flt_func)
    {
      s7_pointer p;
      p = opt_integer_symbol(sc, cadr(car_x));
      if (p)
	{
	  int32_t start;
	  start = sc->pc;
	  opc->v[3].d_id_f = flt_func;
	  opc->v[1].p = p;
	  if (is_t_real(caddr(car_x)))
	    {
	      opc->v[0].fd = opt_d_id_sc;
	      opc->v[2].x = real(caddr(car_x));
	      return(oo_set_type_1(opc, 4, 1, OO_I));
	    }
	  if (float_optimize(sc, cddr(car_x)))
	    {
	      if (d_id_sf_combinable(sc, opc))
		return(true);
	      opc->v[0].fd = opt_d_id_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_I));
	    }
	  pc_fallback(sc, start);
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_dd -------- */

static s7_double opt_d_dd_cc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].d_dd_f(o->v[1].x, o->v[2].x));
}

static s7_double opt_d_dd_cs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_dd_f(o->v[2].x, real(slot_value(o->v[1].p))));
}

static s7_double opt_d_dd_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_dd_f(real(slot_value(o->v[1].p)), o->v[2].x));
}

static s7_double opt_d_dd_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].d_dd_f(real(slot_value(o->v[1].p)), real(slot_value(o->v[2].p))));
}

static s7_double opt_d_dd_ss_mul(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(real(slot_value(o->v[1].p)) * real(slot_value(o->v[2].p)));
}

static s7_double opt_d_dd_cf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_dd_f(o->v[1].x, o1->v[0].fd(o1)));
}

static s7_double opt_d_dd_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_dd_f(o1->v[0].fd(o1), o->v[2].x));
}

static s7_double opt_d_dd_fc_add(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fd(o1) + o->v[2].x);
}

static s7_double opt_d_dd_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_dd_f(real(slot_value(o->v[1].p)), o1->v[0].fd(o1)));
}

static s7_double opt_d_dd_sf_mul(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(real(slot_value(o->v[1].p)) * o1->v[0].fd(o1));
}


static s7_double opt_d_7dd_cc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].d_7dd_f(o->sc, o->v[1].x, o->v[2].x));
}

static s7_double opt_d_7dd_cs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_7dd_f(o->sc, o->v[2].x, real(slot_value(o->v[1].p))));
}

static s7_double opt_d_7dd_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_7dd_f(o->sc, real(slot_value(o->v[1].p)), o->v[2].x));
}

static s7_double opt_d_7dd_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].d_7dd_f(o->sc, real(slot_value(o->v[1].p)), real(slot_value(o->v[2].p))));
}

static s7_double opt_d_7dd_cf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_7dd_f(o->sc, o->v[1].x, o1->v[0].fd(o1)));
}

static s7_double opt_d_7dd_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_7dd_f(o->sc, o1->v[0].fd(o1), o->v[2].x));
}

static s7_double opt_d_7dd_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_7dd_f(o->sc, real(slot_value(o->v[1].p)), o1->v[0].fd(o1)));
}


static s7_double opt_d_dd_sfo(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[4].d_dd_f(real(slot_value(o->v[1].p)), o->v[5].d_7pi_f(o->sc, slot_value(o->v[2].p), integer(slot_value(o->v[3].p)))));
}

static s7_double opt_d_7dd_sfo(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[4].d_7dd_f(o->sc, real(slot_value(o->v[1].p)), o->v[5].d_7pi_f(o->sc, slot_value(o->v[2].p), integer(slot_value(o->v[3].p)))));
}

static bool d_dd_sf_combinable(s7_scheme *sc, opt_info *opc, s7_d_dd_t func)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fd == opt_d_7pi_ss)
	{
	  if (func)
	    {
	      opc->v[4].d_dd_f = opc->v[3].d_dd_f; /* need room for 3 symbols */
	      opc->v[0].fd = opt_d_dd_sfo;
	    }
	  else
	    {
	      opc->v[4].d_7dd_f = opc->v[3].d_7dd_f; /* need room for 3 symbols */
	      opc->v[0].fd = opt_d_7dd_sfo;
	    }
	  opc->v[2].p = o1->v[1].p;
	  opc->v[3].p = o1->v[2].p;
	  opc->v[5].d_7pi_f = o1->v[3].d_7pi_f;
	  backup_pc(sc);
	  return(oo_set_type_3(opc, 6, 1, 2, 3, OO_D, OO_P, OO_I));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static s7_double opt_d_dd_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_dd_f(o1->v[0].fd(o1), real(slot_value(o->v[1].p))));
}

static s7_double opt_d_dd_fs_mul(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fd(o1) * real(slot_value(o->v[1].p)));
}

static s7_double opt_d_7dd_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_7dd_f(o->sc, o1->v[0].fd(o1), real(slot_value(o->v[1].p))));
}

static s7_double opt_d_dd_fso(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].d_dd_f(o->v[5].d_7pi_f(o->sc, slot_value(o->v[2].p), integer(slot_value(o->v[3].p))), real(slot_value(o->v[1].p))));
}

static s7_double opt_d_7dd_fso(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].d_7dd_f(o->sc, o->v[5].d_7pi_f(o->sc, slot_value(o->v[2].p), integer(slot_value(o->v[3].p))), real(slot_value(o->v[1].p))));
}

static bool d_dd_fs_combinable(s7_scheme *sc, opt_info *opc, s7_d_dd_t func)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fd == opt_d_7pi_ss)
	{
	  if (func)
	    {
	      opc->v[4].d_dd_f = opc->v[3].d_dd_f; /* need room for 3 symbols */
	      opc->v[0].fd = opt_d_dd_fso;
	    }
	  else
	    {
	      opc->v[4].d_7dd_f = opc->v[3].d_7dd_f;
	      opc->v[0].fd = opt_d_7dd_fso;
	    }
	  opc->v[2].p = o1->v[1].p;
	  opc->v[3].p = o1->v[2].p;
	  opc->v[5].d_7pi_f = o1->v[3].d_7pi_f;
	  backup_pc(sc);
	  return(oo_set_type_3(opc, 6, 1, 2, 3, OO_D, OO_P, OO_I));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static s7_double opt_d_dd_ff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o2 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_dd_f(x1, o2->v[0].fd(o2)));
}

static s7_double opt_d_dd_ff_mul(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o2 = o->sc->opts[++o->sc->pc];
  return(x1 * o2->v[0].fd(o2));
}

static s7_double opt_d_dd_ff_add(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o2 = o->sc->opts[++o->sc->pc];
  return(x1 + o2->v[0].fd(o2));
}

static s7_double opt_d_dd_ff_sub(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o2 = o->sc->opts[++o->sc->pc];
  return(x1 - o2->v[0].fd(o2));
}

static s7_double opt_d_7dd_ff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o2 = o->sc->opts[++o->sc->pc];
  return(o->v[3].d_7dd_f(o->sc, x1, o2->v[0].fd(o2)));
}

static s7_double opt_d_dd_ff_o1(void *p)
{
  opt_info *o2, *o = (opt_info *)p;
  s7_double x1;
  x1 = o->v[2].d_v_f(o->v[1].obj);
  o2 = o->sc->opts[o->sc->pc += 2];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].d_dd_f(x1, o2->v[0].fd(o2)));
}

static s7_double opt_d_dd_ff_mul1(void *p)
{
  opt_info *o2, *o = (opt_info *)p;
  o2 = o->sc->opts[o->sc->pc += 2];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[2].d_v_f(o->v[1].obj) * o2->v[0].fd(o2));
}

static s7_double opt_d_dd_ff_o2(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double x1;
  oo_rcheck(o->sc, o, 6, 2);
  x1 = o->v[4].d_v_f(o->v[1].obj);
  return(o->v[3].d_dd_f(x1, o->v[5].d_v_f(o->v[2].obj)));
}

static s7_double opt_d_dd_ff_mul2(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 2);
  return(o->v[4].d_v_f(o->v[1].obj) * o->v[5].d_v_f(o->v[2].obj));
}

static s7_double opt_d_dd_ff_o3(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double x1;
  oo_rcheck(o->sc, o, 7, 3);
  x1 = o->v[5].d_v_f(o->v[1].obj);
  return(o->v[4].d_dd_f(x1, o->v[6].d_vd_f(o->v[2].obj, real(slot_value(o->v[3].p)))));
}

static s7_double opt_d_dd_fff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1, x2;
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[4].d_dd_f(o1->v[5].d_7pi_f(o->sc, slot_value(o1->v[2].p), integer(slot_value(o1->v[3].p))), real(slot_value(o1->v[1].p))); /* dd_fso */
  o2 = o->sc->opts[++o->sc->pc];
  x2 = o2->v[4].d_dd_f(o2->v[5].d_7pi_f(o->sc, slot_value(o2->v[2].p), integer(slot_value(o2->v[3].p))), real(slot_value(o2->v[1].p))); /* dd_fso */
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].d_dd_f(x1, x2));
}

static s7_double opt_d_mm_fff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1, x2;
  o1 = o->sc->opts[++o->sc->pc];
  x1 = float_vector_ref_d_7pi(o->sc, slot_value(o1->v[2].p), integer(slot_value(o1->v[3].p))) * real(slot_value(o1->v[1].p));
  o2 = o->sc->opts[++o->sc->pc];
  x2 = float_vector_ref_d_7pi(o->sc, slot_value(o2->v[2].p), integer(slot_value(o2->v[3].p))) * real(slot_value(o2->v[1].p));
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].d_dd_f(x1, x2));
}

static s7_double opt_d_dd_fff_rev(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1, x2;
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[4].d_dd_f(real(slot_value(o1->v[1].p)), o1->v[5].d_7pi_f(o->sc, slot_value(o1->v[2].p), integer(slot_value(o1->v[3].p))));
  o2 = o->sc->opts[++o->sc->pc];
  x2 = o2->v[4].d_dd_f(real(slot_value(o2->v[1].p)), o2->v[5].d_7pi_f(o->sc, slot_value(o2->v[2].p), integer(slot_value(o2->v[3].p))));
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].d_dd_f(x1, x2));
}

static s7_double opt_d_dd_ff_o4(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double x1;
  x1 = o->v[2].d_v_f(o->v[1].obj);
  oo_rcheck(o->sc, o, 8, 3);
  return(o->v[3].d_dd_f(x1, o->v[7].d_vd_f(o->v[5].obj, o->v[4].d_v_f(o->v[6].obj))));
}

static s7_double opt_d_dd_ff_mul4(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 8, 3);
  return(o->v[2].d_v_f(o->v[1].obj) * o->v[7].d_vd_f(o->v[5].obj, o->v[4].d_v_f(o->v[6].obj)));
}

static bool d_dd_ff_combinable(s7_scheme *sc, int32_t start)
{
  opt_info *opc, *o1;
  opc = sc->opts[start - 1];
  o1 = sc->opts[start];
  if (o1->v[0].fd == opt_d_v)
    {
      opt_info *o2;
      /* opc->v[3] is in use */
      o2 = sc->opts[start + 1];
      if ((o2->v[0].fd == opt_d_v) &&
	  (sc->pc == start + 2))
	{
	  opc->v[1].obj = o1->v[5].obj;
	  opc->v[6].p = o1->v[1].p;
	  opc->v[4].d_v_f = o1->v[3].d_v_f;
	  opc->v[2].obj = o2->v[5].obj;
	  opc->v[7].p = o2->v[1].p;
	  opc->v[5].d_v_f = o2->v[3].d_v_f;
	  if (opc->v[3].d_dd_f == multiply_d_dd)
	    opc->v[0].fd = opt_d_dd_ff_mul2;
	  else opc->v[0].fd = opt_d_dd_ff_o2;
	  sc->pc -= 2;
	  return(oo_set_type_2(opc, 8, 6 + (1 << 4), 7 + (2 << 4), OO_V, OO_V));
	}
      if ((o2->v[0].fd == opt_d_vd_s) &&
	  (sc->pc == start + 2))
	{
	  opc->v[4].d_dd_f = opc->v[3].d_dd_f; /* make room for symbols */
	  opc->v[1].obj = o1->v[5].obj;
	  opc->v[7].p = o1->v[1].p;
	  opc->v[5].d_v_f = o1->v[3].d_v_f;
	  opc->v[2].obj = o2->v[5].obj;
	  opc->v[8].p = o2->v[1].p;
	  opc->v[6].d_vd_f = o2->v[3].d_vd_f;
	  opc->v[3].p = o2->v[2].p;
	  opc->v[0].fd = opt_d_dd_ff_o3;
	  sc->pc -= 2;
	  return(oo_set_type_3(opc, 9, 3, 7 + (1 << 4), 8 + (2 << 4), OO_D, OO_V, OO_V));
	}
      if ((o2->v[0].fd == opt_d_vd_o) &&
	  (sc->pc == start + 2))
	{
	  opc->v[1].obj = o1->v[5].obj;
	  opc->v[8].p = o1->v[1].p;
	  opc->v[2].d_v_f = o1->v[3].d_v_f;
	  opc->v[7].d_vd_f = o2->v[3].d_vd_f;
	  opc->v[4].d_v_f = o2->v[4].d_v_f;
	  opc->v[5].obj = o2->v[5].obj;
	  opc->v[9].p = o2->v[1].p;
	  opc->v[6].obj = o2->v[6].obj;
	  opc->v[10].p = o2->v[2].p;
	  if (opc->v[3].d_dd_f == multiply_d_dd)
	    opc->v[0].fd = opt_d_dd_ff_mul4;
	  else opc->v[0].fd = opt_d_dd_ff_o4;
	  sc->pc -= 2;
	  return(oo_set_type_3(opc, 11, 8 + (1 << 4), 9 + (5 << 4), 10 + (6 << 4), OO_V, OO_V, OO_V));
	}
      opc->v[1].obj = o1->v[5].obj;
      opc->v[4].p = o1->v[1].p;
      opc->v[2].d_v_f = o1->v[3].d_v_f;
      if (opc->v[3].d_dd_f == multiply_d_dd)
	opc->v[0].fd = opt_d_dd_ff_mul1;
      else opc->v[0].fd = opt_d_dd_ff_o1;
      return(oo_set_type_1(opc, 5, 4 + (1 << 4), OO_V));
    }

  if (o1->v[0].fd == opt_d_dd_fso)
    {
      opt_info *o2;
      o2 = sc->opts[start + 1];
      if (o2->v[0].fd == opt_d_dd_fso)
	{
	  if ((o1->v[4].d_dd_f == multiply_d_dd) &&
	      (o2->v[4].d_dd_f == multiply_d_dd) &&
	      (o1->v[5].d_7pi_f == float_vector_ref_d_7pi) &&
	      (o2->v[5].d_7pi_f == float_vector_ref_d_7pi))
	    opc->v[0].fd = opt_d_mm_fff;
	  else opc->v[0].fd = opt_d_dd_fff;
	  return(oo_set_type_0(opc, 4));
	}
    }
  if (o1->v[0].fd == opt_d_dd_sfo)
    {
      opt_info *o2;
      o2 = sc->opts[start + 1];
      if (o2->v[0].fd == opt_d_dd_sfo)
	{
	  if ((o1->v[4].d_dd_f == multiply_d_dd) &&
	      (o2->v[4].d_dd_f == multiply_d_dd) &&
	      (o1->v[5].d_7pi_f == float_vector_ref_d_7pi) &&
	      (o2->v[5].d_7pi_f == float_vector_ref_d_7pi))
	    opc->v[0].fd = opt_d_mm_fff; /* multiply is commutative */
	  else opc->v[0].fd = opt_d_dd_fff_rev;
	  return(oo_set_type_0(opc, 4));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static s7_double opt_d_dd_cfo(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 0);
  return(o->v[3].d_dd_f(o->v[2].x, o->v[4].d_v_f(o->v[1].obj)));
}

static s7_double opt_d_7dd_cfo(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 0);
  return(o->v[3].d_7dd_f(o->sc, o->v[2].x, o->v[4].d_v_f(o->v[1].obj)));
}

static s7_double opt_d_dd_cfo1(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 7, 2);
  return(o->v[3].d_dd_f(o->v[4].x, o->v[5].d_vd_f(o->v[6].obj, real(slot_value(o->v[2].p)))));
}

static s7_double opt_d_7dd_cfo1(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 7, 2);
  return(o->v[3].d_7dd_f(o->sc, o->v[4].x, o->v[5].d_vd_f(o->v[6].obj, real(slot_value(o->v[2].p)))));
}

static bool d_dd_cf_combinable(s7_scheme *sc, opt_info *opc, s7_d_dd_t func)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fd == opt_d_v)
	{
	  opc->v[2].x = opc->v[1].x;
	  opc->v[6].p = o1->v[1].p;
	  opc->v[1].obj = o1->v[5].obj;
	  opc->v[4].d_v_f = o1->v[3].d_v_f;
	  if (func)
	    opc->v[0].fd = opt_d_dd_cfo;
	  else opc->v[0].fd = opt_d_7dd_cfo;
	  backup_pc(sc);
	  return(oo_set_type_1(opc, 7, 6 + (1 << 4), OO_V));
	}
      if (o1->v[0].fd == opt_d_vd_s)
	{
	  opc->v[4].x = opc->v[1].x;
	  opc->v[1].p = o1->v[1].p;
	  opc->v[6].obj = o1->v[5].obj;
	  opc->v[2].p = o1->v[2].p;
	  opc->v[5].d_vd_f = o1->v[3].d_vd_f;
	  if (func)
	    opc->v[0].fd = opt_d_dd_cfo1;
	  else opc->v[0].fd = opt_d_7dd_cfo1;
	  backup_pc(sc);
	  return(oo_set_type_2(opc, 7, 1 + (6 << 4), 2, OO_V, OO_D));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool d_dd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_dd_t func;
  s7_d_7dd_t func7 = NULL;
  func = s7_d_dd_function(s_func);
  if (!func) func7 = s7_d_7dd_function(s_func);
  if ((func) || (func7))
    {
      s7_pointer arg1, arg2, slot;
      int32_t start;
      start = sc->pc;
      arg1 = cadr(car_x);
      arg2 = caddr(car_x);
      if (func)
	opc->v[3].d_dd_f = func;
      else opc->v[3].d_7dd_f = func7;

      /* arg1 = real constant */
      if (is_real(arg1))
	{
	  if (is_real(arg2))
	    {
	      if ((!is_float(arg1)) && (!is_float(arg2)))
		return(return_false(sc, car_x, __func__, __LINE__));
	      opc->v[1].x = s7_number_to_real(sc, arg1);
	      opc->v[2].x = s7_number_to_real(sc, arg2);
	      if (func)
		opc->v[0].fd = opt_d_dd_cc;
	      else opc->v[0].fd = opt_d_7dd_cc;
	      return(oo_set_type_0(opc, 4));
	    }
	  slot = opt_float_symbol(sc, arg2);
	  if (slot)
	    {
	      opc->v[1].p = slot;
	      opc->v[2].x = s7_number_to_real(sc, arg1); /* move arg1? */
	      if (func)
		opc->v[0].fd = opt_d_dd_cs;
	      else opc->v[0].fd = opt_d_7dd_cs;
	      return(oo_set_type_1(opc, 4, 1, OO_D));
	    }
	  if (float_optimize(sc, cddr(car_x)))
	    {
	      opc->v[1].x = s7_number_to_real(sc, arg1);
	      if (d_dd_cf_combinable(sc, opc, func))
		return(true);
	      if (func)
		opc->v[0].fd = opt_d_dd_cf;
	      else opc->v[0].fd = opt_d_7dd_cf;
	      return(oo_set_type_0(opc, 4));
	    }
	  pc_fallback(sc, start);
	  return(return_false(sc, car_x, __func__, __LINE__));
	}

      /* arg1 = float symbol */
      slot = opt_float_symbol(sc, arg1);
      if (slot)
	{
	  opc->v[1].p = slot;
	  if (is_real(arg2))
	    {
	      opc->v[2].x = s7_number_to_real(sc, arg2);
	      if (func)
		opc->v[0].fd = opt_d_dd_sc;
	      else opc->v[0].fd = opt_d_7dd_sc;
	      return(oo_set_type_1(opc, 4, 1, OO_D));
	    }
	  slot = opt_float_symbol(sc, arg2);
	  if (slot)
	    {
	      opc->v[2].p = slot;
	      if (func)
		{
		  if (func == multiply_d_dd)
		    opc->v[0].fd = opt_d_dd_ss_mul;
		  else opc->v[0].fd = opt_d_dd_ss;
		}
	      else opc->v[0].fd = opt_d_7dd_ss;
	      return(oo_set_type_2(opc, 4, 1, 2, OO_R, OO_D));
	    }
	  if (float_optimize(sc, cddr(car_x)))
	    {
	      if (d_dd_sf_combinable(sc, opc, func))
		return(true);
	      if (func)
		{
		  if (func == multiply_d_dd)
		    opc->v[0].fd = opt_d_dd_sf_mul;
		  else opc->v[0].fd = opt_d_dd_sf;
		}
	      else opc->v[0].fd = opt_d_7dd_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_D));
	    }
	  pc_fallback(sc, start);
	  return(return_false(sc, car_x, __func__, __LINE__));
	}

      /* arg1 = float expr or non-float */
      if (float_optimize(sc, cdr(car_x)))
	{
	  if (is_real(arg2))
	    {
	      opc->v[2].x = s7_number_to_real(sc, arg2);
	      if (func)
		{
		  if (func == add_d_dd)
		    opc->v[0].fd = opt_d_dd_fc_add;
		  else opc->v[0].fd = opt_d_dd_fc;
		}
	      else opc->v[0].fd = opt_d_7dd_fc;
	      return(oo_set_type_0(opc, 4));
	    }
	  slot = opt_float_symbol(sc, arg2);
	  if (slot)
	    {
	      opc->v[1].p = slot;
	      if (d_dd_fs_combinable(sc, opc, func))
		return(true);
	      if (func)
		{
		  opc->v[0].fd = opt_d_dd_fs;
		  if (func == multiply_d_dd)
		    opc->v[0].fd = opt_d_dd_fs_mul;
		}
	      else opc->v[0].fd = opt_d_7dd_fs;
	      return(oo_set_type_1(opc, 4, 1, OO_D));
	    }
	  if (float_optimize(sc, cddr(car_x)))
	    {
	      if (func)
		{
		  if (d_dd_ff_combinable(sc, start))
		    return(true);
		  opc->v[0].fd = opt_d_dd_ff;
		  if (func == multiply_d_dd)
		    opc->v[0].fd = opt_d_dd_ff_mul;
		  else
		    {
		      if (func == add_d_dd)
			opc->v[0].fd = opt_d_dd_ff_add;
		      else
			{
			  if (func == subtract_d_dd)
			    opc->v[0].fd = opt_d_dd_ff_sub;
			}
		    }
		}
	      else opc->v[0].fd = opt_d_7dd_ff;
	      return(oo_set_type_0(opc, 4));
	    }
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_ddd -------- */
static s7_double opt_d_ddd_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].d_ddd_f(real(slot_value(o->v[1].p)), real(slot_value(o->v[2].p)), real(slot_value(o->v[3].p))));
}

static s7_double opt_d_ddd_ssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[4].d_ddd_f(real(slot_value(o->v[1].p)), real(slot_value(o->v[2].p)), o1->v[0].fd(o1)));
}

static s7_double opt_d_ddd_sff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_double x1;
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 5, 1);
  return(o->v[4].d_ddd_f(real(slot_value(o->v[1].p)), x1, o1->v[0].fd(o1)));
}

static s7_double opt_d_ddd_fff(void *p)
{
  opt_info *o1, *o2, *o3, *o = (opt_info *)p;
  s7_double x1, x2;
  s7_scheme *sc;
  sc = o->sc;
  o1 = sc->opts[++sc->pc];
  x1 = o1->v[0].fd(o1); /* this could involve nested funcs, incrementing pc internally */
  o2 = sc->opts[++sc->pc];
  x2 = o2->v[0].fd(o2);
  o3 = sc->opts[++sc->pc];
  oo_rcheck(o->sc, o, 5, 0);
  return(o->v[4].d_ddd_f(x1, x2, o3->v[0].fd(o3)));
}

static s7_double opt_d_ddd_fff1(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double x1, x2, x3;
  x1 = o->v[1].d_v_f(o->v[2].obj);
  x2 = o->v[3].d_v_f(o->v[4].obj);
  x3 = o->v[5].d_v_f(o->v[6].obj);
  oo_rcheck(o->sc, o, 8, 3);
  return(o->v[7].d_ddd_f(x1, x2, x3));
}

static s7_double opt_d_ddd_fff2(void *p)
{
  opt_info *o = (opt_info *)p;
  opt_info *o2, *o3;
  s7_double x1, x2;
  x1 = o->v[1].d_v_f(o->v[2].obj);
  o->sc->pc += 2;
  o2 = o->sc->opts[o->sc->pc];
  x2 = o2->v[0].fd(o2);
  o3 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 8, 1);
  return(o->v[7].d_ddd_f(x1, x2, o3->v[0].fd(o3)));
}

static bool d_ddd_fff_combinable(s7_scheme *sc, opt_info *opc, int32_t start)
{
  if (sc->opts[start]->v[0].fd == opt_d_v)
    {
      opt_info *o1;
      opc->v[7].d_ddd_f = opc->v[4].d_ddd_f;
      o1 = sc->opts[start];
      opc->v[1].d_v_f = o1->v[3].d_v_f;
      opc->v[2].obj = o1->v[5].obj;
      opc->v[8].p = o1->v[1].p;
      if ((sc->opts[start + 1]->v[0].fd == opt_d_v) &&
	  (sc->opts[start + 2]->v[0].fd == opt_d_v))
	{
	  opc->v[0].fd = opt_d_ddd_fff1;
	  o1 = sc->opts[start + 1];
	  opc->v[3].d_v_f = o1->v[3].d_v_f;
	  opc->v[4].obj = o1->v[5].obj;
	  opc->v[9].p = o1->v[1].p;
	  o1 = sc->opts[start + 2];
	  opc->v[5].d_v_f = o1->v[3].d_v_f;
	  opc->v[6].obj = o1->v[5].obj;
	  opc->v[10].p = o1->v[1].p;
	  sc->pc -= 3;
	  return(oo_set_type_3(opc, 11, 8 + (2 << 4), 9 + (4 << 4), 10 + (6 << 4), OO_V, OO_V, OO_V));
	}
      opc->v[0].fd = opt_d_ddd_fff2;
      return(oo_set_type_1(opc, 9, 8 + (2 << 4), OO_V));
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool d_ddd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_ddd_t f;

  f = s7_d_ddd_function(s_func);
  if (f)
    {
      int32_t start;
      s7_pointer arg1, arg2, slot;
      arg1 = cadr(car_x);
      arg2 = caddr(car_x);
      start = sc->pc;
      opc->v[4].d_ddd_f = f;
      slot = opt_float_symbol(sc, arg1);
      if (slot)
	{
	  opc->v[1].p = slot;
	  slot = opt_float_symbol(sc, arg2);
	  if (slot)
	    {
	      s7_pointer arg3;
	      opc->v[2].p = slot;
	      arg3 = cadddr(car_x);
	      slot = opt_float_symbol(sc, arg3);
	      if (slot)
		{
		  opc->v[3].p = slot;
		  opc->v[0].fd = opt_d_ddd_sss;
		  return(oo_set_type_3(opc, 5, 1, 2, 3, OO_D, OO_D, OO_D));
		}
	      if (float_optimize(sc, cdddr(car_x)))
		{
		  opc->v[0].fd = opt_d_ddd_ssf;
		  return(oo_set_type_2(opc, 5, 1, 2, OO_D, OO_D));
		}
	      pc_fallback(sc, start);
	    }
	  if ((float_optimize(sc, cddr(car_x))) &&
	      (float_optimize(sc, cdddr(car_x))))
	    {
	      opc->v[0].fd = opt_d_ddd_sff;
	      return(oo_set_type_1(opc, 5, 1, OO_D));
	    }
	  pc_fallback(sc, start);
	}
      if ((float_optimize(sc, cdr(car_x))) &&
	  (float_optimize(sc, cddr(car_x))) &&
	  (float_optimize(sc, cdddr(car_x))))
	{
	  if (d_ddd_fff_combinable(sc, opc, start))
	    return(true);
	  opc->v[0].fd = opt_d_ddd_fff;
	      /* (* (env pulsef) (blackman pulse2) (polywave gen (rand-interp rnd)))
	       *  (* (env e)...) is common = opt_d_v: v3 v5 -> opc
	       * (+ k (* 2 alpha) -2.0) (* scl ang ang) (- n k 1)
	       */
	  return(oo_set_type_0(opc, 5));
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_7pid -------- */
static s7_double opt_d_7pid_ssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[4].d_7pid_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o1->v[0].fd(o1)));
}

static s7_pointer opt_d_7pid_ssf_nr(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 5, 2);
  o->v[4].d_7pid_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o1->v[0].fd(o1));
  return(NULL);
}

static s7_double opt_d_7pid_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].d_7pid_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), real(slot_value(o->v[3].p))));
}

static s7_double opt_d_7pid_ssc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[4].d_7pid_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o->v[3].x));
}

static s7_double opt_d_7pid_sff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int pos;
  o1 = o->sc->opts[++o->sc->pc];
  pos = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 5, 1);
  return(o->v[4].d_7pid_f(o->sc, slot_value(o->v[1].p), pos, o1->v[0].fd(o1)));
}

static s7_double opt_d_7pid_sso(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[4].d_7pid_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o->v[5].d_v_f(o->v[3].obj)));
}

static s7_double opt_d_7pid_ss_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 7, 4);
  return(o->v[4].d_7pid_f(o->sc, slot_value(o->v[1].p),
			  integer(slot_value(o->v[2].p)),
			  o->v[3].d_7pi_f(o->sc, slot_value(o->v[5].p),
					  integer(slot_value(o->v[6].p)))));
}

static s7_double opt_d_7pid_ssfo(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer fv;
  fv = slot_value(o->v[1].p);
  oo_rcheck(o->sc, o, 9, 4);
  return(o->v[4].d_7pid_f(o->sc, fv, integer(slot_value(o->v[2].p)),
	    o->v[6].d_dd_f(o->v[5].d_7pi_f(o->sc, fv, integer(slot_value(o->v[3].p))), real(slot_value(o->v[8].p)))));
}

static s7_double opt_d_7pid_ssfo_fv(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double val;
  s7_double *els;
  els = float_vector_floats(slot_value(o->v[1].p));
  val = o->v[6].d_dd_f(els[integer(slot_value(o->v[3].p))], real(slot_value(o->v[8].p)));
  els[integer(slot_value(o->v[2].p))] = val;
  oo_rcheck(o->sc, o, 7, 4);
  return(val);
}

static s7_pointer opt_d_7pid_ssfo_fv_nr(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double *els;
  els = float_vector_floats(slot_value(o->v[1].p));
  els[integer(slot_value(o->v[2].p))] = o->v[6].d_dd_f(els[integer(slot_value(o->v[3].p))], real(slot_value(o->v[8].p)));
  oo_rcheck(o->sc, o, 9, 4);
  return(NULL);
}

static s7_pointer opt_d_7pid_ssfo_fv_add_nr(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double *els;
  els = float_vector_floats(slot_value(o->v[1].p));
  els[integer(slot_value(o->v[2].p))] = els[integer(slot_value(o->v[3].p))] + real(slot_value(o->v[8].p));
  oo_rcheck(o->sc, o, 9, 4);
  return(NULL);
}

static s7_pointer opt_d_7pid_ssfo_fv_sub_nr(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double *els;
  els = float_vector_floats(slot_value(o->v[1].p));
  els[integer(slot_value(o->v[2].p))] = els[integer(slot_value(o->v[3].p))] - real(slot_value(o->v[8].p));
  oo_rcheck(o->sc, o, 9, 4);
  return(NULL);
}

static bool d_7pid_ssf_combinable(s7_scheme *sc, opt_info *opc)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fd == opt_d_v)
	{
	  opc->v[6].p = o1->v[1].p;
	  opc->v[3].obj = o1->v[5].obj;
	  opc->v[5].d_v_f = o1->v[3].d_v_f;
	  opc->v[0].fd = opt_d_7pid_sso;
	  backup_pc(sc);
	  return(oo_set_type_3(opc, 7, 1, 2, 6 + (3 << 4), OO_P, OO_I, OO_V));
	}
      if (o1->v[0].fd == opt_d_7pi_ss)
	{
	  opc->v[3].d_7pi_f = o1->v[3].d_7pi_f;
	  opc->v[5].p = o1->v[1].p;
	  opc->v[6].p = o1->v[2].p;
	  opc->v[0].fd = opt_d_7pid_ss_ss;
	  backup_pc(sc);
	  return(oo_set_type_4(opc, 7, 1, 2, 5, 6, OO_P, OO_I, OO_P, OO_I));
	}
      if ((o1->v[0].fd == opt_d_dd_fso) &&
	  (opc->v[1].p == o1->v[2].p))
	{
	  /* opc: pid_ssf: o->v[4].d_7pid_f(slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o1->v[0].fd(o1))
	   * o1: d_dd_fso: o->v[4].d_dd_f(o->v[5].d_7pi_f(slot_value(o->v[2].p), integer(slot_value(o->v[3].p))), real(slot_value(o->v[1].p))))
	   */
	  opc->v[6].d_dd_f = o1->v[4].d_dd_f;
	  opc->v[5].d_7pi_f = o1->v[5].d_7pi_f;
	  opc->v[3].p = o1->v[3].p;
	  opc->v[8].p = o1->v[1].p; /* can't use v8 since d_to_p commandeers it */
	  opc->v[0].fd = opt_d_7pid_ssfo;
	  if (((opc->v[5].d_7pi_f == float_vector_ref_unchecked) ||
	       (opc->v[5].d_7pi_f == float_vector_ref_d_7pi)) &&
	      ((opc->v[4].d_7pid_f == float_vector_set_unchecked) ||
	       (opc->v[4].d_7pid_f == float_vector_set_d_7pid)))
	    {
	      opc->v[0].fd = opt_d_7pid_ssfo_fv; /* actually if either is *_d, we need to check the indices */
	      oo_set_type_4(opc, 9, 1, 2, 3, 8, OO_FV, OO_I, OO_I, OO_D);
	    }
	  else oo_set_type_4(opc, 9, 1, 2, 3, 8, OO_P, OO_I, OO_I, OO_D);
	  backup_pc(sc);
	  return(true);
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

/* -------- d_7piid -------- */
static s7_double opt_d_7piid_sssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[5].d_7piid_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)), o1->v[0].fd(o1)));
}

static s7_double opt_d_7piid_sssc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[5].d_7piid_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)), o->v[4].x));
}

static s7_double opt_d_7piid_scsf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 2);
  return(o->v[5].d_7piid_f(o->sc, slot_value(o->v[1].p), o->v[2].i, integer(slot_value(o->v[3].p)), o1->v[0].fd(o1)));
}

static s7_double opt_d_7piid_sfff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1, i2;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  i2 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 1);
  return(o->v[5].d_7piid_f(o->sc, slot_value(o->v[1].p), i1, i2, o1->v[0].fd(o1)));
}

static bool opt_float_vector_set(s7_scheme *sc, opt_info *opc, s7_pointer v, s7_pointer indexp1, s7_pointer indexp2, s7_pointer valp)
{
  s7_pointer settee;
  /* fprintf(stderr, "%s: %s %s %s %s\n", __func__, DISPLAY(v), DISPLAY(indexp1), (indexp2) ? DISPLAY(indexp1) : "null", DISPLAY(valp)); */
  settee = symbol_to_slot(sc, v);
  if ((is_slot(settee)) &&
      (!is_immutable(slot_value(settee))))
    {
      s7_pointer slot;
      opc->v[1].p = settee;
      if (is_float_vector(slot_value(settee)))
	{
	  if ((!indexp2) &&
	      (vector_rank(slot_value(settee)) == 1))
	    {
	      opc->v[4].d_7pid_f = float_vector_set_d_7pid;
	      slot = opt_integer_symbol(sc, car(indexp1));
	      if (slot)
		{
		  opc->v[2].p = slot;
		  if ((is_step_end(opc->v[2].p)) &&
		      (denominator(slot_value(opc->v[2].p)) <= vector_length(slot_value(settee))))
		    opc->v[4].d_7pid_f = float_vector_set_unchecked;
		  slot = opt_float_symbol(sc, car(valp));
		  if (slot)
		    {
		      opc->v[3].p = slot;
		      opc->v[0].fd = opt_d_7pid_sss;
		      return(oo_set_type_3(opc, 5, 1, 2, 3, OO_FV, OO_I, OO_D));
		    }
		  if (is_real(car(valp)))
		    {
		      opc->v[3].x = s7_real(car(valp));
		      opc->v[0].fd = opt_d_7pid_ssc;
		      return(oo_set_type_2(opc, 5, 1, 2, OO_FV, OO_I));
		    }
		  if (float_optimize(sc, valp))
		    {
		      if (d_7pid_ssf_combinable(sc, opc))
			return(true);
		      opc->v[0].fd = opt_d_7pid_ssf;
		      return(oo_set_type_2(opc, 5, 1, 2, OO_FV, OO_I));
		    }
		}
	      if ((int_optimize(sc, indexp1)) &&
		  (float_optimize(sc, valp)))
		{
		  opc->v[0].fd = opt_d_7pid_sff;
		  return(oo_set_type_1(opc, 5, 1, OO_FV));
		}
	      return(return_false(sc, NULL, __func__, __LINE__));
	    }

	  if ((indexp2) &&
	      (vector_rank(slot_value(settee)) == 2))
	    {
	      opc->v[5].d_7piid_f = float_vector_set_d_7piid;
	      slot = opt_integer_symbol(sc, car(indexp2));
	      if (slot)
		{
		  opc->v[3].p = slot;
		  if (is_t_integer(car(indexp1)))
		    {
		      if (float_optimize(sc, valp))
			{
			  opc->v[0].fd = opt_d_7piid_scsf;
			  opc->v[2].i = integer(car(indexp1));
			  return(oo_set_type_2(opc, 6, 1, 3, OO_FV, OO_I));
			}
		      return(return_false(sc, NULL, __func__, __LINE__));
		    }
		  slot = opt_integer_symbol(sc, car(indexp1));
		  if (slot)
		    {
		      opc->v[2].p = slot;
		      if (is_real(car(valp)))
			{
			  opc->v[0].fd = opt_d_7piid_sssc;
			  opc->v[4].x = s7_real(car(valp));
			  return(oo_set_type_3(opc, 6, 1, 2, 3, OO_FV, OO_I, OO_I));
			}
		      if (float_optimize(sc, valp))
			{
			  opc->v[0].fd = opt_d_7piid_sssf;
			  return(oo_set_type_3(opc, 6, 1, 2, 3, OO_FV, OO_I, OO_I));
			}
		    }
		  if ((int_optimize(sc, indexp1)) &&
		      (int_optimize(sc, indexp2)) &&
		      (float_optimize(sc, valp)))
		    {
		      opc->v[0].fd = opt_d_7piid_sfff;
		      return(oo_set_type_1(opc, 6, 1, OO_FV));
		    }}}}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static s7_double opt_d_7pii_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].d_7pii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p))));
}

static s7_double opt_d_7pii_scs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[4].d_7pii_f(o->sc, slot_value(o->v[1].p), o->v[2].i, integer(slot_value(o->v[3].p))));
}

static s7_double opt_d_7pii_sff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 5, 1);
  return(o->v[4].d_7pii_f(o->sc, slot_value(o->v[1].p), i1, o1->v[0].fi(o1)));
}

static bool d_7pii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  if (is_symbol(cadr(car_x)))
    {
      s7_d_7pii_t ifunc;
      ifunc = s7_d_7pii_function(s_func);
      if ((ifunc) &&
	  (is_symbol(cadr(car_x))))
	{
	  s7_pointer slot;
	  int32_t start;
	  start = sc->pc;
	  opc->v[1].p = symbol_to_slot(sc, cadr(car_x));

	  if (!is_slot(opc->v[1].p))
	    return(return_false(sc, car_x, __func__, __LINE__));

	  if ((car(car_x) == sc->float_vector_ref_symbol) &&
	      ((!is_float_vector(slot_value(opc->v[1].p))) ||
	       (vector_rank(slot_value(opc->v[1].p)) != 2)))
	    return(return_false(sc, car_x, __func__, __LINE__));

	  opc->v[4].d_7pii_f = ifunc;
	  slot = opt_integer_symbol(sc, cadddr(car_x));
	  if (slot)
	    {
	      opc->v[3].p = slot;
	      slot = opt_integer_symbol(sc, caddr(car_x));
	      if (slot)
		{
		  opc->v[2].p = slot;
		  opc->v[0].fd = opt_d_7pii_sss;
		  return(oo_set_type_3(opc, 5, 1, 2, 3, OO_P, OO_I, OO_I));
		}
	      if (is_t_integer(caddr(car_x)))
		{
		  opc->v[2].i = integer(caddr(car_x));
		  opc->v[0].fd = opt_d_7pii_scs;
		  return(oo_set_type_2(opc, 5, 1, 3, OO_P, OO_I));
		}
	    }
	  if ((int_optimize(sc, cddr(car_x))) &&
	      (int_optimize(sc, cdddr(car_x))))
	    {
	      opc->v[0].fd = opt_d_7pii_sff;
	      return(oo_set_type_1(opc, 5, 1, OO_P));
	    }
	  pc_fallback(sc, start);
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool d_7pid_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_7pid_t f;
  f = s7_d_7pid_function(s_func);
  if ((f) &&
      (is_symbol(cadr(car_x))))
    {
      s7_pointer head, slot;
      int32_t start;
      start = sc->pc;

      head = car(car_x);
      opc->v[4].d_7pid_f = f;

      if (head == sc->float_vector_set_symbol)
	return(opt_float_vector_set(sc, opc, cadr(car_x), cddr(car_x), NULL, cdddr(car_x)));

      opc->v[1].p = symbol_to_slot(sc, cadr(car_x));
      if (is_slot(opc->v[1].p))
	{
	  slot = opt_integer_symbol(sc, caddr(car_x));
	  if (slot)
	    {
	      opc->v[2].p = slot;
	      slot = opt_float_symbol(sc, cadddr(car_x));
	      if (slot)
		{
		  opc->v[3].p = slot;
		  opc->v[0].fd = opt_d_7pid_sss;
		  return(oo_set_type_3(opc, 5, 1, 2, 3, OO_P, OO_I, OO_D));
		}
	      if (float_optimize(sc, cdddr(car_x)))
		{
		  if (d_7pid_ssf_combinable(sc, opc))
		    return(true);
		  opc->v[0].fd = opt_d_7pid_ssf;
		  return(oo_set_type_2(opc, 5, 1, 2, OO_P, OO_I));
		}
	      pc_fallback(sc, start);
	    }
	  if ((int_optimize(sc, cddr(car_x))) &&
	      (float_optimize(sc, cdddr(car_x))))
	    {
	      opc->v[0].fd = opt_d_7pid_sff;
	      return(oo_set_type_1(opc, 5, 1, OO_P));
	    }
	  pc_fallback(sc, start);
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool d_7piid_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_7piid_t f;
  f = s7_d_7piid_function(s_func);
  if ((f) &&
      (is_symbol(cadr(car_x))))
    {
      opc->v[4].d_7piid_f = f;
      if (car(car_x) == sc->float_vector_set_symbol)
	return(opt_float_vector_set(sc, opc, cadr(car_x), cddr(car_x), cdddr(car_x), cddddr(car_x)));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_vid -------- */
static s7_double opt_d_vid_ssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 2);
  return(o->v[4].d_vid_f(o->v[5].obj, integer(slot_value(o->v[2].p)), o1->v[0].fd(o1)));
}

static inline s7_double opt_fmv(void *p)
{
  /* d_vid_ssf -> d_dd_ff_o1 -> d_vd_o1 -> d_dd_ff_o3 */
  opt_info *o1, *o2, *o3, *o = (opt_info *)p;
  s7_double amp_env, index_env, vib;
  s7_scheme *sc;
  sc = o->sc;

  o1 = sc->opts[sc->pc + 1];
  o2 = sc->opts[sc->pc + 3];
  o3 = sc->opts[sc->pc += 5];
  amp_env = o1->v[2].d_v_f(o1->v[1].obj);
  vib = real(slot_value(o2->v[2].p));
  index_env = o3->v[5].d_v_f(o3->v[1].obj);

  oo_rcheck(o->sc, o, 6, 2);
  return(o->v[4].d_vid_f(o->v[5].obj,
			 integer(slot_value(o->v[2].p)),
			 amp_env * o2->v[3].d_vd_f(o2->v[5].obj,
						   vib + (index_env * o3->v[6].d_vd_f(o3->v[2].obj, vib)))));
}

static bool d_vid_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  if ((is_symbol(cadr(car_x))) &&
      (is_symbol(caddr(car_x))))
    {
      s7_d_vid_t flt;
      flt = s7_d_vid_function(s_func);
      if (flt)
	{
	  s7_pointer sig;
	  opc->v[4].d_vid_f = flt;
	  sig = c_function_signature(s_func);
	  if (is_pair(sig))
	    {
	      int32_t start;
	      s7_pointer vslot;
	      start = sc->pc;
	      vslot = opt_types_match(sc, cadr(sig), cadr(car_x));
	      if (vslot)
		{
		  s7_pointer slot;
		  opc->v[0].fd = opt_d_vid_ssf;
		  opc->v[1].p = vslot;
		  slot = opt_integer_symbol(sc, caddr(car_x));
		  if ((slot) &&
		      (float_optimize(sc, cdddr(car_x))))
		    {
		      opt_info *o2;
		      opc->v[2].p = slot;
		      opc->v[5].obj = (void *)c_object_value(slot_value(vslot));
		      o2 = sc->opts[start];
		      if (o2->v[0].fd == opt_d_dd_ff_mul1)
			{
			  opt_info *o3;
			  o3 = sc->opts[start + 2];
			  if (o3->v[0].fd == opt_d_vd_o1)
			    {
			      opt_info *o1;
			      o1 = sc->opts[start + 4];
			      if ((o1->v[0].fd == opt_d_dd_ff_o3) &&
				  (o1->v[4].d_dd_f == multiply_d_dd) &&
				  (o3->v[4].d_dd_f == add_d_dd))
				opc->v[0].fd = opt_fmv;
			    }
			}
		      return(oo_set_type_2(opc, 6, 1 + (5 << 4), 2, OO_V, OO_I));
		    }
		}
	      pc_fallback(sc, start);
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_vdd -------- */
static s7_double opt_d_vdd_ff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1;
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o2 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 1);
  return(o->v[4].d_vdd_f(o->v[5].obj, x1, o2->v[0].fd(o2)));
}

static bool d_vdd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_vdd_t flt;
  flt = s7_d_vdd_function(s_func);
  if (flt)
    {
      s7_pointer sig;
      opc->v[4].d_vdd_f = flt;
      sig = c_function_signature(s_func);
      if (is_pair(sig))
	{
	  s7_pointer slot;
	  slot = opt_types_match(sc, cadr(sig), cadr(car_x));
	  if (slot)
	    {
	      int32_t start;
	      start = sc->pc;
	      if ((float_optimize(sc, cddr(car_x))) &&
		  (float_optimize(sc, cdddr(car_x))))
		{
		  opc->v[1].p = slot;
		  opc->v[5].obj = (void *)c_object_value(slot_value(slot));
		  opc->v[0].fd = opt_d_vdd_ff;
		  return(oo_set_type_1(opc, 6, 1 + (5 << 4), OO_V));
		}
	      pc_fallback(sc, start);
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- d_dddd -------- */
static s7_double opt_d_dddd_ffff(void *p)
{
  opt_info *o1, *o2, *o3, *o4, *o = (opt_info *)p;
  s7_double x1, x2, x3;
  s7_scheme *sc;
  sc = o->sc;
  o1 = sc->opts[++sc->pc];
  x1 = o1->v[0].fd(o1);
  o2 = sc->opts[++sc->pc];
  x2 = o2->v[0].fd(o2);
  o3 = sc->opts[++sc->pc];
  x3 = o3->v[0].fd(o3);
  o4 = sc->opts[++sc->pc];
  oo_rcheck(o->sc, o, 1, 0);
  return(o->v[1].d_dddd_f(x1, x2, x3, o4->v[0].fd(o4)));
}

static bool d_dddd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_d_dddd_t f;
  f = s7_d_dddd_function(s_func);
  if (f)
    {
      if ((float_optimize(sc, cdr(car_x))) &&
	  (float_optimize(sc, cddr(car_x))) &&
	  (float_optimize(sc, cdddr(car_x))) &&
	  (float_optimize(sc, cddddr(car_x))))
	{
	  opc->v[1].d_dddd_f = f;
	  opc->v[0].fd = opt_d_dddd_ffff;
	  return(oo_set_type_0(opc, 2));
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- d_add|multiply|subtract_any ------- */
static s7_double opt_d_add_any_f(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double sum = 0.0;
  int32_t i;
  oo_rcheck(o->sc, o, 2, 0);
  for (i = 0; i < o->v[1].i; i++)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      sum += o1->v[0].fd(o1);
    }
  return(sum);
}

static s7_double opt_d_subtract_any_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_double sum;
  int32_t i;
  s7_scheme *sc;
  sc = o->sc;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = sc->opts[++sc->pc];
  sum = o1->v[0].fd(o1);
  for (i = 1; i < o->v[1].i; i++)
    {
      o1 = sc->opts[++sc->pc];
      sum -= o1->v[0].fd(o1);
    }
  return(sum);
}

static s7_double opt_d_multiply_any_f(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_double sum = 1.0;
  int32_t i;
  oo_rcheck(o->sc, o, 2, 0);
  for (i = 0; i < o->v[1].i; i++)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      sum *= o1->v[0].fd(o1);
    }
  return(sum);
}

static bool d_add_any_ok(s7_scheme *sc, opt_info *opc, s7_pointer car_x, int32_t len)
{
  s7_pointer head;
  int32_t start;
  start = sc->pc;
  head = car(car_x);
  if ((head == sc->add_symbol) ||
      (head == sc->multiply_symbol))
    {
      s7_pointer p;
      int32_t cur_len;
      for (cur_len = 0, p = cdr(car_x); is_pair(p); p = cdr(p), cur_len++)
	if (!float_optimize(sc, p))
	  break;
      if (is_null(p))
	{
	  /* since 2|3|4-arg case is split out above, can cur_len ever be 2? */
	  opc->v[1].i = cur_len;
	  opc->v[0].fd = (head == sc->add_symbol) ? opt_d_add_any_f : opt_d_multiply_any_f;
	  return(oo_set_type_0(opc, 2));
	}
    }
  else
    {
      if (head == sc->subtract_symbol)
	{
	  s7_pointer p;
	  opc->v[1].i = (len - 1);
	  for (p = cdr(car_x); is_pair(p); p = cdr(p))
	    if (!float_optimize(sc, p))
	      break;
	  if (is_null(p))
	    {
	      opc->v[0].fd = opt_d_subtract_any_f;
	      return(oo_set_type_0(opc, 2));
	    }
	}
    }
  pc_fallback(sc, start);
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- d_syntax -------- */
static s7_double opt_set_d_d_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_double x;
  o1 = o->sc->opts[++o->sc->pc];
  x = o1->v[0].fd(o1);
  oo_rcheck(o->sc, o, 2, 1);
  slot_set_value(o->v[1].p, make_real(o->sc, x));
  return(x);
}

static s7_double opt_set_d_d_fm(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_double x;
  o1 = o->sc->opts[++o->sc->pc];
  x = o1->v[0].fd(o1);
  oo_rcheck(o->sc, o, 2, 1);
  real(slot_value(o->v[1].p)) = x;
  return(x);
}

static bool d_syntax_ok(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  if ((len == 3) &&
      (car(car_x) == sc->set_symbol))
    {
      opt_info *opc;
      opc = alloc_opo(sc, car_x);
      if (is_symbol(cadr(car_x)))
	{
	  s7_pointer settee;
	  if ((is_immutable(cadr(car_x))) ||
	      (symbol_has_setter(cadr(car_x))))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  settee = symbol_to_slot(sc, cadr(car_x));
	  if ((is_slot(settee)) &&
	      (!is_immutable(settee)))
	    {
	      opc->v[1].p = settee;
	      if ((!is_t_integer(caddr(car_x))) &&
		  (is_float(slot_value(settee))) &&
		  (float_optimize(sc, cddr(car_x))))
		{
		  if (is_mutable(slot_value(opc->v[1].p)))
		    opc->v[0].fd = opt_set_d_d_fm;
		  else opc->v[0].fd = opt_set_d_d_f;
		  return(oo_set_type_1(opc, 2, 1, OO_R));
		}
	    }
	}
      else
	{
	  /* if is_pair(settee) get setter */
	  if ((is_pair(cadr(car_x))) &&
	      (is_symbol(caadr(car_x))) &&
	      (is_pair(cdadr(car_x))))
	    {
	      if (is_null(cddadr(car_x)))
		return(opt_float_vector_set(sc, opc, caadr(car_x), cdadr(car_x), NULL, cddr(car_x)));
	      if (is_null(cdddr(cadr(car_x))))
		return(opt_float_vector_set(sc, opc, caadr(car_x), cdadr(car_x), cddadr(car_x), cddr(car_x)));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool d_implicit_ok(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  s7_pointer s_slot, slot;
  opt_info *opc;
  s_slot = symbol_to_slot(sc, car(car_x));

  if (!is_slot(s_slot))
    return(return_false(sc, car_x, __func__, __LINE__));

  if (is_float_vector(slot_value(s_slot)))
    {
      /* implicit float-vector-ref */
      if ((len == 2) &&
	  (vector_rank(slot_value(s_slot)) == 1))
	{
	  opc = alloc_opo(sc, car_x);
	  opc->v[1].p = s_slot;
	  opc->v[3].d_7pi_f = float_vector_ref_d_7pi;
	  slot = opt_integer_symbol(sc, cadr(car_x));
	  if (slot)
	    {
	      opc->v[0].fd = opt_d_7pi_ss;
	      opc->v[2].p = slot;
	      if ((is_step_end(opc->v[2].p)) &&
		  (denominator(slot_value(opc->v[2].p)) <= vector_length(slot_value(opc->v[1].p))))
		opc->v[3].d_7pi_f = float_vector_ref_unchecked;
	      return(oo_set_type_2(opc, 4, 1, 2, OO_FV, OO_I));
	    }
	  if (int_optimize(sc, cdr(car_x)))
	    {
	      opc->v[0].fd = opt_d_7pi_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_FV));
	    }
	  return(return_false(sc, car_x, __func__, __LINE__));
	}

      if ((len == 3) &&
	  (vector_rank(slot_value(s_slot)) == 2))
	{
	  opc = alloc_opo(sc, car_x);
	  opc->v[1].p = s_slot;
	  opc->v[4].d_7pii_f = float_vector_ref_d_7pii;
	  slot = opt_integer_symbol(sc, cadr(car_x));
	  if (slot)
	    {
	      opc->v[2].p = slot;
	      slot = opt_integer_symbol(sc, caddr(car_x));
	      if (slot)
		{
		  opc->v[3].p = slot;
		  opc->v[0].fd = opt_d_7pii_sss;
		  return(oo_set_type_3(opc, 5, 1, 2, 3, OO_FV, OO_I, OO_I));
		}
	    }
	  if ((int_optimize(sc, cdr(car_x))) &&
	      (int_optimize(sc, cddr(car_x))))
	    {
	      opc->v[0].fd = opt_d_7pii_sff;
	      return(oo_set_type_1(opc, 5, 1, OO_FV));
	    }
	}
    }

  if ((is_c_object(slot_value(s_slot))) &&
      (len == 2))
    {
      s7_d_7pi_t func;
      s7_pointer getf;
      getf = c_object_getf(sc, slot_value(s_slot));
      if (is_c_function(getf)) /* default is #f */
	{
	  func = s7_d_7pi_function(getf);
	  if (func)
	    {
	      opc = alloc_opo(sc, car_x);
	      opc->v[1].p = s_slot;
	      opc->v[4].obj = (void *)c_object_value(slot_value(s_slot));
	      opc->v[3].d_7pi_f = func;
	      slot = opt_integer_symbol(sc, cadr(car_x));
	      if (slot)
		{
		  opc->v[0].fd = opt_d_7pi_ss;
		  opc->v[2].p = slot;
		  return(oo_set_type_2(opc, 5, 1 + (4 << 4), 2, OO_V, OO_I));
		}
	      if (int_optimize(sc, cdr(car_x)))
		{
		  opc->v[0].fd = opt_d_7pi_sf;
		  return(oo_set_type_1(opc, 5, 1 + (4 << 4), OO_V));
		}}}}
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------------------------------- bool opts -------------------------------- */
static bool opt_b_t(void *p)
{
  return(true);
}

static bool opt_b_f(void *p)
{
  return(false);
}

static bool opt_b_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 1);
  return(slot_value(o->v[1].p) != o->sc->F);
}

static bool opt_bool_not_pair(s7_scheme *sc, s7_pointer car_x)
{
  opt_info *opc;
  s7_pointer p;
  if (!is_symbol(car_x))
    {
      if (!s7_is_boolean(car_x))
	return(return_false(sc, car_x, __func__, __LINE__)); /* i.e. use cell_optimize */
      opc = alloc_opo(sc, car_x);
      opc->v[0].fb = ((car_x == sc->F) ? opt_b_f : opt_b_t);
      return(oo_set_type_0(opc, 1));
    }
  p = opt_simple_symbol(sc, car_x);
  if ((p) &&
      (s7_is_boolean(slot_value(p))))
    {
      opc = alloc_opo(sc, car_x);
      opc->v[1].p = p;
      opc->v[0].fb = opt_b_s;
      return(oo_set_type_1(opc, 2, 1, OO_P));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- b_idp -------- */
static bool opt_b_i_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].b_i_f(integer(slot_value(o->v[1].p))));
}

static bool opt_b_i_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].b_i_f(o1->v[0].fi(o1)));
}

static bool opt_b_d_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].b_d_f(real(slot_value(o->v[1].p))));
}

static bool opt_b_d_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].b_d_f(o1->v[0].fd(o1)));
}

static bool opt_b_p_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].b_p_f(slot_value(o->v[1].p)));
}

static bool opt_b_p_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].b_p_f(o1->v[0].fp(o1)));
}

static bool opt_b_7p_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].b_7p_f(o->sc, slot_value(o->v[1].p)));
}

static bool opt_b_7p_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].b_7p_f(o->sc, o1->v[0].fp(o1)));
}

#if (!WITH_GMP)
static bool opt_zero_mod(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_int x;
  x = integer(slot_value(o->v[1].p));
  oo_rcheck(o->sc, o, 3, 1);
  return((x % o->v[2].i) == 0);
}
#endif

static bool b_idp_ok(s7_scheme *sc, s7_pointer s_func, s7_pointer car_x, s7_pointer arg_type)
{
  int32_t cur_index;
  s7_b_p_t bpf = NULL;
  s7_b_7p_t bpf7 = NULL;
  opt_info *opc;

  opc = alloc_opo(sc, car_x);
  cur_index = sc->pc;

  if (arg_type == sc->is_integer_symbol)
    {
      s7_b_i_t bif;
      bif = s7_b_i_function(s_func);
      if (bif)
	{
	  opc->v[2].b_i_f = bif;
	  if (is_symbol(cadr(car_x)))
	    {
	      opc->v[1].p = symbol_to_slot(sc, cadr(car_x));
	      opc->v[0].fb = opt_b_i_s;
	      return(oo_set_type_1(opc, 3, 1, OO_I));
	    }
	  if (int_optimize(sc, cdr(car_x)))
	    {
#if (!WITH_GMP)
	      opt_info *o1;
	      o1 = sc->opts[sc->pc - 1];
	      if ((o1->v[0].fi == opt_i_ii_sc) &&
		  (o1->v[3].i_ii_f == modulo_i_ii_direct))
		{
		  opc->v[0].fb = opt_zero_mod;
		  opc->v[1].p = o1->v[1].p;
		  opc->v[2].i = o1->v[2].i;
		  backup_pc(sc);
		  return(oo_set_type_1(opc, 3, 1, OO_I));
		}
#endif
	      opc->v[0].fb = opt_b_i_f;
	      return(oo_set_type_0(opc, 3));
	    }
	}
    }
  else
    {
      if (arg_type == sc->is_float_symbol)
	{
	  s7_b_d_t bdf;
	  bdf = s7_b_d_function(s_func);
	  if (bdf)
	    {
	      opc->v[2].b_d_f = bdf;
	      if (is_symbol(cadr(car_x)))
		{
		  opc->v[1].p = symbol_to_slot(sc, cadr(car_x));
		  opc->v[0].fb = opt_b_d_s;
		  return(oo_set_type_1(opc, 3, 1, OO_D));
		}
	      if (float_optimize(sc, cdr(car_x)))
		{
		  opc->v[0].fb = opt_b_d_f;
		  return(oo_set_type_0(opc, 3));
		}
	    }
	}
    }
  pc_fallback(sc, cur_index);

  bpf = s7_b_p_function(s_func);
  if (!bpf) bpf7 = s7_b_7p_function(s_func);
  if ((bpf) || (bpf7))
    {
      if (bpf)
	opc->v[2].b_p_f = bpf;
      else opc->v[2].b_7p_f = bpf7;
      if (is_symbol(cadr(car_x)))
	{
	  s7_pointer p;
	  p = opt_simple_symbol(sc, cadr(car_x));
	  if (!p) return(return_false(sc, car_x, __func__, __LINE__));
	  opc->v[1].p = p;
	  opc->v[0].fb = (bpf) ? opt_b_p_s : opt_b_7p_s;
	  if (s7_is_character(slot_value(p)))
	    {
	      bpf = s7_b_p_direct_function(s_func);
	      if (bpf)
		{
		  opc->v[2].b_p_f = bpf;
		  opc->v[0].fb = opt_b_p_s;
		}
	    }
	  return(oo_set_type_1(opc, 3, 1, OO_P));
	}
      if (cell_optimize(sc, cdr(car_x)))
	{
	  opc->v[0].fb = (bpf) ? opt_b_p_f : opt_b_7p_f;
	  if (arg_type == sc->is_char_symbol)
	    {
	      bpf = s7_b_p_direct_function(s_func);
	      if (bpf)
		{
		  opc->v[2].b_p_f = bpf;
		  opc->v[0].fb = opt_b_p_f;
		}
	    }
	  return(oo_set_type_0(opc, 3));
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- b_pp -------- */
static s7_pointer opt_arg_type(s7_scheme *sc, s7_pointer argp)
{
  s7_pointer arg, slot;
  arg = car(argp);
  if (is_pair(arg))
    {
      if (is_symbol(car(arg)))
	{
	  if ((is_global(car(arg))) ||
	      ((is_slot(global_slot(car(arg)))) &&
	       (symbol_to_slot(sc, car(arg)) == global_slot(car(arg)))))
	    {
	      s7_pointer a_func;
	      a_func = slot_value(global_slot(car(arg)));
	      if (is_c_function(a_func))
		{
		  s7_pointer sig;
		  sig = c_function_signature(a_func);
		  if (is_pair(sig))
		    {
		      if ((car(sig) == sc->is_integer_symbol) ||
			  ((is_pair(car(sig))) && (direct_memq(sc->is_integer_symbol, car(sig)))))
			return(sc->is_integer_symbol);
		      if ((car(sig) == sc->is_float_symbol) ||
			  ((is_pair(car(sig))) && (direct_memq(sc->is_float_symbol, car(sig)))))
			return(sc->is_float_symbol);
		      if ((car(sig) == sc->is_real_symbol) ||
			  (car(sig) == sc->is_number_symbol))
			{
			  int32_t start;
			  start = sc->pc;
			  if (int_optimize(sc, argp))
			    {
			      pc_fallback(sc, start);
			      return(sc->is_integer_symbol);
			    }
			  if (float_optimize(sc, argp))
			    {
			      pc_fallback(sc, start);
			      return(sc->is_float_symbol);
			    }
			  pc_fallback(sc, start);
			}
		      return(car(sig)); /* we want the function's return type in this context */
		    }
		}
	    }
	  slot = symbol_to_slot(sc, car(arg));
	  if ((is_slot(slot)) &&
	      (is_sequence(slot_value(slot))))
	    {
	      s7_pointer sig;
	      sig = s7_signature(sc, slot_value(slot));
	      if (is_pair(sig))
		return(car(sig));
	    }
	}
      return(sc->T);
    }
  if (is_symbol(arg))
    {
      slot = opt_simple_symbol(sc, arg);
      if (!slot) return(sc->T);
      return(s7_type_of(sc, slot_value(slot)));
    }
  return(s7_type_of(sc, arg));
}

static bool opt_b_pp_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer p1;
  o1 = o->sc->opts[++o->sc->pc];
  p1 = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].b_pp_f(p1, o1->v[0].fp(o1)));
}

static bool opt_b_pp_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_pp_f(slot_value(o->v[1].p), o1->v[0].fp(o1)));
}

static bool opt_b_pp_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_pp_f(o1->v[0].fp(o1), slot_value(o->v[1].p)));
}

static bool opt_b_pp_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].b_pp_f(slot_value(o->v[1].p), slot_value(o->v[2].p)));
}

static bool opt_b_pp_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_pp_f(slot_value(o->v[1].p), o->v[2].p));
}

static bool opt_b_pp_sfo(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[3].b_pp_f(slot_value(o->v[1].p), o->v[4].p_p_f(o->sc, slot_value(o->v[2].p))));
}

static bool opt_b_7pp_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer p1;
  o1 = o->sc->opts[++o->sc->pc];
  p1 = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].b_7pp_f(o->sc, p1, o1->v[0].fp(o1)));
}

static bool opt_b_7pp_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_7pp_f(o->sc, slot_value(o->v[1].p), o1->v[0].fp(o1)));
}

static bool opt_b_7pp_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_7pp_f(o->sc, o1->v[0].fp(o1), slot_value(o->v[1].p)));
}

static bool opt_b_7pp_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].b_7pp_f(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p)));
}

static bool opt_lt_b_7pp_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(lt_b_7pp(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p)));
}

static bool opt_b_7pp_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_7pp_f(o->sc, slot_value(o->v[1].p), o->v[2].p));
}

static bool opt_b_7pp_sfo(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[3].b_7pp_f(o->sc, slot_value(o->v[1].p), o->v[4].p_p_f(o->sc, slot_value(o->v[2].p))));
}

static s7_pointer opt_p_p_s(void *p);

static bool b_pp_sf_combinable(s7_scheme *sc, opt_info *opc, bool bpf_case)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fp == opt_p_p_s)
	{
	  opc->v[2].p = o1->v[1].p;
	  opc->v[4].p_p_f = o1->v[2].p_p_f;
	  opc->v[0].fb = (bpf_case) ? opt_b_pp_sfo : opt_b_7pp_sfo;
	  backup_pc(sc);
	  return(oo_set_type_2(opc, 5, 1, 2, OO_P, OO_P));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool opt_b_pp_ffo(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer b1;
  b1 = o->v[4].p_p_f(o->sc, slot_value(o->v[1].p));
  oo_rcheck(o->sc, o, 6, 2);
  return(o->v[3].b_pp_f(b1, o->v[5].p_p_f(o->sc, slot_value(o->v[2].p))));
}

static bool opt_b_7pp_ffo(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer b1;
  b1 = o->v[4].p_p_f(o->sc, slot_value(o->v[1].p));
  oo_rcheck(o->sc, o, 6, 2);
  return(o->v[3].b_7pp_f(o->sc, b1, o->v[5].p_p_f(o->sc, slot_value(o->v[2].p))));
}

static bool b_pp_ff_combinable(s7_scheme *sc, opt_info *opc, bool bpf_case)
{
  if ((sc->pc > 2) &&
      (opc == sc->opts[sc->pc - 3]))
    {
      opt_info *o1, *o2;
      o1 = sc->opts[sc->pc - 2];
      o2 = sc->opts[sc->pc - 1];
      if ((o1->v[0].fp == opt_p_p_s) &&
	  (o2->v[0].fp == opt_p_p_s))
	{
	  opc->v[1].p = o1->v[1].p;
	  opc->v[4].p_p_f = o1->v[2].p_p_f;
	  opc->v[2].p = o2->v[1].p;
	  opc->v[5].p_p_f = o2->v[2].p_p_f;
	  opc->v[0].fb = (bpf_case) ? opt_b_pp_ffo : opt_b_7pp_ffo;
	  sc->pc -= 2;
	  return(oo_set_type_2(opc, 6, 1, 2, OO_P, OO_P));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool b_pp_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, s7_pointer arg1, s7_pointer arg2, bool bpf_case)
{
  int32_t cur_index;
  cur_index = sc->pc;
  /* v[3] is set when we get here */

  if ((is_symbol(arg1)) &&
      (is_symbol(arg2)))
    {
      opc->v[1].p = opt_simple_symbol(sc, arg1);
      opc->v[2].p = opt_simple_symbol(sc, arg2);
      if ((opc->v[1].p) &&
	  (opc->v[2].p))
	{
	  opc->v[0].fb = (bpf_case) ? opt_b_pp_ss : ((opc->v[3].b_7pp_f == lt_b_7pp) ? opt_lt_b_7pp_ss : opt_b_7pp_ss);
	  return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_P));
	}
    }
  if (is_symbol(arg1))
    {
      opc->v[1].p = opt_simple_symbol(sc, arg1);
      if (!opc->v[1].p)
	return(return_false(sc, car_x, __func__, __LINE__));
      if ((!is_symbol(arg2)) &&
	  (!is_pair(arg2)))
	{
	  opc->v[2].p = arg2;
	  opc->v[0].fb = (bpf_case) ? opt_b_pp_sc : opt_b_7pp_sc;
	  return(oo_set_type_1(opc, 4, 1, OO_P));
	}
      if (cell_optimize(sc, cddr(car_x)))
	{
	  if (!b_pp_sf_combinable(sc, opc, bpf_case))
	    {
	      opc->v[0].fb = (bpf_case) ? opt_b_pp_sf : opt_b_7pp_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	  oo_check(sc, opc);
	  return(true);
	}
      pc_fallback(sc, cur_index);
    }
  else
    {
      if ((is_symbol(arg2)) &&
	  (is_pair(arg1)))
	{
	  if (cell_optimize(sc, cdr(car_x)))
	    {
	      opc->v[1].p = symbol_to_slot(sc, arg2);
	      if ((!is_slot(opc->v[1].p)) ||
		  (has_methods(slot_value(opc->v[1].p))))
		return(return_false(sc, car_x, __func__, __LINE__));
	      opc->v[0].fb = (bpf_case) ? opt_b_pp_fs : opt_b_7pp_fs;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	  /* return(return_false(sc, car_x, __func__, __LINE__)); */
	  pc_fallback(sc, cur_index);
	}
    }
  if ((cell_optimize(sc, cdr(car_x))) &&
      (cell_optimize(sc, cddr(car_x))))
    {
      if (b_pp_ff_combinable(sc, opc, bpf_case))
	return(true);
      opc->v[0].fb = (bpf_case) ? opt_b_pp_ff : opt_b_7pp_ff;
      if (s7_b_pp_direct_function(s_func))
	{
	  s7_pointer call_sig, arg1_type, arg2_type;
	  call_sig = c_function_signature(s_func);
	  arg1_type = opt_arg_type(sc, cdr(car_x));
	  arg2_type = opt_arg_type(sc, cddr(car_x));
	  if ((cadr(call_sig) == arg1_type) &&                   /* not car(arg1_type) here: (string>? (string) (read-line)) */
	      (caddr(call_sig) == arg2_type))
	    {
	      opc->v[0].fb = opt_b_pp_ff;
	      opc->v[3].b_pp_f = s7_b_pp_direct_function(s_func);
	      return(oo_set_type_0(opc, 4));
	    }
	}
      return(oo_set_type_0(opc, 4));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- b_pi -------- */
static bool opt_b_pi_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].b_pi_f(o->sc, o1->v[0].fp(o1), integer(slot_value(o->v[1].p))));
}

static bool b_pi_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, s7_pointer arg2)
{
  s7_b_pi_t bpif;
  bpif = s7_b_pi_function(s_func);
  if (bpif)
    {
      opc->v[1].p = symbol_to_slot(sc, arg2); /* slot checked in opt_arg_type */
      if (cell_optimize(sc, cdr(car_x)))
	{
	  opc->v[2].b_pi_f = bpif;
	  opc->v[0].fb = opt_b_pi_fs;
	  return(oo_set_type_1(opc, 3, 1, OO_P));
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- b_dd -------- */
static bool opt_b_dd_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].b_dd_f(real(slot_value(o->v[1].p)), real(slot_value(o->v[2].p))));
}

static bool opt_b_dd_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_dd_f(real(slot_value(o->v[1].p)), o->v[2].x));
}

static bool opt_b_dd_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_dd_f(real(slot_value(o->v[1].p)), o1->v[0].fd(o1)));
}

static bool opt_b_dd_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_dd_f(o1->v[0].fd(o1), real(slot_value(o->v[1].p))));
}

static bool opt_b_dd_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].b_dd_f(o1->v[0].fd(o1), o->v[1].x));
}

static bool opt_b_dd_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_double x1;
  o1 = o->sc->opts[++o->sc->pc];
  x1 = o1->v[0].fd(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].b_dd_f(x1, o1->v[0].fd(o1)));
}

static bool b_dd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, s7_pointer arg1, s7_pointer arg2)
{
  s7_b_dd_t bif;
  int32_t cur_index;
  cur_index = sc->pc;
  bif = s7_b_dd_function(s_func);
  if (bif)
    {
      opc->v[3].b_dd_f = bif;

      if (is_symbol(arg1))
	{
	  opc->v[1].p = symbol_to_slot(sc, arg1);
	  if (is_symbol(arg2))
	    {
	      opc->v[2].p = symbol_to_slot(sc, arg2);
	      opc->v[0].fb = opt_b_dd_ss;
	      return(oo_set_type_2(opc, 4, 1, 2, OO_D, OO_D));
	    }
	  if (is_real(arg2))
	    {
	      opc->v[2].x = s7_number_to_real(sc, arg2);
	      opc->v[0].fb = opt_b_dd_sc;
	      return(oo_set_type_1(opc, 4, 1, OO_D));
	    }
	  if (float_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fb = opt_b_dd_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_D));
	    }
	}
      pc_fallback(sc, cur_index);
      if (float_optimize(sc, cdr(car_x)))
	{
	  if (is_symbol(arg2))
	    {
	      opc->v[1].p = symbol_to_slot(sc, arg2);
	      opc->v[0].fb = opt_b_dd_fs;
	      return(oo_set_type_1(opc, 4, 1, OO_D));
	    }
	  if (is_real(arg2))
	    {
	      opc->v[1].x = s7_number_to_real(sc, arg2);
	      opc->v[0].fb = opt_b_dd_fc;
	      return(oo_set_type_0(opc, 4));
	    }
	  if (float_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fb = opt_b_dd_ff;
	      return(oo_set_type_0(opc, 4));
	    }
	}
    }
  pc_fallback(sc, cur_index);
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- b_ii -------- */
static bool opt_b_ii_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].b_ii_f(integer(slot_value(o->v[1].p)), integer(slot_value(o->v[2].p))));
}

static bool opt_b_ii_ss_lt(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(integer(slot_value(o->v[1].p)) < integer(slot_value(o->v[2].p)));
}

static bool opt_b_ii_ss_gt(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(integer(slot_value(o->v[1].p)) > integer(slot_value(o->v[2].p)));
}

static bool opt_b_ii_ss_leq(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(integer(slot_value(o->v[1].p)) <= integer(slot_value(o->v[2].p)));
}

static bool opt_b_ii_ss_geq(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(integer(slot_value(o->v[1].p)) >= integer(slot_value(o->v[2].p)));
}

static bool opt_b_ii_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_ii_f(integer(slot_value(o->v[1].p)), o->v[2].i));
}

static bool opt_b_ii_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].b_ii_f(i1, o1->v[0].fi(o1)));
}

static bool opt_b_ii_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_ii_f(o1->v[0].fi(o1), integer(slot_value(o->v[2].p))));
}

static bool opt_b_ii_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].b_ii_f(o1->v[0].fi(o1), o->v[2].i));
}

static bool opt_b_ii_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].b_ii_f(integer(slot_value(o->v[1].p)), o1->v[0].fi(o1)));
}

static bool b_ii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, s7_pointer arg1, s7_pointer arg2)
{
  s7_b_ii_t bif;
  bif = s7_b_ii_function(s_func);
  if (bif)
    {
      opc->v[3].b_ii_f = bif;
      if (is_symbol(arg1))
	{
	  opc->v[1].p = symbol_to_slot(sc, arg1);
	  if (is_symbol(arg2))
	    {
	      opc->v[2].p = symbol_to_slot(sc, arg2);
	      opc->v[0].fb = opt_b_ii_ss;
	      if (bif == lt_b_ii)
		opc->v[0].fb = opt_b_ii_ss_lt;
	      else
		{
		  if (bif == gt_b_ii)
		    opc->v[0].fb = opt_b_ii_ss_gt;
		  else
		    {
		      if (bif == geq_b_ii)
			opc->v[0].fb = opt_b_ii_ss_geq;
		      else
			{
			  if (bif == leq_b_ii)
			    opc->v[0].fb = opt_b_ii_ss_leq;
			}
		    }
		}
	      return(oo_set_type_2(opc, 4, 1, 2, OO_I, OO_I));
	    }
	  if (is_opt_int(arg2))
	    {
	      opc->v[2].i = integer(arg2);
	      opc->v[0].fb = opt_b_ii_sc;
	      return(oo_set_type_1(opc, 4, 1, OO_I));
	    }
	  if (int_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fb = opt_b_ii_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_I));
	    }
	  return(return_false(sc, car_x, __func__, __LINE__));
	}
      if (is_symbol(arg2))
	{
	  if (int_optimize(sc, cdr(car_x)))
	    {
	      opc->v[2].p = symbol_to_slot(sc, arg2);
	      opc->v[0].fb = opt_b_ii_fs;
	      return(oo_set_type_1(opc, 4, 2, OO_I));
	    }
	  return(return_false(sc, car_x, __func__, __LINE__));
	}
      if ((is_opt_int(arg2)) &&
	  (int_optimize(sc, cdr(car_x))))
	{
	  opc->v[2].i = integer(arg2);
	  opc->v[0].fb = opt_b_ii_fc;
	  return(oo_set_type_0(opc, 4));
	}
     if ((int_optimize(sc, cdr(car_x))) &&
	 (int_optimize(sc, cddr(car_x))))
       {
	 opc->v[0].fb = opt_b_ii_ff;
	 return(oo_set_type_0(opc, 4));
       }
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- b_or|and -------- */
static bool opt_and_bb(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_scheme *sc;
  sc = o->sc;
  oo_rcheck(sc, o, 2, 0);
  o1 = sc->opts[++sc->pc];
  if (o1->v[0].fb(o1))
    {
      o1 = sc->opts[++sc->pc];
      return(o1->v[0].fb(o1));
    }
  sc->pc = o->v[1].i;
  return(false);
}

static bool opt_and_bb1(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 8, 0);
  if (o->v[7].fb(o))
    {
      opt_info *o1;
      o->sc->pc += 2;
      o1 = o->sc->opts[o->sc->pc];
      return(o1->v[0].fb(o1));
    }
  o->sc->pc = o->v[4].i;
  return(false);
}

static bool opt_and_any_b(void *p)
{
  opt_info *o = (opt_info *)p;
  int32_t i;
  oo_rcheck(o->sc, o, 3, 0);
  for (i = 0; i < o->v[1].i; i++)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      if (!o1->v[0].fb(o1))
	{
	  o->sc->pc = o->v[2].i;
	  return(false);
	}
    }
  return(true);
}

static bool opt_or_bb(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fb(o1))
    {
      o->sc->pc = o->v[1].i;
      return(true);
    }
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fb(o1));
}

static bool opt_or_bb1(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 8, 0);
  if (o->v[7].fb(o))
    {
      o->sc->pc = o->v[4].i;
      return(true);
    }
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  return(o1->v[0].fb(o1));
}

static bool opt_or_any_b(void *p)
{
  opt_info *o = (opt_info *)p;
  int32_t i;
  oo_rcheck(o->sc, o, 3, 0);
  for (i = 0; i < o->v[1].i; i++)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      if (o1->v[0].fb(o1))
	{
	  o->sc->pc = o->v[2].i;
	  return(true);
	}
    }
  return(false);
}

static bool opt_b_or_and(s7_scheme *sc, s7_pointer car_x, int32_t len, int32_t is_and)
{
  opt_info *opc;
  s7_pointer p;

  opc = alloc_opo(sc, car_x);
  if (len == 3)
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc];
      if ((bool_optimize_nw(sc, cdr(car_x))) &&
	  (bool_optimize_nw(sc, cddr(car_x))))
	{
	  if ((o1->v[0].fb == opt_b_dd_ss) ||
	      (o1->v[0].fb == opt_b_ii_ss) ||
	      (o1->v[0].fb == opt_b_ii_ss_lt) || (o1->v[0].fb == opt_b_ii_ss_gt) || (o1->v[0].fb == opt_b_ii_ss_leq) || (o1->v[0].fb == opt_b_ii_ss_geq) ||
	      (o1->v[0].fb == opt_b_pp_ss) ||
	      (o1->v[0].fb == opt_b_7pp_ss) ||
	      (o1->v[0].fb == opt_lt_b_7pp_ss))
	    {
	      opc->v[4].i = sc->pc - 1;
	      opc->v[7].fb = o1->v[0].fb;
	      opc->v[0].fb = (is_and) ? opt_and_bb1 : opt_or_bb1;
	      opc->v[1].p = o1->v[1].p;
	      opc->v[2].p = o1->v[2].p;
#if OPT_INFO_DEBUGGING
	      if (o1->v[0].fb == opt_b_dd_ss) opc->v[3].b_dd_f = o1->v[3].b_dd_f; else
	      if (o1->v[0].fb == opt_b_pp_ss) opc->v[3].b_pp_f = o1->v[3].b_pp_f; else
	      if ((o1->v[0].fb == opt_b_7pp_ss) || (o1->v[0].fb == opt_lt_b_7pp_ss)) opc->v[3].b_7pp_f = o1->v[3].b_7pp_f; else
		opc->v[3].b_ii_f = o1->v[3].b_ii_f;
#else
	      opc->v[3].p = o1->v[3].p; /* this works only in the union vunion case (it's actually supposed to be b_dd_f etc) */
#endif
	      return(oo_set_type_2(opc, 8, 1, 2, OO_P, OO_P));
	    }
	  opc->v[0].fb = (is_and) ? opt_and_bb : opt_or_bb;
	  opc->v[1].i = sc->pc - 1;
	  return(oo_set_type_0(opc, 2));
	}
      return(return_false(sc, car_x, __func__, __LINE__));
    }
  opc->v[1].i = (len - 1);
  for (p = cdr(car_x); is_pair(p); p = cdr(p))
    if (!bool_optimize_nw(sc, p))
      break;
  if (is_null(p))
    {
      opc->v[0].fb = (is_and) ? opt_and_any_b : opt_or_any_b;
      opc->v[2].i = sc->pc - 1;
      return(oo_set_type_0(opc, 3));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool opt_b_and(s7_scheme *sc, s7_pointer car_x, int32_t len) {return(opt_b_or_and(sc, car_x, len, true));}
static bool opt_b_or(s7_scheme *sc, s7_pointer car_x, int32_t len)  {return(opt_b_or_and(sc, car_x, len, false));}


/* ---------------------------------------- cell opts ---------------------------------------- */

static s7_pointer opt_p_c(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 0); return(o->v[1].p);}
static s7_pointer opt_p_s(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 0); return(slot_value(o->v[1].p));}

static bool opt_cell_not_pair(s7_scheme *sc, s7_pointer car_x)
{
  s7_pointer p;
  opt_info *opc;
  if (!is_symbol(car_x))
    {
      opc = alloc_opo(sc, car_x);
      opc->v[1].p = car_x;
      opc->v[0].fp = opt_p_c;
      return(oo_set_type_0(opc, 2));
    }
  p = opt_simple_symbol(sc, car_x);
  if (p)
    {
      opc = alloc_opo(sc, car_x);
      opc->v[1].p = p;
      opc->v[0].fp = opt_p_s;
      return(oo_set_type_1(opc, 2, 1, OO_P));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p -------- */
#define is_opt_safe(P) ((optimize_op(P) >= OP_SAFE_C_S) && (!is_unknown_op(optimize_op(P))))

#define cf_call(Sc, Car_x, S_func, Num) \
   (((is_optimized(Car_x)) && (is_opt_safe(Car_x))) ? c_callee(Car_x) : c_function_call(c_function_chooser(S_func)(Sc, S_func, Num, Car_x, false)))

static s7_pointer opt_p_f(void *p)  {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 0); return(o->v[1].p_f(o->sc));}
static s7_pointer opt_p_cf(void *p) {opt_info *o = (opt_info *)p; oo_rcheck(o->sc, o, 2, 0); return(o->v[1].cf(o->sc, o->sc->nil));}

static bool p_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_p_t func;
  func = s7_p_function(s_func);
  if (func)
    {
      opc->v[1].p_f = func;
      opc->v[0].fp = opt_p_f;
      return(oo_set_type_0(opc, 2));
    }
  if ((is_safe_procedure(s_func)) &&
      (c_function_required_args(s_func) == 0))
    {
      opc->v[1].cf = cf_call(sc, car_x, s_func, 0);
      opc->v[0].fp = opt_p_cf;
      return(oo_set_type_0(opc, 2));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_p -------- */
static s7_pointer opt_p_p_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].p_p_f(o->sc, o->v[1].p));
}

static s7_pointer opt_p_i_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(make_integer(o->sc, o->v[2].i_i_f(o->v[1].i)));
}

static s7_pointer opt_p_7i_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(make_integer(o->sc, o->v[2].i_7i_f(o->sc, o->v[1].i)));
}

static s7_pointer opt_p_d_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(make_real(o->sc, o->v[2].d_d_f(o->v[1].x)));
}

static s7_pointer opt_p_7d_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(make_real(o->sc, o->v[2].d_7d_f(o->sc, o->v[1].x)));
}

static s7_pointer opt_p_p_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].p_p_f(o->sc, slot_value(o->v[1].p)));
}

static s7_pointer opt_p_p_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[2].p_p_f(o->sc, o1->v[0].fp(o1)));
}

static s7_pointer opt_p_p_f1(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[2].p_p_f(o->sc, o->v[3].p_p_f(o->sc, slot_value(o->v[1].p))));
}

static bool p_p_f_combinable(s7_scheme *sc, opt_info *opc)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fp == opt_p_p_s)
	{
	  opc->v[3].p_p_f = o1->v[2].p_p_f;
	  opc->v[1].p = o1->v[1].p;
	  opc->v[0].fp = opt_p_p_f1;
	  backup_pc(sc);
	  return(oo_set_type_1(opc, 4, 1, OO_P));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static s7_pointer opt_p_cf_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[2].cf(o->sc, set_plist_1(o->sc, o1->v[0].fp(o1))));
}

static s7_pointer opt_p_cf_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].cf(o->sc, set_plist_1(o->sc, slot_value(o->v[1].p))));
}

static s7_pointer opt_p_cf_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[2].cf(o->sc, set_plist_1(o->sc, o->v[1].p)));
}

static bool p_p_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_p_p_t ppf;
  int32_t start;
  start = sc->pc;
  if (is_t_integer(cadr(car_x)))
    {
      s7_i_i_t iif;
      s7_i_7i_t i7if;
      opc->v[1].i = integer(cadr(car_x));
      iif = s7_i_i_function(s_func);
      if (iif)
	{
	  opc->v[2].i_i_f = iif;
	  opc->v[0].fp = opt_p_i_c;
	  return(oo_set_type_0(opc, 3));
	}
      i7if = s7_i_7i_function(s_func);
      if (i7if)
	{
	  opc->v[2].i_7i_f = i7if;
	  opc->v[0].fp = opt_p_7i_c;
	  return(oo_set_type_0(opc, 3));
	}
    }
  if (is_float(cadr(car_x)))
    {
      s7_d_d_t ddf;
      s7_d_7d_t d7df;
      opc->v[1].x = real(cadr(car_x));
      ddf = s7_d_d_function(s_func);
      if (ddf)
	{
	  opc->v[2].d_d_f = ddf;
	  opc->v[0].fp = opt_p_d_c;
	  return(oo_set_type_0(opc, 3));
	}
      d7df = s7_d_7d_function(s_func);
      if (d7df)
	{
	  opc->v[2].d_7d_f = d7df;
	  opc->v[0].fp = opt_p_7d_c;
	  return(oo_set_type_0(opc, 3));
	}
    }
  ppf = s7_p_p_function(s_func);
  if (ppf)
    {
      opc->v[2].p_p_f = ppf;
      if ((ppf == symbol_to_string_p) &&
	  (is_optimized(car_x)) &&
	  (c_callee(car_x) == g_symbol_to_string_uncopied))
	opc->v[2].p_p_f = symbol_to_string_uncopied_p;

      if (is_symbol(cadr(car_x)))
	{
	  opc->v[1].p = opt_simple_symbol(sc, cadr(car_x));
	  if (!opc->v[1].p)
	    return(return_false(sc, car_x, __func__, __LINE__));
	  opc->v[0].fp = opt_p_p_s;
	  return(oo_set_type_1(opc, 3, 1, OO_P));
	}
      if (!is_pair(cadr(car_x)))
	{
	  opc->v[1].p = cadr(car_x);
	  opc->v[0].fp = opt_p_p_c;
	  return(oo_set_type_0(opc, 3));
	}
      if (cell_optimize(sc, cdr(car_x)))
	{
	  if (!p_p_f_combinable(sc, opc))
	    {
	      opc->v[0].fp = opt_p_p_f;
	      return(oo_set_type_0(opc, 3));
	    }
	  oo_check(sc, opc);
	  return(true);
	}
    }
  pc_fallback(sc, start);
  if ((is_safe_procedure(s_func)) &&
      (c_function_required_args(s_func) <= 1) &&
      (c_function_all_args(s_func) >= 1))
    {
      s7_pointer slot;
      opc->v[2].cf = cf_call(sc, car_x, s_func, 1);
      if (is_symbol(cadr(car_x)))
	{
	  slot = opt_simple_symbol(sc, cadr(car_x));
	  if (slot)
	    {
	      opc->v[1].p = slot;
	      opc->v[0].fp = opt_p_cf_s;
	      return(oo_set_type_1(opc, 3, 1, OO_P));
	    }
	}
      else
	{
	  if (!is_pair(cadr(car_x)))
	    {
	      opc->v[1].p = cadr(car_x);
	      opc->v[0].fp = opt_p_cf_c;
	      return(oo_set_type_0(opc, 3));
	    }
	  if (cell_optimize(sc, cdr(car_x)))
	    {
	      opc->v[0].fp = opt_p_cf_f;
	      return(oo_set_type_0(opc, 3));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_i -------- */
static s7_pointer opt_p_i_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].p_i_f(o->sc, integer(slot_value(o->v[1].p))));
}

static s7_pointer opt_p_i_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[2].p_i_f(o->sc, o1->v[0].fi(o1)));
}

static bool p_i_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, int32_t pstart)
{
  s7_p_i_t ifunc;
  ifunc = s7_p_i_function(s_func);
  if (ifunc)
    {
      s7_pointer p;
      p = opt_integer_symbol(sc, cadr(car_x));
      if (p)
	{
	  opc->v[1].p = p;
	  opc->v[2].p_i_f = ifunc;
	  opc->v[0].fp = opt_p_i_s;
	  return(oo_set_type_1(opc, 3, 1, OO_I));
	}
      if (int_optimize(sc, cdr(car_x)))
	{
	  opc->v[2].p_i_f = ifunc;
	  opc->v[0].fp = opt_p_i_f;
	  return(oo_set_type_0(opc, 3));
	}
    }
  pc_fallback(sc, pstart);
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_ii -------- */
static s7_pointer opt_p_ii_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].p_ii_f(o->sc, integer(slot_value(o->v[1].p)), integer(slot_value(o->v[2].p))));
}

static s7_pointer opt_p_ii_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_ii_f(o->sc, o1->v[0].fi(o1), integer(slot_value(o->v[2].p))));
}

static s7_pointer opt_p_ii_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_ii_f(o->sc, i1, o1->v[0].fi(o1)));
}

static bool p_ii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, int32_t pstart)
{
  s7_p_ii_t ifunc;
  ifunc = s7_p_ii_function(s_func);
  if (ifunc)
    {
      s7_pointer p2;
      p2 = opt_integer_symbol(sc, caddr(car_x));
      if (p2)
	{
	  s7_pointer p1;
	  p1 = opt_integer_symbol(sc, cadr(car_x));
	  if (p1)
	    {
	      opc->v[1].p = p1;
	      opc->v[2].p = p2;
	      opc->v[3].p_ii_f = ifunc;
	      opc->v[0].fp = opt_p_ii_ss;
	      return(oo_set_type_2(opc, 4, 1, 2, OO_I, OO_I));
	    }
	  if (int_optimize(sc, cdr(car_x)))
	    {
	      opc->v[2].p = p2;
	      opc->v[3].p_ii_f = ifunc;
	      opc->v[0].fp = opt_p_ii_fs;
	      return(oo_set_type_1(opc, 4, 2, OO_I));
	    }
	  pc_fallback(sc, pstart);
	  return(return_false(sc, car_x, __func__, __LINE__));
	}
      if ((int_optimize(sc, cdr(car_x))) &&
	  (int_optimize(sc, cddr(car_x))))
	{
	  opc->v[3].p_ii_f = ifunc;
	  opc->v[0].fp = opt_p_ii_ff;
	  return(oo_set_type_0(opc, 4));
	}
    }
  pc_fallback(sc, pstart);
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_d -------- */
static s7_pointer opt_p_d_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  return(o->v[2].p_d_f(o->sc, real_to_double(o->sc, slot_value(o->v[1].p), "p_d")));
}

static s7_pointer opt_p_d_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[2].p_d_f(o->sc, o1->v[0].fd(o1)));
}

static bool p_d_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, int32_t pstart)
{
  s7_p_d_t ifunc;
  ifunc = s7_p_d_function(s_func);
  if (ifunc)
    {
      s7_pointer p;
      p = opt_float_symbol(sc, cadr(car_x));
      if (p)
	{
	  opc->v[1].p = p;
	  opc->v[2].p_d_f = ifunc;
	  opc->v[0].fp = opt_p_d_s;
	  return(oo_set_type_1(opc, 3, 1, OO_R));
	}
      if ((is_number(cadr(car_x))) && (!is_float(cadr(car_x))))
	return(return_false(sc, car_x, __func__, __LINE__));
      if (float_optimize(sc, cdr(car_x)))
	{
	  opc->v[2].p_d_f = ifunc;
	  opc->v[0].fp = opt_p_d_f;
	  return(oo_set_type_0(opc, 3));
	}
    }
  pc_fallback(sc, pstart);
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_dd -------- */
static s7_pointer opt_p_dd_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].p_dd_f(o->sc, real_to_double(o->sc, slot_value(o->v[1].p), "p_dd"), o->v[2].x));
}

static s7_pointer opt_p_dd_cs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].p_dd_f(o->sc, o->v[2].x, real_to_double(o->sc, slot_value(o->v[1].p), "p_dd")));
}

static bool p_dd_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, int32_t pstart)
{
  s7_p_dd_t ifunc;
  ifunc = s7_p_dd_function(s_func);
  if (ifunc)
    {
      s7_pointer arg1, arg2, slot;
      arg1 = cadr(car_x);
      arg2 = caddr(car_x);
      if (is_float(arg2))
	{
	  slot = opt_real_symbol(sc, arg1);
	  if (slot)
	    {
	      opc->v[2].x = real(arg2);
	      opc->v[1].p = slot;
	      opc->v[3].p_dd_f = ifunc;
	      opc->v[0].fp = opt_p_dd_sc;
	      return(oo_set_type_1(opc, 4, 1, OO_R));
	    }
	}
      if (is_float(arg1))
	{
	  slot = opt_real_symbol(sc, arg2);
	  if (slot)
	    {
	      opc->v[2].x = real(arg1);
	      opc->v[1].p = slot;
	      opc->v[3].p_dd_f = ifunc;
	      opc->v[0].fp = opt_p_dd_cs;
	      return(oo_set_type_1(opc, 4, 1, OO_R));
	    }
	}
    }
  pc_fallback(sc, pstart);
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_pi -------- */
static s7_pointer opt_p_pi_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].p_pi_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p))));
}

static s7_pointer opt_p_pi_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].p_pi_f(o->sc, slot_value(o->v[1].p), o->v[2].i));
}

static s7_pointer opt_p_pi_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_pi_f(o->sc, slot_value(o->v[1].p), o1->v[0].fi(o1)));
}

static s7_pointer opt_p_pi_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_pi_f(o->sc, o1->v[0].fp(o1), o->v[2].i));
}

static bool p_pi_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer sig, s7_pointer car_x)
{
  s7_p_pi_t func;
  func = s7_p_pi_function(s_func);
  if (func)
    {
      s7_pointer obj = NULL, slot1, checker = NULL;

      /* here we know cadr is a symbol */
      slot1 = opt_simple_symbol(sc, cadr(car_x));
      if (!slot1)
	return(return_false(sc, car_x, __func__, __LINE__));
      if ((is_any_vector(slot_value(slot1))) &&
	  (vector_rank(slot_value(slot1)) > 1))
	return(return_false(sc, car_x, __func__, __LINE__));

      opc->v[3].p_pi_f = func;
      opc->v[1].p = slot1;

      if (is_symbol(cadr(sig)))
	checker = cadr(sig);

      if ((s7_p_pi_direct_function(s_func)) &&
	  (checker))
	{
	  obj = slot_value(opc->v[1].p);
	  if ((is_string(obj)) ||
	      (is_pair(obj)) ||
	      (is_any_vector(obj)))
	    {
	      if (((is_string(obj)) && (checker == sc->is_string_symbol)) ||
		  ((is_any_vector(obj)) && (checker == sc->is_vector_symbol)) ||
		  ((is_pair(obj)) && (checker == sc->is_pair_symbol)) ||
		  ((is_byte_vector(obj)) && (checker == sc->is_byte_vector_symbol)))
		opc->v[3].p_pi_f = s7_p_pi_direct_function(s_func);
	    }
	}
      slot1 = opt_integer_symbol(sc, caddr(car_x));
      if (slot1)
	{
	  opc->v[0].fp = opt_p_pi_ss;
	  opc->v[2].p = slot1;
	  if ((obj) &&
	      (is_step_end(slot1)))
	    switch (type(obj))
	      {
	      case T_VECTOR:
		if (denominator(slot_value(slot1)) <= vector_length(obj))
		  opc->v[3].p_pi_f = vector_ref_unchecked;
		return(oo_set_type_2(opc, 4, 1, 2, OO_PV, OO_I));

	      case T_INT_VECTOR:
		if (denominator(slot_value(slot1)) <= vector_length(obj))
		  opc->v[3].p_pi_f = int_vector_ref_unchecked_p;
		return(oo_set_type_2(opc, 4, 1, 2, OO_IV, OO_I));

	      case T_FLOAT_VECTOR:
		if (denominator(slot_value(slot1)) <= vector_length(obj))
		  opc->v[3].p_pi_f = float_vector_ref_unchecked_p;
		return(oo_set_type_2(opc, 4, 1, 2, OO_FV, OO_I));

	      case T_STRING:
		if (denominator(slot_value(slot1)) <= string_length(obj))
		  opc->v[3].p_pi_f = string_ref_unchecked;
		return(oo_set_type_2(opc, 4, 1, 2, OO_S, OO_I));

	      case T_BYTE_VECTOR:
		if (denominator(slot_value(slot1)) <= string_length(obj))
		  opc->v[3].p_pi_f = byte_vector_ref_unchecked_p;
		return(oo_set_type_2(opc, 4, 1, 2, OO_BV, OO_I));
	      }
	  return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_I));
	}
      if (is_t_integer(caddr(car_x)))
	{
	  opc->v[2].i = integer(caddr(car_x));
	  opc->v[0].fp = opt_p_pi_sc;
	  return(oo_set_type_1(opc, 4, 1, OO_P));
	}
      if (int_optimize(sc, cddr(car_x)))
	{
	  opc->v[0].fp = opt_p_pi_sf;
	  return(oo_set_type_1(opc, 4, 1, OO_P));
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static s7_pointer opt_p_pi_fco(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 1);
  return(o->v[3].p_pi_f(o->sc, o->v[4].p_p_f(o->sc, slot_value(o->v[1].p)), o->v[2].i));
}

static bool p_pi_fc_combinable(s7_scheme *sc, opt_info *opc)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fp == opt_p_p_s)
	{
	  opc->v[4].p_p_f = o1->v[2].p_p_f;
	  opc->v[1].p = o1->v[1].p;
	  opc->v[0].fp = opt_p_pi_fco;
	  backup_pc(sc);
	  return(oo_set_type_1(opc, 5, 1, OO_P));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

/* -------- p_pp -------- */
static s7_pointer opt_p_pp_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].p_pp_f(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p)));
}

static s7_pointer opt_p_pp_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].p_pp_f(o->sc, slot_value(o->v[1].p), o->v[2].p));
}

static s7_pointer opt_p_pp_cs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].p_pp_f(o->sc, o->v[2].p, slot_value(o->v[1].p)));
}

static s7_pointer opt_p_pp_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].p_pp_f(o->sc, slot_value(o->v[1].p), o1->v[0].fp(o1)));
}

static s7_pointer opt_p_pp_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_pp_f(o->sc, o1->v[0].fp(o1), slot_value(o->v[1].p)));
}

static s7_pointer opt_p_pp_fc(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_pp_f(o->sc, o1->v[0].fp(o1), o->v[2].p));
}

static s7_pointer opt_p_pp_cc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  return(o->v[3].p_pp_f(o->sc, o->v[1].p, o->v[2].p));
}

static s7_pointer opt_p_pp_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer p1;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  p1 = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_pp_f(o->sc, p1, o1->v[0].fp(o1)));
}

static bool p_pp_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, int32_t pstart)
{
  s7_p_pp_t func;

  func = s7_p_pp_function(s_func);
  if (func)
    {
      s7_pointer slot, sig, checker = NULL;

      sig = c_function_signature(s_func);
      if ((is_pair(sig)) &&
	  (is_pair(cdr(sig))) &&
	  (is_symbol(cadr(sig))))
	checker = cadr(sig);

      opc->v[3].p_pp_f = func;
      if (is_symbol(cadr(car_x)))
	{
	  slot = opt_simple_symbol(sc, cadr(car_x));
	  if (!slot)
	    {
	      pc_fallback(sc, pstart);
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }
	  if ((is_any_vector(slot_value(slot))) &&
	      (vector_rank(slot_value(slot)) > 1))
	    {
	      pc_fallback(sc, pstart);
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }
	  opc->v[1].p = slot;

	  if ((s7_p_pp_direct_function(s_func)) &&
	      (checker))
	    {
	      checker = s7_symbol_value(sc, checker);
	      if (s7_apply_function(sc, checker, set_plist_1(sc, slot_value(slot))) == sc->T)
		opc->v[3].p_pp_f = s7_p_pp_direct_function(s_func);
	    }
	  if (is_symbol(caddr(car_x)))
	    {
	      opc->v[2].p = opt_simple_symbol(sc, caddr(car_x));
	      if (opc->v[2].p)
		{
		  opc->v[0].fp = opt_p_pp_ss;
		  return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_P));
		}
	      pc_fallback(sc, pstart);
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }
	  if ((!is_pair(caddr(car_x))) ||
	      (is_proper_quote(sc, caddr(car_x))))
	    {
	      opc->v[2].p = (!is_pair(caddr(car_x))) ? caddr(car_x) : cadr(caddr(car_x));
	      opc->v[0].fp = opt_p_pp_sc;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	  if (cell_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fp = opt_p_pp_sf;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	}
      else
	{
	  if ((!is_pair(cadr(car_x))) ||
	      (is_proper_quote(sc, cadr(car_x))))
	    {
	      opc->v[1].p = (!is_pair(cadr(car_x))) ? cadr(car_x) : cadadr(car_x);
	      if ((!is_symbol(caddr(car_x))) &&
		  ((!is_pair(caddr(car_x))) ||
		   (is_proper_quote(sc, caddr(car_x)))))
		{
		  opc->v[2].p = (!is_pair(caddr(car_x))) ? caddr(car_x) : cadr(caddr(car_x));
		  opc->v[0].fp = opt_p_pp_cc;
		  return(oo_set_type_0(opc, 4));
		}
	      if (is_symbol(caddr(car_x)))
		{
		  opc->v[2].p = opc->v[1].p;
		  opc->v[1].p = opt_simple_symbol(sc, caddr(car_x));
		  if (opc->v[1].p)
		    {
		      opc->v[0].fp = opt_p_pp_cs;
		      return(oo_set_type_1(opc, 4, 1, OO_P));
		    }
		  pc_fallback(sc, pstart);
		  return(return_false(sc, car_x, __func__, __LINE__));
		}
	    }
	  if (cell_optimize(sc, cdr(car_x)))
	    {
	      if (is_symbol(caddr(car_x)))
		{
		  opc->v[1].p = opt_simple_symbol(sc, caddr(car_x));
		  if (opc->v[1].p)
		    {
		      opc->v[0].fp = opt_p_pp_fs;
		      return(oo_set_type_1(opc, 4, 1, OO_P));
		    }
		  pc_fallback(sc, pstart);
		  return(return_false(sc, car_x, __func__, __LINE__));
		}
	      if ((!is_pair(caddr(car_x))) ||
		  (is_proper_quote(sc, caddr(car_x))))
		{
		  if (is_t_integer(caddr(car_x)))
		    {
		      s7_p_pi_t ifunc;
		      ifunc = s7_p_pi_function(s_func);
		      if (ifunc)
			{
			  opc->v[2].i = integer(caddr(car_x));
			  opc->v[3].p_pi_f = ifunc;
			  if (!p_pi_fc_combinable(sc, opc))
			    {
			      opc->v[0].fp = opt_p_pi_fc;
			      return(oo_set_type_0(opc, 4));
			    }
			  oo_check(sc, opc);
			  return(true);
			}
		    }
		  opc->v[2].p = (!is_pair(caddr(car_x))) ? caddr(car_x) : cadr(caddr(car_x));
		  opc->v[0].fp = opt_p_pp_fc;
		  return(oo_set_type_0(opc, 4));
		}
	      if (cell_optimize(sc, cddr(car_x)))
		{
		  opc->v[0].fp = opt_p_pp_ff;
		  return(oo_set_type_0(opc, 4));
		}
	    }
	}
    }
  pc_fallback(sc, pstart);
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_cf_pp -------- */
static s7_pointer opt_p_cf_ff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t tx;
  s7_pointer po2;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  tx = next_tx(o->sc);
  o->sc->t_temps[tx] = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  po2 = o1->v[0].fp(o1);
  return(o->v[3].cf(o->sc, set_plist_2(o->sc, o->sc->t_temps[tx], po2)));
}

static s7_pointer opt_p_cf_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer po1;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  po1 = o1->v[0].fp(o1);
  return(o->v[3].cf(o->sc, set_plist_2(o->sc, po1, slot_value(o->v[1].p))));
}

static s7_pointer opt_p_cf_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer po1;
  o1 = o->sc->opts[++o->sc->pc];
  po1 = o1->v[0].fp(o1);
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].cf(o->sc, set_plist_2(o->sc, slot_value(o->v[1].p), po1)));
}

static s7_pointer opt_p_cf_sc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  return(o->v[3].cf(o->sc, set_plist_2(o->sc, slot_value(o->v[1].p), o->v[2].p)));
}

static s7_pointer opt_p_cf_ss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].cf(o->sc, set_plist_2(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p))));
}

static bool p_cf_pp_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, int32_t pstart)
{
  if ((is_safe_procedure(s_func)) &&
      (c_function_required_args(s_func) <= 2) &&
      (c_function_all_args(s_func) >= 2))
    {
      /* if optimized, we want to use the current c_call (to take advantage of fixups like substring_temp),
       *   but those same fixups are incorrect for this context if op_safe_c_c related.
       */
      opc->v[3].cf = cf_call(sc, car_x, s_func, 2);
      if (is_symbol(cadr(car_x)))
	{
	  opc->v[1].p = symbol_to_slot(sc, cadr(car_x));
	  if ((is_slot(opc->v[1].p)) &&
	      (!has_methods(slot_value(opc->v[1].p))))
	    {
	      if (is_symbol(caddr(car_x)))
		{
		  opc->v[2].p = opt_simple_symbol(sc, caddr(car_x));
		  if (opc->v[2].p)
		    {
		      opc->v[0].fp = opt_p_cf_ss;
		      return(oo_set_type_2(opc, 4, 1, 2, OO_P, OO_P));
		    }
		  pc_fallback(sc, pstart);
		  return(return_false(sc, car_x, __func__, __LINE__));
		}
	      if (!is_pair(caddr(car_x)))
		{
		  opc->v[2].p = caddr(car_x);
		  opc->v[0].fp = opt_p_cf_sc;
		  return(oo_set_type_1(opc, 4, 1, OO_P));
		}
	      if (cell_optimize(sc, cddr(car_x)))
		{
		  opc->v[0].fp = opt_p_cf_sf;
		  return(oo_set_type_1(opc, 4, 1, OO_P));
		}
	    }
	  else
	    {
	      pc_fallback(sc, pstart);
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }
	}
      if (cell_optimize(sc, cdr(car_x)))
	{
	  if (is_symbol(caddr(car_x)))
	    {
	      opc->v[1].p = opt_simple_symbol(sc, caddr(car_x));
	      if (opc->v[1].p)
		{
		  opc->v[0].fp = opt_p_cf_fs;
		  return(oo_set_type_1(opc, 4, 1, OO_P));
		}
	      pc_fallback(sc, pstart);
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }
	  if (cell_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fp = opt_p_cf_ff;
	      return(oo_set_type_0(opc, 4));
	    }
	}
    }
  pc_fallback(sc, pstart);
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- p_pip --------*/

static s7_pointer opt_p_pip_ssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_pip_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o1->v[0].fp(o1)));
}

static s7_pointer opt_p_pip_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].p_pip_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), slot_value(o->v[3].p)));
}

static s7_pointer opt_p_pip_ssc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[3].p_pip_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o->v[4].p));
}

static s7_pointer opt_p_pip_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 2);
  return(o->v[3].p_pip_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o->v[5].p_p_f(o->sc, o->v[4].p)));
}

static s7_pointer opt_p_pip_sff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_int i1;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o2 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_pip_f(o->sc, slot_value(o->v[1].p), i1, o2->v[0].fp(o2)));
}

static s7_pointer opt_p_pip_sso(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 7, 4);
  return(o->v[5].p_pip_f(o->sc, slot_value(o->v[1].p),
			integer(slot_value(o->v[2].p)),
			o->v[6].p_pi_f(o->sc, slot_value(o->v[3].p),
				       integer(slot_value(o->v[4].p)))));
}

static s7_pointer opt_p_pip_ssf1(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 2);
  o1 = o->sc->opts[o->sc->pc += 2];
  return(o->v[3].p_pip_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), o->v[4].p_p_f(o->sc, o1->v[0].fp(o1))));
}

static bool p_pip_ssf_combinable(s7_scheme *sc, opt_info *opc, int32_t start)
{
  opt_info *o1;
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      o1 = sc->opts[sc->pc - 1];
      if (o1->v[0].fp == opt_p_pi_ss) /* ref for set! as in (set! (var ind) ...) for example */
	{
	  int32_t ref_type, set_type;
	  ref_type = o1->types[0];
	  set_type = opc->types[0];
	  opc->v[5].p_pip_f = opc->v[3].p_pip_f;
	  opc->v[6].p_pi_f = o1->v[3].p_pi_f;
	  opc->v[3].p = o1->v[1].p;
	  opc->v[4].p = o1->v[2].p;
	  opc->v[0].fp = opt_p_pip_sso;
	  backup_pc(sc);
	  return(oo_set_type_4(opc, 7, 1, 2, 3, 4, set_type, OO_I, ref_type, OO_I));
	}
      if (o1->v[0].fp == opt_p_p_c)
	{
	  opc->v[5].p_p_f = o1->v[2].p_p_f;
	  opc->v[4].p = o1->v[1].p;
	  backup_pc(sc);
	  opc->v[0].fp = opt_p_pip_c;
	  return(oo_set_type_2(opc, 6, 1, 2, OO_P, OO_I));
	}
    }

  o1 = sc->opts[start];
  if (o1->v[0].fp == opt_p_p_f)
    {
      opc->v[4].p_p_f = o1->v[2].p_p_f;
      opc->v[0].fp = opt_p_pip_ssf1;
      return(oo_set_type_2(opc, 5, 1, 2, OO_P, OO_I));
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool p_pip_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_p_pip_t func;
  s7_pointer obj, slot1, sig, checker = NULL;
  int32_t op2 = OO_P;

  func = s7_p_pip_function(s_func);
  if (!func)
    return(return_false(sc, car_x, __func__, __LINE__));

  sig = c_function_signature(s_func);
  if ((is_pair(sig)) &&
      (is_pair(cdr(sig))) &&
      (is_symbol(cadr(sig))))
    checker = cadr(sig);

  /* here we know cadr is a symbol */
  slot1 = symbol_to_slot(sc, cadr(car_x));
  if ((!is_slot(slot1)) ||
      (has_methods(slot_value(slot1))) ||
      (is_immutable(slot_value(slot1))))
    return(return_false(sc, car_x, __func__, __LINE__));
  if ((is_any_vector(slot_value(slot1))) &&
      (vector_rank(slot_value(slot1)) > 1))
    return(return_false(sc, car_x, __func__, __LINE__));

  opc->v[1].p = slot1;
  obj = slot_value(opc->v[1].p);
  switch (type(obj))
    {
    case T_VECTOR:       op2 = (is_typed_vector(obj)) ? OO_TV : OO_PV; break;
    case T_INT_VECTOR:   op2 = OO_IV; break;
    case T_FLOAT_VECTOR: op2 = OO_FV; break;
    case T_STRING:       op2 = OO_S;  break;
    case T_BYTE_VECTOR:  op2 = OO_BV; break;
    case T_PAIR: 	 op2 = OO_L;  break;
    case T_LET:          op2 = OO_E;  break;
    case T_HASH_TABLE:   op2 = OO_H;  break;
    default:             op2 = OO_P;  break;
    }

  opc->v[3].p_pip_f = func;
  if ((s7_p_pip_direct_function(s_func)) &&
      (checker))
    {
      if ((is_normal_vector(obj)) && (checker == sc->is_vector_symbol))
	{
	  if (is_typed_vector(obj))
	    opc->v[3].p_pip_f = typed_vector_set_p_pip_direct;
	  else opc->v[3].p_pip_f = vector_set_p_pip_direct;
	}
      else
	{
	  if ((is_pair(obj)) && (checker == sc->is_pair_symbol))
	    opc->v[3].p_pip_f = s7_p_pip_direct_function(s_func);
	  else
	    {
	      s7_pointer val_type;
	      val_type = opt_arg_type(sc, cdddr(car_x));
	      if (val_type == cadddr(sig))
		{
		  if (((is_string(obj)) && (checker == sc->is_string_symbol)) ||
		      ((is_float_vector(obj)) && (checker == sc->is_float_vector_symbol)) ||
		      ((is_int_vector(obj)) && (checker == sc->is_int_vector_symbol)) ||
		      ((is_byte_vector(obj)) && (checker == sc->is_byte_vector_symbol)))
		    opc->v[3].p_pip_f = s7_p_pip_direct_function(s_func);
		}
	    }
	}
    }
  if (is_symbol(caddr(car_x)))
    {
      s7_pointer slot2;
      int32_t start;
      start = sc->pc;
      slot2 = opt_integer_symbol(sc, caddr(car_x));
      if (slot2)
	{
	  opc->v[2].p = slot2;
	  if (is_step_end(slot2))
	    switch (type(obj))
	      {
	      case T_VECTOR:
		if (denominator(slot_value(slot2)) <= vector_length(obj))
		  opc->v[3].p_pip_f = (is_typed_vector(obj)) ? typed_vector_set_unchecked : vector_set_unchecked;
		break;

	      case T_INT_VECTOR:
		if (denominator(slot_value(slot2)) <= vector_length(obj))
		  opc->v[3].p_pip_f = int_vector_set_unchecked_p;
		break;

	      case T_FLOAT_VECTOR:
		if (denominator(slot_value(slot2)) <= vector_length(obj))
		  opc->v[3].p_pip_f = float_vector_set_unchecked_p;
		break;

	      case T_STRING:
		if (denominator(slot_value(slot2)) <= string_length(obj))
		  opc->v[3].p_pip_f = string_set_unchecked;
		break;

	      case T_BYTE_VECTOR:
		if (denominator(slot_value(slot2)) <= string_length(obj))
		  opc->v[3].p_pip_f = byte_vector_set_unchecked_p;
		break;
	      }

	  if (is_symbol(cadddr(car_x)))
	    {
	      s7_pointer val_slot;
	      val_slot = opt_simple_symbol(sc, cadddr(car_x));
	      if (val_slot)
		{
		  opc->v[4].p_pip_f = opc->v[3].p_pip_f;
		  opc->v[3].p = val_slot;
		  opc->v[0].fp = opt_p_pip_sss;
		  return(oo_set_type_3(opc, 5, 1, 2, 3, op2, OO_I, OO_P));
		}
	    }
	  else
	    {
	      if ((!is_pair(cadddr(car_x))) ||
		  (is_proper_quote(sc, cadddr(car_x))))
		{
		  if (!is_pair(cadddr(car_x)))
		    opc->v[4].p = cadddr(car_x);
		  else opc->v[4].p = cadr(cadddr(car_x));
		  opc->v[0].fp = opt_p_pip_ssc;
		  return(oo_set_type_2(opc, 5, 1, 2, op2, OO_I));
		}
	    }
	  if (cell_optimize(sc, cdddr(car_x)))
	    {
	      if (p_pip_ssf_combinable(sc, opc, start))
		return(true);
	      opc->v[0].fp = opt_p_pip_ssf;
	      return(oo_set_type_2(opc, 4, 1, 2, op2, OO_I));
	    }
	}
    }
  else /* not symbol caddr */
    {
      if ((int_optimize(sc, cddr(car_x))) &&
	  (cell_optimize(sc, cdddr(car_x))))
	{
	  opc->v[0].fp = opt_p_pip_sff;
	  if ((obj) && (is_normal_vector(obj)))
	    return(oo_set_type_1(opc, 4, 1, op2));
	  return(oo_set_type_1(opc, 4, 1, op2));
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_piip -------- */
static s7_pointer opt_p_piip_sssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[5].p_piip_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)), o1->v[0].fp(o1)));
}

static s7_pointer opt_p_piip_sssc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 3);
  return(o->v[5].p_piip_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)), o->v[4].p));
}

static s7_pointer opt_p_piip_sfff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1, i2;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  i2 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 6, 1);
  return(o->v[5].p_piip_f(o->sc, slot_value(o->v[1].p), i1, i2, o1->v[0].fp(o1)));
}

static bool p_piip_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  /* this currently assumes s_func == vector-set! because there aren't any other p_piip functions(!) */
  s7_p_piip_t func;
  func = s7_p_piip_function(s_func);
  if ((func) &&
      (is_symbol(cadr(car_x))))
    {
      s7_pointer slot1, obj;
      slot1 = symbol_to_slot(sc, cadr(car_x));
      if (!is_slot(slot1))
	return(return_false(sc, car_x, __func__, __LINE__));
      obj = slot_value(slot1);
      if ((has_methods(obj)) || (is_immutable(obj)))
	return(return_false(sc, car_x, __func__, __LINE__));
      if ((is_any_vector(obj)) && /* vector_set_p_piip calls vector_setter(obj) */
	  (vector_rank(obj) == 2))
	{
	  s7_pointer indexp1, indexp2, valp, slot;
	  indexp1 = cddr(car_x);
	  indexp2 = cdddr(car_x);
	  valp = cddddr(car_x);
	  opc->v[1].p = slot1;
	  opc->v[5].p_piip_f = vector_set_p_piip;
	  slot = opt_integer_symbol(sc, car(indexp2));
	  if (slot)
	    {
	      opc->v[3].p = slot;
	      slot = opt_integer_symbol(sc, car(indexp1));
	      if (slot)
		{
		  opc->v[2].p = slot;
		  if ((is_symbol(car(valp))) ||
		      (is_unquoted_pair(car(valp))))
		    {
		      if (cell_optimize(sc, valp))
			{
			  opc->v[0].fp = opt_p_piip_sssf;
			  return(oo_set_type_3(opc, 6, 1, 2, 3, OO_P, OO_I, OO_I));
			}
		      return(return_false(sc, car_x, __func__, __LINE__));
		    }
		  opc->v[0].fp = opt_p_piip_sssc;
		  opc->v[4].p = (is_pair(car(valp))) ? cadar(valp) : car(valp);
		  return(oo_set_type_3(opc, 6, 1, 2, 3, OO_P, OO_I, OO_I));
		}
	    }
	  if ((int_optimize(sc, indexp1)) &&
	      (int_optimize(sc, indexp2)) &&
	      (cell_optimize(sc, valp)))
	    {
	      opc->v[0].fp = opt_p_piip_sfff;
	      return(oo_set_type_1(opc, 6, 1, (is_typed_vector(obj)) ? OO_TV : OO_PV));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_pii -------- */
static s7_pointer opt_p_pii_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].p_pii_f(o->sc, slot_value(o->v[1].p), integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p))));
}

static s7_pointer opt_p_pii_sff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i1, i2;
  o1 = o->sc->opts[++o->sc->pc];
  i1 = o1->v[0].fi(o1);
  o1 = o->sc->opts[++o->sc->pc];
  i2 = o1->v[0].fi(o1);
  oo_rcheck(o->sc, o, 5, 1);
  return(o->v[4].p_pii_f(o->sc, slot_value(o->v[1].p), i1, i2));
}

static bool p_pii_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_p_pii_t func;
  func = s7_p_pii_function(s_func);
  if ((func) &&
      (is_symbol(cadr(car_x))))
    {
      s7_pointer slot1, obj;
      slot1 = symbol_to_slot(sc, cadr(car_x));
      if (!is_slot(slot1))
	return(return_false(sc, car_x, __func__, __LINE__));
      obj = slot_value(slot1);
      if ((has_methods(obj)) || (is_immutable(obj)))
	return(return_false(sc, car_x, __func__, __LINE__));
      if ((is_normal_vector(obj)) &&
	  (vector_rank(obj) == 2))
	{
	  s7_pointer indexp1, indexp2, slot;
	  indexp1 = cddr(car_x);
	  indexp2 = cdddr(car_x);
	  opc->v[1].p = slot1;
	  opc->v[4].p_pii_f = vector_ref_p_pii;
	  slot = opt_integer_symbol(sc, car(indexp2));
	  if (slot)
	    {
	      opc->v[3].p = slot;
	      slot = opt_integer_symbol(sc, car(indexp1));
	      if (slot)
		{
		  opc->v[2].p = slot;
		  opc->v[0].fp = opt_p_pii_sss;
		  return(oo_set_type_3(opc, 5, 1, 2, 3, OO_P, OO_I, OO_I));
		}
	    }
	  if ((int_optimize(sc, indexp1)) &&
	      (int_optimize(sc, indexp2)))
	    {
	      opc->v[0].fp = opt_p_pii_sff;
	      return(oo_set_type_1(opc, 5, 1, OO_PV));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_ppi -------- */
static s7_pointer opt_p_ppi_psf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_ppi_f(o->sc, o->v[2].p, slot_value(o->v[1].p), o1->v[0].fi(o1)));
}

static bool p_ppi_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_p_ppi_t ifunc;
  ifunc = s7_p_ppi_function(s_func);
  if (ifunc)
    {
      int32_t start;
      start = sc->pc;
      opc->v[3].p_ppi_f = ifunc;
      if ((s7_is_character(cadr(car_x))) &&
	  (is_symbol(caddr(car_x))) &&
	  (int_optimize(sc, cdddr(car_x))))
	{
	  s7_pointer slot;
	  slot = opt_simple_symbol(sc, caddr(car_x));
	  if (slot)
	    {
	      opc->v[2].p = cadr(car_x);
	      opc->v[1].p = slot;
	      opc->v[0].fp = opt_p_ppi_psf;
	      return(oo_set_type_1(opc, 4, 1, OO_P));
	    }
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_ppp -------- */
static s7_pointer opt_p_ppp_ssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_ppp_f(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p), o1->v[0].fp(o1)));
}

static s7_pointer opt_p_ppp_sfs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_ppp_f(o->sc, slot_value(o->v[1].p), o1->v[0].fp(o1), slot_value(o->v[2].p)));
}

static s7_pointer opt_p_ppp_scs(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].p_ppp_f(o->sc, slot_value(o->v[1].p), o->v[4].p, slot_value(o->v[2].p)));
}

static s7_pointer opt_p_ppp_sff(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_pointer po1;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[++o->sc->pc];
  po1 = o1->v[0].fp(o1);
  o2 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_ppp_f(o->sc, slot_value(o->v[1].p), po1, o2->v[0].fp(o2)));
}

static s7_pointer opt_p_ppp_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].p_ppp_f(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p), slot_value(o->v[3].p)));
}

static s7_pointer opt_p_ppp_ssc(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  return(o->v[3].p_ppp_f(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p), o->v[4].p));
}

static s7_pointer opt_p_ppp_fff(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer po1, po2;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  po1 = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  po2 = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o->v[3].p_ppp_f(o->sc, po1, po2, o1->v[0].fp(o1)));
}

static bool p_ppp_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  s7_p_ppp_t func;
  func = s7_p_ppp_function(s_func);
  if (func)
    {
      s7_pointer arg1, arg2, arg3;
      int32_t start, op2 = OO_P;
      s7_pointer sig, checker = NULL;

      sig = c_function_signature(s_func);
      if ((is_pair(sig)) &&
	  (is_pair(cdr(sig))) &&
	  (is_symbol(cadr(sig))))
	checker = cadr(sig);
      start = sc->pc;

      opc->v[3].p_ppp_f = func;
      arg1 = cadr(car_x);
      arg2 = caddr(car_x);
      arg3 = cadddr(car_x);
      if (is_symbol(arg1)) /* dealt with at the top -> p1 */
	{
	  s7_pointer slot, obj;
	  slot = symbol_to_slot(sc, arg1);
	  if ((!is_slot(slot)) ||
	      (has_methods(slot_value(slot))))
	    return(return_false(sc, car_x, __func__, __LINE__));

	  obj = slot_value(slot);
	  if ((is_any_vector(obj)) &&
	      (vector_rank(obj) > 1))
	    return(return_false(sc, car_x, __func__, __LINE__));

	  if (car(car_x) == sc->hash_table_set_symbol) /* the other setters (than nash-table/let) won't happen here -- no p_ppp function */
	    {
	      if ((!is_hash_table(obj)) || (is_immutable(obj)))
		return(return_false(sc, car_x, __func__, __LINE__));
	      op2 = OO_H;
	    }
	  else
	    {
	      if (car(car_x) == sc->let_set_symbol)
		{
		  if ((!is_let(obj)) || (is_immutable(obj)))
		    return(return_false(sc, car_x, __func__, __LINE__));
		  op2 = OO_E;
		}
	    }

	  opc->v[1].p = slot;
	  if ((checker) && (s7_p_ppp_direct_function(s_func)))
	    {
	      checker = s7_symbol_value(sc, checker);
	      if (s7_apply_function(sc, checker, set_plist_1(sc, obj)) == sc->T)
		opc->v[3].p_ppp_f = s7_p_ppp_direct_function(s_func);
	    }
	  if (is_symbol(arg2))
	    {
	      slot = opt_simple_symbol(sc, arg2);
	      if (slot)
		{
		  opc->v[2].p = slot;
		  if (is_symbol(arg3))
		    {
		      slot = opt_simple_symbol(sc, arg3);
		      if (slot)
			{
			  opc->v[4].p_ppp_f = opc->v[3].p_ppp_f;
			  opc->v[3].p = slot;
			  opc->v[0].fp = opt_p_ppp_sss;
			  return(oo_set_type_3(opc, 5, 1, 2, 3, op2, OO_P, OO_P));
			}
		    }
		  else
		    {
		      if ((!is_pair(arg3)) ||
			  ((car(arg3) == sc->quote_symbol) &&
			   (is_pair(cdr(arg3))))) /* (quote) as arg3 */
			{
			  if (!is_pair(arg3))
			    opc->v[4].p = arg3;
			  else opc->v[4].p = cadr(arg3);
			  opc->v[0].fp = opt_p_ppp_ssc;
			  return(oo_set_type_2(opc, 5, 1, 2, op2, OO_P));
			}
		    }
		  if (cell_optimize(sc, cdddr(car_x)))
		    {
		      opc->v[0].fp = opt_p_ppp_ssf;
		      return(oo_set_type_2(opc, 4, 1, 2, op2, OO_P));
		    }
		  pc_fallback(sc, start);
		}
	    }
	  if ((is_proper_quote(sc, arg2)) &&
	      (is_symbol(arg3)))
	    {
	      s7_pointer val_slot;
	      val_slot = opt_simple_symbol(sc, arg3);
	      if (val_slot)
		{
		  opc->v[4].p = cadr(arg2);
		  opc->v[2].p = val_slot;
		  opc->v[0].fp = opt_p_ppp_scs;
		  if (opc->v[3].p_ppp_f == let_set_p_ppp)
		    {
		      if (is_symbol(cadr(arg2))) /* checked is_let, has_methods and is_immutable above */
			opc->v[3].p_ppp_f = let_set_p_ppp_1;
		      else return(return_false(sc, car_x, __func__, __LINE__));
		    }
		  return(oo_set_type_2(opc, 5, 1, 2, op2, OO_P));
		}
	    }
	  if (cell_optimize(sc, cddr(car_x)))
	    {
	      if (is_symbol(arg3))
		{
		  s7_pointer val_slot;
		  val_slot = opt_simple_symbol(sc, arg3);
		  if (val_slot)
		    {
		      opc->v[2].p = val_slot;
		      opc->v[0].fp = opt_p_ppp_sfs;
		      return(oo_set_type_2(opc, 4, 1, 2, op2, OO_P));
		    }
		}
	      if (cell_optimize(sc, cdddr(car_x)))
		{
		  opc->v[0].fp = opt_p_ppp_sff;
		  return(oo_set_type_1(opc, 4, 1, op2));
		}
	    }
	}
      else
	{
	  if ((cell_optimize(sc, cdr(car_x))) &&
	      (cell_optimize(sc, cddr(car_x))) &&
	      (cell_optimize(sc, cdddr(car_x))))
	    {
	      opc->v[0].fp = opt_p_ppp_fff;
	      return(oo_set_type_0(opc, 4));
	    }
	}
      pc_fallback(sc, start);
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- p_cf_ppp -------- */
static s7_pointer opt_p_cf_sss(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 3);
  return(o->v[4].cf(o->sc, set_plist_3(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p), slot_value(o->v[3].p))));
}

static s7_pointer opt_p_cf_ssf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 5, 2);
  return(o->v[4].cf(o->sc, set_plist_3(o->sc, slot_value(o->v[1].p), slot_value(o->v[2].p), o1->v[0].fp(o1))));
}

static s7_pointer opt_p_cf_ppp(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t tx1, tx2;
  s7_pointer po3;
  o1 = o->sc->opts[++o->sc->pc];
  oo_rcheck(o->sc, o, 3, 0);
  tx1 = next_tx(o->sc);
  o->sc->t_temps[tx1] = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  tx2 = next_tx(o->sc);
  o->sc->t_temps[tx2] = o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  po3 = o1->v[0].fp(o1);
  return(o->v[2].cf(o->sc, set_plist_3(o->sc, o->sc->t_temps[tx1], o->sc->t_temps[tx2], po3)));
}

static bool p_cf_ppp_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x)
{
  int32_t start;
  start = sc->pc;
  /* css (tbig (<= 2 m j)) ccs scs cfc ssf sfc fsc -- ssf then maybe scs */
  if ((is_safe_procedure(s_func)) &&
      (c_function_required_args(s_func) <= 3) &&
      (c_function_all_args(s_func) >= 3))
    {
      s7_pointer slot, arg;
      arg = cadr(car_x);
      if (is_symbol(arg))
	{
	  slot = opt_simple_symbol(sc, arg);
	  if (slot)
	    {
	      opc->v[1].p = slot;
	      arg = caddr(car_x);
	      if (is_symbol(arg))
		{
		  slot = opt_simple_symbol(sc, arg);
		  if (slot)
		    {
		      opc->v[2].p = slot;
		      arg = cadddr(car_x);
		      if (is_symbol(arg))
			{
			  slot = opt_simple_symbol(sc, arg);
			  if (slot)
			    {
			      opc->v[3].p = slot;
			      opc->v[4].cf = cf_call(sc, car_x, s_func, 3);
			      opc->v[0].fp = opt_p_cf_sss;
			      return(oo_set_type_3(opc, 5, 1, 2, 3, OO_P, OO_P, OO_P));
			    }
			}
		      else
			{
			  if (cell_optimize(sc, cdddr(car_x)))
			    {
			      opc->v[4].cf = cf_call(sc, car_x, s_func, 3);
			      opc->v[0].fp = opt_p_cf_ssf;
			      return(oo_set_type_2(opc, 5, 1, 2, OO_P, OO_P));
			    }}}}}}
      if ((cell_optimize(sc, cdr(car_x))) &&
	  (cell_optimize(sc, cddr(car_x))) &&
	  (cell_optimize(sc, cdddr(car_x))))
	{
	  opc->v[2].cf = cf_call(sc, car_x, s_func, 3);
	  opc->v[0].fp = opt_p_cf_ppp;
	  return(oo_set_type_0(opc, 3));
	}
    }
  pc_fallback(sc, start);
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- p_cf_any -------- */
static s7_pointer opt_p_cf_any(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer arg;
  int32_t i, tx;
  tx = next_tx(o->sc);
  oo_rcheck(o->sc, o, 3, 0);
  o->sc->t_temps[tx] = safe_list_if_possible(o->sc, o->v[1].i);
  for (i = 0, arg = o->sc->t_temps[tx]; i < o->v[1].i; i++, arg = cdr(arg))
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      set_car(arg, o1->v[0].fp(o1));
    }
  arg = o->v[2].cf(o->sc, o->sc->t_temps[tx]);
  clear_list_in_use(o->sc->t_temps[tx]);
  o->sc->current_safe_list = 0;
  return(arg);
}

static bool p_cf_any_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer car_x, int32_t len)
{
  if ((is_safe_procedure(s_func)) &&
      (c_function_required_args(s_func) <= (len - 1)) &&
      (c_function_all_args(s_func) >= (len - 1)))
    {
      s7_pointer p;      /* (vector-set! v k i 2) gets here */
      opc->v[1].i = (len - 1);
      for (p = cdr(car_x); is_pair(p); p = cdr(p))
	if (!cell_optimize(sc, p))
	  break;
      if (is_null(p))
	{
	  opc->v[0].fp = opt_p_cf_any;
	  opc->v[2].cf = cf_call(sc, car_x, s_func, len - 1);
	  return(oo_set_type_0(opc, 3));
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- p_fx_any -------- */

static s7_pointer opt_p_fx_any(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  return(o->v[1].cf(o->sc, o->v[2].p));
}

static bool p_fx_any_ok(s7_scheme *sc, opt_info *opc, s7_pointer s_func, s7_pointer x)
{
  s7_function f;
  f = fx_choose(sc, x, sc->envir, let_symbol_is_safe);
  if (f)
    {
      opc->v[0].fp = opt_p_fx_any;
      opc->v[1].cf = f;
      opc->v[2].p = car(x);
      return(oo_set_type_0(opc, 3));
    }
  return(return_false(sc, x, __func__, __LINE__));
}


/* -------- p_implicit -------- */

static bool p_implicit(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  s7_pointer s_slot;
  s_slot = symbol_to_slot(sc, car(car_x));

  if (is_slot(s_slot))
    {
      s7_pointer obj;
      obj = slot_value(s_slot);

      if (is_sequence(obj))
	{
	  opt_info *opc;
	  opc = alloc_opo(sc, car_x);
	  opc->v[1].p = s_slot;
	  if (len == 2)
	    {
	      int32_t op2 = OO_P;
	      switch (type(obj))
		{
		case T_PAIR:       opc->v[3].p_pi_f = list_ref_p_pi_direct;    op2 = OO_L; break;
		case T_HASH_TABLE: opc->v[3].p_pp_f = s7_hash_table_ref;       op2 = OO_H; break;
		case T_LET:        opc->v[3].p_pp_f = let_ref_p_pp;	       op2 = OO_E; break;
		case T_STRING:     opc->v[3].p_pi_f = string_ref_p_pi_direct;  op2 = OO_S; break;

		case T_BYTE_VECTOR:
		case T_VECTOR:
		case T_INT_VECTOR:
		case T_FLOAT_VECTOR:
		  if (vector_rank(obj) != 1)
		    return(return_false(sc, car_x, __func__, __LINE__));
		  opc->v[3].p_pi_f = vector_ref_p_pi_direct;
		  op2 = OO_AV;
		  break;

		case T_C_OBJECT:
		  return(return_false(sc, car_x, __func__, __LINE__)); /* no pi_ref because ref assumes pp */
		  break;

		default:
		  return(return_false(sc, car_x, __func__, __LINE__));
		}
	      /* now v3.p_pi|pp.f is set */
	      if (is_symbol(cadr(car_x)))
		{
		  s7_pointer slot;
		  slot = symbol_to_slot(sc, cadr(car_x));
		  if (is_slot(slot))
		    {
		      opc->v[2].p = slot;
		      if ((!is_hash_table(obj)) && /* these because opt_int below */
			  (!is_let(obj)))
			{
			  if (is_opt_int(slot_value(slot)))
			    {
			      opc->v[0].fp = opt_p_pi_ss;
			      if (is_step_end(opc->v[2].p))
				{
				  switch (type(obj))
				    {
				    case T_STRING:
				      if (denominator(slot_value(opc->v[2].p)) <= string_length(obj))
					{
					  opc->v[3].p_pi_f = string_ref_unchecked;
					  op2 = OO_S;
					}
				      break;

				    case T_BYTE_VECTOR:
				      if (denominator(slot_value(opc->v[2].p)) <= byte_vector_length(obj))
					{
					  opc->v[3].p_pi_f = byte_vector_ref_unchecked_p;
					  op2 = OO_BV;
					}
				      break;

				    case T_VECTOR:
				      if (denominator(slot_value(opc->v[2].p)) <= vector_length(obj))
					{
					  opc->v[3].p_pi_f = vector_ref_unchecked;
					  op2 = OO_PV;
					}
				      break;

				    case T_FLOAT_VECTOR:
				      if (denominator(slot_value(opc->v[2].p)) <= vector_length(obj))
					{
					  opc->v[3].p_pi_f = float_vector_ref_unchecked_p;
					  op2 = OO_FV;
					}
				      break;

				    case T_INT_VECTOR:
				      if (denominator(slot_value(opc->v[2].p)) <= vector_length(obj))
					{
					  opc->v[3].p_pi_f = int_vector_ref_unchecked_p;
					  op2 = OO_IV;
					}
				      break;
				    }
				}
			      return(oo_set_type_2(opc, 4, 1, 2, op2, OO_I));
			    }
			  return(return_false(sc, car_x, __func__, __LINE__)); /* I think this reflects that a non-int index is an error for list-ref et al */
			}
		      opc->v[0].fp = opt_p_pp_ss;
		      return(oo_set_type_2(opc, 4, 1, 2, op2, OO_P));
		    }
		}
	      else
		{
		  if ((!is_hash_table(obj)) &&
		      (!is_let(obj)))
		    {
		      if (is_t_integer(cadr(car_x)))
			{
			  opc->v[2].i = integer(cadr(car_x));
			  opc->v[0].fp = opt_p_pi_sc;
			  return(oo_set_type_1(opc, 4, 1, op2));
			}
		      if (int_optimize(sc, cdr(car_x)))
			{
			  opc->v[0].fp = opt_p_pi_sf;
			  return(oo_set_type_1(opc, 4, 1, op2));
			}
		      return(return_false(sc, car_x, __func__, __LINE__));
		    }
		  if (cell_optimize(sc, cdr(car_x)))
		    {
		      opc->v[0].fp = opt_p_pp_sf;
		      return(oo_set_type_1(opc, 4, 1, op2));
		    }
		}
	    } /* len==2 */
	  else
	    {
	      if (len > 2)
		{
		  s7_pointer p;
		  int32_t start;
		  start = sc->pc;
		  if ((is_normal_vector(obj)) &&
		      (len == 3) && (vector_rank(obj) == 2))
		    {
		      if ((int_optimize(sc, cdr(car_x))) &&
			  (int_optimize(sc, cddr(car_x))))
			{
			  opc->v[0].fp = opt_p_pii_sff;
			  /* opc->v[1].p set above */
			  opc->v[4].p_pii_f = vector_ref_p_pii_direct;
			  return(oo_set_type_1(opc, 5, 1, OO_P));
			}
		      pc_fallback(sc, start);
		    }

		  opc->v[1].i = len;
		  for (p = car_x; is_pair(p); p = cdr(p))
		    if (!cell_optimize(sc, p))
		      break;
		  if (is_null(p))
		    {
		      opc->v[0].fp = opt_p_cf_any;
		      switch (type(obj))     /* string can't happen here (no multidimensional strings) */
			{
			case T_PAIR:         opc->v[2].cf = g_list_ref;           break;
			case T_HASH_TABLE:   opc->v[2].cf = g_hash_table_ref;     break;
			/* case T_LET:       opc->v[2].cf = g_let_ref;            break; */ /* this doesn't handle implicit indices via g_let_ref! apply_let */
			case T_INT_VECTOR:   opc->v[2].cf = g_int_vector_ref;     break;
			case T_FLOAT_VECTOR: opc->v[2].cf = g_float_vector_ref;   break;
			case T_VECTOR:       opc->v[2].cf = g_vector_ref;         break;
			default:             return(return_false(sc, car_x, __func__, __LINE__));
			}
		      return(oo_set_type_0(opc, 3));
		    }}}
	} /* obj is sequence */
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- cell_quote -------- */
static bool opt_cell_quote(s7_scheme *sc, s7_pointer car_x)
{
  opt_info *opc;
  if (!is_null(cddr(car_x)))
    return(return_false(sc, car_x, __func__, __LINE__));
  opc = alloc_opo(sc, car_x);
  opc->v[1].p = cadr(car_x);
  opc->v[0].fp = opt_p_c;
  return(oo_set_type_0(opc, 2));
}

/* -------- cell_set -------- */
static s7_pointer opt_set_p_p_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer x;
  oo_rcheck(o->sc, o, 2, 1);
  o1 = o->sc->opts[++o->sc->pc];
  x = o1->v[0].fp(o1);
  slot_set_value(o->v[1].p, x);
  return(x);
}

static s7_pointer opt_set_p_i_s(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer val;
  oo_rcheck(o->sc, o, 3, 2);
  val = slot_value(o->v[2].p);
  if (is_mutable(val))
    val = make_integer(o->sc, integer(val));
  slot_set_value(o->v[1].p, val);
  return(val);
}

static s7_pointer opt_set_p_i_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer x;
  oo_rcheck(o->sc, o, 2, 1);
  o1 = o->sc->opts[++o->sc->pc];
  x = make_integer(o->sc, o1->v[0].fi(o1));
  slot_set_value(o->v[1].p, x);
  return(x);
}

static s7_pointer opt_set_p_d_s(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer val;
  oo_rcheck(o->sc, o, 3, 2);
  val = slot_value(o->v[2].p);
  if (is_mutable(val))
    val = make_real(o->sc, real(val));
  slot_set_value(o->v[1].p, val);
  return(val);
}

static s7_pointer opt_set_p_d_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer x;
  oo_rcheck(o->sc, o, 2, 1);
  o1 = o->sc->opts[++o->sc->pc];
  x = make_real(o->sc, o1->v[0].fd(o1));
  slot_set_value(o->v[1].p, x);
  return(x);
}

static s7_pointer opt_set_p_d_f_mm_add(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1, x2;
  oo_rcheck(o->sc, o, 3, 1);

  o1 = o->sc->opts[o->sc->pc += 2];
  x1 = float_vector_ref_d_7pi(o->sc, slot_value(o1->v[2].p), integer(slot_value(o1->v[3].p))) * real(slot_value(o1->v[1].p));
  o2 = o->sc->opts[++o->sc->pc];
  x2 = float_vector_ref_d_7pi(o->sc, slot_value(o2->v[2].p), integer(slot_value(o2->v[3].p))) * real(slot_value(o2->v[1].p));

  slot_set_value(o->v[1].p, make_real(o->sc, x1 + x2));
  return(slot_value(o->v[1].p));
}

static s7_pointer opt_set_p_d_f_mm_subtract(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_double x1, x2;
  oo_rcheck(o->sc, o, 3, 1);

  o1 = o->sc->opts[o->sc->pc += 2];
  x1 = float_vector_ref_d_7pi(o->sc, slot_value(o1->v[2].p), integer(slot_value(o1->v[3].p))) * real(slot_value(o1->v[1].p));
  o2 = o->sc->opts[++o->sc->pc];
  x2 = float_vector_ref_d_7pi(o->sc, slot_value(o2->v[2].p), integer(slot_value(o2->v[3].p))) * real(slot_value(o2->v[1].p));

  slot_set_value(o->v[1].p, make_real(o->sc, x1 - x2));
  return(slot_value(o->v[1].p));
}

static s7_pointer opt_set_p_c(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 1);
  slot_set_value(o->v[1].p, o->v[2].p);
  return(o->v[2].p);
}

static s7_pointer opt_set_p_i_fo(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer x;
  s7_int i;
  oo_rcheck(o->sc, o, 4, 3);
  i = o->v[4].i_ii_f(integer(slot_value(o->v[2].p)), integer(slot_value(o->v[3].p)));
  x = make_integer(o->sc, i);
  slot_set_value(o->v[1].p, x);
  return(x);
}

static s7_pointer opt_set_p_i_fo_add(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer x;
  s7_int i;
  oo_rcheck(o->sc, o, 4, 3);
  i = integer(slot_value(o->v[2].p)) + integer(slot_value(o->v[3].p));
  x = make_integer(o->sc, i);
  slot_set_value(o->v[1].p, x);
  return(x);
}

static s7_pointer opt_set_p_i_fo1(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer x;
  s7_int i;
  oo_rcheck(o->sc, o, 4, 2);
  i = o->v[4].i_ii_f(integer(slot_value(o->v[2].p)), o->v[3].i);
  x = make_integer(o->sc, i);
  slot_set_value(o->v[1].p, x);
  return(x);
}

static s7_pointer opt_set_p_i_fo1_add(void *p)
{
  opt_info *o = (opt_info *)p;
  s7_pointer x;
  s7_int i;
  oo_rcheck(o->sc, o, 4, 2);
  i = integer(slot_value(o->v[2].p)) + o->v[3].i;
  x = make_integer(o->sc, i);
  slot_set_value(o->v[1].p, x);
  return(x);
}

static bool set_p_i_f_combinable(s7_scheme *sc, opt_info *opc)
{
  if ((sc->pc > 1) &&
      (opc == sc->opts[sc->pc - 2]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 1];
      if ((o1->v[0].fi == opt_i_ii_ss) ||
	  (o1->v[0].fi == opt_i_ii_ss_add))
	{
	  opc->v[4].i_ii_f = o1->v[3].i_ii_f;
	  opc->v[2].p = o1->v[1].p;
	  opc->v[3].p = o1->v[2].p;
	  if (o1->v[0].fi == opt_i_ii_ss_add)
	    opc->v[0].fp = opt_set_p_i_fo_add;
	  else opc->v[0].fp = opt_set_p_i_fo;
	  backup_pc(sc);
	  return(oo_set_type_3(opc, 5, 1, 2, 3, OO_I, OO_I, OO_I));
	}
      if ((o1->v[0].fi == opt_i_ii_sc) ||
	  (o1->v[0].fi == opt_i_ii_sc_add))
	{
	  opc->v[4].i_ii_f = o1->v[3].i_ii_f;
	  opc->v[2].p = o1->v[1].p;
	  opc->v[3].i = o1->v[2].i;
	  if (o1->v[0].fi == opt_i_ii_sc_add)
	    opc->v[0].fp = opt_set_p_i_fo1_add;
	  else opc->v[0].fp = opt_set_p_i_fo1;
	  backup_pc(sc);
	  return(oo_set_type_2(opc, 5, 1, 2, OO_I, OO_I));
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool set_p_d_f_combinable(s7_scheme *sc, opt_info *opc)
{
  if ((sc->pc > 3) &&
      (opc == sc->opts[sc->pc - 4]))
    {
      opt_info *o1;
      o1 = sc->opts[sc->pc - 3];
      if ((o1->v[0].fd == opt_d_mm_fff) &&
	  ((o1->v[3].d_dd_f == add_d_dd) || (o1->v[3].d_dd_f == subtract_d_dd)))
	{
	  /* opc->v[2].d_dd_f = o1->v[3].d_dd_f; */
	  opc->v[0].fp = (o1->v[3].d_dd_f == add_d_dd) ? opt_set_p_d_f_mm_add : opt_set_p_d_f_mm_subtract;
	  return(true);
	}
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static bool is_some_number(s7_scheme *sc, s7_pointer tp)
{
  return((tp == sc->is_integer_symbol) ||
	 (tp == sc->is_float_symbol) ||
	 (tp == sc->is_real_symbol) ||
	 (tp == sc->is_complex_symbol) ||
	 (tp == sc->is_number_symbol) ||
	 (tp == sc->is_rational_symbol));
}

static bool opt_cell_set(s7_scheme *sc, s7_pointer car_x) /* len == 3 here (p_syntax) */
{
  opt_info *opc;
  s7_pointer target;

  opc = alloc_opo(sc, car_x);
  target = cadr(car_x);
  if (is_symbol(target))
    {
      s7_pointer settee;
      if ((is_constant_symbol(sc, target)) ||
	  (symbol_has_setter(target)))
	return(return_false(sc, car_x, __func__, __LINE__));
      settee = symbol_to_slot(sc, target);

      if ((is_slot(settee)) &&
	  (!is_immutable(settee)) &&
	  (!is_syntax(slot_value(settee))))
	{
	  /* type changes here can confuse the rest of the optimizer */
	  s7_pointer atype, stype;

	  opc->v[1].p = settee;
	  stype = s7_type_of(sc, slot_value(settee));

	  if (stype == sc->is_integer_symbol)
	    {
	      if (is_symbol(caddr(car_x)))
		{
		  s7_pointer val_slot;
		  val_slot = opt_integer_symbol(sc, caddr(car_x));
		  if (val_slot)
		    {
		      opc->v[2].p = val_slot;
		      opc->v[0].fp = opt_set_p_i_s;
		      return(oo_set_type_2(opc, 3, 1, 2, OO_I, OO_I));
		    }
		}
	      else
		{
		  if (int_optimize(sc, cddr(car_x)))
		    {
		      if (!set_p_i_f_combinable(sc, opc))
			{
			  opc->v[0].fp = opt_set_p_i_f;
			  return(oo_set_type_1(opc, 3, 1, OO_P));
			}
		      oo_check(sc, opc);
		      return(true);
		    }
		  return(return_false(sc, car_x, __func__, __LINE__));
		}
	    }
	  if (stype == sc->is_float_symbol)
	    {
	      if (is_float(caddr(car_x)))
		{
		  opc->v[2].p = caddr(car_x);
		  opc->v[0].fp = opt_set_p_c;
		  return(oo_set_type_1(opc, 3, 1, OO_P));
		}
	      if (is_symbol(caddr(car_x)))
		{
		  s7_pointer val_slot;
		  val_slot = opt_float_symbol(sc, caddr(car_x));
		  if (val_slot)
		    {
		      opc->v[2].p = val_slot;
		      opc->v[0].fp = opt_set_p_d_s;
		      return(oo_set_type_2(opc, 3, 1, 2, OO_D, OO_D));
		    }
		}
	      else
		{
		  if ((is_pair(caddr(car_x))) &&
		      (float_optimize(sc, cddr(car_x))))
		    {
		      if (!set_p_d_f_combinable(sc, opc))
			opc->v[0].fp = opt_set_p_d_f;
		      return(oo_set_type_1(opc, 3, 1, OO_P));
		    }
		  return(return_false(sc, car_x, __func__, __LINE__));
		}
	    }
	  atype = opt_arg_type(sc, cddr(car_x));
	  if ((is_some_number(sc, atype)) &&
	      (!is_some_number(sc, stype)))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  if (cell_optimize(sc, cddr(car_x)))
	    {
	      opc->v[0].fp = opt_set_p_p_f;
	      return(oo_set_type_1(opc, 3, 1, OO_P));
	    }
	}
    }
  else
    {
      if ((is_pair(target)) &&
	  (is_symbol(car(target))) &&
	  (is_pair(cdr(target))) &&
	  ((is_null(cddr(target))) || (is_null(cdddr(target)))))
	{
	  s7_pointer s_slot;
	  s_slot = symbol_to_slot(sc, car(target));
	  if (is_slot(s_slot))
	    {
	      s7_pointer obj;
	      opc->v[1].p = s_slot;
	      obj = slot_value(s_slot);
	      if (/* (!has_methods(obj)) && */ /* not mentioned in d_impicit */
		  (is_mutable_sequence(obj)))
		{
		  int32_t op2 = OO_P;
		  s7_pointer index;
		  switch (type(obj))
		    {
		    case T_STRING:
		      {
			s7_pointer val_type;
			if (is_pair(cddr(target))) return(return_false(sc, car_x, __func__, __LINE__));
			val_type = opt_arg_type(sc, cddr(car_x));
			if (val_type != sc->is_char_symbol)
			  return(return_false(sc, car_x, __func__, __LINE__));
			opc->v[3].p_pip_f = string_set_p_pip_direct;
			op2 = OO_S;
		      }
		      break;

		    case T_VECTOR:
		      /* is_opt_int below to handle the index */
		      if (is_null(cddr(target)))
			{
			  if (vector_rank(obj) != 1) return(return_false(sc, car_x, __func__, __LINE__));
			  if (is_typed_vector(obj))
			    {
			      op2 = OO_TV;
			      opc->v[3].p_pip_f = typed_vector_set_p_pip_direct;
			    }
			  else
			    {
			      op2 = OO_PV;
			      opc->v[3].p_pip_f = vector_set_p_pip_direct;
			    }
			}
		      else
			{
			  s7_pointer indexp1, indexp2, valp, slot;
			  if (vector_rank(obj) != 2) return(return_false(sc, car_x, __func__, __LINE__));
			  opc->v[5].p_piip_f = (is_typed_vector(obj)) ? typed_vector_set_p_piip_direct : vector_set_p_piip_direct;
			  indexp1 = cdr(target);
			  indexp2 = cddr(target);
			  valp = cddr(car_x);
			  slot = opt_integer_symbol(sc, car(indexp2));
			  if (slot)
			    {
			      opc->v[3].p = slot;
			      slot = opt_integer_symbol(sc, car(indexp1));
			      if (slot)
				{
				  opc->v[2].p = slot;
				  if ((is_symbol(car(valp))) ||
				      (is_unquoted_pair(car(valp))))
				    {
				      if (cell_optimize(sc, valp))
					{
					  opc->v[0].fp = opt_p_piip_sssf;
					  return(oo_set_type_3(opc, 6, 1, 2, 3, (is_typed_vector(obj)) ? OO_TV : OO_PV, OO_I, OO_I));
					}
				      return(return_false(sc, car_x, __func__, __LINE__));
				    }
				  opc->v[0].fp = opt_p_piip_sssc;
				  opc->v[4].p = (is_pair(car(valp))) ? cadar(valp) : car(valp);
				  return(oo_set_type_3(opc, 6, 1, 2, 3, (is_typed_vector(obj)) ? OO_TV : OO_PV, OO_I, OO_I));
				}
			    }
			  if ((int_optimize(sc, indexp1)) &&
			      (int_optimize(sc, indexp2)) &&
			      (cell_optimize(sc, valp)))
			    {
			      /* v[1].p is set above as the vector slot */
			      opc->v[0].fp = opt_p_piip_sfff;
			      return(oo_set_type_1(opc, 6, 1, (is_typed_vector(obj)) ? OO_TV : OO_PV));
			    }
			  return(return_false(sc, car_x, __func__, __LINE__));
			}
		      break;

		    case T_FLOAT_VECTOR:
		      if (opt_float_vector_set(sc, opc, car(target), cdr(target), (is_null(cddr(target))) ? NULL : cddr(target), cddr(car_x)))
			{
			  if (oo_size(opc) < 8) oo_resize(opc, 8);
			  opc->v[7].fd = opc->v[0].fd;
			  opc->v[0].fp = d_to_p;
			  oo_check(sc, opc);
			  return(true);
			}
		      return(return_false(sc, car_x, __func__, __LINE__));

		    case T_BYTE_VECTOR:
		    case T_INT_VECTOR:
		      if (opt_int_vector_set(sc, OO_AV, opc, car(target), cdr(target), (is_null(cddr(target))) ? NULL : cddr(target), cddr(car_x)))
			{
			  if (oo_size(opc) < 8) oo_resize(opc, 8);
			  opc->v[7].fi = opc->v[0].fi;
			  opc->v[0].fp = i_to_p;
			  oo_check(sc, opc);
			  return(true);
			}
		      return(return_false(sc, car_x, __func__, __LINE__));

		    case T_C_OBJECT:
		      if ((is_null(cddr(target))) &&
			  (is_c_function(c_object_setf(sc, obj))))
			{
			  /* d_7pid_ok assumes cadr is the target, not car etc */
			  s7_d_7pid_t func;
			  func = s7_d_7pid_function(c_object_setf(sc, obj));
			  if (func)
			    {
			      s7_pointer slot;
			      opc->v[4].d_7pid_f = func;
			      slot = opt_integer_symbol(sc, cadr(target));
			      if (slot)
				{
				  if (float_optimize(sc, cddr(car_x)))
				    {
				      opc->v[7].fd = opt_d_7pid_ssf;
				      opc->v[0].fp = d_to_p; /* cell_optimize, so need to return s7_pointer */
				      opc->v[2].p = slot;
				      return(oo_set_type_2(opc, 5, 1, 2, OO_V, OO_I));
				    }
				}
			      else
				{
				  if ((int_optimize(sc, cdr(target))) &&
				      (float_optimize(sc, cddr(car_x))))
				    {
				      opc->v[7].fd = opt_d_7pid_sff;
				      opc->v[0].fp = d_to_p;
				      return(oo_set_type_1(opc, 5, 1, OO_V));
				    }}}
			}
		      return(return_false(sc, car_x, __func__, __LINE__));

		    case T_PAIR:
		      if (is_pair(cddr(target))) return(return_false(sc, car_x, __func__, __LINE__));
		      op2 = OO_L;
		      opc->v[3].p_pip_f = list_set_p_pip_direct;
		      break;

		    case T_HASH_TABLE:
		      if (is_pair(cddr(target))) return(return_false(sc, car_x, __func__, __LINE__));
		      op2 = OO_H;
		      opc->v[3].p_ppp_f = s7_hash_table_set;
		      break;

		    case T_LET:
		      /* here we know the let is a covered mutable let */
		      if (is_pair(cddr(target))) return(return_false(sc, car_x, __func__, __LINE__));
		      op2 = OO_E;
		      if ((is_keyword(cadr(target))) ||
			  ((is_quoted_pair(cadr(target))) &&
			   (is_symbol(cadadr(target)))))
			opc->v[3].p_ppp_f = let_set_p_ppp_1;
		      else opc->v[3].p_ppp_f = let_set_p_ppp_2;
		      break;

		    default:
		      return(return_false(sc, car_x, __func__, __LINE__));
		    }
		  index = cadr(target);
		  if (is_symbol(index))
		    {
		      s7_pointer slot;
		      int32_t start;
		      start = sc->pc;
		      slot = opt_simple_symbol(sc, index);
		      if (slot)
			{
			  opc->v[2].p = slot;
			  if ((is_opt_int(slot_value(slot))) &&
			      (is_step_end(opc->v[2].p)))
			    {
			      if (is_string(obj))
				{
				  if (denominator(slot_value(opc->v[2].p)) <= string_length(obj))
				    {
				      opc->v[3].p_pip_f = string_set_unchecked;
				      op2 = OO_S;
				    }
				}
			      else
				{
				  if (is_byte_vector(obj))
				    {
				      if (denominator(slot_value(opc->v[2].p)) <= byte_vector_length(obj))
					{
					  opc->v[3].p_pip_f = byte_vector_set_unchecked_p;
					  op2 = OO_BV;
					}
				    }
				  else
				    {
				      if (is_any_vector(obj)) /* true for all 3 vectors */
					{
					  if ((is_any_vector(obj)) &&
					      (denominator(slot_value(opc->v[2].p)) <= vector_length(obj)))
					    {
					      if ((is_normal_vector(obj)) && (is_typed_vector(obj)))
						{
						  opc->v[3].p_pip_f = typed_vector_set_unchecked;
						  op2 = OO_TV;
						}
					      else
						{
						  opc->v[3].p_pip_f = vector_set_unchecked;
						  op2 = OO_AV; /* AV=any vector */
						}}}}}
			    }
			  if (is_symbol(caddr(car_x)))
			    {
			      s7_pointer val_slot;
			      val_slot = opt_simple_symbol(sc, caddr(car_x));
			      if (val_slot)
				{
				  if ((is_string(obj)) ||
				      (is_any_vector(obj)) ||
				      (is_pair(obj)))
				    {
				      opc->v[4].p_pip_f = opc->v[3].p_pip_f;
				      opc->v[3].p = val_slot;
				      opc->v[0].fp = opt_p_pip_sss;
				      return(oo_set_type_3(opc, 5, 1, 2, 3, op2, OO_I, OO_P));
				    }
				  opc->v[4].p_ppp_f = opc->v[3].p_ppp_f;
				  opc->v[3].p = val_slot;
				  opc->v[0].fp = opt_p_ppp_sss;
				  return(oo_set_type_3(opc, 5, 1, 2, 3, op2, OO_P, OO_P));
				}
			    }
			  else
			    {
			      if ((!is_pair(caddr(car_x))) ||
				  (is_proper_quote(sc, caddr(car_x))))
				{
				  if (!is_pair(caddr(car_x)))
				    opc->v[4].p = caddr(car_x);
				  else opc->v[4].p = cadr(caddr(car_x));
				  if ((is_string(obj)) ||
				      (is_any_vector(obj)) ||
				      (is_pair(obj)))
				    {
				      opc->v[0].fp = opt_p_pip_ssc;
				      return(oo_set_type_2(opc, 5, 1, 2, op2, OO_I));
				    }
				  opc->v[0].fp = opt_p_ppp_ssc;
				  return(oo_set_type_2(opc, 5, 1, 2, op2, OO_P));
				}
			    }
			  if (cell_optimize(sc, cddr(car_x)))
			    {
			      if ((is_string(obj)) ||
				  (is_any_vector(obj)) ||
				  (is_pair(obj)))
				{
				  oo_set_type_2(opc, 5, 1, 2, op2, OO_I); /* needed in p_pip_ssf_combinable! */
				  if (p_pip_ssf_combinable(sc, opc, start))
				    return(true);
				  opc->v[0].fp = opt_p_pip_ssf;
				  return(oo_set_type_2(opc, 5, 1, 2, op2, OO_I));
				}
			      opc->v[0].fp = opt_p_ppp_ssf;
			      return(oo_set_type_2(opc, 5, 1, 2, op2, op2));
			    }
			}
		    }
		  else
		    {
		      if ((is_string(obj)) ||
			  (is_pair(obj)) ||
			  (is_any_vector(obj)))
			{
			  if ((int_optimize(sc, cdr(target))) &&
			      (cell_optimize(sc, cddr(car_x))))
			    {
			      opc->v[0].fp = opt_p_pip_sff;
			      return(oo_set_type_1(opc, 4, 1, op2));
			    }
			  return(return_false(sc, car_x, __func__, __LINE__));
			}
		      if ((is_proper_quote(sc, cadr(target))) &&
			  (is_symbol(caddr(car_x))))
			{
			  s7_pointer val_slot;
			  val_slot = opt_simple_symbol(sc, caddr(car_x));
			  if (val_slot)
			    {
			      opc->v[4].p = cadr(cadr(target));
			      opc->v[2].p = val_slot;
			      opc->v[0].fp = opt_p_ppp_scs;
			      return(oo_set_type_2(opc, 5, 1, 2, op2, OO_P));
			    }
			}
		      if (cell_optimize(sc, cdr(target)))
			{
			  if (is_symbol(caddr(car_x)))
			    {
			      s7_pointer val_slot;
			      val_slot = opt_simple_symbol(sc, caddr(car_x));
			      if (val_slot)
				{
				  opc->v[2].p = val_slot;
				  opc->v[0].fp = opt_p_ppp_sfs;
				  return(oo_set_type_2(opc, 4, 1, 2, op2, OO_P));
				}
			    }
			  if (cell_optimize(sc, cddr(car_x)))
			    {
			      opc->v[0].fp = opt_p_ppp_sff;
			      return(oo_set_type_1(opc, 4, 1, op2));
			    }}}}}}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------- cell_begin -------- */
static s7_pointer opt_begin_p(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int i, len;
  oo_rcheck(o->sc, o, 2, 0);
  len = o->v[1].i - 1;
  for (i = 0; i < len; i++)
    {
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fp(o1));
}

static s7_pointer opt_begin_p_1(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 0, 0);   /* ?? */
  o1 = o->sc->opts[++o->sc->pc];
  o1->v[0].fp(o1);
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fp(o1));
}

static void oo_idp_nr_fixup(opt_info *start)
{
  if (start->v[0].fp == d_to_p)
    {
      start->v[0].fp = d_to_p_nr;
      if (start->v[7].fd == opt_d_7pid_ssf)
	start->v[0].fp = opt_d_7pid_ssf_nr;
      else
	{
	  if (start->v[7].fd == opt_d_7pid_ssfo_fv)
	    {
	      start->v[0].fp = opt_d_7pid_ssfo_fv_nr;
	      if (start->v[6].d_dd_f == add_d_dd)
		start->v[0].fp = opt_d_7pid_ssfo_fv_add_nr;
	      else
		{
		  if (start->v[6].d_dd_f == subtract_d_dd)
		    start->v[0].fp = opt_d_7pid_ssfo_fv_sub_nr;
		}}}}
  else
    {
      if (start->v[0].fp == i_to_p)
	start->v[0].fp = i_to_p_nr;
    }
}

static bool opt_cell_begin(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  opt_info *opc;
  s7_pointer p;
  opc = alloc_opo(sc, car_x);
  for (p = cdr(car_x); is_pair(p); p = cdr(p))
    {
      opt_info *start;
      start = sc->opts[sc->pc];
      if (!cell_optimize(sc, p))
	return(return_false(sc, car_x, __func__, __LINE__));
      if (is_pair(cdr(p)))
	oo_idp_nr_fixup(start);
    }
  opc->v[1].i = len - 1;
  opc->v[0].fp = (len == 3) ? opt_begin_p_1 : opt_begin_p;
  return(oo_set_type_0(opc, 2));
}

/* -------- cell_when|unless -------- */
static s7_pointer opt_when_p(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fb(o1))
    {
      int32_t i, len;
      len = o->v[1].i - 1;
      for (i = 0; i < len; i++)
	{
	  o1 = o->sc->opts[++o->sc->pc];
	  o1->v[0].fp(o1);
	}
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[3].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_unless_p(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t i, len;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fb(o1))
    {
      o->sc->pc = o->v[3].i;
      return(o->sc->unspecified);
    }
  len = o->v[1].i - 1;
  for (i = 0; i < len; i++)
    {
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fp(o1));
}

static bool opt_cell_when(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  s7_pointer p;
  opt_info *opc;
  opc = alloc_opo(sc, car_x);
  if (!bool_optimize(sc, cdr(car_x)))
    return(return_false(sc, car_x, __func__, __LINE__));
  for (p = cddr(car_x); is_pair(p); p = cdr(p))
    {
      opt_info *start;
      start = sc->opts[sc->pc];
      if (!cell_optimize(sc, p))
	return(return_false(sc, car_x, __func__, __LINE__));
      if (is_pair(cdr(p)))
	oo_idp_nr_fixup(start);
    }
  opc->v[1].i = len - 2;
  opc->v[3].i = sc->pc - 1;
  opc->v[0].fp = ((car(car_x) == sc->when_symbol) ? opt_when_p : opt_unless_p);
  return(oo_set_type_0(opc, 4));
}

/* -------- cell_cond -------- */
static s7_pointer opt_cond(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  o->v[2].p = o->sc->unspecified;
  while (o->sc->pc < o->v[1].i)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  return(o->v[2].p);
}

static s7_pointer case_value(opt_info *o)
{
  opt_info *top, *o1;
  int32_t i, len;
  top = (opt_info *)(o->v[5].obj);
  len = o->v[1].i - 1;
  for (i = 0; i < len; i++)
    {
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  o1 = o->sc->opts[++o->sc->pc];
  top->v[2].p = o1->v[0].fp(o1);
  o->sc->pc = top->v[1].i;
  return(top->v[2].p);
}

static s7_pointer opt_cond_clause(void *p)
{
  /* top->p1 gets result, top->i1 is end index, o->v[3].i is end of current clause, o->v[1].i = body len */
  opt_info *o1, *o = (opt_info *)p;
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fb(o1))
    return(case_value(o));
  o->sc->pc = o->v[3].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_cond_2(void *p)
{
  /* 2 branches, results 1 expr, else */
  opt_info *o1, *o2, *o = (opt_info *)p;
  s7_pointer res;
  oo_rcheck(o->sc, o, 2, 0);
  o->sc->pc += 2;
  o2 = o->sc->opts[o->sc->pc];       /* this is the boolean expr of the first clause */
  if (!o2->v[0].fb(o2))
    o->sc->pc = o->v[3].i;            /* jump over first clause and #t */
  o1 = o->sc->opts[++o->sc->pc];
  res = o1->v[0].fp(o1);
  o->sc->pc = o->v[1].i;              /* end of cond index */
  return(res);
}

static bool opt_cell_cond(s7_scheme *sc, s7_pointer car_x)
{
  /* top->v[2].p gets result, top->v[1].i is end index, clause->v[3].i is end of current clause,
   *   clause->v[1].i = clause result len, clause->v[5].obj = top
   */
  s7_pointer p, last_clause = NULL;
  opt_info *top;
  int32_t branches = 0, max_blen = 0, start_pc;
  top = alloc_opo(sc, car_x);
  start_pc = sc->pc;
  for (p = cdr(car_x); is_pair(p); p = cdr(p), branches++)
    {
      opt_info *opc;
      s7_pointer clause, cp;
      int32_t blen;
      clause = car(p);
      if ((!is_pair(clause)) ||
	  (!is_pair(cdr(clause))) || /* leave the test->result case for later */
	  (cadr(clause) == sc->feed_to_symbol))
	return(return_false(sc, clause, __func__, __LINE__));

      last_clause = clause;
      opc = alloc_opo(sc, car_x);
      oo_set_type_0(opc, 6);
      if ((car(clause) == sc->else_symbol) ||
	  (car(clause) == sc->T))
	{
	  opt_info *opb;
	  opb = alloc_opo(sc, clause);
	  opb->v[0].fb = opt_b_t;
	  oo_set_type_0(opb, 1);
	}
      else
	{
	  if (!bool_optimize(sc, clause))
	    return(return_false(sc, clause, __func__, __LINE__));
	}
      for (blen = 0, cp = cdr(clause); is_pair(cp); blen++, cp = cdr(cp))
	if (!cell_optimize(sc, cp))
	  return(return_false(sc, cp, __func__, __LINE__));
      if (!is_null(cp))
	return(return_false(sc, cp, __func__, __LINE__));
      opc->v[1].i = blen;
      if (max_blen < blen) max_blen = blen;
      opc->v[3].i = sc->pc - 1;
      opc->v[5].obj = (void *)top;
      opc->v[0].fp = opt_cond_clause;
    }
  top->v[1].i = sc->pc - 1;
  top->v[0].fp = opt_cond;
  if (branches == 2)
    {
      if ((max_blen == 1) &&
	  ((car(last_clause) == sc->else_symbol) ||
	   (car(last_clause) == sc->T)))
	{
	  opt_info *o1;
	  o1 = sc->opts[start_pc];
	  top->v[3].i = o1->v[3].i + 2;
	  top->v[0].fp = opt_cond_2;
	}
    }
  return(oo_set_type_0(top, 6));
}

/* -------- cell_and|or -------- */
static s7_pointer opt_and_pp(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fp(o1) == o->sc->F)
    {
      o->sc->pc = o->v[1].i;
      return(o->sc->F);
    }
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fp(o1));
}

static s7_pointer opt_and_any_p(void *p)
{
  opt_info *o = (opt_info *)p;
  int32_t i;
  s7_pointer val;
  oo_rcheck(o->sc, o, 3, 0);
  val = o->sc->T; /* (and) -> #t */
  for (i = 0; i < o->v[1].i; i++)
    {
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      val = o1->v[0].fp(o1);
      if (val == o->sc->F)
	{
	  o->sc->pc = o->v[2].i;
	  return(o->sc->F);
	}
    }
  return(val);
}

static s7_pointer opt_or_pp(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_pointer val;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  val = o1->v[0].fp(o1);
  if (val != o->sc->F)
    {
      o->sc->pc = o->v[1].i;
      return(val);
    }
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fp(o1));
}

static s7_pointer opt_or_any_p(void *p)
{
  opt_info *o = (opt_info *)p;
  int32_t i;
  oo_rcheck(o->sc, o, 3, 0);
  for (i = 0; i < o->v[1].i; i++)
    {
      s7_pointer val;
      opt_info *o1;
      o1 = o->sc->opts[++o->sc->pc];
      val = o1->v[0].fp(o1);
      if (val != o->sc->F)
	{
	  o->sc->pc = o->v[2].i;
	  return(val);
	}
    }
  return(o->sc->F);
}

static bool opt_cell_and(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  opt_info *opc;
  opc = alloc_opo(sc, car_x);
  if (len == 3)
    {
      opt_info *wrapper;
      int32_t start;
      opc->v[0].fp = ((car(car_x) == sc->or_symbol) ? opt_or_pp : opt_and_pp);
      wrapper = sc->opts[sc->pc];
      start = sc->pc;
      if (!cell_optimize(sc, cdr(car_x)))
	{
	  pc_fallback(sc, start);
	  if (!bool_optimize_nw(sc, cdr(car_x)))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  if (oo_size(wrapper) < 8) oo_resize(wrapper, 8);
	  wrapper->v[7].fb = wrapper->v[0].fb;
	  wrapper->v[0].fp = b_to_p;
	}
      start = sc->pc;
      if (!cell_optimize(sc, cddr(car_x)))
	{
	  pc_fallback(sc, start);
	  if (!bool_optimize_nw(sc, cddr(car_x)))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  if (oo_size(wrapper) < 8) oo_resize(wrapper, 8);
	  wrapper->v[7].fb = wrapper->v[0].fb;
	  wrapper->v[0].fp = b_to_p;
	}
      opc->v[1].i = sc->pc - 1;
      return(oo_set_type_0(opc, 2));
    }
  if (len > 0)
    {
      s7_pointer p;
      opc->v[1].i = (len - 1);
      opc->v[0].fp = ((car(car_x) == sc->or_symbol) ? opt_or_any_p : opt_and_any_p);
      for (p = cdr(car_x); is_pair(p); p = cdr(p))
	{
	  opt_info *wrapper;
	  int32_t start;
	  wrapper = sc->opts[sc->pc];
	  start = sc->pc;
	  if (!cell_optimize(sc, p))
	    {
	      pc_fallback(sc, start);
	      if (!bool_optimize_nw(sc, p))
		return(return_false(sc, car_x, __func__, __LINE__));
	      if (oo_size(wrapper) < 8) oo_resize(wrapper, 8);
	      wrapper->v[7].fb = wrapper->v[0].fb;
	      wrapper->v[0].fp = b_to_p;
	    }
	}
      opc->v[2].i = sc->pc - 1;
      return(oo_set_type_0(opc, 3));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- cell_if -------- */
static s7_pointer opt_if_bp(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fb(o1))
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_bp_nr(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fb(o1))
    {
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  return(NULL);
}

static s7_pointer opt_if_bp_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  if (o->v[2].b_p_f(o1->v[0].fp(o1)))
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_bp_pb(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[7].fp(o1) != o->sc->F)
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_bp_ii_fc(void *p)
{
  opt_info *o1, *o2, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  o2 = o->sc->opts[++o->sc->pc];
  if (o1->v[3].b_ii_f(o2->v[0].fi(o2), o1->v[2].i))
  /* if (o1->v[7].fp(o1) != o->sc->F) */
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 2, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (!o1->v[0].fb(o1))
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}
/* also b_ii_sf (mac) */

static s7_pointer opt_if_nbp_f(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 3, 0);
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  if (!(o->v[2].b_p_f(o1->v[0].fp(o1))))
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp_s(void *p)
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  if (!(o->v[2].b_p_f(slot_value(o->v[3].p))))
    {
      opt_info *o1;
      o->sc->pc += 2;
      o1 = o->sc->opts[o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp_sc(void *p) /* b_pp_sc */
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  if (!(o->v[3].b_pp_f(slot_value(o->v[2].p), o->v[4].p)))
    {
      opt_info *o1;
      o->sc->pc += 2;
      o1 = o->sc->opts[o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp_7sc(void *p) /* b_7pp_sc */
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  if (!(o->v[3].b_7pp_f(o->sc, slot_value(o->v[2].p), o->v[4].p)))
    {
      opt_info *o1;
      o->sc->pc += 2;
      o1 = o->sc->opts[o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp_ss(void *p) /* b_ii_ss */
{
  opt_info *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 2);
  if (!(o->v[3].b_ii_f(integer(slot_value(o->v[2].p)), integer(slot_value(o->v[4].p)))))
    {
      opt_info *o1;
      o->sc->pc += 2;
      o1 = o->sc->opts[o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp_fs(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  if (!(o->v[2].b_pi_f(o->sc, o1->v[0].fp(o1), integer(slot_value(o->v[3].p))))) /* b_pi_fs */
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp_fs_nr(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o1 = o->sc->opts[o->sc->pc];
  if (!(o->v[2].b_pi_f(o->sc, o1->v[0].fp(o1), integer(slot_value(o->v[3].p))))) /* b_pi_fs */
    {
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  return(NULL);
}

static s7_pointer opt_if_nbp_sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  if (!(o->v[2].b_pp_f(slot_value(o->v[3].p), o1->v[0].fp(o1))))   /* b_pp_sf */
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_nbp_7sf(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 1);
  o->sc->pc += 2;
  o1 = o->sc->opts[o->sc->pc];
  if (!(o->v[2].b_7pp_f(o->sc, slot_value(o->v[3].p), o1->v[0].fp(o1))))   /* b_7pp_sf */
    {
      o1 = o->sc->opts[++o->sc->pc];
      return(o1->v[0].fp(o1));
    }
  o->sc->pc = o->v[1].i;
  return(o->sc->unspecified);
}

static s7_pointer opt_if_bpp(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 4, 0);
  o1 = o->sc->opts[++o->sc->pc];
  if (o1->v[0].fb(o1))
    {
      s7_pointer val;
      o1 = o->sc->opts[++o->sc->pc];
      val = o1->v[0].fp(o1);
      o->sc->pc = o->v[3].i;
      return(val);
    }
  o->sc->pc = o->v[1].i;
  o1 = o->sc->opts[++o->sc->pc];
  return(o1->v[0].fp(o1));
}

static bool opt_cell_if(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  opt_info *opc;
  opc = alloc_opo(sc, car_x);
  if (len == 3)
    {
      opt_info *next;
      next = sc->opts[sc->pc];
      if ((is_pair(cadr(car_x))) &&
	  (caadr(car_x) == sc->not_symbol) &&
	  (is_pair(cdadr(car_x))) && /* (if (not)... */
	  (is_null(cddadr(car_x))))  /* (if (not a b)... */
	{
	  if ((bool_optimize(sc, cdadr(car_x))) &&
	      (cell_optimize(sc, cddr(car_x))))
	    {
	      opc->v[0].fp = opt_if_nbp;
	      opc->v[1].i = sc->pc - 1;
	      if (next->v[0].fb == opt_b_p_f)
		{
		  opc->v[2].b_p_f = next->v[2].b_p_f;
		  opc->v[0].fp = opt_if_nbp_f;
		  return(oo_set_type_0(opc, 3));
		}
	      if (next->v[0].fb == opt_b_p_s)
		{
		  opc->v[2].b_p_f = next->v[2].b_p_f;
		  opc->v[3].p = next->v[1].p;
		  opc->v[0].fp = opt_if_nbp_s;
		  return(oo_set_type_1(opc, 4, 3, OO_P));
		}
	      if (next->v[0].fb == opt_b_pi_fs)
		{
		  opc->v[2].b_pi_f = next->v[2].b_pi_f;
		  opc->v[3].p = next->v[1].p;
		  opc->v[0].fp = opt_if_nbp_fs;
		  return(oo_set_type_1(opc, 4, 3, OO_P));
		}
	      if ((next->v[0].fb == opt_b_pp_sf) ||
		  (next->v[0].fb == opt_b_7pp_sf))
		{
		  if (next->v[0].fb == opt_b_pp_sf)
		    {
		      opc->v[2].b_pp_f = next->v[3].b_pp_f;
		      opc->v[0].fp = opt_if_nbp_sf;
		    }
		  else
		    {
		      opc->v[2].b_7pp_f = next->v[3].b_7pp_f;
		      opc->v[0].fp = opt_if_nbp_7sf;
		    }
		  opc->v[3].p = next->v[1].p;
		  return(oo_set_type_1(opc, 4, 3, OO_P));
		}
	      if ((next->v[0].fb == opt_b_pp_sc) ||
		  (next->v[0].fb == opt_b_7pp_sc))
		{
		  if (next->v[0].fb == opt_b_pp_sc)
		    {
		      opc->v[3].b_pp_f = next->v[3].b_pp_f;
		      opc->v[0].fp = opt_if_nbp_sc;
		    }
		  else
		    {
		      opc->v[3].b_7pp_f = next->v[3].b_7pp_f;
		      opc->v[0].fp = opt_if_nbp_7sc;
		    }
		  opc->v[2].p = next->v[1].p;
		  opc->v[4].p = next->v[2].p;
		  return(oo_set_type_1(opc, 5, 2, OO_P));
		}
	      if ((next->v[0].fb == opt_b_ii_ss) ||
		  (next->v[0].fb == opt_b_ii_ss_lt) || (next->v[0].fb == opt_b_ii_ss_gt) || (next->v[0].fb == opt_b_ii_ss_leq) || (next->v[0].fb == opt_b_ii_ss_geq))
		{
		  opc->v[3].b_ii_f = next->v[3].b_ii_f;
		  opc->v[2].p = next->v[1].p;
		  opc->v[4].p = next->v[2].p;
		  opc->v[0].fp = opt_if_nbp_ss;
		  return(oo_set_type_2(opc, 5, 2, 4, OO_I, OO_I));
		}
	      return(oo_set_type_0(opc, 2));
	    }
	}
      else
	{
	  if ((bool_optimize(sc, cdr(car_x))) &&
	      (cell_optimize(sc, cddr(car_x))))
	    {
	      opc->v[0].fp = opt_if_bp;
	      opc->v[1].i = sc->pc - 1;

	      if (next->v[0].fb == p_to_b)
		{
		  opc->v[0].fp = opt_if_bp_pb;
		  return(oo_set_type_0(opc, 2));
		}
	      if (next->v[0].fb == opt_b_p_f)
		{
		  opc->v[2].b_p_f = next->v[2].b_p_f;
		  opc->v[0].fp = opt_if_bp_f;
		  return(oo_set_type_0(opc, 3));
		}
	      if (next->v[0].fb == opt_b_ii_fc)
		{
		  opc->v[0].fp = opt_if_bp_ii_fc;
		  return(oo_set_type_0(opc, 2));
		}
	      return(oo_set_type_0(opc, 2));
	    }
	}
      return(return_false(sc, car_x, __func__, __LINE__));
    }
  if (len == 4)
    {
      if ((bool_optimize(sc, cdr(car_x))) &&
	  (cell_optimize(sc, cddr(car_x))))
	{
	  opc->v[0].fp = opt_if_bpp;
	  opc->v[1].i = sc->pc - 1;
	  if (cell_optimize(sc, cdddr(car_x)))
	    {
	      opc->v[3].i = sc->pc - 1;
	      return(oo_set_type_0(opc, 4));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- cell_case -------- */
static bool case_memv(s7_scheme *sc, s7_pointer x, s7_pointer y)
{
  s7_pointer z;
  if (is_simple(x))
    {
      for (z = y; is_pair(z); z = cdr(z))
	if (x == car(z))
	  return(true);
      return(false);
    }
  for (z = y; is_pair(z); z = cdr(z))
    if (s7_is_eqv(x, car(z))) return(true);
  return(false);
}

static s7_pointer opt_case(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 5, 0);
  o->v[2].p = o->sc->unspecified;
  o1 = o->sc->opts[++o->sc->pc];
  o->v[4].p = o1->v[0].fp(o1);
  while (o->sc->pc < o->v[1].i)
    {
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  return(o->v[2].p);
}

static s7_pointer opt_case_clause(void *p)
{
  /* top->v[2].p gets result, top->i1 is end index, top->v[4].p is selector, o->v[3].i is end of current clause, o->v[1].i = body len */
  opt_info *top, *o = (opt_info *)p;
  oo_rcheck(o->sc, o, 6, 0);
  top = (opt_info *)(o->v[5].obj);
  if ((o->v[2].p == o->sc->else_symbol) ||
      (case_memv(o->sc, top->v[4].p, o->v[2].p)))
    return(case_value(o));
  o->sc->pc = o->v[3].i;
  return(o->sc->unspecified);
}

static bool opt_cell_case(s7_scheme *sc, s7_pointer car_x)
{
  /* top->v[2].p gets result, top->v[1].i is end index, clause->v[3].i is end of current clause,
   * clause->v[1].i = clause result len, clause->v[5].obj = top
   */
  opt_info *top;
  top = alloc_opo(sc, car_x);
  if (cell_optimize(sc, cdr(car_x))) /* selector */
    {
      s7_pointer p;
      for (p = cddr(car_x); is_pair(p); p = cdr(p))
	{
	  opt_info *opc;
	  s7_pointer clause, cp;
	  int32_t blen;
	  clause = car(p);
	  if ((!is_pair(clause)) ||
	      ((!is_pair(car(clause))) && (car(clause) != sc->else_symbol)) ||
	      (!is_pair(cdr(clause))) ||
	      (cadr(clause) == sc->feed_to_symbol))
	    return(return_false(sc, clause, __func__, __LINE__));

	  opc = alloc_opo(sc, car_x);
	  if (car(clause) == sc->else_symbol)
	    {
	      if (!is_null(cdr(p)))
		return(return_false(sc, clause, __func__, __LINE__));
	      opc->v[2].p = sc->else_symbol;
	    }
	  else
	    {
	      if (!s7_is_proper_list(sc, car(clause)))
		return(return_false(sc, clause, __func__, __LINE__));
	      opc->v[2].p = car(clause);
	    }

	  for (blen = 0, cp = cdr(clause); is_pair(cp); blen++, cp = cdr(cp))
	    if (!cell_optimize(sc, cp))
	      return(return_false(sc, cp, __func__, __LINE__));
	  if (!is_null(cp))
	    return(return_false(sc, cp, __func__, __LINE__));
	  opc->v[1].i = blen;
	  opc->v[3].i = sc->pc - 1;
	  opc->v[5].obj = (void *)top;
	  opc->v[0].fp = opt_case_clause;
	  oo_set_type_0(opc, 6);
	}
      if (!is_null(p))
	return(return_false(sc, p, __func__, __LINE__));
      top->v[1].i = sc->pc - 1;
      top->v[0].fp = opt_case;
      return(oo_set_type_0(top, 5));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- cell_let_temporarily -------- */
static s7_pointer opt_let_temporarily(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t tx, i, len;
  s7_pointer result;

  oo_rcheck(o->sc, o, 5, 1);
  tx = next_tx(o->sc);
  o1 = o->sc->opts[++o->sc->pc];

  o->v[4].p = slot_value(o->v[1].p);         /* save and protect old value */
  o->sc->t_temps[tx] = o->v[4].p;
  if (is_immutable_slot(o->v[1].p))
    immutable_object_error(o->sc, set_elist_3(o->sc, immutable_error_string, o->sc->let_temporarily_symbol, slot_symbol(o->v[1].p)));
  slot_set_value(o->v[1].p, o1->v[0].fp(o1)); /* set new value */

  len = o->v[2].i - 1;
  for (i = 0; i < len; i++)
    {
      o1 = o->sc->opts[++o->sc->pc];
      o1->v[0].fp(o1);
    }
  o1 = o->sc->opts[++o->sc->pc];
  result = o1->v[0].fp(o1);

  slot_set_value(o->v[1].p, o->v[4].p);      /* restore old */
  return(result);
}

static bool opt_cell_let_temporarily(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  s7_pointer vars;
  if (len <= 2)
    return(return_false(sc, car_x, __func__, __LINE__));

  vars = cadr(car_x);
  if ((is_pair(vars)) &&
      (is_pair(car(vars))) &&
      (is_null(cdr(vars))) &&        /* just one var for now */
      (is_symbol(caar(vars))) &&     /*   and var is (sym val) */
      (is_pair(cdar(vars))) &&
      (is_null(cddar(vars))) &&
      (!is_immutable(caar(vars))) &&
      (!is_syntactic_symbol(caar(vars))))
    {
      s7_pointer p;
      opt_info *opc;
      opc = alloc_opo(sc, car_x);
      opc->v[1].p = symbol_to_slot(sc, caar(cadr(car_x)));
      if (!is_slot(opc->v[1].p))
	return(return_false(sc, car_x, __func__, __LINE__));

      if (!cell_optimize(sc, cdar(cadr(car_x))))
	return(return_false(sc, car_x, __func__, __LINE__));
      for (p = cddr(car_x); is_pair(p); p = cdr(p))
	if (!cell_optimize(sc, p))
	  return(return_false(sc, car_x, __func__, __LINE__));

      opc->v[2].i = len - 2;
      opc->v[0].fp = opt_let_temporarily;
      return(oo_set_type_1(opc, 5, 1, OO_P));
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

/* -------- cell_do -------- */
static s7_pointer opt_do_no_vars(void *p)
{
  /* no vars, no return */
  opt_info *o = (opt_info *)p; /* o->v[2].p=frame, o->v[1].i=body end index, o->v[3].i=body length, o->v[4].i=return length, o->v[5].i=end index */
  opt_info *ostart;
  int32_t loop;
  s7_pointer old_e;
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 6, 0);
  old_e = sc->envir;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, old_e);
  sc->envir = o->v[2].p;

  loop = ++sc->pc;
  ostart = sc->opts[loop];
  if (o->v[3].i == 0)
    {
      while (true)
	{
	  if (ostart->v[0].fb(ostart)) break;
	  sc->pc = loop;
	}
    }
  else
    {
      while (true)
	{
	  int32_t i;
	  if (ostart->v[0].fb(ostart)) break;
	  for (i = 0; i < o->v[3].i; i++)
	    {
	      opt_info *o1;
	      o1 = sc->opts[++sc->pc];
	      o1->v[0].fp(o1);
	    }
	  sc->pc = loop;
	}
    }
  sc->pc = o->v[5].i;
  unstack(sc);
  sc->envir = old_e;
  return(sc->T);
}

static s7_pointer opt_do_1(void *p)
{
  /* 1 var, 1 expr, no return */
  opt_info *o1, *ostart, *o = (opt_info *)p; /* o->v[2].p=frame, o->v[5].i=end index */
  int32_t loop;
  s7_pointer vp, old_e;
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 6, 0);
  old_e = sc->envir;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, old_e);
  sc->envir = o->v[2].p;

  vp = let_slots(o->v[2].p);
  o1 = sc->opts[++sc->pc];
  slot_set_value(vp, o1->v[0].fp(o1));

  loop = ++sc->pc;
  ostart = sc->opts[loop];
  while (true)
    {
      if (ostart->v[0].fb(ostart)) break;
      o1 = sc->opts[++sc->pc];
      o1->v[0].fp(o1);
      o1 = sc->opts[++sc->pc];
      slot_set_value(vp, o1->v[0].fp(o1));
      sc->pc = loop;
    }
  sc->pc = o->v[5].i;
  unstack(sc);
  sc->envir = old_e;
  return(sc->T);
}

static s7_pointer opt_do_n(void *p)
{
  /* 1 var, no return */
  opt_info *o1, *ostart, *o = (opt_info *)p; /* o->v[2].p=frame, o->v[1].i=body end index, o->v[3].i=body length, o->v[4].i=return length, o->v[5].i=end index */
  int32_t loop;
  s7_pointer vp, old_e;
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 6, 0);
  old_e = sc->envir;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, old_e);
  sc->envir = o->v[2].p;

  vp = let_slots(o->v[2].p);
  o1 = sc->opts[++sc->pc];
  slot_set_value(vp, o1->v[0].fp(o1));

  loop = ++sc->pc;
  ostart = sc->opts[loop];
  if (o->v[3].i == 2)
    {
      while (true)
	{
	  if (ostart->v[0].fb(ostart)) break;
	  o1 = sc->opts[++sc->pc];
	  o1->v[0].fp(o1);
	  o1 = sc->opts[++sc->pc];
	  o1->v[0].fp(o1);
	  o1 = sc->opts[++sc->pc];
	  slot_set_value(vp, o1->v[0].fp(o1));
	  sc->pc = loop;
	}
    }
  else
    {
      while (true)
	{
	  int32_t i;
	  if (ostart->v[0].fb(ostart))
	    break;
	  for (i = 0; i < o->v[3].i; i++)
	    {
	      o1 = sc->opts[++sc->pc];
	      o1->v[0].fp(o1);
	    }
	  o1 = sc->opts[++sc->pc];
	  slot_set_value(vp, o1->v[0].fp(o1));
	  sc->pc = loop;
	}
    }
  sc->pc = o->v[5].i;
  unstack(sc);
  sc->envir = old_e;
  return(sc->T);
}

static s7_pointer opt_dotimes_2(void *p)
{
  /* 1 var, no return */
  opt_info *o1, *o = (opt_info *)p; /* o->v[2].p=frame, o->v[1].i=body end index, o->v[3].i=body length, o->v[4].i=return length, o->v[5].i=end index, v6.i=end if int32_t */
  int32_t loop;
  s7_int end;
  s7_pointer vp, old_e;
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 6, 0);
  old_e = sc->envir;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, old_e);
  sc->envir = o->v[2].p;

  vp = slot_value(dox_slot1(o->v[2].p));
  if (is_slot(dox_slot2_unchecked(o->v[2].p)))
    end = integer(slot_value(dox_slot2(o->v[2].p)));
  else end = o->v[6].i;

  o1 = sc->opts[++sc->pc];
  integer(vp) = integer(o1->v[0].fp(o1));

  loop = o->v[4].i - 1;
  if (o->v[3].i == 2)
    {
      while (integer(vp) < end)
	{
	  sc->pc = loop;
	  o1 = sc->opts[++sc->pc];
	  o1->v[0].fp(o1);
	  o1 = sc->opts[++sc->pc];
	  o1->v[0].fp(o1);
	  integer(vp)++;
	}
    }
  else
    {
      while (integer(vp) < end)
	{
	  int32_t i;
	  sc->pc = loop;
	  for (i = 0; i < o->v[3].i; i++)
	    {
	      o1 = sc->opts[++sc->pc];
	      o1->v[0].fp(o1);
	    }
	  integer(vp)++;
	}
    }
  sc->pc = o->v[5].i;
  unstack(sc);
  sc->envir = old_e;
  return(sc->T);
}

static s7_pointer opt_do_list_simple(void *p)
{
  /* 1 var, 1 expr, no return, step by cdr, end=null? */
  opt_info *o1, *o = (opt_info *)p; /* o->v[2].p=frame, o->v[5].i=end index */
  int32_t loop;
  s7_pointer vp, old_e;
  s7_scheme *sc;
  s7_pointer (*fp)(void *o);
  sc = o->sc;

  oo_rcheck(sc, o, 6, 0);
  old_e = sc->envir;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, old_e);
  sc->envir = o->v[2].p;

  vp = let_slots(o->v[2].p);
  o1 = sc->opts[++sc->pc];
  slot_set_value(vp, o1->v[0].fp(o1));

  loop = sc->pc + 2;
  o1 = sc->opts[loop];

  fp = o1->v[0].fp;
  if (fp == opt_if_bp) fp = opt_if_bp_nr;
  while (!is_null(slot_value(vp)))
    {
      sc->pc = loop;
      fp(o1);
      slot_set_value(vp, cdr(slot_value(vp)));
    }
  sc->pc = o->v[5].i;
  unstack(sc);
  sc->envir = old_e;
  return(sc->T);
}

static s7_pointer opt_do_very_simple(void *p)
{
  /* like simple but step can be direct */
  opt_info *o1, *o = (opt_info *)p;
  s7_int end, loop;
  s7_pointer vp, old_e;
  s7_pointer (*f)(void *p);
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 6, 0); /* v[2].p is a let */
  old_e = sc->envir;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, old_e);
  sc->envir = o->v[2].p;

  vp = slot_value(dox_slot1(o->v[2].p));
  if (is_slot(dox_slot2_unchecked(o->v[2].p)))
    end = integer(slot_value(dox_slot2(o->v[2].p)));
  else end = o->v[3].i;
  o1 = sc->opts[++sc->pc];
  integer(vp) = integer(o1->v[0].fp(o1));

  loop = o->v[4].i;
  sc->pc = loop;
  o1 = sc->opts[loop]; /* the body */
  f = o1->v[0].fp;
  while (integer(vp) < end)
    {
      f(o1);
      sc->pc = loop;
      integer(vp)++;
    }
  sc->pc = o->v[5].i;
  unstack(sc);
  sc->envir = old_e;
  return(sc->T);
}

static s7_pointer opt_do_prepackaged(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  s7_int end;
  s7_pointer vp, old_e;
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 6, 0);
  old_e = sc->envir;
  push_stack_no_let_no_code(sc, OP_GC_PROTECT, old_e);
  sc->envir = o->v[2].p;

  vp = slot_value(dox_slot1(o->v[2].p));
  if (is_slot(dox_slot2_unchecked(o->v[2].p)))
    end = integer(slot_value(dox_slot2(o->v[2].p)));
  else end = o->v[3].i;
  o1 = sc->opts[++sc->pc];
  integer(vp) = integer(o1->v[0].fp(o1));

  o->v[6].p = vp;
  o->v[1].i = end;
  o->v[7].fp(o);

  sc->pc = o->v[5].i;
  unstack(sc);
  sc->envir = old_e;
  return(sc->T);
}

static s7_pointer opt_do_dpnr(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t loop;
  s7_pointer vp;
  s7_int end;
  s7_double (*f)(void *p);
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 7, 0);
  end = o->v[1].i;
  vp = o->v[6].p;
  loop = o->v[4].i;
  o1 = sc->opts[loop]; /* the body */
  f = o1->v[7].fd;
  while (integer(vp) < end)
    {
      sc->pc = loop;
      f(o1);
      integer(vp)++;
    }
  return(NULL);
}

static s7_pointer opt_do_ipnr(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t loop;
  s7_pointer vp;
  s7_int end;
  s7_int (*f)(void *p);
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 7, 0);
  end = o->v[1].i;
  vp = o->v[6].p;
  loop = o->v[4].i;
  o1 = sc->opts[loop]; /* the body */
  f = o1->v[7].fi;
  while (integer(vp) < end)
    {
      sc->pc = loop;
      f(o1);
      integer(vp)++;
    }
  return(NULL);
}

static s7_pointer opt_do_ifbp(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t loop;
  s7_pointer vp;
  s7_int end;
  bool (*f)(void *p);
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 7, 0);
  end = o->v[1].i;
  vp = o->v[6].p;
  loop = o->v[4].i + 1;
  o1 = sc->opts[loop];
  f = o1->v[0].fb;
  while (integer(vp) < end)
    {
      sc->pc = loop;
      if (f(o1))
	{
	  opt_info *o2;
	  o2 = sc->opts[++sc->pc];
	  o2->v[0].fp(o2);
	}
      integer(vp)++;
    }
  return(NULL);
}

static s7_pointer opt_do_setpif(void *p)
{
  opt_info *o1, *o = (opt_info *)p;
  int32_t loop;
  s7_pointer vp, val;
  s7_int end;
  s7_scheme *sc;
  sc = o->sc;

  oo_rcheck(sc, o, 5, 2);
  end = o->v[1].i;
  vp = o->v[6].p;
  loop = o->v[4].i;
  o1 = sc->opts[loop];

  val = make_mutable_integer(sc, integer(slot_value(o1->v[1].p)));
  slot_set_value(o1->v[1].p, val);
  while (integer(vp) < end)
    {
      integer(val) = o1->v[4].i_ii_f(integer(slot_value(o1->v[2].p)), o1->v[3].i);
      integer(vp)++;
    }
  return(NULL);
}

static bool stop_is_safe(s7_scheme *sc, s7_pointer stop, s7_pointer body)
{
  /* this could be folded into the cell_optimize traveral */
  s7_pointer p;
  for (p = body; is_pair(p); p = cdr(p))
    if ((is_pair(car(p))) &&
	(caar(p) == sc->set_symbol) &&
	(is_pair(cdar(p))) &&
	(cadar(p) == stop))
      return(!s7_tree_memq(sc, stop, cdr(p)));
  return(true);
}

static bool do_is_safe(s7_scheme *sc, s7_pointer body, s7_pointer steppers, s7_pointer var_list, bool *has_set);

static bool opt_cell_do(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  opt_info *opc;
  s7_pointer p, end, frame = NULL, old_e, slot, stop, ind, ind_step, var;
  int32_t i, var_len, body_len, body_index, step_len, rtn_len;
  bool has_set = false;

  if (len < 3)
    return(return_false(sc, car_x, __func__, __LINE__));

  if (!s7_is_proper_list(sc, cadr(car_x)))
    return(return_false(sc, car_x, __func__, __LINE__));
  var_len = safe_list_length(cadr(car_x));
  step_len = var_len;
  body_len = len - 3;
  end = caddr(car_x);
  if (!is_pair(end))
    return(return_false(sc, car_x, __func__, __LINE__));

  old_e = sc->envir;
  opc = alloc_opo(sc, car_x);

  new_frame(sc, sc->envir, frame);
  push_stack(sc, OP_GC_PROTECT, old_e, frame);

  /* the vars have to be added to the frame before evaluating the inits
   *    else symbol_id can be > let_id (see "(test (do ((i (do ((i (do ((i 0 (+ i 1)))...")
   */
  clear_symbol_list(sc);
  for (p = cadr(car_x); is_pair(p); p = cdr(p))
    {
      s7_pointer var, sym;
      var = car(p);
      if ((is_pair(var)) &&
	  (is_symbol(car(var))) &&
	  (is_pair(cdr(var))))
	{
	  sym = car(var);

	  if ((is_constant_symbol(sc, sym)) ||
	      (symbol_has_setter(sym)))
	    return(return_false(sc, car_x, __func__, __LINE__));
	  if (symbol_is_in_list(sc, sym))
	    eval_error(sc, "duplicate identifier in do: ~A", 30, var);
	  add_symbol_to_list(sc, sym);
	  add_slot(frame, sym, sc->undefined);
	}
      else return(return_false(sc, car_x, __func__, __LINE__));
    }

  if (tis_slot(let_slots(frame)))
    let_set_slots(frame, reverse_slots(sc, let_slots(frame)));

  for (p = cadr(car_x), slot = let_slots(frame); is_pair(p); p = cdr(p), slot = next_slot(slot))
    {
      s7_pointer var;
      var = car(p);
      if (!cell_optimize(sc, cdr(var))) /* opt init in outer env */
	return(return_false(sc, car_x, __func__, __LINE__));
      if (is_pair(cddr(var)))
	{
	  set_has_stepper(slot);
	  if (!is_null(cdddr(var)))
	    return(return_false(sc, car_x, __func__, __LINE__));
	}
      else
	{
	  step_len--;
	  if (!is_null(cddr(var)))
	    return(return_false(sc, car_x, __func__, __LINE__));
	}
      if (is_symbol(cadr(var)))
	slot_set_value(slot, slot_value(symbol_to_slot(sc, cadr(var))));
      else
	{
	  if (!is_pair(cadr(var)))
	    slot_set_value(slot, cadr(var));
	  else
	    {
	      if (is_proper_quote(sc, cadr(var)))
		slot_set_value(slot, cadadr(var));
	      else
		{
		  s7_pointer sf;
		  sf = lookup_checked(sc, caadr(var));
		  if (is_c_function(sf))
		    {
		      s7_pointer sig;
		      sig = c_function_signature(sf);
		      if ((is_pair(sig)) &&
			  ((car(sig) == sc->is_integer_symbol) ||
			   ((is_pair(car(sig))) &&
			    (direct_memq(sc->is_integer_symbol, car(sig))))))
			slot_set_value(slot, small_int(0));
		    }}}}}
  sc->envir = frame;
  for (p = cadr(car_x); is_pair(p); p = cdr(p))
    {
      s7_pointer var;
      var = car(p);
      if (is_pair(cddr(var)))
	{
	  s7_pointer init_type;
	  init_type = opt_arg_type(sc, cdr(var));
	  if (((init_type == sc->is_integer_symbol) ||
	       (init_type == sc->is_float_symbol)) &&
	      (opt_arg_type(sc, cddr(var)) != init_type))
	    {
#if OPT_PRINT
	      fprintf(stderr, "init_type: %s, but opt_arg: %s\n", DISPLAY(init_type), DISPLAY(opt_arg_type(sc, cddr(var))));
#endif
	      unstack(sc); /* not pop_stack! */
	      sc->envir = old_e;
	      return(return_false(sc, car_x, __func__, __LINE__));
	    }
	}
    }

  if (!bool_optimize_nw(sc, end))
    {
      unstack(sc); /* not pop_stack! */
      sc->envir = old_e;
      return(return_false(sc, car_x, __func__, __LINE__));
    }

  stop = car(end);
  if ((is_pair(stop)) &&
      ((car(stop) == sc->eq_symbol) || (car(stop) == sc->geq_symbol) || (car(stop) == sc->gt_symbol)) &&
      (is_pair(cdr(stop))) &&
      (is_symbol(cadr(stop))) &&
      (is_pair(cddr(stop))) &&
      (is_null(cdddr(stop))) &&
      ((is_opt_int(caddr(stop))) || (is_symbol(caddr(stop)))))
    {
      s7_pointer stop_slot;
      if (is_symbol(caddr(stop)))
	stop_slot = opt_integer_symbol(sc, caddr(stop));
      else stop_slot = sc->nil;
      if (stop_slot)
	{
	  s7_int lim;
	  bool set_stop = false;
	  s7_pointer slot;

	  if (is_slot(stop_slot))
	    lim = integer(slot_value(stop_slot));
	  else lim = integer(caddr(stop));
	  if (car(stop) == sc->gt_symbol) lim++;

	  for (p = cadr(car_x), slot = let_slots(frame); is_pair(p); p = cdr(p), slot = next_slot(slot))
	    {
	      /* this could be put off until it is needed (ref/set), but this code is not called much
	       *    another choice: go from init downto 0: init is lim
	       */
	      if (slot_symbol(slot) == cadr(stop))
		set_stop = true; /* don't overrule this decision below */
	      if (has_stepper(slot))
		{
		  s7_pointer var, step;
		  var = car(p);
		  step = caddr(var);
		  if ((is_opt_int(slot_value(slot))) &&
		      (is_pair(step)) &&
		      (is_pair(cdr(step))) &&
		      (car(var) == cadr(stop)) &&
		      (car(var) == cadr(step)) &&
		      ((car(stop) != sc->eq_symbol) || /* else > protects at least the top */
		       ((caddr(step) == small_int(1)) && (car(step) == sc->add_symbol))))
		    {
		      set_step_end(slot);
		      denominator(slot_value(slot)) = lim;
		    }
		}
	    }

	  if (!set_stop)
	    {
	      s7_pointer slot;
	      slot = opt_integer_symbol(sc, cadr(stop));
	      if ((slot) &&
		  (stop_is_safe(sc, cadr(stop), cddr(car_x))))
		{
		  set_step_end(slot);
		  denominator(slot_value(slot)) = lim;
		}
	    }
	}
    }

  body_index = sc->pc;
  for (i = 3, p = cdddr(car_x); i < len; i++, p = cdr(p))
    {
      opt_info *start;
      start = sc->opts[sc->pc];
      if (!cell_optimize(sc, p))
	break;
      oo_idp_nr_fixup(start);
    }

  if (!is_null(p))
    {
      unstack(sc);
      sc->envir = old_e;
      return(return_false(sc, car_x, __func__, __LINE__));
    }

  for (p = cadr(car_x); is_pair(p); p = cdr(p))
    {
      s7_pointer var;
      var = car(p);
      if ((is_pair(cddr(var))) &&
	  (!cell_optimize(sc, cddr(var))))
	break;
    }

  if (!is_null(p))
    {
      unstack(sc);
      sc->envir = old_e;
      return(return_false(sc, car_x, __func__, __LINE__));
    }

  rtn_len = 0;
  opc->v[1].i = sc->pc - 1;
  if (!is_list(cdr(end)))
    {
      unstack(sc);
      sc->envir = old_e;
      return(return_false(sc, car_x, __func__, __LINE__));
    }
  for (p = cdr(end); is_pair(p); p = cdr(p), rtn_len++)
    if (!cell_optimize(sc, p))
      break;
  if (!is_null(p))
    {
      unstack(sc);
      sc->envir = old_e;
      return(return_false(sc, car_x, __func__, __LINE__));
    }
  opc->v[2].p = frame;
  opc->v[3].i = len - 3; /* body_len */
  opc->v[4].i = rtn_len;
  opc->v[5].i = sc->pc - 1;
  sc->envir = old_e;

  if ((var_len == 0) && (rtn_len == 0))
    {
      opc->v[0].fp = opt_do_no_vars;
      return(oo_set_type_0(opc, 6));
    }

  if ((var_len != 1) || (step_len != 1) || (rtn_len != 0))
    {
      /* two steppers by 1, or -1/cdr or non-stepper(s)+step1 or step1+float-step */
      unstack(sc);
      sc->envir = old_e;
      return(return_false(sc, car_x, __func__, __LINE__));
    }

  opc->v[0].fp = (body_len == 1) ? opt_do_1 : opt_do_n;

  /* just a first stab at this
   *    set|let-set? if not caddr, hash-table|vector|list-set if not cadddr: old code checks !has_set for dotimes
   *    implicit set similar
   *    also (+ 1 ind) and (= end ind) and >= and body_len=any but still safe_stepper(s)
   */
  var = caadr(car_x);
  ind = car(var);
  ind_step = caddr(var);
  end = caaddr(car_x);
  slot = let_slots(frame);

  if ((is_pair(end)) &&                      /* (= i len|100) */
      (cadr(end) == ind) &&
      (is_pair(ind_step)))                   /* (+ i 1) */
    {
      if (((car(end) == sc->eq_symbol) || (car(end) == sc->geq_symbol)) &&
	  ((is_symbol(caddr(end))) || (is_t_integer(caddr(end)))) &&
	  (is_null(cdddr(end))) &&
	  (car(ind_step) == sc->add_symbol) &&
	  (cadr(ind_step) == ind) &&
	  (caddr(ind_step) == small_int(1)) &&
	  (is_null(cdddr(ind_step))) &&
	  (do_is_safe(sc, cdddr(car_x), sc->w = list_1(sc, ind), sc->nil, &has_set)))
	{
	  dox_set_slot1(frame, slot);
	  dox_set_slot2_unchecked(frame, (is_symbol(caddr(end))) ? symbol_to_slot(sc, caddr(end)) : sc->undefined);
	  slot_set_value(slot, make_mutable_integer(sc, integer(slot_value(slot))));
	  opc->v[4].i = body_index;
	  if (body_len == 1)
	    {
	      opt_info *o1;
	      opc->v[0].fp = opt_do_very_simple;
	      if (is_t_integer(caddr(end)))
		opc->v[3].i = integer(caddr(end));

	      o1 = sc->opts[body_index];
	      /* v2, v3, v4, v5 are in use */
	      if (o1->v[0].fp == d_to_p_nr)
		{
		  /* snd-test: (do ((k 0 (+ k 1))) ((= k N)) (float-vector-set! rl k (read-sample rd))) */
		  opc->v[0].fp = opt_do_prepackaged;
		  opc->v[7].fp = opt_do_dpnr;
		}
	      else
		{
		  if (o1->v[0].fp == i_to_p_nr)
		    {
		      opc->v[0].fp = opt_do_prepackaged;
		      opc->v[7].fp = opt_do_ipnr;
		    }
		  else
		    {
		      if (o1->v[0].fp == opt_if_bp)
			{
			  opc->v[0].fp = opt_do_prepackaged;
			  opc->v[7].fp = opt_do_ifbp;
			}
		      else
			{
			  if (o1->v[0].fp == opt_set_p_i_fo1)
			    {
			      opc->v[0].fp = opt_do_prepackaged;
			      opc->v[7].fp = opt_do_setpif;
			    }}}}}
	  else
	    {
	      opc->v[0].fp = opt_dotimes_2;
	      if (is_t_integer(caddr(end)))
		opc->v[6].i = integer(caddr(end));
	    }
	}
      else
	{
	  if ((car(end) == sc->is_null_symbol) &&
	      (is_null(cddr(end))) &&
	      (car(ind_step) == sc->cdr_symbol) &&
	      (cadr(ind_step) == ind) &&
	      (is_null(cddr(ind_step))) &&
	      (body_len == 1) &&
	      (do_is_safe(sc, cdddr(car_x), sc->w = list_1(sc, ind), sc->nil, &has_set)))
	    opc->v[0].fp = opt_do_list_simple;
	}
    }
  return(oo_set_type_0(opc, 8));
}

static bool p_syntax(s7_scheme *sc, s7_pointer car_x, int32_t len)
{
  opcode_t op;
  s7_pointer func;
  func = slot_value(global_slot(car(car_x)));
  op = (opcode_t)syntax_opcode(func);
  switch (op)
    {
    case OP_QUOTE:
      if ((is_pair(cdr(car_x))) && (is_null(cddr(car_x))))
	return(opt_cell_quote(sc, car_x));
      break;

    case OP_SET:
      if (len == 3)
	return(opt_cell_set(sc, car_x));
      break;

    case OP_BEGIN:
      if (len > 1)
	return(opt_cell_begin(sc, car_x, len));
      break;

    case OP_WHEN:
    case OP_UNLESS:
      if (len > 2)
	return(opt_cell_when(sc, car_x, len));
      break;

    case OP_COND:
      if (len > 1)
	return(opt_cell_cond(sc, car_x));
      break;

    case OP_AND:
    case OP_OR:
      return(opt_cell_and(sc, car_x, len));

    case OP_IF:
      return(opt_cell_if(sc, car_x, len));

    case OP_CASE:
      if (len > 2)
	return(opt_cell_case(sc, car_x));
      break;

    case OP_LET_TEMPORARILY:
      return(opt_cell_let_temporarily(sc, car_x, len));

    case OP_DO:
      return(opt_cell_do(sc, car_x, len));

    default:
      break;
    }
  /* longjmp(sc->opt_exit, 1); */ /* what good could it do to back up?  But we need to make sure sc->envir isn't clobbered (in op_do??) */
  return(return_false(sc, car_x, __func__, __LINE__));
}


/* -------------------------------------------------------------------------------- */
static bool float_optimize(s7_scheme *sc, s7_pointer expr)
{
  s7_pointer car_x, head;
#if (WITH_GMP)
  return(return_false(sc, car_x, __func__, __LINE__));
#endif
  car_x = car(expr);
  if (!is_pair(car_x)) /* wrap constants/symbols */
    return(opt_float_not_pair(sc, car_x));

  head = car(car_x);
  if (is_symbol(head))
    {
      /* get func, check sig, check all args */
      s7_pointer s_func;
      s7_int len;

      len = s7_list_length(sc, car_x);
      /* need to check int_opt here */

      if ((is_syntactic_symbol(head)) ||
	  (is_syntactic_pair(car_x)))
	return(d_syntax_ok(sc, car_x, len));

      if ((is_global(head)) ||
	  ((is_slot(global_slot(head))) &&
	   (symbol_to_slot(sc, head) == global_slot(head))))
	s_func = slot_value(global_slot(head));
      else return(d_implicit_ok(sc, car_x, len));

      if (is_c_function(s_func))
	{
	  opt_info *opc;
	  opc = alloc_opo(sc, car_x);
	  switch (len)
	    {
	    case 1:
	      if (d_ok(sc, opc, s_func))
		return(true);
	      break;

	    case 2:                            /* (f v) or (f d): (env e) or (abs x) */
	      if ((d_d_ok(sc, opc, s_func, car_x)) ||
		  (d_v_ok(sc, opc, s_func, car_x)) ||
		  (d_p_ok(sc, opc, s_func, car_x)))
		return(true);
	      break;

	    case 3:
	      if ((d_dd_ok(sc, opc, s_func, car_x)) ||
		  (d_vd_ok(sc, opc, s_func, car_x)) ||
		  (d_id_ok(sc, opc, s_func, car_x)) ||
		  (d_pd_ok(sc, opc, s_func, car_x)) ||
		  (d_ip_ok(sc, opc, s_func, car_x)) ||
		  (d_7pi_ok(sc, opc, s_func, car_x)))
		return(true);
	      break;

	    case 4:
	      if ((d_ddd_ok(sc, opc, s_func, car_x)) ||
		  (d_7pid_ok(sc, opc, s_func, car_x)) ||
		  (d_vid_ok(sc, opc, s_func, car_x)) ||
		  (d_vdd_ok(sc, opc, s_func, car_x)) ||
		  (d_7pii_ok(sc, opc, s_func, car_x)))
		return(true);

	      break;

	    case 5:
	      if ((d_dddd_ok(sc, opc, s_func, car_x)) ||
		  (d_7piid_ok(sc, opc, s_func, car_x)))
		return(true);
	      break;

	    default:
	      if (d_add_any_ok(sc, opc, car_x, len))
		return(true);
	      break;
	    }
	}
      else
	{
	  if (is_macro(s_func))
	    {
 	      if (!pair_no_opt(expr))
 		return(float_optimize(sc, set_plist_1(sc, s7_macroexpand(sc, s_func, cdar(expr))))); /* is this use of plist safe? */
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool int_optimize(s7_scheme *sc, s7_pointer expr)
{
  s7_pointer car_x, head;
  /* fprintf(stderr, "%s: %s\n", __func__, DISPLAY(expr)); */
#if (WITH_GMP)
  return(return_false(sc, car_x, __func__, __LINE__));
#endif
  car_x = car(expr);

  if (!is_pair(car_x)) /* wrap constants/symbols */
    return(opt_int_not_pair(sc, car_x));

  head = car(car_x);
  if (is_symbol(head))
    {
      s7_pointer s_func;
      s7_int len;
      len = s7_list_length(sc, car_x);

      if ((is_syntactic_symbol(head)) ||
	  (is_syntactic_pair(car_x)))
	return(i_syntax_ok(sc, car_x, len));

      if ((is_global(head)) ||
	  ((is_slot(global_slot(head))) &&
	   (symbol_to_slot(sc, head) == global_slot(head))))
	s_func = slot_value(global_slot(head));
      else return(i_implicit_ok(sc, car_x, len));

      if (is_c_function(s_func))
	{
	  opt_info *opc;
	  opc = alloc_opo(sc, car_x);
	  switch (len)
	    {
	    case 2:
	      if (i_idp_ok(sc, opc, s_func, car_x))
		return(true);
	      break;

	    case 3:
	      if ((i_ii_ok(sc, opc, s_func, car_x)) ||
		  (i_7pi_ok(sc, opc, s_func, car_x)))
		return(true);
	      break;

	    case 4:
	      if ((i_iii_ok(sc, opc, s_func, car_x)) ||
		  (i_7pii_ok(sc, opc, s_func, car_x)))
		return(true);
	      break;

	    case 5:
	      {
		int32_t pstart;
		pstart = sc->pc;
		if (i_7piii_ok(sc, opc, s_func, car_x))
		  return(true);
		pc_fallback(sc, pstart);
	      }
	      /* break; */

	    default:
	      if (((head == sc->add_symbol) ||
		   (head == sc->multiply_symbol)) &&
		  (i_add_any_ok(sc, opc, car_x)))
		return(true);
	      break;
	    }
	}
      else
	{
	  if (is_macro(s_func))
	    {
 	      if (!pair_no_opt(expr))
 		return(int_optimize(sc, set_plist_1(sc, s7_macroexpand(sc, s_func, cdar(expr)))));
	    }}}
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool cell_optimize(s7_scheme *sc, s7_pointer expr)
{
  s7_pointer car_x, head;
  /* fprintf(stderr, "%s: %s, %d\n", __func__, DISPLAY(expr), sc->pc); */

  car_x = car(expr);
  if (!is_pair(car_x)) /* wrap constants/symbols */
    return(opt_cell_not_pair(sc, car_x));

  head = car(car_x);
  if (is_symbol(head))
    {
      s7_pointer s_func = NULL;
      s7_int len;
      len = s7_list_length(sc, car_x);

      if ((is_syntactic_symbol(head)) ||
	  (is_syntactic_pair(car_x)))
	return(p_syntax(sc, car_x, len));

      if ((is_global(head)) ||
	  ((is_slot(global_slot(head))) &&
	   (symbol_to_slot(sc, head) == global_slot(head))))
	s_func = slot_value(global_slot(head));
      else return(p_implicit(sc, car_x, len));

      if (is_c_function(s_func))
	{
	  opt_info *opc;
	  s7_pointer sig;
	  int32_t pstart;

	  sig = c_function_signature(s_func);
	  opc = alloc_opo(sc, car_x);
	  pstart = sc->pc;

	  switch (len)
	    {
	    case 1:
	      if (p_ok(sc, opc, s_func, car_x))
		return(true);
	      break;

	    case 2:
	      if ((p_i_ok(sc, opc, s_func, car_x, sc->pc)) ||
		  (p_d_ok(sc, opc, s_func, car_x, sc->pc)) ||
		  (p_p_ok(sc, opc, s_func, car_x)))
		return(true);
	      break;

	    case 3:
	      {
		s7_i_ii_t ifunc;
		if (is_symbol(cadr(car_x)))
		  {
		    if ((is_pair(sig)) &&
			(is_pair(cdr(sig))) &&
			(is_pair(cddr(sig))) &&
			(caddr(sig) == sc->is_integer_symbol))
		      {
			if (p_pi_ok(sc, opc, s_func, sig, car_x))
			  return(true);

			if ((car(sig) == sc->is_float_symbol) ||
			    (car(sig) == sc->is_real_symbol))
			  {
			    s7_d_7pi_t f;
			    f = s7_d_7pi_function(s_func);
			    if (f)
			      {
				sc->pc = pstart - 1;
				if (float_optimize(sc, expr))
				  {
				    if (oo_size(opc) < 8) oo_resize(opc, 8);
				    opc->v[7].fd = opc->v[0].fd;
				    opc->v[0].fp = d_to_p;
				    return(true);
				  }
			      }
			  }
		      }
		    pc_fallback(sc, pstart);
		  }

		ifunc = s7_i_ii_function(s_func);
		sc->pc = pstart - 1;
		if ((ifunc) &&
		    (int_optimize(sc, expr)))
		  {
		    if (oo_size(opc) < 8) oo_resize(opc, 8);
		    opc->v[7].fi = opc->v[0].fi;
		    opc->v[0].fp = i_to_p;
		    if (opc->v[7].fi == opt_i_ii_ss_add)
		      opc->v[0].fp = opt_p_ii_ss_add;
		    else
		      {
			if (opc->v[7].fi == opt_i_ii_fc_add)
			  opc->v[0].fp = opt_p_ii_fc_add;
		      }
		    return(true);
		  }
		pc_fallback(sc, pstart);

		if ((p_ii_ok(sc, opc, s_func, car_x, pstart)) ||
		    (p_dd_ok(sc, opc, s_func, car_x, pstart)) ||
		    (p_pp_ok(sc, opc, s_func, car_x, pstart)) ||
		    (p_cf_pp_ok(sc, opc, s_func, car_x, pstart)))
		  return(true);
	      }
	      break;

	    case 4:
	      if (is_symbol(cadr(car_x)))
		{
		  if ((is_pair(sig)) &&
		      (is_pair(cdr(sig))) &&
		      (is_pair(cddr(sig))) &&
		      (caddr(sig) == sc->is_integer_symbol))
		    {
		      if (p_pii_ok(sc, opc, s_func, car_x))
			return(true);
		      if (p_pip_ok(sc, opc, s_func, car_x))
			return(true);

		      if (((car(sig) == sc->is_float_symbol) ||
			   (car(sig) == sc->is_real_symbol)) &&
			  (s7_d_7pid_function(s_func)) &&
			  (d_7pid_ok(sc, opc, s_func, car_x)))
			{
			  /* if d_7pid is ok, we need d_to_p for cell_optimize */
			  if (oo_size(opc) < 8) oo_resize(opc, 8);
			  opc->v[7].fd = opc->v[0].fd;
			  opc->v[0].fp = d_to_p;
			  return(true);
			}

		      sc->pc = pstart - 1;
		      if ((car(sig) == sc->is_integer_symbol) &&
			  (s7_i_7pii_function(s_func)) &&
			  (i_7pii_ok(sc, alloc_opo(sc, expr), s_func, car_x)))
			{
			  if (oo_size(opc) < 8) oo_resize(opc, 8);
			  opc->v[7].fi = opc->v[0].fi;
			  opc->v[0].fp = i_to_p;
			  return(true);
			}
		    }
		  pc_fallback(sc, pstart);
		}

	      if ((p_ppi_ok(sc, opc, s_func, car_x)) ||
		  (p_ppp_ok(sc, opc, s_func, car_x)) ||
		  (p_cf_ppp_ok(sc, opc, s_func, car_x)))
		return(true);
	      break;

	    case 5:
	      if ((head == sc->float_vector_set_symbol) &&
		  (d_7piid_ok(sc, opc, s_func, car_x)))
		{
		  if (oo_size(opc) < 8) oo_resize(opc, 8);
		  opc->v[7].fd = opc->v[0].fd;
		  opc->v[0].fp = d_to_p;         /* as above, if d_7piid is ok, we need d_to_p for cell_optimize */
		  return(true);
		}
	      /* pc_fallback(sc, pstart); */
	      if (i_7piii_ok(sc, opc, s_func, car_x))
		{
		  if (oo_size(opc) < 8) oo_resize(opc, 8);
		  opc->v[7].fi = opc->v[0].fi;
		  opc->v[0].fp = i_to_p;
		  return(true);
		}
	      if (head == sc->int_vector_set_symbol) /* TODO: p_cf_any is confused below via opt_int_not_pair */
		return(return_false(sc, car_x, __func__, __LINE__));
	      /* pc_fallback(sc, pstart); */
	      if (p_piip_ok(sc, opc, s_func, car_x))
		return(true);
	      pc_fallback(sc, pstart);

	    default:
	      if (p_cf_any_ok(sc, opc, s_func, car_x, len))
		return(true);
	      break;
	    }
	}
      else
	{
	  if (is_closure(s_func))
	    {
	      opt_info *opc;
	      opc = alloc_opo(sc, car_x);
	      if (p_fx_any_ok(sc, opc, s_func, expr))
		return(true);
	    }
	  if (is_macro(s_func))
	    return(return_false(sc, car_x, __func__, __LINE__)); /* macroexpand+cell_optimize here restarts the optimize process */
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool bool_optimize_nw(s7_scheme *sc, s7_pointer expr)
{
  s7_pointer car_x, head;

  car_x = car(expr);
  if (!is_pair(car_x)) /* wrap constants/symbols */
    return(opt_bool_not_pair(sc, car_x));

  head = car(car_x);
  if (is_symbol(head))
    {
      s7_pointer s_func;
      s7_int len;
      len = s7_list_length(sc, car_x);

      if ((is_syntactic_symbol(head)) ||
	  (is_syntactic_pair(car_x)))
	{
	  if (head == sc->and_symbol)
	    return(opt_b_and(sc, car_x, len));
	  if (head == sc->or_symbol)
	    return(opt_b_or(sc, car_x, len));
	  return(return_false(sc, car_x, __func__, __LINE__));
	}

      if ((is_global(head)) ||
	  ((is_slot(global_slot(head))) &&
	   (symbol_to_slot(sc, head) == global_slot(head))))
	s_func = slot_value(global_slot(head));
      else return(return_false(sc, car_x, __func__, __LINE__));

      if (is_c_function(s_func))
	{
	  if (symbol_id(head) != 0)             /* (float-vector? (block)) -- both safe c_funcs, but this is a method invocation */
	    return(return_false(sc, car_x, __func__, __LINE__));
	  switch (len)
	    {
	    case 2:
	      return(b_idp_ok(sc, s_func, car_x, opt_arg_type(sc, cdr(car_x))));

	    case 3:
	      {
		s7_b_pp_t bpf;
		s7_b_7pp_t bpf7 = NULL;
		bpf = s7_b_pp_function(s_func);
		if (!bpf) bpf7 = s7_b_7pp_function(s_func);
		if ((bpf) || (bpf7))
		  {
		    opt_info *opc;
		    s7_pointer sig1, sig2, arg1, arg2;
		    opc = alloc_opo(sc, car_x);

		    arg1 = cadr(car_x);
		    arg2 = caddr(car_x);
		    sig1 = opt_arg_type(sc, cdr(car_x));
		    sig2 = opt_arg_type(sc, cddr(car_x));

		    if (sig2 == sc->is_integer_symbol)
		      {
			int32_t cur_index;
			cur_index = sc->pc;

			if ((sig1 == sc->is_integer_symbol) &&
			    (b_ii_ok(sc, opc, s_func, car_x, arg1, arg2)))
			  return(true);
			pc_fallback(sc, cur_index);

			if ((is_symbol(arg2)) &&
			    (b_pi_ok(sc, opc, s_func, car_x, arg2)))
			  return(true);
			pc_fallback(sc, cur_index);
		      }

		    if ((sig1 == sc->is_float_symbol) &&
			(sig2 == sc->is_float_symbol) &&
			(b_dd_ok(sc, opc, s_func, car_x, arg1, arg2)))
		      return(true);

		    if (bpf)
		      opc->v[3].b_pp_f = bpf;
		    else opc->v[3].b_7pp_f = bpf7;
		    return(b_pp_ok(sc, opc, s_func, car_x, arg1, arg2, bpf != NULL));
		  }
	      }
	      break;

	    default:
	      break;
	    }
	}
      else
	{
	  if (is_macro(s_func))
	    return(return_false(sc, car_x, __func__, __LINE__));
	}
    }
  return(return_false(sc, car_x, __func__, __LINE__));
}

static bool bool_optimize(s7_scheme *sc, s7_pointer expr)
{
  int32_t start;
  opt_info *wrapper;
  start = sc->pc;
  if (bool_optimize_nw(sc, expr))
    return(true);
  pc_fallback(sc, start);
  wrapper = sc->opts[start];
  if (cell_optimize(sc, expr))
    {
      if (wrapper->v[7].fp) /* (when (+ i 1) ...) */
	return(return_false(sc, NULL, __func__, __LINE__));
      if (oo_size(wrapper) < 8) oo_resize(wrapper, 8);
      wrapper->v[7].fp = wrapper->v[0].fp;
      wrapper->v[0].fb = p_to_b;
      return(true);
    }
  return(return_false(sc, NULL, __func__, __LINE__));
}

static s7_function s7_bool_optimize(s7_scheme *sc, s7_pointer expr)
{
#if WITH_GMP
  return(NULL);
#endif
  if (setjmp(sc->opt_exit) == 0)
    {
      sc->pc = 0;
      if (bool_optimize(sc, expr))
	return(opt_bool_any);
    }
  return(NULL);
}

s7_float_function s7_float_optimize(s7_scheme *sc, s7_pointer expr)
{
#if WITH_GMP
  return(NULL);
#endif
  if (setjmp(sc->opt_exit) == 0)
    {
      sc->pc = 0;
      if (float_optimize(sc, expr))
	return(opt_float_any);
    }
  return(NULL);
}

static s7_function s7_optimize_1(s7_scheme *sc, s7_pointer expr, bool nr)
{
#if WITH_GMP
  return(NULL);
#endif
  if ((!is_pair(expr)) || (pair_no_opt(expr)))
    return(NULL);

  if (setjmp(sc->opt_exit) == 0)
    {
      sc->pc = 0;
      if (!no_int_opt(expr))
	{
	  if (int_optimize(sc, expr))
	    return((nr) ? opt_int_any_nr : opt_wrap_int);
	  pc_fallback(sc, 0);
	  set_no_int_opt(expr);
	}
      if (!no_float_opt(expr))
	{
	  if (float_optimize(sc, expr))
	    return((nr) ? opt_float_any_nr : opt_wrap_float);
	  pc_fallback(sc, 0);
	  set_no_float_opt(expr);
	}
      if (!no_bool_opt(expr))
	{
	  if (bool_optimize_nw(sc, expr))
	    return((nr) ? opt_bool_any_nr : opt_wrap_bool);
	  pc_fallback(sc, 0);
	  set_no_bool_opt(expr);
	}
      if (cell_optimize(sc, expr))
	return((nr) ? opt_cell_any_nr : opt_wrap_cell);
      set_pair_no_opt(expr);
    }
  return(NULL);
}

s7_function s7_optimize(s7_scheme *sc, s7_pointer expr)    {return(s7_optimize_1(sc, expr, false));}
s7_function s7_optimize_nr(s7_scheme *sc, s7_pointer expr) {return(s7_optimize_1(sc, expr, true));}

static s7_pointer g_optimize(s7_scheme *sc, s7_pointer args)
{
  s7_function f;
  s7_pointer code;
  code = car(args);
  f = s7_optimize(sc, code);
  if (f)
    return(f(sc, car(code)));
  return(sc->undefined);
}

static s7_function s7_cell_optimize(s7_scheme *sc, s7_pointer expr, bool nr)
{
#if WITH_GMP
  return(NULL);
#endif
  if (setjmp(sc->opt_exit) == 0)
    {
      sc->pc = 0;
      if (cell_optimize(sc, expr))
	return((nr) ? opt_cell_any_nr : opt_wrap_cell);
    }
  return(NULL);
}

/* caller: s7_float_optimize(sc, expr, env) to return a function that when called evaluates expr in env
 *   s7_float_optimize returns an s7_float_function (s7_double opt_float_any(s7_scheme *sc, s7_pointer expr) normally)
 *   s7_float_any evaluates the program stored in sc->opts by calling opts[0]->f(opts[0])
 *   each portion of expr resides in an opt_info struct, evalled by calling its "fd" function on itself
 *   fd chooses the basic form of the expr, calling one of the underlying functions in opts[n] such as opt_d_c
 *   finally that calls the actual function such as abs_d
 */

static void clear_optimizer_fixups(s7_scheme *sc)
{
  optfix_t *p, *n;
  for (p = sc->optimizer_fixups; p; p = n)
    {
      n = optfix_next(p);
      liberate_block(sc, p);
    }
  sc->optimizer_fixups = NULL;
}

static void add_optimizer_fixup(s7_scheme *sc, s7_pointer expr, uint32_t op)
{
  optfix_t *p;
#if S7_DEBUGGING
  if (((op & 1) != 0) && (!fx_function[op])) fprintf(stderr, "no fx fixup for %s\n", op_names[op]);
#endif
  p = (optfix_t *)mallocate_block(sc);
  optfix_expr(p) = expr;
  optfix_op(p) = op;
  optfix_next(p) = sc->optimizer_fixups;
  sc->optimizer_fixups = p;
}

static void handle_optimizer_fixups(s7_scheme *sc)
{
  optfix_t *p;
  for (p = sc->optimizer_fixups; p; p = optfix_next(p))
    set_optimize_op(optfix_expr(p), optfix_op(p));
  clear_optimizer_fixups(sc);
}


/* ---------------------------------------- for-each ---------------------------------------- */

static inline s7_pointer make_counter(s7_scheme *sc, s7_pointer iter)
{
  s7_pointer x;
  new_cell(sc, x, T_COUNTER);
  counter_set_result(x, sc->nil);
  counter_set_list(x, iter);     /* iterator -- here it's always either an iterator or a pair */
  counter_set_capture(x, 0);     /* will be capture_let_counter */
  counter_set_let(x, sc->nil);   /* will be the saved env */
  counter_set_slots(x, sc->nil); /* local env slots before body is evalled */
  return(x);
}

static s7_pointer make_iterators(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  sc->temp3 = args;
  sc->z = sc->nil;                                    /* don't use sc->args here -- it needs GC protection until we get the iterators */
  for (p = cdr(args); is_pair(p); p = cdr(p))
    {
      s7_pointer iter;
      iter = car(p);
      if (!is_iterator(car(p)))
	iter = s7_make_iterator(sc, iter);
      sc->z = cons(sc, iter, sc->z);
    }
  sc->temp3 = sc->nil;
  return(safe_reverse_in_place(sc, sc->z));
}

static bool tree_has_setters(s7_scheme *sc, s7_pointer tree)
{
  clear_symbol_list(sc);
  add_symbol_to_list(sc, sc->set_symbol);
  add_symbol_to_list(sc, sc->vector_set_symbol);
  add_symbol_to_list(sc, sc->list_set_symbol);
  add_symbol_to_list(sc, sc->let_set_symbol);
  add_symbol_to_list(sc, sc->hash_table_set_symbol);
  add_symbol_to_list(sc, sc->set_car_symbol);
  add_symbol_to_list(sc, sc->set_cdr_symbol);
  return(tree_set_memq(sc, tree));
}

static s7_pointer g_for_each_closure(s7_scheme *sc, s7_pointer f, s7_pointer seq)
{
  s7_pointer body;

  body = closure_body(f);
  if (!pair_no_opt(body))
    {
      s7_function func;
      s7_pointer slot, old_e, expr, pars;

      old_e = sc->envir;
      pars = closure_args(f);
      sc->envir = new_frame_in_env(sc, closure_let(f)); /* (for-each (let ((x 0)) (lambda ....)) ...), so closure_let(f) */
      if (is_pair(seq))
	slot = make_slot_1(sc, sc->envir, car(pars), sc->F);
      else
	{
	  if (is_float_vector(seq))
	    slot = make_slot_1(sc, sc->envir, car(pars), real_zero);
	  else slot = make_slot_1(sc, sc->envir, car(pars), ((is_int_vector(seq)) || (is_byte_vector(seq))) ? small_int(0) : sc->F);
	}
      if (is_null(cdr(body)))
	{
	  expr = car(body);
	  func = s7_optimize_nr(sc, body);
	}
      else
	{
	  expr = cons(sc, sc->begin_symbol, body);
	  sc->v = expr; /* GC protection? */
	  func = s7_cell_optimize(sc, cons(sc, expr, sc->nil), true);
	}

      if (func)
	{
	  if (is_pair(seq))
	    {
	      s7_pointer x, y;
	      for (x = seq, y = x; is_pair(x); )
		{
		  slot_set_value(slot, car(x));
		  func(sc, expr);
		  x = cdr(x);
		  if (is_pair(x))
		    {
		      slot_set_value(slot, car(x));
		      func(sc, expr);
		      y = cdr(y);
		      x = cdr(x);
		      if (x == y) return(sc->unspecified);
		    }
		}
	      return(sc->unspecified);
	    }

	  if (is_float_vector(seq))
	    {
	      s7_double *vals;
	      s7_int i, len;
	      len = vector_length(seq);
	      vals = float_vector_floats(seq);

	      if ((len > 1000) &&
		  (!tree_has_setters(sc, body)))
		{
		  s7_pointer sv;
		  sv = s7_make_mutable_real(sc, 0.0);
		  slot_set_value(slot, sv);
		  for (i = 0; i < len; i++)
		    {
		      real(sv) = vals[i];
		      func(sc, expr);
		    }
		  return(sc->unspecified);
		}
	      for (i = 0; i < len; i++)
		{
		  slot_set_value(slot, make_real(sc, vals[i]));
		  func(sc, expr);
		}
	      return(sc->unspecified);
	    }

	  /* if no set! vector|list|let|hash-table-set! set-car!|cdr! mutable arg? */
	  if (is_int_vector(seq))
	    {
	      s7_int *vals;
	      s7_int i, len;
	      len = vector_length(seq);
	      vals = int_vector_ints(seq);

	      if ((len > 1000) &&
		  (!tree_has_setters(sc, body)))
		{
		  s7_pointer sv;
		  sv = make_mutable_integer(sc, 0);
		  slot_set_value(slot, sv);
		  for (i = 0; i < len; i++)
		    {
		      integer(sv) = vals[i];
		      func(sc, expr);
		    }
		  return(sc->unspecified);
		}

	      for (i = 0; i < len; i++)
		{
		  slot_set_value(slot, make_integer(sc, vals[i]));
		  func(sc, expr);
		}
	      return(sc->unspecified);
	    }

	  sc->z = seq;
	  if (!is_iterator(sc->z))
	    sc->z = s7_make_iterator(sc, sc->z);
	  seq = sc->z;
	  push_stack_no_let(sc, OP_GC_PROTECT, seq, f);
	  sc->z = sc->nil;
	  while (true)
	    {
	      slot_set_value(slot, s7_iterate(sc, seq));
	      if (iterator_is_at_end(seq))
		{
		  unstack(sc);
		  /* free_cell(sc, seq); */ /* 16-Jan-19 */
		  return(sc->unspecified);
		}
	      func(sc, expr);
	    }
	}
      set_pair_no_opt(body);
      sc->envir = old_e;
    }

  if ((is_null(cdr(body))) &&
      (is_pair(seq)))
    {
      s7_pointer c;
      c = make_counter(sc, seq);
      counter_set_result(c, seq);
      push_stack(sc, OP_FOR_EACH_2, c, f);
      return(sc->unspecified);
    }

  sc->z = seq;
  if (!is_iterator(sc->z))
    sc->z = s7_make_iterator(sc, sc->z);
  push_stack(sc, OP_FOR_EACH_1, make_counter(sc, sc->z), f);
  sc->z = sc->nil;
  return(sc->unspecified);
}

static inline bool for_each_arg_is_null(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  bool got_nil = false;
  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer obj;
      obj = car(p);
      if (!is_mappable(obj))
	{
	  if (is_null(obj))
	    got_nil = true;
	  else return(simple_wrong_type_argument_with_type(sc, sc->for_each_symbol, obj, a_sequence_string));
	}
    }
  return(got_nil);
}

static s7_pointer g_for_each(s7_scheme *sc, s7_pointer args)
{
  #define H_for_each "(for-each proc object . objects) applies proc to each element of the objects traversed in parallel. \
Each object can be a list, string, vector, hash-table, or any other sequence."
  #define Q_for_each s7_make_circular_signature(sc, 2, 3, sc->is_unspecified_symbol, sc->is_procedure_symbol, sc->is_sequence_symbol)

  s7_pointer f;
  s7_int len;
  bool arity_ok = false;

  /* try the normal case first */
  f = car(args);                                /* the function */
  len = safe_list_length(cdr(args));

  if (is_closure(f))                            /* not lambda* that might get confused about arg names */
    {
      if ((len == 1) &&
	  (is_pair(closure_args(f))) &&
	  (is_null(cdr(closure_args(f)))))
	arity_ok = true;
    }
  else
    {
      if (!is_applicable(f))
	return(method_or_bust_with_type(sc, f, sc->for_each_symbol, args, something_applicable_string, 1));
    }

  if ((!arity_ok) &&
      (!s7_is_aritable(sc, f, len)))
    return(s7_error(sc, sc->wrong_number_of_args_symbol,
		    set_elist_3(sc, wrap_string(sc, "for-each ~A: ~A args?", 21), f, small_int(len))));

  /* if function is safe c func, do the for-each locally */
  if ((is_safe_procedure(f)) &&
      (is_c_function(f)))
    {
      s7_function func;
      s7_pointer iters;

      if (for_each_arg_is_null(sc, cdr(args))) return(sc->unspecified);

      func = c_function_call(f);    /* presumably this is either display/write, or method call? */
      sc->z = make_iterators(sc, args);
      sc->z = cons(sc, sc->z, make_list(sc, len, sc->nil));
      push_stack_no_let(sc, OP_GC_PROTECT, sc->args, sc->z); /* temporary GC protection */
      if (len == 1)
	{
	  s7_pointer x, y;
	  x = caar(sc->z);
	  y = cdr(sc->z);
	  sc->z = sc->nil;
	  while (true)
	    {
	      set_car(y, s7_iterate(sc, x));
	      if (iterator_is_at_end(x))
		{
		  /* not pop_stack here since that can clobber sc->code et al, and if this for-each call is
		   *   being treated as safe, c_call(for-each) assumes everywhere that sc->code is left alone.
		   */
		  unstack(sc);
		  /* free_cell(sc, x); */ /* 16-Jan-19 */
		  return(sc->unspecified);
		}
	      func(sc, y);
	    }
	}
      iters = sc->z;
      sc->z = sc->nil;
      while (true)
	{
	  s7_pointer x, y;
	  for (x = car(iters), y = cdr(iters); is_pair(x); x = cdr(x), y = cdr(y))
	    {
	      set_car(y, s7_iterate(sc, car(x)));
	      if (iterator_is_at_end(car(x)))
		{
		  unstack(sc);
		  return(sc->unspecified);
		}
	    }
	  func(sc, cdr(iters));
	}
    }

  set_current_code(sc, sc->code);
  /* if closure call is straightforward, use OP_FOR_EACH_1 */
  if ((len == 1) &&
      (is_closure(f)) &&                        /* not lambda* that might get confused about arg names */
      (closure_arity_to_int(sc, f) == 1) &&     /* not a rest arg: not is_pair: (lambda (x . args) arg) */
      (!is_constant_symbol(sc, car(closure_args(f)))))
    return(g_for_each_closure(sc, f, cadr(args)));

  if (for_each_arg_is_null(sc, cdr(args))) return(sc->unspecified);

  push_stack(sc, OP_FOR_EACH, cons(sc, make_iterators(sc, args), make_list(sc, len, sc->nil)), f);
  sc->z = sc->nil;
  return(sc->unspecified);
}

static bool op_for_each(s7_scheme *sc)
{
  s7_pointer x, y, iterators, saved_args;
  iterators = car(sc->args);
  saved_args = cdr(sc->args);
  for (x = saved_args, y = iterators; is_pair(x); x = cdr(x), y = cdr(y))
    {
      set_car(x, s7_iterate(sc, car(y)));
      if (iterator_is_at_end(car(y)))
	{
	  sc->value = sc->unspecified;
	  free_cell(sc, sc->args);
	  sc->args = sc->nil;
	  return(true);
	}
    }
  push_stack(sc, OP_FOR_EACH, sc->args, sc->code);
  sc->args = saved_args;
  if (needs_copied_args(sc->code))
    sc->args = copy_list(sc, sc->args);
  return(false);
}

/* for-each et al remake the local frame, but that's only needed if the local env is exported,
 *   and that can only happen through make-closure in various guises and curlet.
 *   owlet captures, but it would require a deliberate error to use it in this context.
 *   c_objects call object_set_let but that requires a prior curlet or sublet.  So we have
 *   sc->capture_let_counter that is incremented every time an environment is captured, then
 *   here we save that ctr, call body, on rerun check ctr, if it has not changed we are safe and can reuse frame.
 */

static bool op_for_each_1(s7_scheme *sc)
{
  s7_pointer counter, p, arg, code;
  counter = sc->args;
  p = counter_list(counter);
  arg = s7_iterate(sc, p);
  if (iterator_is_at_end(p))
    {
      sc->value = sc->unspecified;
      free_cell(sc, counter);
      sc->args = sc->nil;
      return(true);
    }
  code = sc->code;
  if (counter_capture(counter) != sc->capture_let_counter)
    {
      new_frame_with_slot(sc, closure_let(code), sc->envir, car(closure_args(code)), arg);
      counter_set_let(counter, sc->envir);
      counter_set_slots(counter, let_slots(sc->envir));
      counter_set_capture(counter, sc->capture_let_counter);
    }
  else
    {
      let_set_slots(counter_let(counter), counter_slots(counter));
      sc->envir = old_frame_with_slot(sc, counter_let(counter), arg);
    }
  push_stack(sc, OP_FOR_EACH_1, counter, code);
  sc->code = T_Pair(closure_body(code));
  return(false);
}

static bool op_for_each_2(s7_scheme *sc)
{
  s7_pointer c, lst, arg, code;
  c = sc->args; /* the counter */
  lst = counter_list(c);
  if (!is_pair(lst))  /* '(1 2 . 3) as arg? -- counter_list can be anything here */
    {
      sc->value = sc->unspecified;
      free_cell(sc, c);
      sc->args = sc->nil;
      return(true);
    }
  code = T_Clo(sc->code);
  arg = car(lst);
  counter_set_list(c, cdr(lst));
  if (sc->cur_op == OP_FOR_EACH_3)
    {
      counter_set_result(c, cdr(counter_result(c)));
      if (counter_result(c) == counter_list(c))
	{
	  sc->value = sc->unspecified;
	  free_cell(sc, c);
	  sc->args = sc->nil;
	  return(true);
	}
      push_stack(sc, OP_FOR_EACH_2, c, code);
    }
  else push_stack(sc, OP_FOR_EACH_3, c, code);
  if (counter_capture(c) != sc->capture_let_counter)
    {
      new_frame_with_slot(sc, closure_let(code), sc->envir, car(closure_args(code)), arg);
      counter_set_let(c, sc->envir);
      counter_set_slots(c, let_slots(sc->envir));
      counter_set_capture(c, sc->capture_let_counter);
    }
  else
    {
      let_set_slots(counter_let(c), counter_slots(c));
      sc->envir = old_frame_with_slot(sc, counter_let(c), arg);
    }
  sc->code = car(closure_body(code));
  return(false);
}


/* ---------------------------------------- map ---------------------------------------- */

static s7_pointer slookup(s7_scheme *sc, s7_pointer s) {return(slot_value(s));}

static s7_pointer g_map_closure(s7_scheme *sc, s7_pointer f, s7_pointer seq)
{
  s7_pointer body;

  body = closure_body(f);
  if ((is_pair(seq)) &&
      (!pair_no_opt(body)) &&
      (is_optimized(car(body)))) /* for index.scm? */
    {
      s7_function func;
      s7_pointer slot, old_e, expr;

      old_e = sc->envir;
      sc->envir = new_frame_in_env(sc, closure_let(f));
      slot = make_slot_1(sc, sc->envir, car(closure_args(f)), sc->F);

      if (is_null(cdr(body)))
	{
	  expr = car(body);
	  if (is_symbol(expr))
	    {
	      expr = symbol_to_slot(sc, expr);
	      func = slookup;
	    }
	  else func = s7_optimize(sc, body);
	}
      else
	{
	  expr = cons(sc, sc->begin_symbol, body);
	  sc->w = expr; /* GC protection? */
	  func = s7_cell_optimize(sc, cons(sc, expr, sc->nil), false);
	}
      if (func)
	{
	  s7_pointer fast, slow;
	  sc->v = sc->nil;
	  push_stack_no_let(sc, OP_GC_PROTECT, f, seq);
	  for (fast = seq, slow = seq; is_pair(fast); fast = cdr(fast), slow = cdr(slow))
	    {
	      s7_pointer z;
	      slot_set_value(slot, car(fast));
	      z = func(sc, expr);
	      if (z != sc->no_value)
		sc->v = cons(sc, z, sc->v);
	      if (is_pair(cdr(fast)))
		{
		  fast = cdr(fast);
		  if (fast == slow)
		    break;
		  slot_set_value(slot, car(fast));
		  z = func(sc, expr);
		  if (z != sc->no_value)
		    sc->v = cons(sc, z, sc->v);
		}
	    }
	  unstack(sc);
	  return(safe_reverse_in_place(sc, sc->v));
	}
      set_pair_no_opt(body);
      sc->envir = old_e;
    }

  if ((is_null(cdr(body))) &&
      (is_pair(seq)))
    {
      closure_set_map_list(f, seq);
      push_stack(sc, OP_MAP_2, make_counter(sc, seq), f);
      return(sc->unspecified);
    }

  sc->z = (!is_iterator(seq)) ? s7_make_iterator(sc, seq) : seq;
  push_stack(sc, OP_MAP_1, make_counter(sc, sc->z), f);
  sc->z = sc->nil;
  return(sc->nil);
}

static s7_pointer g_map(s7_scheme *sc, s7_pointer args)
{
  #define H_map "(map proc object . objects) applies proc to a list made up of the next element of each of its arguments, returning \
a list of the results.  Its arguments can be lists, vectors, strings, hash-tables, or any applicable objects."
  #define Q_map s7_make_circular_signature(sc, 2, 3, sc->is_proper_list_symbol, sc->is_procedure_symbol, sc->is_sequence_symbol)

  s7_pointer p, f;
  s7_int len;
  bool got_nil = false;

  f = car(args);                                /* the function */
  for (len = 0, p = cdr(args); is_not_null(p); p = cdr(p), len++)
    {
      if (!is_mappable(car(p)))
	{
	  if (is_null(car(p)))
	    got_nil = true;
	  else return(simple_wrong_type_argument_with_type(sc, sc->map_symbol, car(p), a_sequence_string));
	}
    }

  switch (type(f))
    {
    case T_C_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      if ((c_function_required_args(f) > len) ||
	  (c_function_all_args(f) < len))
	return(s7_error(sc, sc->wrong_number_of_args_symbol,
			set_elist_3(sc, wrap_string(sc, "map ~A: ~A args?", 16), f, small_int(len))));

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
      /* if function is safe c func, do the map locally */
      if (got_nil) return(sc->nil);
      if (is_safe_procedure(f))
	{
	  s7_function func;
	  func = c_function_call(f);
	  if ((is_pair(cadr(args))) &&
	      (len == 1))
	    {
	      s7_pointer f_args, val, fast, slow;
	      f_args = list_1(sc, sc->F);
	      val = list_1(sc, sc->nil);
	      push_stack_no_let(sc, OP_GC_PROTECT, f_args, val);
	      for (fast = cadr(args), slow = cadr(args); is_pair(fast); fast = cdr(fast), slow = cdr(slow))
		{
		  s7_pointer z;
		  set_car(f_args, car(fast));
		  z = func(sc, f_args);
		  if (z != sc->no_value)
		    set_car(val, cons(sc, z, car(val)));
		  if (is_pair(cdr(fast)))
		    {
		      fast = cdr(fast);
		      if (fast == slow)
			break;
		      set_car(f_args, car(fast));
		      z = func(sc, f_args);
		      if (z != sc->no_value)
			set_car(val, cons(sc, z, car(val)));
		    }
		}
	      unstack(sc);
	      return(safe_reverse_in_place(sc, car(val)));
	    }
	  else
	    {
	      s7_pointer val, val1, old_args, iter_list;
	      sc->z = make_iterators(sc, args);
	      val1 = cons(sc, sc->z, make_list(sc, len, sc->nil));
	      iter_list = sc->z;
	      old_args = sc->args;
	      func = c_function_call(f);
	      push_stack_no_let(sc, OP_GC_PROTECT, val1, val = cons(sc, sc->nil, sc->code)); /* temporary GC protection: need to protect val1, iter_list, val */
	      sc->z = sc->nil;
	      while (true)
		{
		  s7_pointer x, y, z;
		  for (x = iter_list, y = cdr(val1); is_pair(x); x = cdr(x), y = cdr(y))
		    {
		      set_car(y, s7_iterate(sc, car(x)));
		      if (iterator_is_at_end(car(x)))
			{
			  unstack(sc);
			  /* free_cell(sc, car(x)); */ /* 16-Jan-19 iterator in circular list -- see s7test */
			  sc->args = T_Pos(old_args);
			  return(safe_reverse_in_place(sc, car(val)));
			}
		    }
		  z = func(sc, cdr(val1)); /* can this contain multiple-values? */
		  if (z != sc->no_value)
		    set_car(val, cons(sc, z, car(val)));
		}
	    }
	}
      else /* not safe procedure */
	{
	  /* to mimic map values handling elsewhere:
	   *   ((lambda args (format *stderr* "~A~%" (map values args))) (values)):   ()
	   *   ((lambda args (format *stderr* "~A~%" (map values args))) (values #<unspecified>)): #<unspecified> etc
	   */
	  if ((f == slot_value(global_slot(sc->values_symbol))) &&
	      (len == 1) &&
	      (!has_methods(cadr(args)))) /* iterator should be ok here -- object_to_list can handle it */
	    {
	      p = object_to_list(sc, cadr(args));
	      if (p != cadr(args))
		return(p);
	    }
	}
      break;

      case T_CLOSURE:
	{
	  int32_t fargs;
	  fargs = closure_arity_to_int(sc, f);
	  /* if closure call is straightforward, use OP_MAP_1 */
	  if ((len == 1) &&
	      (fargs == 1) &&
	      (!is_constant_symbol(sc, car(closure_args(f)))))
	    {
	      /* g_map_closure here if not s7_tree_memq 'map takes more time than it saves */
	      if (got_nil) return(sc->nil);
	      /* don't go to OP_MAP_2 here! It assumes no recursion */
	      sc->z = (!is_iterator(cadr(args))) ? s7_make_iterator(sc, cadr(args)) : cadr(args);
	      push_stack(sc, OP_MAP_1, make_counter(sc, sc->z), f);
	      sc->z = sc->nil;
	      return(sc->nil);
	    }
	  if ((fargs > len) ||
	      ((fargs < len) &&
	       ((fargs >= 0) ||
		(abs(fargs) > len))))
	    return(s7_error(sc, sc->wrong_number_of_args_symbol,
			    set_elist_3(sc, wrap_string(sc, "map ~A: ~A args?", 16), f, small_int(len))));
	  if (got_nil) return(sc->nil);
	}
	break;

    default:
      if (!is_applicable(f))
	return(method_or_bust_with_type(sc, f, sc->map_symbol, args, something_applicable_string, 1));

      if ((!is_pair(f)) &&
	  (!s7_is_aritable(sc, f, len)))
	return(s7_error(sc, sc->wrong_number_of_args_symbol,
			set_elist_3(sc, wrap_string(sc, "map ~A: ~A args?", 16), f, small_int(len))));
      if (got_nil) return(sc->nil);
      break;
    }

  set_current_code(sc, sc->code);
  sc->z = make_iterators(sc, args);
  push_stack(sc, OP_MAP, make_counter(sc, sc->z), f);
  sc->z = sc->nil;
  return(sc->nil);
}

static bool op_map(s7_scheme *sc)
{
  s7_pointer y, iterators;
  iterators = counter_list(sc->args);
  sc->x = sc->nil;                     /* can't use preset args list here (as in for-each): (map list '(a b c)) */
  for (y = iterators; is_pair(y); y = cdr(y))
    {
      s7_pointer x;
      x = s7_iterate(sc, car(y));
      if (iterator_is_at_end(car(y)))
	{
	  sc->value = safe_reverse_in_place(sc, counter_result(sc->args));
	  free_cell(sc, sc->args);
	  sc->args = sc->nil;
	  return(true);
	}
      sc->x = cons(sc, x, sc->x);
    }
  sc->x = safe_reverse_in_place(sc, sc->x);
  push_stack(sc, OP_MAP_GATHER, sc->args, sc->code);
  sc->args = sc->x;
  sc->x = sc->nil;

  if (needs_copied_args(sc->code))
    sc->args = copy_list(sc, sc->args);
  return(false);
}

static bool op_map_1(s7_scheme *sc)
{
  s7_pointer x, args, p, code;
  code = sc->code;
  args = sc->args;
  p = counter_list(args);
  x = s7_iterate(sc, p);

  if (iterator_is_at_end(p))
    {
      sc->value = safe_reverse_in_place(sc, counter_result(args));
      /* an experiment */
      free_cell(sc, sc->args);
      sc->args = sc->nil;
      return(true);
    }
  push_stack(sc, OP_MAP_GATHER_1, args, code);
  if (counter_capture(args) != sc->capture_let_counter)
    {
      new_frame_with_slot(sc, closure_let(code), sc->envir, car(closure_args(code)), x);
      counter_set_let(args, sc->envir);
      counter_set_slots(args, let_slots(sc->envir));
      counter_set_capture(args, sc->capture_let_counter);
    }
  else
    {
      /* the counter_slots field saves the original local let slot(s) representing the function
       *   argument.  If the function has internal defines, they get added to the front of the
       *   slots list, but old_frame_with_slot (maybe stupidly) assumes only the one original
       *   slot exists when it updates its symbol_id from the (possibly changed) let_id.  So,
       *   a subsequent reference to the parameter name causes "unbound variable", or a segfault
       *   if the check has been optimized away.  I think each function call should start with
       *   the original let slots, so counter_slots saves that pointer, and resets it here.
       */
      let_set_slots(counter_let(args), counter_slots(args));
      sc->envir = old_frame_with_slot(sc, counter_let(args), x);
    }
  sc->code = T_Pair(closure_body(code));
  return(false);
}

static bool op_map_2(s7_scheme *sc)
{
  s7_pointer x, c, p, code;
  code = sc->code;
  c = sc->args;
  p = counter_list(c);
  if (!is_pair(p))
    {
      sc->value = safe_reverse_in_place(sc, counter_result(c));
      free_cell(sc, sc->args);
      sc->args = sc->nil;
      return(true);
    }
  x = car(p);
  counter_set_list(c, cdr(p));

  if (sc->cur_op == OP_MAP_GATHER_3)
    {
      closure_set_map_list(code, cdr(closure_map_list(code)));
      /* this depends on code (the function) being non-recursive, else closure_setter gets stepped on */
      if (closure_map_list(code) == counter_list(c))
	{
	  sc->value = safe_reverse_in_place(sc, counter_result(c));
	  free_cell(sc, c);
	  sc->args = sc->nil;
	  return(true);
	}
      push_stack(sc, OP_MAP_GATHER_2, c, code);
    }
  else push_stack(sc, OP_MAP_GATHER_3, c, code);

  if (counter_capture(c) != sc->capture_let_counter)
    {
      new_frame_with_slot(sc, closure_let(code), sc->envir, car(closure_args(code)), x);
      counter_set_let(c, sc->envir);
      counter_set_slots(c, let_slots(sc->envir));
      counter_set_capture(c, sc->capture_let_counter);
    }
  else
    {
      let_set_slots(counter_let(c), counter_slots(c));
      sc->envir = old_frame_with_slot(sc, counter_let(c), x);
    }
  sc->code = car(closure_body(code));
  return(false);
}


/* -------------------------------- multiple-values -------------------------------- */

static s7_pointer splice_in_values(s7_scheme *sc, s7_pointer args)
{
  int64_t top;
  s7_pointer x;
  top = s7_stack_top(sc) - 1; /* stack_end - stack_start if negative, we're in big trouble */
#if SHOW_EVAL_OPS
  safe_print(fprintf(stderr, "splice %s %s\n", op_names[stack_op(sc->stack, top)], DISPLAY_80(sc->args)));
#endif
  switch (stack_op(sc->stack, top))
    {
      /* the normal case -- splice values into caller's args */
    case OP_EVAL_ARGS1:
    case OP_EVAL_ARGS2:
    case OP_EVAL_ARGS3:
    case OP_EVAL_ARGS4:
      /* code = args yet to eval in order, args = evalled args reversed
       *
       * it's not safe to simply reverse args and tack the current stacked args onto its (new) end,
       *   setting stacked args to cdr of reversed-args and returning car because the list (args)
       *   can be some variable's value in a macro expansion via ,@ and reversing it in place
       *   (all this to avoid consing), clobbers the variable's value.
       */
      for (x = args; is_not_null(cdr(x)); x = cdr(x))
	stack_args(sc->stack, top) = cons(sc, car(x), stack_args(sc->stack, top));
      return(car(x));

      /* in the next set, the main evaluator branches blithely assume no multiple-values,
       *   and if it happens anyway, we go to a different branch here
       */
    case OP_SAFE_C_FP_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_FP_MV_1;
    case OP_SAFE_C_FP_MV_1:
      if (is_immutable(args)) /* (let () (define (func) (with-output-to-string (lambda () (apply-values (write '(1 2)))))) (func) (func)) */
	args = copy_list(sc, args);
      set_multiple_value(args);
      return(args);

    case OP_SAFE_C_SSP_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_SSP_MV_1;
      return(args);

    case OP_C_AP_1:
    case OP_SAFE_C_SP_1:
    case OP_SAFE_CONS_SP_1:
    case OP_SAFE_MEMQ_SP_1:
    case OP_SAFE_ADD_SP_1:
    case OP_SAFE_SUBTRACT_SP_1:
    case OP_SAFE_MULTIPLY_SP_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_SP_MV;
      return(args);

    case OP_SAFE_C_PS_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_PS_MV;
      return(args);

    case OP_SAFE_C_PC_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_PC_MV;
      return(args);

    case OP_SAFE_C_PA_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_PA_MV;
      return(args);

    case OP_C_P_1:
    case OP_SAFE_C_P_1:
    case OP_NOT_P_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_C_P_MV;
      return(args);

    case OP_SAFE_CLOSURE_P_1:
    case OP_CLOSURE_P_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_CLOSURE_P_MV;
      return(args);

    case OP_SAFE_CLOSURE_AP_1:
    case OP_CLOSURE_AP_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_CLOSURE_AP_MV;
      return(args);

    case OP_SAFE_CLOSURE_PA_1:
    case OP_CLOSURE_PA_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_CLOSURE_PA_MV;
      return(args);

    case OP_SAFE_C_PP_1:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_PP_3_MV;
      return(args);

    case OP_SAFE_C_PP_5:
      stack_element(sc->stack, top) = (s7_pointer)OP_SAFE_C_PP_6_MV;
      return(args);

    case OP_EVAL_ARGS5:
      /* code = previous arg saved, args = ante-previous args reversed
       *   we'll take value->code->args and reverse in args5
       *   if one value, return it, else
       *      put code onto args, splice as above until there are 2 left
       *      set code to first and value to last
       */
      if (is_null(args))
	return(sc->unspecified);

      if (is_null(cdr(args)))
	return(car(args));

      stack_args(sc->stack, top) = cons(sc, stack_code(sc->stack, top), stack_args(sc->stack, top));
      for (x = args; is_not_null(cddr(x)); x = cdr(x))
	stack_args(sc->stack, top) = cons(sc, car(x), stack_args(sc->stack, top));
      stack_code(sc->stack, top) = car(x);
      return(cadr(x));

      /* look for errors here rather than glomming up the set! and let code. */
    case OP_SET_SAFE:             /* symbol is sc->code after pop */
    case OP_SET1:                 /* (set! var (values 1 2 3)) */
      eval_error_with_caller2(sc, "~A: can't set '~A to ~S", 23, sc->set_symbol,
 			      stack_code(sc->stack, top), cons(sc, sc->values_symbol, args));

    case OP_SET_PAIR_P_1:
      eval_error(sc, "too many values to set! ~S", 26, cons(sc, sc->values_symbol, args));

    case OP_INCREMENT_SP_1:       /* slot is in stack_args(top), args is the values list */
      stack_element(sc->stack, top) = (s7_pointer)OP_INCREMENT_SP_MV;
      return(args);

    case OP_LET1:                                             /* (let ((var (values 1 2 3))) ...) */
      {
	s7_pointer p, let_code, vars, sym;
	p = stack_args(sc->stack, top);
	for (let_code = p; is_pair(cdr(let_code)); let_code = cdr(let_code));
	for (vars = caar(let_code); is_pair(cdr(p)); p = cdr(p), vars = cdr(vars));
	sym = caar(vars);
	eval_error_with_caller2(sc, "~A: can't bind '~A to ~S", 24, sc->let_symbol, sym, cons(sc, sc->values_symbol, args));
	/* stack_args: ((((x (values 1 2))) x)) in (let ((x (values 1 2))) x)
	 *             (1 (((x 1) (y (values 1 2))) x)) in (let ((x 1) (y (values 1 2))) x)
	 */
      }

    case OP_LET_ONE_1:             /* sc->args = symbol */
    case OP_LET_ONE_2:
    case OP_LET_ONE_P_1:
    case OP_LET_ONE_P_2:
      eval_error_with_caller2(sc, "~A: can't bind '~A to ~S", 24, sc->let_symbol,
			      stack_args(sc->stack, top), cons(sc, sc->values_symbol, args));

    case OP_LET_STAR1:             /* here caar(sc->code) is bound to sc->value */
      eval_error_with_caller2(sc, "~A: can't bind '~A to ~S", 24, sc->let_star_symbol,
			      caar(stack_code(sc->stack, top)), cons(sc, sc->values_symbol, args));

    case OP_LETREC1:               /* here sc->args is the slot about to receive a value */
      eval_error_with_caller2(sc, "~A: can't bind '~A to ~S", 24, sc->letrec_symbol,
			      slot_symbol(stack_args(sc->stack, top)), cons(sc, sc->values_symbol, args));

    case OP_LETREC_STAR1:
      eval_error_with_caller2(sc, "~A: can't bind '~A to ~S", 24, sc->letrec_star_symbol,
			      slot_symbol(stack_args(sc->stack, top)), cons(sc, sc->values_symbol, args));

      /* handle 'and' and 'or' specially */
    case OP_AND_P1:
    case OP_AND1:
    case OP_AND_SAFE_P_REST: /* from OP_AND_SAFE_P1 or P2 */
      for (x = args; is_not_null(cdr(x)); x = cdr(x))
	if (car(x) == sc->F)
	  return(sc->F);
      return(car(x));

    case OP_OR_P1:
    case OP_OR1:
      for (x = args; is_not_null(cdr(x)); x = cdr(x))
	if (car(x) != sc->F)
	  return(car(x));
      return(car(x));

    case OP_IF1:    /* (if (values ...) ...) */
    case OP_IF_PP:
    case OP_IF_PPP:
    case OP_IF_PR:
    case OP_IF_PRR:
    case OP_WHEN_PP:
    case OP_UNLESS_PP:
    case OP_WITH_LET1:
    case OP_CASE_G_G:
    case OP_CASE_G_S:
    case OP_CASE_E_G:
    case OP_CASE_E_S:
    case OP_CASE_S_G:
    case OP_CASE_S_S:
    case OP_CASE_I_S:
    case OP_COND1:
    case OP_COND1_SIMPLE:
      return(car(args));

    case OP_BARRIER:
      pop_stack(sc);
      return(splice_in_values(sc, args));

    case OP_GC_PROTECT:
      sc->stack_end -= 4;
      return(splice_in_values(sc, args));

    case OP_BEGIN0:
    case OP_BEGIN1:
      /* here we have a values call with nothing to splice into.  So flush it...
       *   otherwise the multiple-values bit gets set in some innocent list and never unset:
       *     (let ((x '((1 2)))) (eval `(apply apply values x)) x) -> ((values 1 2))
       * other cases: (+ 1 (begin (values 5 6) (values 2 3)) 4) -> 10 -- the (5 6) is dropped
       *              (let () (values 1 2 3) 4) but (+ (let () (values 1 2))) -> 3
       */
      return(args);

    case OP_DEACTIVATE_GOTO:  /* (+ (call-with-exit (lambda (ret) (values 1 2 3)))) */
      call_exit_active(stack_args(sc->stack, top)) = false;

    case OP_CATCH:
    case OP_CATCH_1:
    case OP_CATCH_2:
    case OP_CATCH_ALL:
      /* (+ (catch #t (lambda () (values 3 4)) (lambda args args))) */
      pop_stack(sc);
      return(splice_in_values(sc, args));

    case OP_EXPANSION:
      /* we get here if a reader-macro (define-expansion) returns multiple values.
       *    these need to be read in order into the current reader lists (we'll assume OP_READ_LIST is next in the stack.
       *    and that it will be expecting the next arg entry in sc->value).
       */
      top -= 4;
      for (x = args; is_not_null(cdr(x)); x = cdr(x))
	stack_args(sc->stack, top) = cons(sc, car(x), stack_args(sc->stack, top));
      pop_stack(sc);               /* need GC protection in loop above, so do this afterwards */
      return(car(x));              /* sc->value from OP_READ_LIST point of view */

    default:
      /* fprintf(stderr, "splice on: %s\n", op_names[stack_op(sc->stack, top)]); */
      break;
    }

  /* let it meander back up the call chain until someone knows where to splice it
   *   the is_immutable check protects against setting the multiple value bit on (say) sc->hash_table_signature
   */
  if (is_immutable(args))
    args = copy_list(sc, args);
  set_multiple_value(args);
  return(args);
}

s7_pointer s7_values(s7_scheme *sc, s7_pointer args)
{
  #define H_values "(values obj ...) splices its arguments into whatever list holds it (its 'continuation')"
  #define Q_values s7_make_circular_signature(sc, 1, 2, sc->values_symbol, sc->T)

  if (is_null(args))         /* ((lambda () (let ((x 1)) (set! x (boolean? (values)))))) */
    return(sc->no_value);
  if (is_null(cdr(args)))
    return(car(args));
  return(splice_in_values(sc, args));
}

#define g_values s7_values

static s7_pointer values_p(s7_scheme *sc) {return(sc->no_value);}
static s7_pointer values_p_p(s7_scheme *sc, s7_pointer p) {return(p);}


/* -------------------------------- quasiquote -------------------------------- */

static s7_pointer g_list_values(s7_scheme *sc, s7_pointer args)
{
  #define H_list_values "(list-values ...) returns its arguments in a list (internal to quasiquote)"
  #define Q_list_values s7_make_circular_signature(sc, 1, 2, sc->is_list_symbol, sc->T)

  s7_pointer x;
  bool checked = false;

  for (x = args; is_pair(x); x = cdr(x))
    {
      if (is_pair(car(x)))
	{
	  if (is_checked(car(x)))
	    checked = true;
	}
      else
	{
	  if (car(x) == sc->no_value) /* unchecked_car|cdr unrolled here is not faster */
	    break;
	}
    }
  if (is_null(x))
    {
      if (checked)
	{
	  sc->u = args;
	  check_heap_size(sc, 8192);
#if S7_DEBUGGING
	  if (tree_is_cyclic(sc, args))
	    {
	      fprintf(stderr, "%s[%d]: hit a cyclic list?\n", __func__, __LINE__);
	      abort();
	    }
#endif
	  return(copy_tree(sc, args)); /* copy_tree can't handle cyclic trees */
	}
      return((is_immutable(args)) ? copy_list(sc, args) : args);
    }
  /* if a macro expands into a recursive function with a macro argument as its body (or reasonable facsimile thereof),
   *   and the safety (as in safe_closure) of the body changes from safe to unsafe, then (due to the checked bits
   *   protecting against cycles in optimize_expression|syntax), the possible safe_closure call will not be fixed,
   *   the safe_closure's assumption about the saved local frame will be violated, and we'll get "<arg> unbound".
   *   examples:
   *     (define-macro (badmac tst) `(let loop ((x 1)) (if (> x 0) (loop (- x 1)) ,tst)))
   *     (badmac (vector 0))
   *     (badmac (let ((x (lambda () 1))) (eq? x x)))
   *     (define-macro (badmac1 tst) `(let () (define (badf x) (if (> x 0) (badf (- x 1)) ,tst)) (badf 1)))
   *     (badmac1 (vector 0))
   *     (badmac1 (let ((x (lambda () 1))) (eq? x x)))
   * clear_all_optimizations assumes its argument has no cycles, and automatically calling copy_tree slows
   *   everything down intolerably, so...
   * if the checked bit it on in a macro expansion, that means we're re-expanding this macro, and therefore
   *   have to copy the tree.
   * we can't set_cdr(pc...) as in earlier versions of this code -- might be an embedded permanent list
   */

  /* splice out #<values>, (list-values (apply-values ())) -> () etc */
  sc->w = sc->nil;
  for (x = args; is_pair(x); x = cdr(x))
    if (car(x) != sc->no_value)
      sc->w = cons(sc, car(x), sc->w);
  sc->u = sc->nil;
  if (is_pair(sc->w))
    {
      x = safe_reverse_in_place(sc, sc->w);
      sc->w = sc->nil;
      return(x);
    }
  return(sc->nil);
}

static s7_pointer g_apply_values(s7_scheme *sc, s7_pointer args)
{
  #define H_apply_values "(apply-values var) applies values to var.  This is an internal function."
  #define Q_apply_values s7_make_signature(sc, 2, sc->T, sc->is_list_symbol)
  s7_pointer x;

  if (is_null(args))
    return(sc->no_value);

  if (is_null(cdr(args)))
    x = car(args);
  else x = apply_list_star(sc, args);

  if (!s7_is_proper_list(sc, x))
    return(apply_list_error(sc, args));
  if (is_null(x))
    return(sc->no_value);

  return(g_values(sc, x));
}

/* (apply values ...) replaces (unquote_splicing ...)
 *   (define-macro (hi a) `(+ 1 ,a) == (list '+ 1 a)
 *   (define-macro (hi a) ``(+ 1 ,,a) == (list list '+ 1 (list quote a)))
 *   (define-macro (hi a) `(+ 1 ,@a) == (list '+ 1 (apply values a))
 *   (define-macro (hi a) ``(+ 1 ,,@a) == (list list '+ 1 (apply values a))
 *
 * this is not the same as CL's quasiquote; for example:
 *   [1]> (let ((a 1) (b 2)) `(,a ,@b)) -> '(1 . 2)
 *   in s7 this is an error.
 *
 * also in CL the target of ,@ can apparently be a circular list
 * one surprising twist: write/display return their first argument directly, so (apply-values (write `(+ x 1))) is the same as (apply-values `(+ x 1))
 *   If this is in a function body, and the function is called twice, it is self-modifying code and behaves in unexpected ways.
 */

static bool is_simple_code(s7_scheme *sc, s7_pointer form)
{
  s7_pointer tmp, slow;
  for (tmp = form, slow = form; is_pair(tmp); tmp = cdr(tmp), slow = cdr(slow))
    {
      if (is_pair(car(tmp)))
	{
	  if (!is_simple_code(sc, car(tmp)))
	    return(false);
	}
      else
	{
	  if ((car(tmp) == sc->unquote_symbol) ||
	      ((is_null(car(tmp))) && (is_null(cdr(tmp)))))
	    return(false);
	}
      tmp = cdr(tmp);
      if (!is_pair(tmp)) return(is_null(tmp));
      if (tmp == slow) return(false);
      if (is_pair(car(tmp)))
	{
	  if (!is_simple_code(sc, car(tmp)))
	    return(false);
	}
      else
	{
	  if ((car(tmp) == sc->unquote_symbol) ||
	      ((is_null(car(tmp))) && (is_null(cdr(tmp)))))
	    return(false);
	}
    }
  return(is_null(tmp));
}

/* since the reader expands unquote et al, and the printer does not unexpand them, the standard scheme quine in s7 is:
 *   ((lambda (x) (list-values x (list-values 'quote x))) '(lambda (x) (list-values x (list-values 'quote x))))
 * but that depends on the "p" in repl...
 */

static s7_pointer g_quasiquote_1(s7_scheme *sc, s7_pointer form, bool check_cycles)
{
  #define H_quasiquote "(quasiquote arg) is the same as `arg.  If arg is a list, it can contain \
comma (\"unquote\") and comma-atsign (\"apply values\") to pre-evaluate portions of the list. \
unquoted expressions are evaluated and plugged into the list, apply-values evaluates the expression \
and splices the resultant list into the outer list. `(1 ,(+ 1 1) ,@(list 3 4)) -> (1 2 3 4)."

  if (!is_pair(form))
    {
      if ((is_symbol(form)) &&
	  (!is_keyword(form)))
	return(list_2(sc, sc->quote_symbol, form));
      /* things that evaluate to themselves don't need to be quoted. */
      return(form);
    }

  if (car(form) == sc->unquote_symbol)
    {
      if (!is_pair(cdr(form)))             /* (unquote) or (unquote . 1) */
	{
	  if (is_null(cdr(form)))
	    eval_error(sc, "unquote: no argument, ~S", 24, form);
	  else eval_error(sc, "unquote: stray dot, ~S", 22, form);
	}
      if (is_not_null(cddr(form)))
	eval_error(sc, "unquote: too many arguments, ~S", 31, form);
      return(cadr(form));
    }

  /* it's a list, so return the list with each element handled as above.
   *    we try to support dotted lists which makes the code much messier.
   * if no element of the list is a list or unquote, just return the original quoted
   */
  if (((check_cycles) && (tree_is_cyclic(sc, form))) ||
      (is_simple_code(sc, form)))
    return(list_2(sc, sc->quote_symbol, form));

  {
    s7_int len, i;
    s7_pointer orig, bq, old_scw;
    bool dotted = false;

    len = s7_list_length(sc, form);
    if (len < 0)
      {
	len = -len;
	dotted = true;
      }
    old_scw = sc->w;
    push_stack_no_let_no_code(sc, OP_GC_PROTECT, sc->w);

    sc->w = sc->nil;
    for (i = 0; i <= len; i++)
      sc->w = cons(sc, sc->nil, sc->w);

    set_car(sc->w, sc->list_values_symbol);

    if (!dotted)
      {
	for (orig = form, bq = cdr(sc->w), i = 0; i < len; i++, orig = cdr(orig), bq = cdr(bq))
	  {
	    if ((is_pair(cdr(orig))) &&             /* this was is_pair(orig) which seems to be always the case */
		(cadr(orig) == sc->unquote_symbol)) /* `(1 . ,(+ 1 1)) -> '(1 unquote (+ 1 1)) -> '(1 . 2) etc */
	      {
		if (!is_pair(cddr(orig)))
		  {
		    sc->w = old_scw;
		    unstack(sc);
		    eval_error(sc, "unquote: no argument, ~S", 24, form);
		  }
		set_car(bq, g_quasiquote_1(sc, car(orig), false));
		set_cdr(bq, sc->nil);
		sc->w = list_3(sc, sc->append_symbol, sc->w, caddr(orig));
		break;
	      }
	    else set_car(bq, g_quasiquote_1(sc, car(orig), false));
	  }
      }
    else
      {
	/* `(1 2 . 3) */
	len--;
	for (orig = form, bq = cdr(sc->w), i = 0; i < len; i++, orig = cdr(orig), bq = cdr(bq))
	  set_car(bq, g_quasiquote_1(sc, car(orig), false));
	set_car(bq, g_quasiquote_1(sc, car(orig), false));

	sc->w = list_3(sc, sc->append_symbol, sc->w, g_quasiquote_1(sc, cdr(orig), false));
	/* quasiquote might quote a symbol in cdr(orig), so it's not completely pointless */
      }

    bq = sc->w;
    sc->w = old_scw;
    unstack(sc);
    return(bq);
  }
}

static s7_pointer g_quasiquote(s7_scheme *sc, s7_pointer args)
{
  /* this is for explicit quasiquote support, not the backquote stuff in macros
   *   but it is problematic.  g_quasiquote_1 above expands (for example) `(+ ,x) into (list (quote +) x),
   *   so (multiple-value-bind (quote) quasiquote `(+ ,x)) expands to ((lambda (quote) (list '+ x)) quasiquote)
   *   which is an infinite loop.  Guile says syntax error (because it thinks "quote" can't be a parameter name, I think).
   */
  return(g_quasiquote_1(sc, car(args), true));
}


/* ---------------- reader funcs for eval ---------------- */

static void back_up_stack(s7_scheme *sc)
{
  opcode_t top_op;
  top_op = stack_op(sc->stack, s7_stack_top(sc) - 1);
  if (top_op == OP_READ_DOT)
    {
      pop_stack(sc);
      top_op = stack_op(sc->stack, s7_stack_top(sc) - 1);
    }
  if ((top_op == OP_READ_VECTOR) ||
      (top_op == OP_READ_BYTE_VECTOR) ||
      (top_op == OP_READ_INT_VECTOR) ||
      (top_op == OP_READ_FLOAT_VECTOR))
   {
      pop_stack(sc);
      top_op = stack_op(sc->stack, s7_stack_top(sc) - 1);
    }
  if (top_op == OP_READ_QUOTE)
    pop_stack(sc);
}

static token_t read_sharp(s7_scheme *sc, s7_pointer pt)
{
  int32_t c;
  /* inchar can return EOF, so it can't be used directly as an index into the digits array */
  c = inchar(pt);
  switch (c)
    {
    case EOF:
      s7_error(sc, sc->read_error_symbol, set_elist_1(sc, wrap_string(sc, "unexpected '#' at end of input", 30)));
      break;

    case '(':
      sc->w = small_int(1);
      return(TOKEN_VECTOR);

    case 'i':
      if (read_sharp(sc, pt) == TOKEN_VECTOR)
	return(TOKEN_INT_VECTOR);
      backchar('i', pt);
      break;

    case 'r':
      if (read_sharp(sc, pt) == TOKEN_VECTOR)
	return(TOKEN_FLOAT_VECTOR);
      backchar('r', pt);
      break;

    case 'u':
      if (s7_peek_char(sc, pt) == chars['8']) /* backwards compatibility: #u8(...) == #u(...) */
	{
	  int32_t bc;
	  bc = inchar(pt);
	  if (s7_peek_char(sc, pt) == chars['('])
	    {
	      inchar(pt);
	      sc->w = small_int(1);
	      return(TOKEN_BYTE_VECTOR);
	    }
	  backchar(bc, pt);
	}
      if (read_sharp(sc, pt) == TOKEN_VECTOR)
	return(TOKEN_BYTE_VECTOR);
      backchar('u', pt);
      break;

    case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
      {
	/* here we can get an overflow: #1231231231231232131D() */
	s7_int dims;
	int32_t d, loc = 0;
	sc->strbuf[loc++] = (unsigned char)c;
	dims = digits[c];

	while (true)
	  {
	    s7_int dig;
	    d = inchar(pt);
	    if (d == EOF)
	      s7_error(sc, sc->read_error_symbol,
		       set_elist_1(sc, wrap_string(sc, "unexpected end of input while reading #n...", 43)));

	    dig = digits[d];
	    if (dig >= 10) break;
	    dims = dig + (dims * 10);
	    if ((dims <= 0) ||
		(dims > S7_SHORT_MAX))
	      s7_error(sc, sc->read_error_symbol,
		       set_elist_2(sc, wrap_string(sc, "overflow while reading #nD: ~A", 30), wrap_integer1(sc, dims)));
	    sc->strbuf[loc++] = (unsigned char)d;
	  }
	sc->strbuf[loc++] = d;
	if ((d == 'd') || (d == 'i') || (d == 'r') || (d == 'u'))
	  {
	    int32_t e;
	    e = inchar(pt);
	    if (e == EOF)
	      s7_error(sc, sc->read_error_symbol,
		       set_elist_1(sc, wrap_string(sc, "unexpected end of input while reading #n()", 42)));
	    sc->strbuf[loc++] = (unsigned char)e;
	    if (e == '(')
	      {
		sc->w = make_integer(sc, dims);
		if (d == 'd') return(TOKEN_VECTOR);
		if (d == 'r') return(TOKEN_FLOAT_VECTOR);
		if (d == 'u') return(TOKEN_BYTE_VECTOR);
		return(TOKEN_INT_VECTOR);
	      }
	  }
	/* try to back out */
	for (d = loc - 1; d > 0; d--)
	  backchar(sc->strbuf[d], pt);
      }
      break;

    case ':':  /* turn #: into : -- this is for compatibility with Guile, sigh.
		*   I just noticed that Rick is using this -- I'll just leave it alone.
		*   but that means : readers need to handle this case specially.
		* I don't think #! is special anymore -- maybe remove that code?
		*/
      sc->strbuf[0] = ':';
      return(TOKEN_ATOM);

      /* block comments in #! ... !# */
      /* this is needed when an input file is treated as a script:
	 #!/home/bil/cl/snd
	 !#
	 (format #t "a test~%")
	 (exit)
      * but very often the closing !# is omitted which is too bad
      */
    case '!':
      {
	char last_char;
	s7_pointer reader;

	/* make it possible to override #! handling */
	for (reader = slot_value(sc->sharp_readers); is_pair(reader); reader = cdr(reader))
	  if (s7_character(caar(reader)) == '!')
	    {
	      sc->strbuf[0] = (unsigned char)c;
	      return(TOKEN_SHARP_CONST); /* next stage notices any errors */
	    }

	/* not #! as block comment (for Guile I guess) */
	last_char = ' ';
	while ((c = inchar(pt)) != EOF)
	  {
	    if ((c == '#') &&
		(last_char == '!'))
	      break;
	    last_char = c;
	  }
	if (c == EOF)
	  s7_error(sc, sc->read_error_symbol,
		   set_elist_1(sc, wrap_string(sc, "unexpected end of input while reading #!", 40)));
	return(token(sc));
      }

      /* block comments in #| ... |#
       *   since we ignore everything until the |#, internal semicolon comments are ignored,
       *   meaning that ;|# is as effective as |#
       */
    case '|':
      {
	if (is_file_port(pt))
	  {
	    char last_char;
	    last_char = ' ';
	    while (true)
	      {
		c = fgetc(port_file(pt));
		if (c == EOF)
		  s7_error(sc, sc->read_error_symbol,
			   set_elist_1(sc, wrap_string(sc, "unexpected end of input while reading #|", 40)));
		if ((c == '#') &&
		    (last_char == '|'))
		  break;
		last_char = c;
		if (c == '\n')
		  port_line_number(pt)++;
	      }
	    return(token(sc));
	  }
	else
	  {
	    const char *str, *orig_str, *p, *pend;

	    orig_str = (const char *)(port_data(pt) + port_position(pt));
	    pend = (const char *)(port_data(pt) + port_data_size(pt));
	    str = orig_str;

	    while (true)
	      {
		p = strchr(str, (int)'|');
		if ((!p) || (p >= pend))
		  {
		    port_position(pt) = port_data_size(pt);
		    s7_error(sc, sc->read_error_symbol,
			     set_elist_1(sc, wrap_string(sc, "unexpected end of input while reading #|", 40)));
		  }
		if (p[1] == '#')
		  break;
		str = (const char *)(p + 1);
	      }
	    port_position(pt) += (p - orig_str + 2);

	    /* now count newline inside the comment */
	    str = (const char *)orig_str;
	    pend = p;
	    while (true)
	      {
		p = strchr(str, (int)'\n');
		if ((p) && (p < pend))
		  {
		    port_line_number(pt)++;
		    str = (char *)(p + 1);
		  }
		else break;
	      }
	    return(token(sc));
	  }
      }
    }
  sc->strbuf[0] = (unsigned char)c;
  return(TOKEN_SHARP_CONST); /* next stage notices any errors */
}

static token_t read_comma(s7_scheme *sc, s7_pointer pt)
{
  int32_t c;
  /* here we probably should check for symbol names that start with "@":
       (define-macro (hi @foo) `(+ ,@foo 1)) -> hi
       (hi 2) -> ;foo: unbound variable
     but
       (define-macro (hi .foo) `(+ ,.foo 1)) -> hi
       (hi 2) -> 3
     and ambiguous:
       (define-macro (hi @foo . foo) `(list ,@foo))
     what about , @foo -- is the space significant?  We accept ,@ foo.
  */

  if ((c = inchar(pt)) == '@')
    return(TOKEN_AT_MARK);

  if (c == EOF)
    {
      sc->strbuf[0] = ',';  /* was '@' which doesn't make any sense */
      return(TOKEN_COMMA);  /* was TOKEN_ATOM, which also doesn't seem sensible */
    }

  backchar(c, pt);
  return(TOKEN_COMMA);
}

static token_t read_dot(s7_scheme *sc, s7_pointer pt)
{
  int32_t c;
  c = inchar(pt);
  if (c != EOF)
    {
      backchar(c, pt);
      if ((!char_ok_in_a_name[c]) && (c != 0))
	return(TOKEN_DOT);
    }
  else
    {
      sc->strbuf[0] = '.';
      return(TOKEN_DOT);
    }
  sc->strbuf[0] = '.';
  return(TOKEN_ATOM);  /* i.e. something that can start with a dot like a number */
}

static token_t token(s7_scheme *sc) /* inline here is slower */
{
  int32_t c;
  c = port_read_white_space(sc->input_port)(sc, sc->input_port);
  switch (c)
    {
    case '(':  return(TOKEN_LEFT_PAREN);
    case ')':  return(TOKEN_RIGHT_PAREN);
    case '.':  return(read_dot(sc, sc->input_port));
    case '\'': return(TOKEN_QUOTE);
    case ';':  return(port_read_semicolon(sc->input_port)(sc, sc->input_port));
    case '"':  return(TOKEN_DOUBLE_QUOTE);
    case '`':  return(TOKEN_BACK_QUOTE);
    case ',':  return(read_comma(sc, sc->input_port));
    case '#':  return(read_sharp(sc, sc->input_port));
    case '\0':
    case EOF:  return(TOKEN_EOF);
    default:
      sc->strbuf[0] = (unsigned char)c; /* every TOKEN_ATOM return goes to port_read_name, so we save a backchar/inchar shuffle by starting the read here */
      return(TOKEN_ATOM);
    }
}

static int32_t read_x_char(s7_scheme *sc, int32_t i, s7_pointer pt)
{
  /* possible "\xn...;" char (write creates these things, so we have to read them)
   *   but we could have crazy input like "\x -- with no trailing double quote
   */
  while (true)
    {
      int32_t d1, d2, c;
      c = inchar(pt);
      if (c == '"')
	{
	  backchar(c, pt);
	  return(i);
	}
      if (c == ';') return(i);
      if (c == EOF)
	{
	  read_error(sc, "#<eof> in midst of hex-char");
	  return(i);
	}
      d1 = digits[c];
      if (d1 >= 16)
	{
	  sc->strbuf[i++] = (unsigned char)c; /* just go on -- maybe a special char is not intended */
	  return(i);
	}
      c = inchar(pt);
      if (c == '"')
	{
	  sc->strbuf[i++] = (unsigned char)d1;
	  backchar((char)c, pt);
	  return(i);
	}
      if (c == EOF)
	{
	  read_error(sc, "#<eof> in midst of hex-char");
	  return(i);
	}
      if (c == ';')
	{
	  sc->strbuf[i++] = (unsigned char)d1;
	  return(i);
	}
      d2 = digits[c];
      if (d2 >= 16)
	{
	  sc->strbuf[i++] = (unsigned char)c; /* just go on -- maybe a special char is not intended */
	  return(i);
	}
      sc->strbuf[i++] = (unsigned char)(16 * d1 + d2);
    }
  return(i);
}

static s7_pointer unknown_string_constant(s7_scheme *sc, int32_t c)
{
  /* check *read-error-hook* */
  if (hook_has_functions(sc->read_error_hook))
    {
      s7_pointer result;
      result = s7_call(sc, sc->read_error_hook, list_2(sc, sc->F, s7_make_character(sc, (uint8_t)c)));
      if (s7_is_character(result))
	return(result);
    }
  return(sc->T);
}

static s7_pointer read_string_constant(s7_scheme *sc, s7_pointer pt)
{
  /* sc->F => error
   *   no check needed here for bad input port and so on
   */
  s7_int i = 0;

  if (is_string_port(pt))
    {
      /* try the most common case first */
      char *s, *start, *end;
      start = (char *)(port_data(pt) + port_position(pt));
      if (*start == '"')
	{
	  port_position(pt)++;
	  return(make_empty_string(sc, 0, 0));
	}

      end = (char *)(port_data(pt) + port_data_size(pt));
      s = strpbrk(start, "\"\n\\");
      if ((!s) || (s >= end))                     /* can this read a huge string constant from a file? */
	{
	  if (start == end)
	    sc->strbuf[0] = '\0';
	  else memcpy((void *)(sc->strbuf), (void *)start, (end - start > 8) ? 8 : (end - start));
	  sc->strbuf[8] = '\0';
	  return(sc->F);
	}
      if (*s == '"')
	{
	  s7_int len;
	  len = s - start;
	  port_position(pt) += (len + 1);
	  return(make_string_with_length(sc, start, len));
	}

      for (; s < end; s++)
	{
	  if (*s == '"')                         /* switch here no faster */
	    {
	      s7_int len;
	      len = s - start;
	      port_position(pt) += (len + 1);
	      return(make_string_with_length(sc, start, len));
	    }
	  if (*s == '\\')
	    {
	      /* all kinds of special cases here (resultant string is not the current string), so drop to loop below (setting "i") */
	      s7_int len;
	      len = (s7_int)(s - start);
	      if (len > 0)
		{
		  if (len >= sc->strbuf_size)
		    resize_strbuf(sc, len);
		  /* for (i = 0; i < len; i++) sc->strbuf[i] = port_data(pt)[port_position(pt)++]; */
		  memcpy((void *)(sc->strbuf), (void *)(port_data(pt) + port_position(pt)), len);
		  port_position(pt) += len;
		}
	      i = len;
	      break;
	    }
	  else
	    {
	      if (*s == '\n')
		port_line_number(pt)++;
	    }
	}
    }

  while (true)
    {
      /* splitting this check out and duplicating the loop was slower?!? */
      int32_t c;
      c = port_read_character(pt)(sc, pt);

      switch (c)
	{
	case '\n':
	  port_line_number(pt)++;
	  sc->strbuf[i++] = (unsigned char)c;
	  break;

	case EOF:
	  sc->strbuf[(i > 8) ? 8 : i] = '\0';
	  return(sc->F);

	case '"':
	  return(make_string_with_length(sc, sc->strbuf, i));

	case '\\':
	  c = inchar(pt);

	  switch (c)
	    {
	    case EOF:
	      sc->strbuf[(i > 8) ? 8 : i] = '\0';
	      return(sc->F);

	    case '\\': case '"': case '|':
	      sc->strbuf[i++] = (unsigned char)c;
              break;

	    case 'n': sc->strbuf[i++] = '\n'; break;
	    case 't': sc->strbuf[i++] = '\t'; break;
	    case 'r': sc->strbuf[i++] = '\r'; break;
	    case '/': sc->strbuf[i++] = '/';  break;
	    case 'b': sc->strbuf[i++] = (unsigned char)8;    break;
	    case 'f': sc->strbuf[i++] = (unsigned char)12;   break;

	    case 'x':
	      i = read_x_char(sc, i, pt);
              break;

            default:	      /* if (!is_white_space(c)) */ /* changed 8-Apr-12 */
	      if ((c != '\n') && (c != '\r')) /* i.e. line continuation via #\\ at end of line */
		{
		  s7_pointer result;
		  result = unknown_string_constant(sc, c);
		  if (s7_is_character(result))
		    sc->strbuf[i++] = character(result);
		  else return(result);
		}
	      /* #f here would give confusing error message "end of input", so return #t=bad backslash.
	       *     this is not optimal. It's easy to forget that backslash needs to be backslashed.
	       * the white_space business half-implements Scheme's \<newline>...<eol>... or \<space>...<eol>...
	       *   feature -- the characters after \ are flushed if they're all white space and include a newline.
	       *   (string->number "1\   2") is 12??  Too bizarre.
	       */
	    }
	  break;

	default:
	  sc->strbuf[i++] = (unsigned char)c;
	  break;
	}

      if (i >= sc->strbuf_size)
	resize_strbuf(sc, i);
    }
}

static s7_pointer read_expression_read_error(s7_scheme *sc)
{
  s7_pointer pt;
  pop_stack(sc);
  pt = sc->input_port;
  if ((is_input_port(pt)) &&
      (!port_is_closed(pt)) &&
      (port_data(pt)) &&
      (port_position(pt) > 0))
    {
      s7_int start, pos;
      s7_pointer p;
      char *msg;
      
      pos = port_position(pt);
      start = pos - 40;
      if (start < 0) start = 0;
      
      p = make_empty_string(sc, 128, '\0');
      msg = string_value(p);
      memcpy((void *)msg, (void *)"at \"...", 7);
      memcpy((void *)(msg + 7), (void *)(port_data(pt) + start), pos - start);
      memcpy((void *)(msg + 7 + pos - start), (void *)"...", 3);
      string_length(p) = 7 + pos - start + 3;
      return(s7_error(sc, sc->read_error_symbol, set_elist_1(sc, p)));
    }
  return(read_error(sc, "stray comma before ')'?"));         /* '("a" "b",) */
}

static s7_pointer read_expression(s7_scheme *sc)
{
  while (true)
    {
      int32_t c;
      switch (sc->tok)
	{
	case TOKEN_EOF:
	  return(eof_object);

	case TOKEN_BYTE_VECTOR:
	  push_stack_no_let_no_code(sc, OP_READ_BYTE_VECTOR, sc->w);
	  sc->tok = TOKEN_LEFT_PAREN;
	  break;

	case TOKEN_INT_VECTOR:
	  push_stack_no_let_no_code(sc, OP_READ_INT_VECTOR, sc->w);
	  sc->tok = TOKEN_LEFT_PAREN;
	  break;

	case TOKEN_FLOAT_VECTOR:
	  push_stack_no_let_no_code(sc, OP_READ_FLOAT_VECTOR, sc->w);
	  sc->tok = TOKEN_LEFT_PAREN;
	  break;

	case TOKEN_VECTOR:         /* already read #( -- TOKEN_VECTOR is triggered by #( */
	  push_stack_no_let_no_code(sc, OP_READ_VECTOR, sc->w);   /* sc->w is the dimensions */
	  /* fall through */

	case TOKEN_LEFT_PAREN:
	  sc->tok = token(sc);

	  if (sc->tok == TOKEN_RIGHT_PAREN)
	    return(sc->nil);

	  if (sc->tok == TOKEN_DOT)
	    {
	      back_up_stack(sc);
	      do {c = inchar(sc->input_port);} while ((c != ')') && (c != EOF));
	      return(read_error(sc, "stray dot after '('?"));         /* (car '( . )) */
	    }

	  if (sc->tok == TOKEN_EOF)
	    return(missing_close_paren_error(sc));

	  push_stack_no_let_no_code(sc, OP_READ_LIST, sc->nil);
	  /* here we need to clear args, but code is ignored */

	  check_stack_size(sc);
	  break;

	case TOKEN_QUOTE:
	  push_stack_no_let_no_code(sc, OP_READ_QUOTE, sc->nil);
	  sc->tok = token(sc);
	  break;

	case TOKEN_BACK_QUOTE:
	  sc->tok = token(sc);
	  push_stack_no_let_no_code(sc, OP_READ_QUASIQUOTE, sc->nil);
	  break;

	case TOKEN_COMMA:
	  push_stack_no_let_no_code(sc, OP_READ_UNQUOTE, sc->nil);
	  sc->tok = token(sc);
	  switch (sc->tok)
	    {
	    case TOKEN_EOF:
	      pop_stack(sc);
	      return(read_error(sc, "stray comma at the end of the input?"));

	    case TOKEN_RIGHT_PAREN:
	      return(read_expression_read_error(sc));

	    default:
	      break;
	    }
	  break;

	case TOKEN_AT_MARK:
	  push_stack_no_let_no_code(sc, OP_READ_APPLY_VALUES, sc->nil);
	  sc->tok = token(sc);
	  break;

	case TOKEN_ATOM:
	  return(port_read_name(sc->input_port)(sc, sc->input_port));
	  /* If reading list (from lparen), this will finally get us to op_read_list */

	case TOKEN_DOUBLE_QUOTE:
	  sc->value = read_string_constant(sc, sc->input_port);
	  if (sc->value == sc->F)                                   /* can happen if input code ends in the middle of a string */
	    return(string_read_error(sc, "end of input encountered while in a string"));
	  if (sc->value == sc->T)
	    return(read_error(sc, "unknown backslash usage -- perhaps you meant two backslashes?"));
	  if (sc->safety > IMMUTABLE_VECTOR_SAFETY) set_immutable(sc->value);
	  return(sc->value);

	case TOKEN_SHARP_CONST:
	  return(port_read_sharp(sc->input_port)(sc, sc->input_port));

	case TOKEN_DOT:                                             /* (catch #t (lambda () (+ 1 . . )) (lambda args 'hiho)) */
	  back_up_stack(sc);
	  do {c = inchar(sc->input_port);} while ((c != ')') && (c != EOF));
	  return(read_error(sc, "stray dot in list?"));             /* (+ 1 . . ) */

	case TOKEN_RIGHT_PAREN:                                     /* (catch #t (lambda () '(1 2 . )) (lambda args 'hiho)) */
	  back_up_stack(sc);
	  return(read_error(sc, "unexpected close paren"));         /* (+ 1 2)) or (+ 1 . ) */
	}
    }
  /* we never get here */
  return(sc->nil);
}


/* ---------------- *unbound-variable-hook* ---------------- */

static s7_pointer loaded_library(s7_scheme *sc, const char *file)
{
  s7_pointer p;
  for (p = slot_value(global_slot(sc->libraries_symbol)); is_pair(p); p = cdr(p))
    if (local_strcmp(file, string_value(caar(p))))
      return(cdar(p));
  return(sc->nil);
}

static s7_pointer find_closure_let(s7_scheme *sc, s7_pointer cur_env)
{
  s7_pointer e;
  for (e = cur_env; is_let(e); e = outlet(e))
    if (is_funclet(e))
      return(e);
  return(sc->nil);
}

static s7_pointer unbound_variable(s7_scheme *sc, s7_pointer sym)
{
  /* this always occurs in a context where we're trying to find anything, so I'll move a couple of those checks here */
  if (has_let_ref_fallback(sc->envir)) /* an experiment -- see s7test (with-let *db* (+ int32_t (length str))) */
    return(call_let_ref_fallback(sc, sc->envir, sym));
  /* but if the thing we want to hit this fallback happens to exist at a higher level, oops... */

  if (sym == sc->unquote_symbol)
    eval_error(sc, "unquote (',') occurred outside quasiquote: ~S", 45, current_code(sc));

  if (sym == sc->__func___symbol) /* __func__ is a sort of symbol macro */
    {
      s7_pointer env;
      env = find_closure_let(sc, sc->envir);
      if (is_let(env))
	{
	  /* for C-defined things like hooks and dilambda, let_file and let_line are 0 */
	  if ((has_let_file(env)) &&
	      (let_file(env) <= (s7_int)sc->file_names_top) && /* let_file(env) might be > int32_t */
	      (let_line(env) > 0))
	    return(list_3(sc, funclet_function(env), sc->file_names[let_file(env)], make_integer(sc, let_line(env))));
	  return(funclet_function(env));
	}
      return(sc->undefined);
    }

  if (safe_strcmp(symbol_name(sym), "|#"))
    return(read_error(sc, "unmatched |#"));

  /* check *autoload*, autoload_names, then *unbound-variable-hook* */
  if ((sc->autoload_names) ||
      (is_hash_table(sc->autoload_table)) ||
      (hook_has_functions(sc->unbound_variable_hook)))
    {
      s7_pointer result, cur_code, value, code, args, cur_env, x, z;
      /* sc->args and sc->code are pushed on the stack by s7_call, then
       *   restored by eval, so they are normally protected, but sc->value and current_code(sc) are
       *   not protected (yet).  We need current_code(sc) so that the possible eventual error
       *   call can tell where the error occurred, and we need sc->value because it might
       *   be awaiting addition to sc->args in e.g. OP_EVAL_ARGS5, and then be clobbered
       *   by the hook function.  (+ 1 asdf) will end up evaluating (+ asdf asdf) if sc->value
       *   is not protected.  We also need to save/restore sc->envir in case s7_load is called.
       */

      args = (sc->args) ? sc->args : sc->nil;
      code = sc->code;
      value = sc->value;
      cur_code = current_code(sc);
      cur_env = sc->envir;
      result = sc->undefined;
      x = sc->x;
      z = sc->z;
      sc->temp7 = cons(sc, code, cons(sc, args, cons(sc, value, cons(sc, cur_code, cons(sc, x, cons(sc, z, sc->nil)))))); /* not s7_list (debugger checks) */

      if ((port_file_number(sc->input_port) > 1) &&
	  (!is_pair(cur_code)))
	{
	  /* isolated typo perhaps -- no pair to hold the position info, so make one. current_code(sc) is GC-protected, so this should be safe. */
	  cur_code = cons(sc, sym, sc->nil);     /* the error will say "(sym)" which is not too misleading */
	  pair_set_line(cur_code, port_line_number(sc->input_port));
	  pair_set_file(cur_code, port_file_number(sc->input_port));
	  set_has_line_number(cur_code);
	}

#if (!DISABLE_AUTOLOAD)
      /* check sc->autoload_names */
      if ((sc->is_autoloading) &&
	  (sc->autoload_names))
	{
	  const char *file;
	  bool loaded = false;
	  file = find_autoload_name(sc, sym, &loaded, true);
	  if ((file) && (!loaded))
	    {
	      s7_pointer e;
	      /* if we've already loaded this file, we can get the library (e) from a table [(file lib) ...]
	       * here it was possible to get caught in a loop:
	       *   change file, reload, unbound var seen, check autoload, it says "load file"... (where file does not get added to *libraries*)
	       *   so the "loaded" arg tries to catch such cases
	       */
	      e = loaded_library(sc, file);
	      if (!is_let(e))
		e = s7_load(sc, file);
	      result = s7_symbol_value(sc, sym); /* calls find_symbol, does not trigger unbound_variable search */
	      if ((result == sc->undefined) &&
		  (is_let(e)))
		{
		  result = s7_let_ref(sc, e, sym);
		  /* I think to be consistent we should add '(sym . result) to the global env */
		  if (result != sc->undefined)
		    s7_define(sc, sc->nil, sym, result);
		}
	    }
	}
#endif

      if (result == sc->undefined)
	{
#if (!DISABLE_AUTOLOAD)
	  /* check the *autoload* hash table */
	  if ((sc->is_autoloading) &&
	      (is_hash_table(sc->autoload_table)))
	    {
	      s7_pointer val;
	      /* it was possible to get in a loop here: missing paren in x.scm, checks last symbol, sees
	       *   autoload sym -> x.scm, loads x.scm, missing paren...
	       */
	      val = s7_hash_table_ref(sc, sc->autoload_table, sym);
	      if (is_string(val))                /* val should be a filename. *load-path* is searched if necessary. */
		s7_load(sc, string_value(val));
	      else
		{
		  if (is_closure(val))           /* val should be a function of one argument, the current (calling) environment */
		    s7_call(sc, val, s7_cons(sc, sc->envir, sc->nil));
		}
	      result = s7_symbol_value(sc, sym); /* calls find_symbol, does not trigger unbound_variable search */
	    }
#endif

	  /* check *unbound-variable-hook* */
	  if ((result == sc->undefined) &&
	      (is_procedure(sc->unbound_variable_hook)) &&
	      (hook_has_functions(sc->unbound_variable_hook)))
	    {
	      /* (let () (set! (hook-functions *unbound-variable-hook*) (list (lambda (v) _asdf_))) _asdf_) */
	      s7_pointer old_hook;

	      old_hook = sc->unbound_variable_hook;
	      set_car(sc->z2_1, old_hook);
	      sc->unbound_variable_hook = sc->error_hook;      /* avoid the infinite loop mentioned above -- error_hook might be () or #f if we're in error-hook now */
	      result = s7_call(sc, old_hook, list_1(sc, sym)); /* not s7_apply_function */
	      sc->unbound_variable_hook = old_hook;
	    }
	}

      sc->value = T_Pos(value);
      set_current_code(sc, cur_code);
      sc->args = T_Pos(args);
      sc->code = code;
      sc->envir = cur_env;
      sc->x = x;
      sc->z = z;
      sc->temp7 = sc->nil;

      if ((result != sc->undefined) &&
	  (result != sc->unspecified))
	return(result);
    }
  eval_error_any(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, sym);
}

static s7_pointer syntax(s7_scheme *sc, const char *name, opcode_t op, s7_pointer min_args, s7_pointer max_args, const char *doc)
{
  s7_pointer x, syn;
  uint64_t hash;
  uint32_t loc;

  hash = raw_string_hash((const uint8_t *)name, safe_strlen(name));
  loc = hash % SYMBOL_TABLE_SIZE;
  x = new_symbol(sc, name, safe_strlen(name), hash, loc);

  syn = alloc_pointer(sc);
  set_type(syn, T_SYNTAX | T_SYNTACTIC | T_DONT_EVAL_ARGS | T_GLOBAL | T_UNHEAP);
  syntax_opcode(syn) = op;
  syntax_set_symbol(syn, x);
  syntax_min_args(syn) = integer(min_args);
  syntax_max_args(syn) = ((max_args == max_arity) ? -1 : integer(max_args));
  syntax_documentation(syn) = doc;

  set_global_slot(x, permanent_slot(sc, x, syn));
  set_initial_slot(x, permanent_slot(sc, x, syn));
  /* set_local_slot(x, global_slot(x)); */
  set_type_bit(x, T_SYMBOL | T_SYNTACTIC | T_GLOBAL | T_UNHEAP);
  symbol_set_local_unchecked(x, 0LL, sc->nil);
  symbol_set_ctr(x, 0;)
  return(x);
}

static s7_pointer definer_syntax(s7_scheme *sc, const char *name, opcode_t op, s7_pointer min_args, s7_pointer max_args, const char *doc)
{
  s7_pointer x;
  x = syntax(sc, name, op, min_args, max_args, doc);
  set_is_definer(x);
  return(x);
}

static s7_pointer binder_syntax(s7_scheme *sc, const char *name, opcode_t op, s7_pointer min_args, s7_pointer max_args, const char *doc)
{
  s7_pointer x;
  x = syntax(sc, name, op, min_args, max_args, doc);
  set_is_binder(x);
  return(x);
}

static s7_pointer g_is_pair_car_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if (is_pair(val))                                               /* (define (tst) (let ((a 123)) (pair? (car a)))) */
    return(make_boolean(sc, is_pair(car(val))));
  return(g_is_pair(sc, set_plist_1(sc, g_car(sc, set_plist_1(sc, val)))));
}

static s7_pointer g_is_pair_cdr_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if (is_pair(val))
    return(make_boolean(sc, is_pair(cdr(val))));
  return(g_is_pair(sc, set_plist_1(sc, g_cdr(sc, set_plist_1(sc, val)))));
}

static s7_pointer g_is_pair_cddr_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if ((is_pair(val)) && (is_pair(cdr(val))))
    return(make_boolean(sc, is_pair(cddr(val))));
  return(g_is_pair(sc, set_plist_1(sc, g_cddr(sc, set_plist_1(sc, val)))));
}

static s7_pointer g_is_pair_cadr_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if ((is_pair(val)) &&
      (is_pair(cdr(val))))
    return(make_boolean(sc, is_pair(cadr(val))));
  return(g_is_pair(sc, set_plist_1(sc, g_cadr(sc, set_plist_1(sc, val)))));
}

static s7_pointer g_is_null_cddr_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if ((is_pair(val)) && (is_pair(cdr(val))))
    return(make_boolean(sc, is_null(cddr(val))));
  return(g_is_null(sc, set_plist_1(sc, g_cddr(sc, set_plist_1(sc, val)))));
}

static s7_pointer g_is_null_cadr_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if ((is_pair(val)) && (is_pair(cdr(val))))
    return(make_boolean(sc, is_null(cadr(val))));
  return(g_is_null(sc, set_plist_1(sc, g_cadr(sc, set_plist_1(sc, val)))));
}

static s7_pointer g_is_symbol_cadr_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if ((is_pair(val)) && (is_pair(cdr(val))))
    return(make_boolean(sc, is_symbol(cadr(val))));
  return(g_is_symbol(sc, set_plist_1(sc, g_cadr(sc, set_plist_1(sc, val)))));
}

static s7_pointer is_pair_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if (is_h_safe_c_s(cadr(expr)))
    {
      s7_function g;
      g = c_callee(cadr(expr));
      if (g == g_car)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_pair_car_s);
	}
      if (g == g_cdr)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_pair_cdr_s);
	}
      if (g == g_cddr)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_pair_cddr_s);
	}
      if (g == g_cadr)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_pair_cadr_s);
	}
    }
  return(f);
}

static s7_pointer g_is_null_cdr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadar(args));
  if (is_pair(val))
    return(make_boolean(sc, is_null(cdr(val))));
  return(g_is_null(sc, set_plist_1(sc, g_cdr(sc, set_plist_1(sc, val)))));
}

static s7_pointer is_null_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if (is_h_safe_c_s(cadr(expr)))
    {
      s7_function g;
      g = c_callee(cadr(expr));
      if (g == g_cdr)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_null_cdr);
	}
      if (g == g_cddr)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_null_cddr_s);
	}
      if (g == g_cadr)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_null_cadr_s);
	}
    }
  return(f);
}

static s7_pointer is_symbol_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if (is_h_safe_c_s(cadr(expr)))
    {
      s7_function g;
      g = c_callee(cadr(expr));
      if (g == g_cadr)
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_symbol_cadr_s);
	}
    }
  return(f);
}

static s7_pointer g_format_allg(s7_scheme *sc, s7_pointer args)
{
  return(g_format_1(sc, args));
}

static s7_pointer g_format_just_control_string(s7_scheme *sc, s7_pointer args)
{
  s7_pointer pt, str;
  pt = car(args);
  str = cadr(args);

  if (pt == sc->F)
    return(str);

  if (is_null(pt))
    {
      pt = sc->output_port;
      if (pt == sc->F)
	return(sc->F);
    }
  if (pt == sc->T)
    {
      if ((sc->output_port != sc->F) && (string_length(str) != 0))
	port_write_string(sc->output_port)(sc, string_value(str), string_length(str), sc->output_port);
      return(str);
    }

  if ((!is_output_port(pt)) ||
      (port_is_closed(pt)))
    return(method_or_bust_with_type(sc, pt, sc->format_symbol, args, a_format_port_string, 1));

  if (string_length(str) == 0)
    {
      if (!is_output_port(pt))
	return(make_empty_string(sc, 0, 0));
      return(sc->F);
    }

  port_write_string(pt)(sc, string_value(str), string_length(str), pt);
  return(sc->F);
}

static s7_pointer g_format_as_objstr(s7_scheme *sc, s7_pointer args)
{
  s7_pointer func, obj;

  obj = caddr(args);
  if ((!has_active_methods(sc, obj)) ||
      ((func = find_method(sc, find_let(sc, obj), sc->format_symbol)) == sc->undefined))
    return(s7_object_to_string(sc, obj, false));

  return(s7_apply_function(sc, func, list_3(sc, sc->F, cadr(args), obj)));
}

static s7_pointer g_format_allg_no_column(s7_scheme *sc, s7_pointer args)
{
  s7_pointer pt, str;
  pt = car(args);
  if (is_null(pt))
    {
      pt = sc->output_port;
      if (pt == sc->F)
	return(sc->F);
    }

  if (!((s7_is_boolean(pt)) ||
	((is_output_port(pt)) &&             /* (current-output-port) or call-with-open-file arg, etc */
	 (!port_is_closed(pt)))))
    return(method_or_bust_with_type(sc, pt, sc->format_symbol, args, a_format_port_string, 1));

  str = cadr(args);
  sc->format_column = 0;
  return(format_to_port_1(sc, (pt == sc->T) ? sc->output_port : pt,
			  string_value(str), cddr(args), NULL,
			  !is_output_port(pt),   /* i.e. is boolean port so we're returning a string */
			  false,                 /* we checked in advance that it is not columnized */
			  string_length(str),
			  str));
}

static s7_pointer format_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args > 1)
    {
      s7_pointer port, str_arg;
      port = cadr(expr);
      str_arg = caddr(expr);
      if (is_string(str_arg))
	{
	  if ((ops) && ((args == 2) || (args == 3)))
	    {
	      s7_int len;
	      char *orig;
	      const char *p;

	      orig = string_value(str_arg);
	      p = strchr((const char *)orig, (int)'~');
	      if (!p)
		{
		  if (args == 2)
		    {
		      if (s7_is_boolean(port))
			set_optimize_op(expr, HOP_SAFE_C_D);
		      return(sc->format_just_control_string);
		    }
		  return(f);
		}

	      len = string_length(str_arg);
	      if ((args == 2) &&
		  (len > 1) &&
		  (orig[len - 1] == '%') &&
		  ((p - orig) == len - 2))
		{
		  orig[len - 2] = '\n';
		  orig[len - 1] = '\0';
		  string_length(str_arg) = len - 1;
		  if (s7_is_boolean(port))
		    set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->format_just_control_string);
		}

	      if ((args == 3) &&
		  (len == 2) &&
		  (port == sc->F) &&
		  (orig[0] == '~') &&
		  ((orig[1] == 'A') || (orig[1] == 'a')))
		return(sc->format_as_objstr);
	    }

	  /* this used to worry about optimized expr and particular cases -- why? I can't find a broken case */
	  if (!is_columnizing(string_value(str_arg)))
	    return(sc->format_allg_no_column);
	  return(sc->format_allg);
	}
    }
  return(f);
}

static s7_pointer g_is_eq_car(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst, val;
  lst = lookup(sc, cadar(args));
  val = lookup(sc, cadr(args));
  if (is_pair(lst))
    return(make_boolean(sc, car(lst) == val));
  return(make_boolean(sc, s7_is_eq(g_car(sc, set_plist_1(sc, lst)), val)));
}

static s7_pointer g_is_eq_car_q(s7_scheme *sc, s7_pointer args)
{
  s7_pointer lst;
  lst = lookup(sc, opt2_sym(args));
  if (is_pair(lst))
    return(make_boolean(sc, car(lst) == opt3_any(args)));
  return(make_boolean(sc, s7_is_eq(g_car(sc, set_plist_1(sc, lst)), opt3_any(args))));
}

static s7_pointer g_is_eq_caar_q(s7_scheme *sc, s7_pointer args)
{
  /* (eq? (caar x) 'y), but x is not guaranteed to be list(list) */
  s7_pointer lst;
  lst = lookup(sc, opt2_sym(args));
  if ((is_pair(lst)) && (is_pair(car(lst))))
    return(make_boolean(sc, caar(lst) == opt3_any(args)));
  return(make_boolean(sc, s7_is_eq(g_caar(sc, set_plist_1(sc, lst)), opt3_any(args))));
}

static s7_pointer is_eq_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if (is_h_safe_c_s(cadr(expr)))
    {
      if (((optimize_op(expr) == HOP_SAFE_C_opSq_S) ||
	   (optimize_op(expr) == HOP_SAFE_C_CAR_S_S) ||
	   ((is_h_safe_c_d(expr)) &&
	    (is_normal_symbol(caddr(expr))))) &&
	  (c_callee(cadr(expr)) == g_car))
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  return(sc->is_eq_car);
	}
      if (is_proper_quote(sc, caddr(expr)))
	{
	  /* is_proper_quote does not check the quoted object, so it might not be a symbol */
	  if (c_callee(cadr(expr)) == g_car)
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      set_opt2_sym(cdr(expr), cadadr(expr));        /* cadr(expr) is hop_safe_c_s */
	      set_opt3_any(cdr(expr), cadr(caddr(expr)));   /* but cadr(caddr(expr)) might not be a symbol */
	      return(sc->is_eq_car_q);
	    }
	  if (c_callee(cadr(expr)) == g_caar)
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      set_opt2_sym(cdr(expr), cadadr(expr));
	      set_opt3_any(cdr(expr), cadr(caddr(expr)));
	      return(sc->is_eq_caar_q);
	    }
	}
    }
  return(f);
}

static s7_pointer g_not_is_pair_s(s7_scheme *sc, s7_pointer args)   {check_boolean_not_method(sc, is_pair,      sc->is_pair_symbol, args);}
static s7_pointer g_not_is_null_s(s7_scheme *sc, s7_pointer args)   {check_boolean_not_method(sc, is_null,      sc->is_null_symbol, args);}
static s7_pointer g_not_is_symbol_s(s7_scheme *sc, s7_pointer args) {check_boolean_not_method(sc, is_symbol,    sc->is_symbol_symbol, args);}
static s7_pointer g_not_is_number_s(s7_scheme *sc, s7_pointer args) {check_boolean_not_method(sc, s7_is_number, sc->is_number_symbol, args);}

/* eq? does not check for methods */
static s7_pointer g_not_is_eq_sq(s7_scheme *sc, s7_pointer args)
{
  return(make_boolean(sc, lookup(sc, cadar(args)) != opt2_con(args)));             /* cadr(caddr(car(args))) */
}

static s7_pointer g_not_is_eq_ss(s7_scheme *sc, s7_pointer args)
{
  return(make_boolean(sc, lookup(sc, cadar(args)) != lookup(sc, opt3_sym(args)))); /* caddr(car(args)) */
}

/* here the method finder is in either car or cdr */
static s7_pointer g_not_is_pair_car_s(s7_scheme *sc, s7_pointer args)
{
  s7_pointer val;
  val = lookup(sc, cadr(cadar(args)));
  if (is_pair(val))
    return(make_boolean(sc, !is_pair(car(val))));
  return(g_not(sc, set_plist_1(sc, g_is_pair(sc, set_plist_1(sc, g_car(sc, set_plist_1(sc, val)))))));
}

static s7_pointer g_not_c_c(s7_scheme *sc, s7_pointer args)
{
  /* args: ( (null? l) ) */
  return(make_boolean(sc, is_false(sc, d_call(sc, car(args)))));
}

static s7_pointer not_chooser(s7_scheme *sc, s7_pointer g, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(g);
  if (is_optimized(cadr(expr))) /* cadr(expr) might be a symbol, for example; is_optimized includes is_pair */
    {
      if (is_h_safe_c_s(cadr(expr)))
	{
	  s7_function f;
	  f = c_callee(cadr(expr));

	  if (f == g_is_pair)
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->not_is_pair_s);
	    }
	  if (f == g_is_null)
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->not_is_null_s);
	    }
	  if (f == g_is_symbol)
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->not_is_symbol_s);
	    }

	  /* g_is_number is c_function_call(slot_value(global_slot(sc->is_number_symbol)))
	   *   so if this is changed (via openlet??) the latter is perhaps better??
	   * but user might have (#_number? e), so we can't change later and catch this.
	   */
	  if ((f == g_is_number) || (f == g_is_complex))
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->not_is_number_s);
	    }
	}
      if ((optimize_op(cadr(expr)) == HOP_SAFE_C_SC) &&
	  (c_callee(cadr(expr)) == g_is_eq))
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  if (is_pair(caddr(cadr(expr))))
	    set_opt2_con(cdr(expr), cadr(caddr(cadr(expr))));
	  else set_opt2_con(cdr(expr), caddr(cadr(expr)));
	  return(sc->not_is_eq_sq);
	}
      if (optimize_op(cadr(expr)) == HOP_SAFE_C_SS)
	{
	  if (c_callee(cadr(expr)) == g_is_eq)
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      set_opt3_sym(cdr(expr), caddr(cadr(expr)));
	      return(sc->not_is_eq_ss);
	    }
	}
      if (is_h_safe_c_d(cadr(expr)))
	{
	  set_optimize_op(expr, HOP_SAFE_C_D);
	  if (c_callee(cadr(expr)) == g_is_pair_car_s)
	    return(sc->not_is_pair_car_s);
	  return(sc->not_c_c);
	}
    }
  return(g);
}

static s7_pointer vector_ref_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  /* if (symbol_id(sc->vector_ref_symbol) != 0) return(f); */
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg1, arg2;
	  arg1 = cadr(expr);
	  arg2 = caddr(expr);
	  if (is_normal_symbol(arg1))
	    {
	      if (((optimize_op(expr) == HOP_SAFE_C_SC) ||
		   (is_h_safe_c_d(expr))) &&
		  (s7_is_integer(arg2)) &&
		  (s7_integer(arg2) >= 0))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  switch (s7_integer(arg2)) /* (might be big int) */
		    {
		    case 0: return(sc->vector_ref_ic_0);
		    case 1: return(sc->vector_ref_ic_1);
		    case 2: return(sc->vector_ref_ic_2);
		    case 3: return(sc->vector_ref_ic_3);
		    default: return(sc->vector_ref_ic);
		    }
		}
	      if ((is_possibly_constant(arg1)) &&
		  (is_slot(local_slot(arg1))))
		{
		  s7_pointer v;
		  v = slot_value(local_slot(arg1));
		  if ((is_normal_vector(v)) &&
		      (vector_rank(v) == 1))
		    return(sc->vector_ref_2_direct);
		}
	    }
	}
      /* vector_ref_sub_s1 was not worth the code, and few other easily optimized expressions happen here */
      return(sc->vector_ref_2);
    }
  if (args == 3)
    return(sc->vector_ref_3);
  return(f);
}

static s7_pointer vector_set_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 3) return(sc->vector_set_3);
  if (args == 4) return(sc->vector_set_4);
  return(f);
}

static s7_pointer list_set_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if ((args == 3) &&
      (s7_is_integer(caddr(expr))) &&
      (s7_integer(caddr(expr)) >= 0) &&
      (s7_integer(caddr(expr)) < sc->max_list_length))
    return(sc->list_set_ic);
  return(f);
}

static s7_pointer hash_table_ref_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
 if (args == 2)
    {
      /* choosers are run even in non-hop non-safe-symbol contexts, so any that look for a symbol
       *   need some way to ensure it is safe before changing to (say) hash_table_ref_ss which
       *   assumes that (coming from op_safe_c_ss normally).  But we get here more than once on
       *   the same expression somehow, so we have to recognize the initial case (h_safe_c_ss),
       *   then kludge up the returning case (h_safe_c_c).  Using is_slot(symbol_to_slot()) is
       *   no good because in context we use the current walker's "e" env to see the symbol,
       *   not the running environment.
       */
      if (ops)
	{
	  if ((optimize_op(expr) == HOP_SAFE_C_SS) ||
	      ((is_h_safe_c_d(expr)) &&
	       (is_normal_symbol(cadr(expr))) &&
	       (is_normal_symbol(caddr(expr)))))
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->hash_table_ref_ss);
	    }
	  if (((optimize_op(expr) == HOP_SAFE_C_S_opSq) ||
	       ((is_h_safe_c_d(expr)) && (is_symbol(cadr(expr))))) &&
	      (is_h_safe_c_s(caddr(expr))) &&
	      (c_callee(caddr(expr)) == g_car))
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      set_opt3_sym(cdr(expr), cadr(caddr(expr)));
	      return(sc->hash_table_ref_car);
	    }
	}
      return(sc->hash_table_ref_2);
    }
  return(f);
}

#if (!WITH_GMP)
static s7_pointer modulo_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if ((args == 2) &&
      ((optimize_op(expr) == HOP_SAFE_C_SC) ||
       ((is_h_safe_c_d(expr)) &&
	(is_normal_symbol(cadr(expr))))) &&
      (is_t_integer(caddr(expr))) &&
      (integer(caddr(expr)) > 1))
    {
      set_optimize_op(expr, HOP_SAFE_C_D);
      return(sc->mod_si);
    }
  return(f);
}
#endif

static s7_pointer argument_type(s7_scheme *sc, s7_pointer arg1)
{
  if (is_pair(arg1))
    {
      if (car(arg1) == sc->quote_symbol)
	return(s7_type_of(sc, cadr(arg1)));

      if ((is_h_optimized(arg1)) &&
	  (is_safe_c_op(optimize_op(arg1))) &&
	  (is_c_function(opt1_cfunc(arg1))))
	{
	  s7_pointer sig;
	  sig = c_function_signature(opt1_cfunc(arg1));
	  if ((sig) &&
	      (is_pair(sig)) &&
	      (is_symbol(car(sig))))
	    return(car(sig));
	}
    }
  else
    {
      if (!is_symbol(arg1))
	return(s7_type_of(sc, arg1));
    }
  return(NULL);
}

#if (!WITH_GMP)
static s7_pointer chooser_check_arg_types(s7_scheme *sc, s7_pointer arg1, s7_pointer arg2, s7_pointer fallback,
					  s7_pointer f_2_ff, s7_pointer f_2_ii, s7_pointer f_2_if, s7_pointer f_2_fi,
					  s7_pointer f_2_xi, s7_pointer f_2_ix, s7_pointer f_2_fx, s7_pointer f_2_xf)
{
  s7_pointer arg1_type, arg2_type;

  arg1_type = argument_type(sc, arg1);
  arg2_type = argument_type(sc, arg2);

  if ((arg1_type) || (arg2_type))
    {
      if (arg1_type == sc->is_float_symbol)
	{
	  if (arg2_type == sc->is_float_symbol)
	    return(f_2_ff);
	  if (arg2_type == sc->is_integer_symbol)
	    return(f_2_fi);
	  return(f_2_fx);
	}
      if (arg1_type == sc->is_integer_symbol)
	{
	  if (arg2_type == sc->is_float_symbol)
	    return(f_2_if);
	  if (arg2_type == sc->is_integer_symbol)
	    return(f_2_ii);
	  return(f_2_ix);
	}
      if (arg2_type == sc->is_float_symbol)
	return(f_2_xf);
      if (arg2_type == sc->is_integer_symbol)
	return(f_2_xi);
    }
  return(fallback);
}
#endif

static s7_pointer add_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  /* (+ s f) (+ (* s s) s) (+ s s) (+ s (* s s)) */
#if (!WITH_GMP)
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg1, arg2;
	  arg1 = cadr(expr);
	  arg2 = caddr(expr);

	  if (arg2 == small_int(1))                          /* (+ ... 1) */
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_SC) ||    /* (+ x 1) */
		  ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg1))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->add_cs1);
		}
	      return(sc->add_s1);
	    }
	  if (arg1 == small_int(1))
	    return(sc->add_1s);

	  if (s7_is_integer(arg2))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_SC) ||    /* (+ x 123) */
		  ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg1))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->add_si);
		}
	    }

	  if ((is_t_real(arg2)) &&
	      ((optimize_op(expr) == HOP_SAFE_C_SC) ||       /* (+ x 1.0) */
	       ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg1)))))
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->add_sf);
	    }

	  if (is_t_real(arg1))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_CS) ||    /* (+ 1.0 x) */
		  ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg2))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->add_fs);
		}
	      if ((is_h_safe_c_d(arg2)) &&
		  (c_callee(arg2) == g_multiply_sf))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->add_f_sf);
		}
	    }
	  return(chooser_check_arg_types(sc, arg1, arg2, sc->add_2,
					 sc->add_2_ff, sc->add_2_ii, sc->add_2_if, sc->add_2_fi,
					 sc->add_2_xi, sc->add_2_ix, sc->add_2_fx, sc->add_2_xf));
	}
      return(sc->add_2);
    }
#endif
  return(f);
}

static s7_pointer multiply_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
#if (!WITH_GMP)
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg1, arg2;
	  arg1 = cadr(expr);
	  arg2 = caddr(expr);

	  if (is_normal_symbol(arg1))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_SC) ||
		  (is_h_safe_c_d(expr)))
		{
		  if (s7_is_integer(arg2))
		    {
		      set_optimize_op(expr, HOP_SAFE_C_D);
		      return(sc->multiply_si);
		    }
		  if (is_t_real(arg2))
		    {
		      set_optimize_op(expr, HOP_SAFE_C_D);
		      return(sc->multiply_sf);
		    }
		}
	      if ((arg1 == arg2) &&
		  ((optimize_op(expr) == HOP_SAFE_C_SS) || (is_h_safe_c_d(expr))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->sqr_ss);
		}
	    }

	  if (is_symbol(arg2))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_CS) ||
		  (is_h_safe_c_d(expr)))
		{
		  if (s7_is_integer(arg1))
		    {
		      set_optimize_op(expr, HOP_SAFE_C_D);
		      return(sc->multiply_is);
		    }
		  if (is_t_real(arg1))
		    {
		      set_optimize_op(expr, HOP_SAFE_C_D);
		      return(sc->multiply_fs);
		    }
		}
	    }
	  return(chooser_check_arg_types(sc, arg1, arg2, sc->multiply_2,
					 sc->mul_2_ff, sc->mul_2_ii, sc->mul_2_if, sc->mul_2_fi,
					 sc->mul_2_xi, sc->mul_2_ix, sc->mul_2_fx, sc->mul_2_xf));
	}
      return(sc->multiply_2);
    }
#endif
  return(f);
}

static s7_pointer subtract_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
#if (!WITH_GMP)
  if (args == 1)
    return(sc->subtract_1);

  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg1, arg2;
	  arg1 = cadr(expr);
	  arg2 = caddr(expr);

	  if (arg2 == small_int(1))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_SC) ||    /* (- x 1) */
		  ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg1))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->subtract_cs1);
		}
	      return(sc->subtract_s1);
	    }

	  if (is_t_real(arg2))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_SC) ||    /* (- x 1.0) */
		  ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg1))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->subtract_sf);
		}
	    }

	  if (is_t_real(arg1))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_CS) ||    /* (- 1.0 x) */
		  ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg2))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->subtract_fs);
		}
	    }

	  if (s7_is_integer(arg2))
	    {
	      if ((optimize_op(expr) == HOP_SAFE_C_SC) ||    /* (- x 123) */
		  ((is_h_safe_c_d(expr)) && (is_normal_symbol(arg1))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->subtract_csn);
		}
	    }

	  if (is_t_real(arg2))
	    return(sc->subtract_2f);
	}
      return(sc->subtract_2);
    }
#endif
  return(f);
}

static s7_pointer divide_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
#if (!WITH_GMP)
  if (args == 1)
    return(sc->invert_1);
  if (ops)
    {
      if (args == 2)
	{
	  s7_pointer arg1;
	  arg1 = cadr(expr);
	  if ((is_t_real(arg1)) &&
	      (real(arg1) == 1.0))
	    return(sc->divide_1r);
	}
    }
#endif
  return(f);
}

#if (!WITH_GMP)
static s7_pointer equal_chooser(s7_scheme *sc, s7_pointer ur_f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg1, arg2;
	  arg1 = cadr(expr);
	  arg2 = caddr(expr);

	  if (s7_is_integer(arg2))
	    {
	      if ((is_safely_optimized(arg1)) &&
		  (has_fx(arg1)))
		{
		  s7_function f;
		  f = c_callee(arg1);
		  if (f == g_length)
		    {
		      if (is_h_safe_c_s(arg1))
			{
			  set_optimize_op(expr, HOP_SAFE_C_D);
			  return(sc->equal_length_ic);
			}
		    }
		}
	      if ((optimize_op(expr) == HOP_SAFE_C_SC) ||
		  ((is_h_safe_c_d(expr)) && (is_symbol(arg1))))
		{
		  set_optimize_op(expr, HOP_SAFE_C_D);
		  return(sc->equal_s_ic);
		}
	      return(sc->equal_2i);
	    }
	}
      return(sc->equal_2);
    }
  return(ur_f);
}

static s7_pointer less_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg2;
	  arg2 = caddr(expr);
	  if (is_t_integer(arg2))
	    {
	      if (is_h_safe_c_s(cadr(expr)))
		{
		  s7_function fc;
		  fc = c_callee(cadr(expr));
		  if (fc == g_length)
		    {
		      set_optimize_op(expr, HOP_SAFE_C_D);
		      return(sc->less_length_ic);
		    }
		}
	      if (integer(arg2) == 0)
		return(sc->less_s0);

	      if ((integer(arg2) < s7_int32_max) &&
		  (integer(arg2) > s7_int32_min))
		return(sc->less_s_ic);
	    }
	}
      return(sc->less_2);
    }
  return(f);
}

static s7_pointer leq_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg2;
	  arg2 = caddr(expr);
	  if ((is_t_integer(arg2)) &&
	      (integer(arg2) < s7_int32_max) &&
	      (integer(arg2) > s7_int32_min))
	    return(sc->leq_s_ic);
	}
      return(sc->leq_2);
    }
  return(f);
}

static s7_pointer greater_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg2;
	  arg2 = caddr(expr);

	  if ((is_t_integer(arg2)) &&
	      (integer(arg2) < s7_int32_max) &&
	      (integer(arg2) > s7_int32_min))
	    return(sc->greater_s_ic);

	  if ((is_t_real(arg2)) &&
	      (real(arg2) < s7_int32_max) &&
	      (real(arg2) > s7_int32_min))
	    return(sc->greater_s_fc);
	}
      return(sc->greater_2);
    }
  return(f);
}

static s7_pointer geq_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg2;
	  arg2 = caddr(expr);
	  if ((is_t_integer(arg2)) &&
	      (integer(arg2) < s7_int32_max) &&
	      (integer(arg2) > s7_int32_min))
	    return(sc->geq_s_ic);
	  if ((is_t_real(arg2)) &&
	      (real(arg2) < s7_int32_max) &&
	      (real(arg2) > s7_int32_min))
	    return(sc->geq_s_fc);
	}
      return(sc->geq_2);
    }
  return(f);
}
#endif
/* end (!WITH_GMP) */

static bool returns_char(s7_scheme *sc, s7_pointer arg)
{
  return(argument_type(sc, arg) == sc->is_char_symbol);
}

static s7_pointer char_equal_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    {
      if (ops)
	{
	  s7_pointer arg1, arg2;
	  arg1 = cadr(expr);
	  arg2 = caddr(expr);
	  if ((returns_char(sc, arg1)) && (returns_char(sc, arg2)))
	    return(sc->simple_char_eq);

	  if (((optimize_op(expr) == HOP_SAFE_C_SC) ||
	       ((is_h_safe_c_d(expr)) && (is_symbol(arg1)))) &&
	      (s7_is_character(arg2)))
	    {
	      set_optimize_op(expr, HOP_SAFE_C_D);
	      return(sc->char_equal_s_ic);
	    }
	}
      return(sc->char_equal_2);
    }
  return(f);
}

static s7_pointer char_less_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    return(sc->char_less_2);
  return(f);
}

static s7_pointer char_greater_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (args == 2)
    return(sc->char_greater_2);
  return(f);
}

static void check_for_substring_temp(s7_scheme *sc, s7_pointer expr)
{
  s7_pointer nps[NUM_STRING_WRAPPERS];
  s7_pointer p, arg;
  int32_t pairs = 0, substrs = 0;
  /* a bit tricky -- accept temp only if there's just one inner expression and it calls substring
   *   and don't use this for arg if arg is returned: (reverse! (write-string (symbol->string x)))
   */
  for (p = cdr(expr); is_pair(p); p = cdr(p))
    {
      arg = car(p);
      if (is_pair(arg))
	{
	  pairs++;
	  if ((is_symbol(car(arg))) &&
	      (is_safely_optimized(arg)) &&
	      (has_fx(arg)))
	    {
	      if (c_callee(arg) == g_substring)
		{
		  if (substrs < NUM_STRING_WRAPPERS)
		    nps[substrs++] = arg;
		}
	      else
		{
		  if (c_callee(arg) == g_symbol_to_string)
		    set_c_function(arg, sc->symbol_to_string_uncopied);
		  else
		    {
		      if ((c_callee(arg) == g_read_line) &&
			  (is_pair(cdr(arg))))
			set_c_function(arg, sc->read_line_uncopied);
		    }}}}}
  if ((pairs > 0) &&
      (pairs == substrs))
    {
      int32_t i;
      for (i = 0; i < substrs; i++)
	set_c_function(nps[i], sc->substring_to_temp);
    }
}

static s7_pointer char_position_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  if (!ops) return(f);
  if (((args == 2) || (args == 3)) &&
      (s7_is_character(cadr(expr))))
     return(sc->char_position_csi);
  return(f);
}

static s7_pointer string_equal_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  check_for_substring_temp(sc, expr);
  if (args == 2)
    return(sc->string_equal_2);
  return(f);
}

static s7_pointer string_less_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  check_for_substring_temp(sc, expr);
  if (args == 2)
    return(sc->string_less_2);
  return(f);
}

static s7_pointer string_greater_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  check_for_substring_temp(sc, expr);
  if (args == 2)
    return(sc->string_greater_2);
  return(f);
}

static s7_pointer string_substring_chooser(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops)
{
  /* used by several string functions */
  check_for_substring_temp(sc, expr);
  return(f);
}

static s7_pointer g_or_n(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer x;
      x = fx_call(sc, p);
      if (is_true(sc, x))
	return(x);
    }
  return(sc->F);
}

static s7_pointer g_or_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  p = fx_call(sc, args);
  if (p != sc->F) return(p);
  p = cdr(args);
  return(fx_call(sc, p));
}

static s7_pointer g_or_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  p = fx_call(sc, args);
  if (p != sc->F) return(p);
  p = cdr(args);
  p = fx_call(sc, p);
  if (p != sc->F) return(p);
  p = cddr(args);
  return(fx_call(sc, p));
}

static s7_pointer g_and_n(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p, x;
  x = sc->T;
  for (p = args; is_pair(p); p = cdr(p))
    {
      x = fx_call(sc, p);
      if (is_false(sc, x))
	return(x);
    }
  return(x);
}

static s7_pointer g_and_2(s7_scheme *sc, s7_pointer args)
{
  if (fx_call(sc, args) == sc->F)
    return(sc->F);
  return(fx_call(sc, cdr(args)));
}

static s7_pointer g_and_3(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  if (fx_call(sc, args) == sc->F)
    return(sc->F);
  p = cdr(args);
  if (fx_call(sc, p) == sc->F)
    return(sc->F);
  p = cdr(p);
  return(fx_call(sc, p));
}

static s7_pointer g_if_a_a(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  if (is_true(sc, fx_call(sc, args)))
    p = cdr(args);
  else return(sc->unspecified);
  return(fx_call(sc, p));
}

static s7_pointer g_if_a_aa(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  if (is_true(sc, fx_call(sc, args)))
    p = cdr(args);
  else p = cddr(args);
  return(fx_call(sc, p));
}

static s7_pointer g_if_not_a_a(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  if (is_true(sc, c_call(args)(sc, cadar(args))))
    return(sc->unspecified);
  p = cdr(args);
  return(fx_call(sc, p));
}

static s7_pointer g_if_not_a_aa(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  if (is_false(sc, c_call(args)(sc, cadar(args))))
    p = cdr(args);
  else p = cddr(args);
  return(fx_call(sc, p));
}

static s7_pointer g_if_x_qq(s7_scheme *sc, s7_pointer args)
{
  if (is_true(sc, fx_call(sc, args)))
    return(opt3_any(args));
  return(opt3_any(cdr(args)));
}

static s7_pointer g_if_x_qa(s7_scheme *sc, s7_pointer args)
{
  if (is_true(sc, fx_call(sc, args)))
    return(opt3_any(args));
  return(fx_call(sc, cddr(args)));
}

static s7_pointer g_or_s_direct(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p;
  set_car(sc->t1_1, lookup(sc, cadar(args)));
  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer x;
      x = c_call(car(p))(sc, sc->t1_1);
      if (is_true(sc, x))
	return(x);
    }
  return(sc->F);
}

static s7_pointer g_or_s_direct_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  set_car(sc->t1_1, lookup(sc, cadar(args)));
  x = c_call(car(args))(sc, sc->t1_1);
  if (is_true(sc, x)) return(x);
  return(c_call(cadr(args))(sc, sc->t1_1));
}

static s7_pointer g_or_s_type_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  x = lookup(sc, cadar(args));
  return(make_boolean(sc, (type(x) == symbol_type(caar(args))) || (type(x) == symbol_type(caadr(args)))));
}

static s7_pointer g_and_s_direct(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p, x = sc->T;
  set_car(sc->t1_1, lookup(sc, cadar(args)));
  for (p = args; is_pair(p); p = cdr(p))
    {
      x = c_call(car(p))(sc, sc->t1_1);
      if (is_false(sc, x))
	return(x);
    }
  return(x);
}

static s7_pointer g_and_s_direct_2(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  set_car(sc->t1_1, lookup(sc, cadar(args)));
  x = c_call(car(args))(sc, sc->t1_1);
  if (is_false(sc, x)) return(x);
  return(c_call(cadr(args))(sc, sc->t1_1));
}

static s7_pointer make_function_with_class(s7_scheme *sc, s7_pointer cls, const char *name, s7_function f,
					   int32_t required_args, int32_t optional_args, bool rest_arg, const char *doc)
{
  s7_pointer uf;
  /* the "safe_function" business here doesn't matter -- this is after the optimizer decides what is safe */
  uf = s7_make_safe_function(sc, name, f, required_args, optional_args, rest_arg, doc);
  s7_function_set_class(uf, cls);
  c_function_signature(uf) = c_function_signature(cls);
  return(uf);
}

static s7_pointer set_function_chooser(s7_scheme *sc, s7_pointer sym, s7_pointer (*chooser)(s7_scheme *sc, s7_pointer f, int32_t args, s7_pointer expr, bool ops))
{
  s7_pointer f;
  f = slot_value(global_slot(sym));
#ifndef WITHOUT_CHOOSERS
  c_function_chooser(f) = chooser;
#endif
  return(f);
}

static void init_choosers(s7_scheme *sc)
{
  s7_pointer f;

  /* + */
  f = set_function_chooser(sc, sc->add_symbol, add_chooser);
  sc->add_class = c_function_class(f);

  sc->add_2 = make_function_with_class(sc, f, "+", g_add_2, 2, 0, false, "+ opt");
  sc->add_1s = make_function_with_class(sc, f, "+", g_add_1s, 2, 0, false, "+ opt");
  sc->add_s1 = make_function_with_class(sc, f, "+", g_add_s1, 2, 0, false, "+ opt");
  sc->add_cs1 = make_function_with_class(sc, f, "+", g_add_cs1, 2, 0, false, "+ opt");
  sc->add_si = make_function_with_class(sc, f, "+", g_add_si, 2, 0, false, "+ opt");
  sc->add_sf = make_function_with_class(sc, f, "+", g_add_sf, 2, 0, false, "+ opt");
  sc->add_fs = make_function_with_class(sc, f, "+", g_add_fs, 2, 0, false, "+ opt");
  sc->add_f_sf = make_function_with_class(sc, f, "+", g_add_f_sf, 2, 0, false, "+ opt");

#if (!WITH_GMP)
  sc->add_2_ff = make_function_with_class(sc, f, "+", g_add_2_ff, 2, 0, false, "+ opt");
  sc->add_2_ii = make_function_with_class(sc, f, "+", g_add_2_ii, 2, 0, false, "+ opt");
  sc->add_2_if = make_function_with_class(sc, f, "+", g_add_2_if, 2, 0, false, "+ opt");
  sc->add_2_fi = make_function_with_class(sc, f, "+", g_add_2_fi, 2, 0, false, "+ opt");
  sc->add_2_xi = make_function_with_class(sc, f, "+", g_add_2_xi, 2, 0, false, "+ opt");
  sc->add_2_ix = make_function_with_class(sc, f, "+", g_add_2_ix, 2, 0, false, "+ opt");
  sc->add_2_fx = make_function_with_class(sc, f, "+", g_add_2_fx, 2, 0, false, "+ opt");
  sc->add_2_xf = make_function_with_class(sc, f, "+", g_add_2_xf, 2, 0, false, "+ opt");
#endif

  /* - */
  f = set_function_chooser(sc, sc->subtract_symbol, subtract_chooser);
  sc->subtract_class = c_function_class(f);
  sc->subtract_1 = make_function_with_class(sc, f, "-", g_subtract_1, 1, 0, false, "- opt");
  sc->subtract_2 = make_function_with_class(sc, f, "-", g_subtract_2, 2, 0, false, "- opt");
  sc->subtract_s1 = make_function_with_class(sc, f, "-", g_subtract_s1, 2, 0, false, "- opt");
  sc->subtract_cs1 = make_function_with_class(sc, f, "-", g_subtract_cs1, 2, 0, false, "- opt");
  sc->subtract_csn = make_function_with_class(sc, f, "-", g_subtract_csn, 2, 0, false, "- opt");
  sc->subtract_sf = make_function_with_class(sc, f, "-", g_subtract_sf, 2, 0, false, "- opt");
  sc->subtract_2f = make_function_with_class(sc, f, "-", g_subtract_2f, 2, 0, false, "- opt");
  sc->subtract_fs = make_function_with_class(sc, f, "-", g_subtract_fs, 2, 0, false, "- opt");

  /* * */
  f = set_function_chooser(sc, sc->multiply_symbol, multiply_chooser);
  sc->multiply_class = c_function_class(f);
#if (!WITH_GMP)
  sc->multiply_2 = make_function_with_class(sc, f, "*", g_multiply_2, 2, 0, false, "* opt");
  sc->multiply_is = make_function_with_class(sc, f, "*", g_multiply_is, 2, 0, false, "* opt");
  sc->multiply_si = make_function_with_class(sc, f, "*", g_multiply_si, 2, 0, false, "* opt");
  sc->multiply_fs = make_function_with_class(sc, f, "*", g_multiply_fs, 2, 0, false, "* opt");
  sc->multiply_sf = make_function_with_class(sc, f, "*", g_multiply_sf, 2, 0, false, "* opt");

  sc->mul_2_ff = make_function_with_class(sc, f, "*", g_mul_2_ff, 2, 0, false, "* opt");
  sc->mul_2_ii = make_function_with_class(sc, f, "*", g_mul_2_ii, 2, 0, false, "* opt");
  sc->mul_2_if = make_function_with_class(sc, f, "*", g_mul_2_if, 2, 0, false, "* opt");
  sc->mul_2_fi = make_function_with_class(sc, f, "*", g_mul_2_fi, 2, 0, false, "* opt");
  sc->mul_2_xi = make_function_with_class(sc, f, "*", g_mul_2_xi, 2, 0, false, "* opt");
  sc->mul_2_ix = make_function_with_class(sc, f, "*", g_mul_2_ix, 2, 0, false, "* opt");
  sc->mul_2_fx = make_function_with_class(sc, f, "*", g_mul_2_fx, 2, 0, false, "* opt");
  sc->mul_2_xf = make_function_with_class(sc, f, "*", g_mul_2_xf, 2, 0, false, "* opt");

  sc->sqr_ss = make_function_with_class(sc, f, "*", g_sqr_ss, 2, 0, false, "* opt");
#endif

  /* / */
  f = set_function_chooser(sc, sc->divide_symbol, divide_chooser);
#if (!WITH_GMP)
  sc->invert_1 = make_function_with_class(sc, f, "/", g_invert_1, 1, 0, false, "/ opt");
  sc->divide_1r = make_function_with_class(sc, f, "/", g_divide_1r, 2, 0, false, "/ opt");

  /* modulo */
  f = set_function_chooser(sc, sc->modulo_symbol, modulo_chooser);
  sc->mod_si = make_function_with_class(sc, f, "modulo", g_mod_si, 2, 0, false, "modulo opt");

  /* = */
  f = set_function_chooser(sc, sc->eq_symbol, equal_chooser);
  sc->equal_class = c_function_class(f);
  sc->equal_s_ic = make_function_with_class(sc, f, "=", g_equal_s_ic, 2, 0, false, "= opt");
  sc->equal_length_ic = make_function_with_class(sc, f, "=", g_equal_length_ic, 2, 0, false, "= opt");
#if (!WITH_GMP)
  sc->equal_2 = make_function_with_class(sc, f, "=", g_equal_2, 2, 0, false, "= opt");
#endif
  sc->equal_2i = make_function_with_class(sc, f, "=", g_equal_2i, 2, 0, false, "= opt");

  /* < */
  f = set_function_chooser(sc, sc->lt_symbol, less_chooser);
  sc->less_s_ic = make_function_with_class(sc, f, "<", g_less_s_ic, 2, 0, false, "< opt");
  sc->less_s0 = make_function_with_class(sc, f, "<", g_less_s0, 2, 0, false, "< opt");
  sc->less_2 = make_function_with_class(sc, f, "<", g_less_2, 2, 0, false, "< opt");
  sc->less_length_ic = make_function_with_class(sc, f, "<", g_less_length_ic, 2, 0, false, "< opt");

  /* > */
  f = set_function_chooser(sc, sc->gt_symbol, greater_chooser);
  sc->greater_s_ic = make_function_with_class(sc, f, ">", g_greater_s_ic, 2, 0, false, "> opt");
  sc->greater_s_fc = make_function_with_class(sc, f, ">", g_greater_s_fc, 2, 0, false, "> opt");
  sc->greater_2 = make_function_with_class(sc, f, ">", g_greater_2, 2, 0, false, "> opt");

  /* <= */
  f = set_function_chooser(sc, sc->leq_symbol, leq_chooser);
  sc->leq_s_ic = make_function_with_class(sc, f, "<=", g_leq_s_ic, 2, 0, false, "<= opt");
  sc->leq_2 = make_function_with_class(sc, f, "<=", g_leq_2, 2, 0, false, "<= opt");

  /* >= */
  f = set_function_chooser(sc, sc->geq_symbol, geq_chooser);
  sc->geq_s_ic = make_function_with_class(sc, f, ">=", g_geq_s_ic, 2, 0, false, ">= opt");
  sc->geq_s_fc = make_function_with_class(sc, f, ">=", g_geq_s_fc, 2, 0, false, ">= opt");
  sc->geq_2 = make_function_with_class(sc, f, ">=", g_geq_2, 2, 0, false, ">= opt");

  /* random */
  f = set_function_chooser(sc, sc->random_symbol, random_chooser);
  sc->random_1 = make_function_with_class(sc, f, "random", g_random_1, 1, 0, false, "random opt");
  sc->random_ic = make_function_with_class(sc, f, "random", g_random_ic, 1, 0, false, "random opt");
  sc->random_rc = make_function_with_class(sc, f, "random", g_random_rc, 1, 0, false, "random opt");
#endif

  /* char=? */
  f = set_function_chooser(sc, sc->char_eq_symbol, char_equal_chooser);
  sc->simple_char_eq = make_function_with_class(sc, f, "char=?", g_simple_char_eq, 2, 0, false, "char=? opt");
  sc->char_equal_s_ic = make_function_with_class(sc, f, "char=?", g_char_equal_s_ic, 2, 0, false, "char=? opt");
  sc->char_equal_2 = make_function_with_class(sc, f, "char=?", g_char_equal_2, 2, 0, false, "char=? opt");

  /* char>? */
  f = set_function_chooser(sc, sc->char_gt_symbol, char_greater_chooser);
  sc->char_greater_2 = make_function_with_class(sc, f, "char>?", g_char_greater_2, 2, 0, false, "char>? opt");

  /* char<? */
  f = set_function_chooser(sc, sc->char_lt_symbol, char_less_chooser);
  sc->char_less_2 = make_function_with_class(sc, f, "char<?", g_char_less_2, 2, 0, false, "char<? opt");

  /* char-position */
  f = set_function_chooser(sc, sc->char_position_symbol, char_position_chooser);
  sc->char_position_csi = make_function_with_class(sc, f, "char-position", g_char_position_csi, 2, 1, false, "char-position opt");

  /* string=? */
  f = set_function_chooser(sc, sc->string_eq_symbol, string_equal_chooser);
  sc->string_equal_2 = make_function_with_class(sc, f, "string=?", g_string_equal_2, 2, 0, false, "string=? opt");

  /* substring */
  sc->substring_to_temp = s7_make_function(sc, "substring", g_substring_to_temp, 2, 1, false, "substring opt");
  s7_function_set_class(sc->substring_to_temp, slot_value(global_slot(sc->substring_symbol)));

  /* string>? */
  f = set_function_chooser(sc, sc->string_gt_symbol, string_greater_chooser);
  sc->string_greater_2 = make_function_with_class(sc, f, "string>?", g_string_greater_2, 2, 0, false, "string>? opt");

  /* string<? */
  f = set_function_chooser(sc, sc->string_lt_symbol, string_less_chooser);
  sc->string_less_2 = make_function_with_class(sc, f, "string<?", g_string_less_2, 2, 0, false, "string<? opt");

  /* string-ref et al */
  set_function_chooser(sc, sc->string_ref_symbol, string_substring_chooser);
  set_function_chooser(sc, sc->string_append_symbol, string_substring_chooser);
  set_function_chooser(sc, sc->string_to_symbol_symbol, string_substring_chooser);
#if (!WITH_PURE_S7)
  set_function_chooser(sc, sc->string_length_symbol, string_substring_chooser);
  set_function_chooser(sc, sc->string_copy_symbol, string_substring_chooser);
#endif

  /* symbol->string */
  f = slot_value(global_slot(sc->symbol_to_string_symbol));
  sc->symbol_to_string_uncopied = s7_make_function(sc, "symbol->string", g_symbol_to_string_uncopied, 1, 0, false, "symbol->string opt");
  s7_function_set_class(sc->symbol_to_string_uncopied, f);

  /* display */
  f = set_function_chooser(sc, sc->display_symbol, display_chooser);
  sc->display_2 = make_function_with_class(sc, f, "display", g_display_2, 2, 0, false, "display opt");

  /* vector-ref */
  f = set_function_chooser(sc, sc->vector_ref_symbol, vector_ref_chooser);
  sc->vector_ref_ic = make_function_with_class(sc, f, "vector-ref", g_vector_ref_ic, 2, 0, false, "vector-ref opt");
  sc->vector_ref_ic_0 = make_function_with_class(sc, f, "vector-ref", g_vector_ref_ic_0, 1, 0, false, "vector-ref opt");
  sc->vector_ref_ic_1 = make_function_with_class(sc, f, "vector-ref", g_vector_ref_ic_1, 1, 0, false, "vector-ref opt");
  sc->vector_ref_ic_2 = make_function_with_class(sc, f, "vector-ref", g_vector_ref_ic_2, 1, 0, false, "vector-ref opt");
  sc->vector_ref_ic_3 = make_function_with_class(sc, f, "vector-ref", g_vector_ref_ic_3, 1, 0, false, "vector-ref opt");
  sc->vector_ref_2 = make_function_with_class(sc, f, "vector-ref", g_vector_ref_2, 2, 0, false, "vector-ref opt");
  sc->vector_ref_3 = make_function_with_class(sc, f, "vector-ref", g_vector_ref_3, 3, 0, false, "vector-ref opt");
  sc->vector_ref_2_direct = make_function_with_class(sc, f, "vector-ref", g_vector_ref_2_direct, 2, 0, false, "vector-ref opt");

  /* vector-set! */
  f = set_function_chooser(sc, sc->vector_set_symbol, vector_set_chooser);
  sc->vector_set_3 = make_function_with_class(sc, f, "vector-set!", g_vector_set_3, 3, 0, false, "vector-set! opt");
  sc->vector_set_4 = make_function_with_class(sc, f, "vector-set!", g_vector_set_4, 4, 0, false, "vector-set! opt");

  /* float-vector-ref */
  f = set_function_chooser(sc, sc->float_vector_ref_symbol, float_vector_ref_chooser);
  sc->fv_ref_2 = make_function_with_class(sc, f, "float-vector-ref", g_fv_ref_2, 2, 0, false, "float-vector-ref opt");
  sc->fv_ref_3 = make_function_with_class(sc, f, "float-vector-ref", g_fv_ref_3, 3, 0, false, "float-vector-ref opt");

  /* float-vector-set */
  f = set_function_chooser(sc, sc->float_vector_set_symbol, float_vector_set_chooser);
  sc->fv_set_3 = make_function_with_class(sc, f, "float-vector-set!", g_fv_set_3, 3, 0, false, "float-vector-set! opt");
  sc->fv_set_unchecked = make_function_with_class(sc, f, "float-vector-set!", g_fv_set_unchecked, 3, 0, false, "float-vector-set! opt");

  /* int-vector-ref */
  f = set_function_chooser(sc, sc->int_vector_ref_symbol, int_vector_ref_chooser);
  sc->iv_ref_2 = make_function_with_class(sc, f, "int-vector-ref", g_iv_ref_2, 2, 0, false, "int-vector-ref opt");
  sc->iv_ref_3 = make_function_with_class(sc, f, "int-vector-ref", g_iv_ref_3, 3, 0, false, "int-vector-ref opt");

  /* int-vector-set */
  f = set_function_chooser(sc, sc->int_vector_set_symbol, int_vector_set_chooser);
  sc->iv_set_3 = make_function_with_class(sc, f, "int-vector-set!", g_iv_set_3, 3, 0, false, "int-vector-set! opt");

  /* byte-vector-ref */
  f = set_function_chooser(sc, sc->byte_vector_ref_symbol, byte_vector_ref_chooser);
  sc->bv_ref_2 = make_function_with_class(sc, f, "byte-vector-ref", g_bv_ref_2, 2, 0, false, "byte-vector-ref opt");
  sc->bv_ref_3 = make_function_with_class(sc, f, "byte-vector-ref", g_bv_ref_3, 3, 0, false, "byte-vector-ref opt");

  /* byte-vector-set */
  f = set_function_chooser(sc, sc->byte_vector_set_symbol, byte_vector_set_chooser);
  sc->bv_set_3 = make_function_with_class(sc, f, "byte-vector-set!", g_bv_set_3, 3, 0, false, "byte-vector-set! opt");

  /* list-set! */
  f = set_function_chooser(sc, sc->list_set_symbol, list_set_chooser);
  sc->list_set_ic = make_function_with_class(sc, f, "list-set!", g_list_set_ic, 3, 0, false, "list-set! opt");

  /* hash-table-ref */
  f = set_function_chooser(sc, sc->hash_table_ref_symbol, hash_table_ref_chooser);
  sc->hash_table_ref_2 = make_function_with_class(sc, f, "hash-table-ref", g_hash_table_ref_2, 2, 0, false, "hash-table-ref opt");
  sc->hash_table_ref_ss = make_function_with_class(sc, f, "hash-table-ref", g_hash_table_ref_ss, 2, 0, false, "hash-table-ref opt");
  sc->hash_table_ref_car = make_function_with_class(sc, f, "hash-table-ref", g_hash_table_ref_car, 2, 0, false, "hash-table-ref opt");

  /* hash-table */
  f = set_function_chooser(sc, sc->hash_table_symbol, hash_table_chooser);
  sc->hash_table_2 = make_function_with_class(sc, f, "hash-table", g_hash_table_2, 2, 0, false, "hash-table opt");

  /* format */
  f = set_function_chooser(sc, sc->format_symbol, format_chooser);
  sc->format_allg = make_function_with_class(sc, f, "format", g_format_allg, 1, 0, true, "format opt");
  sc->format_allg_no_column = make_function_with_class(sc, f, "format", g_format_allg_no_column, 1, 0, true, "format opt");
  sc->format_just_control_string = make_function_with_class(sc, f, "format", g_format_just_control_string, 2, 0, false, "format opt");
  sc->format_as_objstr = make_function_with_class(sc, f, "format", g_format_as_objstr, 3, 0, true, "format opt");

  /* not */
  f = set_function_chooser(sc, sc->not_symbol, not_chooser);
  sc->not_is_pair_s = make_function_with_class(sc, f, "not", g_not_is_pair_s, 1, 0, false, "not opt");
  sc->not_is_null_s = make_function_with_class(sc, f, "not", g_not_is_null_s, 1, 0, false, "not opt");
  sc->not_is_symbol_s = make_function_with_class(sc, f, "not", g_not_is_symbol_s, 1, 0, false, "not opt");
  sc->not_is_number_s = make_function_with_class(sc, f, "not", g_not_is_number_s, 1, 0, false, "not opt");
  sc->not_is_eq_ss = make_function_with_class(sc, f, "not", g_not_is_eq_ss, 1, 0, false, "not opt");
  sc->not_is_eq_sq = make_function_with_class(sc, f, "not", g_not_is_eq_sq, 1, 0, false, "not opt");
  sc->not_is_pair_car_s = make_function_with_class(sc, f, "not", g_not_is_pair_car_s, 1, 0, false, "not opt");
  sc->not_c_c = make_function_with_class(sc, f, "not", g_not_c_c, 1, 0, false, "not opt");

  /* pair? */
  f = set_function_chooser(sc, sc->is_pair_symbol, is_pair_chooser);
  sc->is_pair_car_s = make_function_with_class(sc, f, "pair?", g_is_pair_car_s, 1, 0, false, "pair? opt");
  sc->is_pair_cdr_s = make_function_with_class(sc, f, "pair?", g_is_pair_cdr_s, 1, 0, false, "pair? opt");
  sc->is_pair_cddr_s = make_function_with_class(sc, f, "pair?", g_is_pair_cddr_s, 1, 0, false, "pair? opt");
  sc->is_pair_cadr_s = make_function_with_class(sc, f, "pair?", g_is_pair_cadr_s, 1, 0, false, "pair? opt");

  /* null? */
  f = set_function_chooser(sc, sc->is_null_symbol, is_null_chooser);
  sc->is_null_cdr = make_function_with_class(sc, f, "null?", g_is_null_cdr, 1, 0, false, "null? opt");
  sc->is_null_cddr_s = make_function_with_class(sc, f, "null?", g_is_null_cddr_s, 1, 0, false, "null? opt");
  sc->is_null_cadr_s = make_function_with_class(sc, f, "null?", g_is_null_cadr_s, 1, 0, false, "null? opt");

  /* symbol? */
  f = set_function_chooser(sc, sc->is_symbol_symbol, is_symbol_chooser);
  sc->is_symbol_cadr_s = make_function_with_class(sc, f, "symbol?", g_is_symbol_cadr_s, 1, 0, false, "symbol? opt");

  /* eq? */
  f = set_function_chooser(sc, sc->is_eq_symbol, is_eq_chooser);
  sc->is_eq_car = make_function_with_class(sc, f, "eq?", g_is_eq_car, 2, 0, false, "eq? opt");
  sc->is_eq_car_q = make_function_with_class(sc, f, "eq?", g_is_eq_car_q, 2, 0, false, "eq? opt");
  sc->is_eq_caar_q = make_function_with_class(sc, f, "eq?", g_is_eq_caar_q, 2, 0, false, "eq? opt");

  /* member */
  f = set_function_chooser(sc, sc->member_symbol, member_chooser);
  sc->member_ss = make_function_with_class(sc, f, "member", g_member_ss, 2, 0, false, "member opt");
  sc->member_sq = make_function_with_class(sc, f, "member", g_member_sq, 2, 0, false, "member opt");

  /* memq */
  f = set_function_chooser(sc, sc->memq_symbol, memq_chooser);  /* is pure-s7, use member here */
  sc->memq_2 = make_function_with_class(sc, f, "memq", g_memq_2, 2, 0, false, "memq opt");
  sc->memq_3 = make_function_with_class(sc, f, "memq", g_memq_3, 2, 0, false, "memq opt");
  sc->memq_4 = make_function_with_class(sc, f, "memq", g_memq_4, 2, 0, false, "memq opt");
  sc->memq_any = make_function_with_class(sc, f, "memq", g_memq_any, 2, 0, false, "memq opt");
  sc->memq_car = make_function_with_class(sc, f, "memq", g_memq_car, 2, 0, false, "memq opt");
  sc->memq_car_2 = make_function_with_class(sc, f, "memq", g_memq_car_2, 2, 0, false, "memq opt");

  /* tree-set-memq */
  f = set_function_chooser(sc, sc->tree_set_memq_symbol, tree_set_memq_chooser);
  sc->tree_set_memq_syms = make_function_with_class(sc, f, "tree-set-memq", g_tree_set_memq_1, 2, 0, false, "tree-set-memq opt");

  /* read-line */
  sc->read_line_uncopied = s7_make_function(sc, "read-line", g_read_line_uncopied, 1, 1, false, "read-line opt");
  s7_function_set_class(sc->read_line_uncopied, slot_value(global_slot(sc->read_line_symbol)));

  /* eval-string */
  set_function_chooser(sc, sc->eval_string_symbol, eval_string_chooser);

  /* inlet */
  f = set_function_chooser(sc, sc->inlet_symbol, inlet_chooser);
  sc->simple_inlet = make_function_with_class(sc, f, "inlet", g_simple_inlet, 0, 0, true, "inlet opt");

  /* let-ref */
  f = set_function_chooser(sc, sc->let_ref_symbol, let_ref_chooser);
  sc->lint_let_ref = make_function_with_class(sc, f, "let-ref", g_lint_let_ref, 2, 0, false, "let-ref opt");

  /* let-set */
  f = set_function_chooser(sc, sc->let_set_symbol, let_set_chooser);
  sc->lint_let_set = make_function_with_class(sc, f, "let-set!", g_lint_let_set, 3, 0, false, "let-set! opt");

  sc->or_n = s7_make_function(sc, "or", g_or_n, 0, 0, true, "or opt");
  sc->or_2 = s7_make_function(sc, "or", g_or_2, 2, 0, false, "or opt");
  sc->or_3 = s7_make_function(sc, "or", g_or_3, 3, 0, false, "or opt");
  sc->and_n = s7_make_function(sc, "and", g_and_n, 0, 0, true, "and opt");
  sc->and_2 = s7_make_function(sc, "and", g_and_2, 2, 0, false, "and opt");
  sc->and_3 = s7_make_function(sc, "and", g_and_3, 3, 0, false, "and opt");
  sc->if_a_a = s7_make_function(sc, "if", g_if_a_a, 2, 0, false, "if opt");
  sc->if_a_aa = s7_make_function(sc, "if", g_if_a_aa, 3, 0, false, "if opt");
  sc->if_not_a_a = s7_make_function(sc, "if", g_if_not_a_a, 2, 0, false, "if opt");
  sc->if_not_a_aa = s7_make_function(sc, "if", g_if_not_a_aa, 3, 0, false, "if opt");
  sc->if_x_qq = s7_make_function(sc, "if", g_if_x_qq, 3, 0, false, "if opt");
  sc->if_x_qa = s7_make_function(sc, "if", g_if_x_qa, 3, 0, false, "if opt");

  sc->or_s_direct = s7_make_function(sc, "or", g_or_s_direct, 0, 0, true, "or opt");
  sc->and_s_direct = s7_make_function(sc, "and", g_and_s_direct, 0, 0, true, "and opt");
  sc->or_s_direct_2 = s7_make_function(sc, "or", g_or_s_direct_2, 0, 0, true, "or opt");
  sc->and_s_direct_2 = s7_make_function(sc, "and", g_and_s_direct_2, 0, 0, true, "and opt");
  sc->or_s_type_2 = s7_make_function(sc, "or", g_or_s_type_2, 0, 0, true, "or opt");
}

#define choose_c_function(Sc, Expr, Func, Args) set_c_function(Expr, c_function_chooser(Func)(Sc, Func, Args, Expr, true))

static void annotate_args(s7_scheme *sc, s7_pointer args, s7_pointer e)
{
  s7_pointer p;
  for (p = args; is_pair(p); p = cdr(p))
    {
#if S7_DEBUGGING
      s7_function fx;
      fx = fx_choose(sc, p, e, (is_list(e)) ? pair_symbol_is_safe : let_symbol_is_safe);
      if (!fx)
	{
	  fprintf(stderr, "%s: is_fx_safe: %d, fx_choose null?\n", DISPLAY(p), is_fx_safe(sc, car(p)));
	  abort();
	}
      set_c_call(p, fx);
#else
      set_c_call(p, fx_choose(sc, p, e, (is_list(e)) ? pair_symbol_is_safe : let_symbol_is_safe));
#endif
    }
}

static void annotate_arg(s7_scheme *sc, s7_pointer arg, s7_pointer e)
{
  /* if sc->envir is sc->nil, we're at the top-level, but the global_slot check should suffice for that */
  set_c_call(arg, fx_choose(sc, arg, e, (is_list(e)) ? pair_symbol_is_safe : let_symbol_is_safe));
#if S7_DEBUGGING
  if (!c_callee(arg))
    abort();
#endif
}

#define OPTIMIZE_PRINT 0

static opt_t optimize_thunk(s7_scheme *sc, s7_pointer expr, s7_pointer func, int32_t hop, s7_pointer e)
{
#if OPTIMIZE_PRINT
  fprintf(stderr, "opt 0: %s %d\n", DISPLAY(expr), hop);
#endif

  if (is_constant_symbol(sc, car(expr))) hop = 1;

  if ((is_closure(func)) || (is_closure_star(func)))
    {
      bool safe_case;
      safe_case = is_safe_closure(func);
      if (is_immutable(func)) hop = 1;
      if (is_null(closure_args(func)))                 /* no rest arg funny business */
	{
	  s7_pointer body;
	  body = closure_body(func);
	  if (is_null(cdr(body)))
	    {
	      if ((is_safe_closure(func)) &&
		  (is_fx_safe(sc, car(body))))         /* fx stuff is not set yet */
		{
		  annotate_arg(sc, body, e);
		  set_optimize_op(expr, hop + OP_SAFE_THUNK_A);
		  set_closure_has_fx(func);
		  set_opt1_lambda(expr, func);
		  return(OPT_T);
		}
	      set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_THUNK_P : OP_THUNK_P));
	    }
	  else set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_THUNK : OP_THUNK));
	  set_opt1_lambda(expr, func);
	}
      else
	{
	  if (is_closure_star(func))
	    {
	      set_opt1_lambda(expr, func);
	      set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_STAR_FX_0 : OP_CLOSURE_STAR_FX));
	    }
	}
      return(OPT_F);
    }

  if (is_c_function(func))
    {
      if (c_function_required_args(func) != 0)
	return(OPT_F);
      if ((hop == 0) && (symbol_id(car(expr)) == 0)) hop = 1;

      if ((is_safe_procedure(func)) ||
	  (c_function_call(func) == g_list) ||          /* (list) is safe */
	  (c_function_call(func) == g_values))          /* (values) is safe */
	{
	  set_safe_optimize_op(expr, hop + OP_SAFE_C_D);
	  choose_c_function(sc, expr, func, 0);
	  return(OPT_T);
	}
      return(OPT_F);
    }

  if (is_c_function_star(func))
    {
      set_optimized(expr);
      set_optimize_op(expr, hop + OP_SAFE_C_STAR);
      set_c_function(expr, func);
      return(OPT_T);
    }

  return(OPT_F);
}

static opt_t optimize_func_dotted_args(s7_scheme *sc, s7_pointer expr, s7_pointer func, int32_t hop, int32_t args, s7_pointer e)
{
  if (fx_count(sc, expr) == args)
    {
      set_unsafely_optimized(expr);
      annotate_args(sc, cdr(expr), e);
      set_opt3_arglen(expr, small_int(args));
      set_optimize_op(expr, hop + OP_CLOSURE_ANY_FX);
      set_opt1_lambda(expr, func);
      return(OPT_F);
    }
  return(OPT_F);
}

static int32_t combine_ops(s7_scheme *sc, s7_pointer func, s7_pointer expr, combine_op_t cop, s7_pointer e1, s7_pointer e2) /* sc needed for debugger stuff */
{
  int32_t arg_op;
  s7_pointer arg;

  switch (cop)
    {
    case E_C_P:
      arg_op = op_no_hop(e1);
      switch (arg_op)
	{
	case OP_SAFE_C_S: case OP_SAFE_CAR_S: case OP_SAFE_CDR_S: case OP_SAFE_CADR_S:
	case OP_SAFE_IS_PAIR_S: case OP_SAFE_IS_NULL_S: case OP_SAFE_IS_SYMBOL_S:
	  return(OP_SAFE_C_opSq);
	case OP_SAFE_C_D:      return(OP_SAFE_C_opDq);
	case OP_SAFE_C_SS:     return(OP_SAFE_C_opSSq);
	case OP_SAFE_C_SC:     return(OP_SAFE_C_opSCq);
	case OP_SAFE_C_CS:     return(OP_SAFE_C_opCSq);
	case OP_SAFE_C_opSq:   return(OP_SAFE_C_op_opSq_q);
	case OP_SAFE_C_S_opSq: return(OP_SAFE_C_op_S_opSq_q);
	case OP_SAFE_C_CAR_S_S:
	case OP_SAFE_C_opSq_S: return(OP_SAFE_C_op_opSq_S_q);
	case OP_SAFE_C_A:      return(OP_SAFE_C_opAq);
	case OP_SAFE_C_AA:     return(OP_SAFE_C_opAAq);
	case OP_SAFE_C_AAA:    return(OP_SAFE_C_opAAAq);
	  /* deeper opA...q nestings are rare */
	}
      /* opsq_c opsq_opsq s_opdq sss opssq? opdq opssq_s? */
      /* fprintf(stderr, "combine %s: %s\n", op_names[arg_op], DISPLAY(expr)); */
      return(OP_SAFE_C_P); /* this splits out to A in optimize_func one_arg */

    case E_C_SP:
      arg = e2;
      arg_op = op_no_hop(arg);
      switch (arg_op)
	{
	case OP_SAFE_C_S: case OP_SAFE_CAR_S: case OP_SAFE_CDR_S: case OP_SAFE_CADR_S:
	case OP_SAFE_IS_PAIR_S: case OP_SAFE_IS_NULL_S: case OP_SAFE_IS_SYMBOL_S:
	  set_opt1_sym(cdr(expr), cadr(arg));
	  return(OP_SAFE_C_S_opSq);

	case OP_SAFE_C_D:
	  set_opt1_pair(cdr(expr), cdr(arg));
	  return(OP_SAFE_C_S_opDq);

	case OP_SAFE_C_SC:
	  set_opt1_sym(cdr(expr), cadr(arg));
	  set_opt2_con(cdr(expr), caddr(arg));
	  return(OP_SAFE_C_S_opSCq);

	case OP_SAFE_C_CS:	  /* expr is (* a (- 1 b)), e2 is (- 1 b) */
	  /* set_opt1_con(cdr(expr), cadr(arg)); */
	  set_opt2_sym(cdr(expr), caddr(arg));
	  return(OP_SAFE_C_S_opCSq);

	case OP_SAFE_C_SS:	  /* (* a (- b c)) */
	  set_opt1_sym(cdr(expr), cadr(arg));
	  set_opt2_sym(cdr(expr), caddr(arg));
	  return(OP_SAFE_C_S_opSSq);

	case OP_SAFE_C_opSq_C:      return(OP_SAFE_C_S_op_opSq_Cq);
	case OP_SAFE_C_S_opSSq:	    return(OP_SAFE_C_S_op_S_opSSqq);
	case OP_SAFE_C_S_opSq:	    return(OP_SAFE_C_S_op_S_opSqq);
	case OP_SAFE_C_opSSq_opSSq: return(OP_SAFE_C_S_op_opSSq_opSSqq);
	case OP_SAFE_C_A:	    return(OP_SAFE_C_S_opAq);
	case OP_SAFE_C_AA:	    return(OP_SAFE_C_S_opAAq);
	case OP_SAFE_C_CAC: case OP_SAFE_C_CSA: case OP_SAFE_C_SCA:
	case OP_SAFE_C_SAS: case OP_SAFE_C_SSA:	case OP_SAFE_C_AAA:
	  return(OP_SAFE_C_S_opAAAq);
	}
      return(OP_SAFE_C_SP); /* if fxable -> AA later */

    case E_C_PS:
      arg = e1;
      arg_op = op_no_hop(arg);
      switch (arg_op)
	{
	case OP_SAFE_CAR_S:
	  return(OP_SAFE_C_CAR_S_S);
	case OP_SAFE_C_S:
	  if (c_callee(arg) == g_car)
	    {
	      set_opt1_sym(cdr(expr), cadr(arg));
	      return(OP_SAFE_C_CAR_S_S);
	    }
	case OP_SAFE_CDR_S: case OP_SAFE_CADR_S:
	case OP_SAFE_IS_PAIR_S: case OP_SAFE_IS_NULL_S: case OP_SAFE_IS_SYMBOL_S:
	  return(OP_SAFE_C_opSq_S);
	case OP_SAFE_C_SS:    return(OP_SAFE_C_opSSq_S);
	case OP_SAFE_C_D:     return(OP_SAFE_C_opDq_S);
	case OP_SAFE_C_CS:    return(OP_SAFE_C_opCSq_S);
	case OP_SAFE_C_SC:    return(OP_SAFE_C_opSCq_S);
	case OP_SAFE_C_opSq:  return(OP_SAFE_C_op_opSq_q_S);
	case OP_SAFE_C_opSSq:
	  set_opt3_pair(expr, cadadr(expr));
	  return(OP_SAFE_C_op_opSSq_q_S);
	case OP_SAFE_C_opSSq_S:
	  set_opt3_pair(expr, cadadr(expr));
	  return(OP_SAFE_C_op_opSSq_Sq_S);
	case OP_SAFE_C_A:     return(OP_SAFE_C_opAq_S);
	}
      return(OP_SAFE_C_PS);

    case E_C_PC:
      arg = e1;
      arg_op = op_no_hop(arg);
      switch (arg_op)
	{
	case OP_SAFE_C_S: case OP_SAFE_CAR_S: case OP_SAFE_CDR_S: case OP_SAFE_CADR_S:
	case OP_SAFE_IS_PAIR_S: case OP_SAFE_IS_NULL_S: case OP_SAFE_IS_SYMBOL_S:
	  set_opt1_con(cdr(expr), (is_quoted_pair(cadr(e1))) ? cadadr(e1) : cadr(e1));
	  set_opt2_con(cdr(expr), e2);
	  return(OP_SAFE_C_opSq_C);
	case OP_SAFE_C_D:     return(OP_SAFE_C_opDq_C);
	case OP_SAFE_C_CS:    return(OP_SAFE_C_opCSq_C);
	case OP_SAFE_C_SC:    return(OP_SAFE_C_opSCq_C);
	case OP_SAFE_C_opSq:  return(OP_SAFE_C_op_opSq_q_C);
	case OP_SAFE_C_opSSq: return(OP_SAFE_C_op_opSSq_q_C);
	case OP_SAFE_C_SS:    return(OP_SAFE_C_opSSq_C);
	}
      set_opt2_con(cdr(expr), caddr(expr));
      return(OP_SAFE_C_PC);

    case E_C_CP:
      arg = e2;
      arg_op = op_no_hop(arg);
      switch (arg_op)
	{
	case OP_SAFE_C_D:
	  set_opt1_pair(cdr(expr), cdr(arg));
	  return(OP_SAFE_C_C_opDq);

	case OP_SAFE_C_S: case OP_SAFE_CAR_S: case OP_SAFE_CDR_S: case OP_SAFE_CADR_S:
	case OP_SAFE_IS_PAIR_S: case OP_SAFE_IS_NULL_S: case OP_SAFE_IS_SYMBOL_S:
	  set_opt1_sym(cdr(expr), cadr(arg));
	  return(OP_SAFE_C_C_opSq);

	case OP_SAFE_C_CS:
	  /* set_opt1_con(cdr(expr), cadr(arg)); */
	  set_opt2_sym(cdr(expr), caddr(arg));
	  return(OP_SAFE_C_C_opCSq);

	case OP_SAFE_C_SC:
	  set_opt1_sym(cdr(expr), cadr(arg));
	  set_opt2_con(cdr(expr), caddr(arg));
	  return(OP_SAFE_C_C_opSCq);

	case OP_SAFE_C_SS:
	    set_opt1_sym(cdr(expr), cadr(arg));
	    if ((is_real(e1)) &&
		(symbol_id(car(arg)) == 0) &&
		(s7_d_pd_function(slot_value(global_slot(car(arg))))))
	      {
		s7_p_dd_t fp;
		fp = s7_p_dd_function(func);
		if (fp)
		  {
		    /* direct_x_c_c_opssq calls number_to_real on e1 */
		    set_opt3_direct_x(cddr(expr), s7_d_pd_function(slot_value(global_slot(car(arg)))));
		    set_opt2_direct_x_call(cdr(expr), fp);
		    set_direct_x_opt(expr);
		  }
	      }
	    return(OP_SAFE_C_C_opSSq);
	}
      return(OP_SAFE_C_CP);

    case E_C_PP:
      arg = e2;
      arg_op = op_no_hop(arg);
      switch (arg_op)
	{
	case OP_SAFE_C_S: case OP_SAFE_CAR_S: case OP_SAFE_CDR_S: case OP_SAFE_CADR_S:
	case OP_SAFE_IS_PAIR_S: case OP_SAFE_IS_NULL_S: case OP_SAFE_IS_SYMBOL_S:
	  if (is_safe_c_s(e1))
	    {
	      s7_p_dd_t fp;
	      fp = s7_p_dd_function(func);
	      if (fp)
		{
		  if ((symbol_id(car(e1)) == 0) && (s7_d_p_function(slot_value(global_slot(car(e1))))) &&
		      (symbol_id(car(e2)) == 0) && (s7_d_p_function(slot_value(global_slot(car(e2))))))
		    {
		      set_opt3_direct_x(cdr(expr), s7_d_p_function(slot_value(global_slot(car(e1)))));
		      set_opt3_direct_x(cddr(expr), s7_d_p_function(slot_value(global_slot(car(e2)))));
		      set_opt2_direct_x_call(cdr(expr), fp);
		      set_direct_x_opt(expr);
		    }
		}
	      return(OP_SAFE_C_opSq_opSq);
	    }
	  if (optimize_op_match(e1, OP_SAFE_C_SS))
	    return(OP_SAFE_C_opSSq_opSq);
	  if (optimize_op_match(e1, OP_SAFE_C_D))
	    return(OP_SAFE_C_opDq_opSq);
	  break;

	case OP_SAFE_C_D:
	  if (optimize_op_match(e1, OP_SAFE_C_D))
	    return(OP_SAFE_C_opDq_opDq);
	  if (optimize_op_match(e1, OP_SAFE_C_SS))
	    return(OP_SAFE_C_opSSq_opDq);
	  if (optimize_op_match(e1, OP_SAFE_C_S))
	    return(OP_SAFE_C_opSq_opDq);
	  break;

	case OP_SAFE_C_SC:
	  if (optimize_op_match(e1, OP_SAFE_C_SC))
	    return(OP_SAFE_C_opSCq_opSCq);
	  break;

	case OP_SAFE_C_SS:
	  if (optimize_op_match(e1, OP_SAFE_C_D))
	    return(OP_SAFE_C_opDq_opSSq);
	  if (optimize_op_match(e1, OP_SAFE_C_SS))
	    return(OP_SAFE_C_opSSq_opSSq);
	  if (is_safe_c_s(e1))
	    return(OP_SAFE_C_opSq_opSSq);
	  break;
	}
      return(OP_SAFE_C_PP);

    default:
      break;
    }
  return(OP_UNOPT);
}

static bool is_lambda(s7_scheme *sc, s7_pointer sym)
{
  return((sym == sc->lambda_symbol) && (symbol_id(sym) == 0));
  /* symbol_id=0 means it has never been rebound (T_GLOBAL might not be set for initial stuff) */
}

static bool arg_findable(s7_scheme *sc, s7_pointer arg1, s7_pointer e)
{
  if (pair_symbol_is_safe(sc, arg1, e)) return(true); /* includes global_slot check */
  return((!sc->in_with_let) &&
	 (is_slot(symbol_to_slot(sc, arg1))));
}

static opt_t wrap_bad_args(s7_scheme *sc, s7_pointer func, s7_pointer expr, int32_t n_args, int32_t hop)
{
  set_opt3_arglen(expr, small_int(n_args));
  if (is_c_function(func))
    {
      set_safe_optimize_op(expr, hop + ((is_safe_procedure(func)) ?
					((n_args == 1) ? OP_SAFE_C_A : OP_SAFE_C_AA) :
					((n_args == 1) ? OP_C_A : OP_C_AA)));
      set_c_function(expr, func);
      return(OPT_T);
    }
  if ((is_closure(func)) &&
      (!arglist_has_rest(sc, closure_args(func))))
    {
      s7_pointer body;
      bool one_form, safe_case;

      body = closure_body(func);
      one_form = is_null(cdr(body));
      safe_case = is_safe_closure(func);
      set_unsafely_optimized(expr);
      set_opt1_lambda(expr, func);

      if (one_form)
	set_optimize_op(expr, hop + ((safe_case) ?
				     ((n_args == 1) ? OP_SAFE_CLOSURE_A_P : OP_SAFE_CLOSURE_AA_P) :
				     ((n_args == 1) ? OP_CLOSURE_A_P : OP_CLOSURE_AA_P)));
      else
	set_optimize_op(expr, hop + ((safe_case) ?
				     ((n_args == 1) ? OP_SAFE_CLOSURE_A : OP_SAFE_CLOSURE_AA) :
				     ((n_args == 1) ? OP_CLOSURE_A : OP_CLOSURE_AA)));
      return(OPT_F);
    }
  if ((is_closure_star(func)) &&
      (lambda_has_simple_defaults(closure_body(func))) &&
      (closure_star_arity_to_int(sc, func) >= n_args) &&
      (!arglist_has_rest(sc, closure_args(func))))
    {
      set_unsafely_optimized(expr);
      if (n_args == 1)
	set_optimize_op(expr, ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_STAR_A : OP_CLOSURE_STAR_A));
      else
	{
	  if (closure_star_arity_to_int(sc, func) == 2)
	    set_optimize_op(expr, ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_STAR_AA : OP_CLOSURE_STAR_FX));
	  else set_optimize_op(expr, ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_STAR_FX : OP_CLOSURE_STAR_FX));
	}
      set_opt1_lambda(expr, func);
    }
  return(OPT_F);
}

static void fx_tree(s7_scheme *sc, s7_pointer tree, s7_pointer stepper, s7_pointer previous_stepper);

static opt_t optimize_func_one_arg(s7_scheme *sc, s7_pointer expr, s7_pointer func,
				   int32_t hop, int32_t pairs, int32_t symbols, int32_t quotes, int32_t bad_pairs, s7_pointer e)
{
  s7_pointer arg1;
  /* very often, expr is already optimized, quoted stuff is counted under "bad_pairs"! as well as quotes */
#if OPTIMIZE_PRINT
  fprintf(stderr, "opt 1 expr: %s, func: %s, hop: %d, pairs: %d, symbols: %d, quotes: %d, bad: %d\n", DISPLAY_80(expr), DISPLAY(func), hop, pairs, symbols, quotes, bad_pairs);
#endif
  if (quotes > 0)
    {
      if (direct_memq(sc->quote_symbol, e))
	return(OPT_OOPS);
      if ((bad_pairs == quotes) &&
	  (is_constant_symbol(sc, car(expr))))
	hop = 1;
    }

  arg1 = cadr(expr);
  /* need in_with_let -> search only rootlet not find_symbol */
  if ((symbols == 1) &&
      (!arg_findable(sc, arg1, e)))
    {
      /* wrap the bad arg in a check symbol lookup */
      if (s7_is_aritable(sc, func, 1))
	{
	  set_c_call_direct(cdr(expr), fx_unsafe_s);
	  return(wrap_bad_args(sc, func, expr, 1, hop));
	}
      return(OPT_F);
    }

  if (((is_c_function(func)) &&
       (c_function_required_args(func) <= 1) &&
       (c_function_all_args(func) >= 1)) ||
      ((is_c_function_star(func)) &&
       (c_function_all_args(func) == 1))) /* surely no need to check key here? */
    {
      bool func_is_safe;
      func_is_safe = is_safe_procedure(func);
      if ((hop == 0) && (symbol_id(car(expr)) == 0)) hop = 1;

      if (pairs == 0)
	{
	  if (func_is_safe)                  /* safe c function */
	    {
	      set_safe_optimize_op(expr, hop + ((symbols == 0) ? OP_SAFE_C_D : (OP_SAFE_C_S)));
	      choose_c_function(sc, expr, func, 1);

	      /* these are border-line useless -- lint uses cxr_s */
	      if ((symbols == 1) &&
		  (is_global(car(expr))))
		{
		  if (c_callee(expr) == g_car)
		    add_optimizer_fixup(sc, expr, hop + OP_SAFE_CAR_S);
		  if (c_callee(expr) == g_cdr)
		    add_optimizer_fixup(sc, expr, hop + OP_SAFE_CDR_S);
		  if (c_callee(expr) == g_cadr)
		    add_optimizer_fixup(sc, expr, hop + OP_SAFE_CADR_S);
		  if (c_callee(expr) == g_is_pair)
		    add_optimizer_fixup(sc, expr, hop + OP_SAFE_IS_PAIR_S);
		  if (c_callee(expr) == g_is_null)
		    add_optimizer_fixup(sc, expr, hop + OP_SAFE_IS_NULL_S);
		  if (c_callee(expr) == g_is_symbol)
		    add_optimizer_fixup(sc, expr, hop + OP_SAFE_IS_SYMBOL_S);
		}
	      return(OPT_T);
	    }
	  /* c function is not safe */
	  if (symbols == 0)
	    {
	      set_unsafely_optimized(expr);
	      set_optimize_op(expr, hop + OP_C_A); /* OP_C_C never happens */
	      annotate_arg(sc, cdr(expr), e);
	      set_opt3_arglen(expr, small_int(1));
	    }
	  else
	    {
	      set_unsafely_optimized(expr);
	      if (c_function_call(func) == g_read)
		set_optimize_op(expr, hop + OP_READ_S);
	      else set_optimize_op(expr, hop + OP_C_S);
	    }
	  choose_c_function(sc, expr, func, 1);
	  return(OPT_F);
	}
      /* pairs == 1 */
      if (bad_pairs == 0)
	{
	  if (func_is_safe)
	    {
	      int32_t op;
	      op = combine_ops(sc, func, expr, E_C_P, arg1, NULL);
	      if ((hop == 1) &&
		  (is_not_h_optimized(arg1)))
		hop = 0;
	      set_safe_optimize_op(expr, hop + op);
	      if ((!hop) && (is_h_optimized(arg1)))
		clear_hop(arg1);
	      else
		{
		  if ((op == OP_SAFE_C_P) &&
		      (is_fx_safe(sc, arg1)))
		    {
		      set_optimize_op(expr, hop + OP_SAFE_C_A);
		      annotate_arg(sc, cdr(expr), e);
		    }
		}
	      choose_c_function(sc, expr, func, 1);
	      return(OPT_T);
	    }
	  if (is_fx_safe(sc, arg1))
	    {
	      set_unsafe_optimize_op(expr, hop + OP_C_A);
	      annotate_arg(sc, cdr(expr), e);
	      set_opt3_arglen(expr, small_int(1));
	      choose_c_function(sc, expr, func, 1);
	      return(OPT_F);
	    }
	}
      else /* bad_pairs == 1 */
	{
	  if (quotes == 1)
	    {
	      annotate_arg(sc, cdr(expr), e);
	      set_opt3_arglen(expr, small_int(1));
	      if (func_is_safe)
		{
		  set_safe_optimize_op(expr, hop + OP_SAFE_C_A);
		  choose_c_function(sc, expr, func, 1);
		  return(OPT_T);
		}
	      set_unsafe_optimize_op(expr, hop + OP_C_A);
	      choose_c_function(sc, expr, func, 1);
	      return(OPT_F);
	    }
	  /* quotes == 0 */
	  if (!func_is_safe)
	    {
	      s7_pointer lambda_expr;
	      lambda_expr = arg1;
	      if ((is_pair(lambda_expr)) &&
		  (is_lambda(sc, car(lambda_expr))) &&               /* check for stuff like (define (f) (eval (lambda 2))) */
		  (is_pair(cdr(lambda_expr))) &&
		  (is_pair(cddr(lambda_expr))))
		{
		  if ((c_function_call(func) == g_call_with_exit) &&
		      (is_pair(cadr(lambda_expr))) &&
		      (is_null(cdadr(lambda_expr))) &&
		      (is_symbol(caadr(lambda_expr))) &&
		      (!is_probably_constant(caadr(lambda_expr))) && /* (call-with-exit (lambda (pi) ...) */
		      (!direct_memq(car(lambda_expr), e)) &&         /* (let ((lambda #f)) (call-with-exit (lambda ...))) */
		      (s7_is_proper_list(sc, cddr(lambda_expr))))
		    {
		      if (is_null(cdddr(lambda_expr)))
			set_unsafe_optimize_op(expr, hop + OP_CALL_WITH_EXIT_P);
		      else set_unsafe_optimize_op(expr, hop + OP_CALL_WITH_EXIT);
		      choose_c_function(sc, expr, func, 1);
		      set_opt2_pair(expr, cdr(lambda_expr));
		      return(OPT_F);
		    }
		}
	      set_unsafe_optimize_op(expr, hop + OP_C_P);
	      choose_c_function(sc, expr, func, 1);
	      return(OPT_F);
	    }
	  set_unsafe_optimize_op(expr, hop + ((car(expr) == sc->not_symbol) ? OP_NOT_P : OP_SAFE_C_P));
	  choose_c_function(sc, expr, func, 1);
	  return(OPT_F);
	}

      if (func_is_safe)
	set_unsafe_optimize_op(expr, hop + ((is_safely_optimized(arg1)) ? OP_SAFE_C_P : ((car(expr) == sc->not_symbol) ? OP_NOT_P : OP_SAFE_C_P)));
      else set_unsafe_optimize_op(expr, hop + OP_C_P);
      choose_c_function(sc, expr, func, 1);
      return(OPT_F);
    }

  if (is_closure(func))
    {
      bool one_form, safe_case;
      s7_pointer body;
      int32_t arit;

      arit = closure_arity_to_int(sc, func);
      if (arit != 1)
	{
	  if ((arit == -1) &&
	      (is_symbol(closure_args(func))))
	    return(optimize_func_dotted_args(sc, expr, func, hop, 1, e));
	  return(OPT_F);
	}

      safe_case = is_safe_closure(func);
      body = closure_body(func);
      one_form = is_null(cdr(body));
      if (is_immutable(func)) hop = 1;

      if (pairs == 0)
	{
	  bool sym;
	  sym = (symbols == 1);
	  if (sym)
	    set_opt2_sym(expr, arg1);
	  else set_opt2_con(expr, arg1);
	  set_opt1_lambda(expr, func);

	  if (one_form)
	    {
	      if (safe_case)
		{
		  if (is_fx_safe(sc, car(body)))
		    {
		      annotate_arg(sc, body, e);
		      set_safe_optimize_op(expr, hop + ((sym) ? OP_SAFE_CLOSURE_S_A : OP_SAFE_CLOSURE_C_A));
		      set_closure_has_fx(func);
		      fx_tree(sc, body, car(closure_args(func)), NULL);
		      return(OPT_T);
		    }
		  set_optimize_op(expr, hop + ((sym) ? OP_SAFE_CLOSURE_S_P : OP_SAFE_CLOSURE_C_P));
		}
	      else set_optimize_op(expr, hop + ((sym) ? OP_CLOSURE_S_P : OP_CLOSURE_C_P));
	    }
	  else set_optimize_op(expr, hop + ((sym) ? ((safe_case) ? OP_SAFE_CLOSURE_S : OP_CLOSURE_S) : ((safe_case) ? OP_SAFE_CLOSURE_C : OP_CLOSURE_C)));
	  set_unsafely_optimized(expr);
	  return(OPT_F);
	}

      if (fx_count(sc, expr) == 1)
	{
	  set_unsafely_optimized(expr);
	  set_opt1_lambda(expr, func);
	  annotate_arg(sc, cdr(expr), e);
	  set_opt3_arglen(expr, small_int(1));

	  if (one_form)
	    {
	      if (safe_case)
		{
		  if (is_fx_safe(sc, car(body)))
		    {
		      annotate_arg(sc, body, e);
		      set_safe_optimize_op(expr, hop + OP_SAFE_CLOSURE_A_A);
		      set_closure_has_fx(func);
		      fx_tree(sc, body, car(closure_args(func)), NULL);
		      return(OPT_T);
		    }
		  set_optimize_op(expr, hop + OP_SAFE_CLOSURE_A_P);
		}
	      else
		{
		  if ((c_callee(cdr(expr)) == fx_c_sub_si) || (c_callee(cdr(expr)) == fx_c_sub_s1))
		    {
		      set_opt2_pair(expr, cdadr(expr));
		      set_optimize_op(expr, hop + OP_CLOSURE_SUB_P);
		    }
		  else set_optimize_op(expr, hop + OP_CLOSURE_A_P);
		}
	    }
	  else set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_A : OP_CLOSURE_A));
	  set_unsafely_optimized(expr);
	  return(OPT_F);
	}
      set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_P : OP_CLOSURE_P));
      set_opt1_lambda(expr, func);
      set_unsafely_optimized(expr);
      return(OPT_F);  /* don't check is_optimized here for OPT_T */
    }

  if (is_closure_star(func))
    {
      if (is_null(closure_args(func)))
	return(OPT_F);
      if (fx_count(sc, expr) == 1)
	{
	  bool safe_case;
	  safe_case = is_safe_closure(func);
	  if (is_immutable(func)) hop = 1;
	  annotate_arg(sc, cdr(expr), e);
	  set_opt1_lambda(expr, func);
	  set_opt3_arglen(expr, small_int(1));
	  set_unsafely_optimized(expr);
	  if (lambda_has_simple_defaults(closure_body(func)))
	    {
	      if (arglist_has_rest(sc, closure_args(func)))
		set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_STAR_FX_1 : OP_CLOSURE_STAR_FX));
	      else set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_STAR_A : OP_CLOSURE_STAR_A));
	    }
	  else
	    {
	      if (safe_case)
		set_optimize_op(expr, hop + OP_SAFE_CLOSURE_STAR_FX_1);
	    }
	  return(OPT_F);
	}
      return(OPT_F);
    }

  if ((is_c_function_star(func)) &&  /* we checked above for c_function_all_args == 1 */
      (fx_count(sc, expr) == 1))
    {
      if ((hop == 0) && (symbol_id(car(expr)) == 0)) hop = 1;
      set_optimized(expr);
      set_optimize_op(expr, hop + OP_SAFE_C_STAR_A); /* if one arg passed, it's obviously not a keyword-as-parameter-name */
      annotate_arg(sc, cdr(expr), e);
      set_opt3_arglen(expr, small_int(1));
      set_c_function(expr, func);
      return(OPT_T);
    }

  if ((is_any_vector(func)) &&
      (is_fx_safe(sc, arg1)))
    {
      set_unsafe_optimize_op(expr, OP_VECTOR_A);
      annotate_arg(sc, cdr(expr), e);
      set_opt3_arglen(expr, small_int(1));
      return(OPT_T);
    }

  if ((func == sc->s7_let) &&
      (((quotes == 1) && (is_symbol(cadr(arg1)))) ||
       (is_keyword(arg1))))
    {
      /* (*s7* ...) */
      set_optimize_op(expr, OP_S7_LET);
      return(OPT_F);
    }
  /* unknown_* is set later */

  return((is_optimized(expr)) ? OPT_T : OPT_F);
}

static bool let_memq(s7_pointer symbol, s7_pointer symbols)
{
  s7_pointer x;
  for (x = symbols; is_pair(x); x = cdr(x))
    {
      if (car(x) == symbol)
	return(true);
    }
  return(false);
}

static inline s7_pointer find_uncomplicated_symbol(s7_scheme *sc, s7_pointer symbol, s7_pointer e)
{
  s7_pointer x;
  int64_t id;
#if OPTIMIZE_PRINT
  fprintf(stderr, "  find %s in %s (in list: %d)\n", DISPLAY(symbol), DISPLAY(e), symbol_is_in_list(sc, symbol));
#endif
  if ((symbol_is_in_list(sc, symbol)) &&
      (let_memq(symbol, e)))   /* it's probably a local variable reference */
    return(sc->nil);

  if (is_global(symbol))
    return(global_slot(symbol));

  /* see 59108 (OP_DEFINE_* in optimize_syntax) -- keyword version of name is used if a definition is
   *   contingent on some run-time decision, so we're looking here for local defines that might not happen.
   *   s7test.scm has a test case using acos.
   */
  if ((has_keyword(symbol)) &&
      (symbol_is_in_list(sc, symbol_to_keyword(sc, symbol))))
    return(sc->nil);

  id = symbol_id(symbol);
  for (x = sc->envir; id < let_id(x); x = outlet(x));
  for (; is_let(x); x = outlet(x))
    {
      s7_pointer y;
      if (let_id(x) == id)
	return(local_slot(symbol));

      for (y = let_slots(x); tis_slot(y); y = next_slot(y))
	if (slot_symbol(y) == symbol)
	  return(y);
    }

  return(global_slot(symbol)); /* it's no longer global perhaps (local definition now inaccessible) */
}

static bool unsafe_is_safe(s7_scheme *sc, s7_pointer f, s7_pointer e)
{
  if (!is_symbol(f)) return(false);
  f = find_uncomplicated_symbol(sc, f, e); /* how to catch local c-funcs here? */
  if (is_slot(f))
    {
      f = slot_value(f);
      return((is_c_function(f)) &&
	     (is_safe_procedure(f)));
    }
  return(false);
}

static bool two_args_ok(s7_scheme *sc, s7_pointer expr, s7_pointer e)
{
  if ((car(expr) == sc->member_symbol) || (car(expr) == sc->assoc_symbol)) return(true);
  return(unsafe_is_safe(sc, cadr(expr), e));
}

static void opt_sp_1(s7_scheme *sc, s7_function g, s7_pointer expr)
{
#if WITH_GMP
  /* if...endif written this way to make cppcheck happy */
  set_opt1_any(cdr(expr),
	       (s7_pointer)((intptr_t)((g == g_cons) ? OP_SAFE_CONS_SP_1 :
				       ((g == g_memq) ? OP_SAFE_MEMQ_SP_1 :
					OP_SAFE_C_SP_1))));
#else
  set_opt1_any(cdr(expr),
	       (s7_pointer)((intptr_t)((g == g_cons) ? OP_SAFE_CONS_SP_1 :
				       ((g == g_memq) ? OP_SAFE_MEMQ_SP_1 :
					(((g == g_multiply) || (g == g_multiply_2)) ? OP_SAFE_MULTIPLY_SP_1 :
					 (((g == g_add) || (g == g_add_2)) ? OP_SAFE_ADD_SP_1 :
					  (((g == g_subtract) || (g == g_subtract_2)) ? OP_SAFE_SUBTRACT_SP_1 :
					   OP_SAFE_C_SP_1)))))));
#endif
}

static void check_lambda(s7_scheme *sc);

static opt_t optimize_func_two_args(s7_scheme *sc, s7_pointer expr, s7_pointer func, int32_t hop, int32_t pairs, int32_t symbols, int32_t quotes, int32_t bad_pairs, s7_pointer e)
{
  s7_pointer arg1, arg2;
#if OPTIMIZE_PRINT
  fprintf(stderr, "opt 2: %s, hop: %d, pairs: %d, symbols: %d, quotes: %d, bad: %d\n", DISPLAY_80(expr), hop, pairs, symbols, quotes, bad_pairs);
#endif
  if (quotes > 0)
    {
      if (direct_memq(sc->quote_symbol, e))
	return(OPT_OOPS);
      if ((bad_pairs == quotes) &&
	  (is_constant_symbol(sc, car(expr))))
	hop = 1;
    }

  arg1 = cadr(expr);
  arg2 = caddr(expr);
  if (((is_symbol(arg1)) &&
       (!arg_findable(sc, arg1, e))) ||
      ((is_symbol(arg2)) &&
       (!arg_findable(sc, arg2, e))))
    {
      /* wrap bad args */
      if ((is_fx_safe(sc, arg1)) &&
	  (is_fx_safe(sc, arg2)) &&
	  (s7_is_aritable(sc, func, 2)))
	{
	  annotate_args(sc, cdr(expr), e);
	  return(wrap_bad_args(sc, func, expr, 2, hop));
	}
      return(OPT_F);
    }
  /* end of bad symbol wrappers */

  if ((is_c_function(func) &&
       (c_function_required_args(func) <= 2) &&
       (c_function_all_args(func) >= 2)) ||
      ((is_c_function_star(func)) &&
       (c_function_all_args(func) == 2) &&
       (!is_pair(arg1)) && (!is_symbol(arg1))))  /* trying to protect against arg1 evaluating to a keyword */
    {
      /* this is a mess */
      bool func_is_safe;

      if ((hop == 0) && (symbol_id(car(expr)) == 0))
	hop = 1;

      func_is_safe = is_safe_procedure(func);
      if (pairs == 0)
	{
	  if ((func_is_safe) ||
	      ((is_maybe_safe(func)) && (two_args_ok(sc, expr, e))))
	    {
	      /* another case here: set-car! and set-cdr! are safe if symbols==1 and arg1 is the symbol (i.e. arg2 is a constant) */
	      if (symbols == 0)
		set_optimize_op(expr, hop + OP_SAFE_C_D);
	      else
		{
		  if (symbols == 2) /* these two symbols are almost never the same, (sqrt (+ (* x x) (* y y))) */
		    {
		      set_optimize_op(expr, hop + OP_SAFE_C_SS);
		      set_opt2_sym(cdr(expr), arg2);
		    }
		  else
		    {
		      if (is_normal_symbol(arg1))
			{
			  set_opt2_con(cdr(expr), arg2);
			  set_optimize_op(expr, hop + OP_SAFE_C_SC);
			}
		      else
			{
			  set_opt1_con(cdr(expr), arg1);
			  set_optimize_op(expr, hop + OP_SAFE_C_CS);
			}
		    }
		}
	      set_optimized(expr);
	      choose_c_function(sc, expr, func, 2);
	      return(OPT_T);
	    }
	  set_unsafely_optimized(expr);
	  if (symbols == 2)
	    {
	      if (c_function_call(func) == g_apply)
		{
		  set_optimize_op(expr, hop + OP_APPLY_SS);
		  set_opt1_cfunc(expr, func); /* not quite set_c_function */
		  set_opt2_sym(expr, arg2);
		}
	      else
		{
		  set_optimize_op(expr, hop + OP_C_SS);
		  choose_c_function(sc, expr, func, 2);
		}
	    }
	  else
	    {
	      set_optimize_op(expr, hop + OP_C_AA);
	      annotate_args(sc, cdr(expr), e);
	      set_opt3_arglen(expr, small_int(2));
	      choose_c_function(sc, expr, func, 2);
	      if (is_safe_procedure(opt1_cfunc(expr)))
		{
		  clear_unsafe(expr);
		  /* symbols can be 0..2 here, no pairs */
		  set_optimized(expr);
		  if (symbols == 1)
		    {
		      if (is_normal_symbol(arg1))
			{
			  set_optimize_op(expr, hop + OP_SAFE_C_SC);
			  set_opt2_con(cdr(expr), arg2);
			}
		      else
			{
			  set_opt1_con(cdr(expr), arg1);
			  set_optimize_op(expr, hop + OP_SAFE_C_CS);
			}
		    }
		  else
		    {
		      if (symbols == 2)
			{
			  set_optimize_op(expr, hop + OP_SAFE_C_SS);
			  set_opt2_sym(cdr(expr), arg2);
			}
		      else set_optimize_op(expr, hop + OP_SAFE_C_D);
		    }
		  return(OPT_T);
		}
	    }
	  return(OPT_F);
	}

      /* pairs != 0 */
      if ((bad_pairs == 0) &&
	  (pairs == 2))
	{
	  if ((func_is_safe) ||
	      ((is_maybe_safe(func)) && (two_args_ok(sc, expr, e))))
	    {
	      int32_t op;
	      op = combine_ops(sc, func, expr, E_C_PP, arg1, arg2);
	      if ((hop == 1) &&
		  ((is_not_h_optimized(arg1)) || (is_not_h_optimized(arg2))))
		hop = 0;
	      set_safe_optimize_op(expr, hop + op);
	      if (op == OP_SAFE_C_PP)
		opt_sp_1(sc, c_function_call(func), expr); /* calls set_opt1_any, sets opt1(cdr(expr)) to OP_SAFE_CONS_SP_1 and friends */
	      if (!hop)
		{
		  if (is_h_optimized(arg1)) clear_hop(arg1);
		  if (is_h_optimized(arg2)) clear_hop(arg2);
		}
	      else
		{
		  if (op == OP_SAFE_C_PP)
		    {
		      if (is_fx_safe(sc, arg1))
			{
			  if (is_fx_safe(sc, arg2))
			    {
			      set_optimize_op(expr, hop + OP_SAFE_C_AA);
			      annotate_args(sc, cdr(expr), e);
			      set_opt3_arglen(expr, small_int(2));
			    }
			  else
			    {
			      set_optimize_op(expr, hop + OP_SAFE_C_AP);
			      annotate_arg(sc, cdr(expr), e);
			      set_opt3_arglen(expr, small_int(2));
			    }
			}
		      else
			{
			  if (is_fx_safe(sc, arg2))
			    {
			      set_optimize_op(expr, hop + OP_SAFE_C_PA);
			      annotate_arg(sc, cddr(expr), e);
			      set_opt3_arglen(expr, small_int(2));
			    }
			}
		    }
		}
	      choose_c_function(sc, expr, func, 2); /* this might change the op to safe_c_c, so it has to be last */
	      return(OPT_T);
	    }
	}

      if ((bad_pairs == 0) &&
	  (pairs == 1))
	{
	  if ((func_is_safe) ||
	      ((is_maybe_safe(func)) && (two_args_ok(sc, expr, e))))
	    {
	      combine_op_t orig_op;
	      int32_t op;

	      if (is_pair(arg1))
		{
		  if (is_normal_symbol(arg2))
		    orig_op = E_C_PS;
		  else orig_op = E_C_PC;
		  op = combine_ops(sc, func, expr, orig_op, arg1, arg2);
		  if ((!hop) && (is_h_optimized(arg1))) clear_hop(arg1);
		}
	      else
		{
		  if (is_normal_symbol(arg1))
		    orig_op = E_C_SP;
		  else orig_op = E_C_CP;
		  op = combine_ops(sc, func, expr, orig_op, arg1, arg2);
		  if ((!hop) && (is_h_optimized(arg2))) clear_hop(arg2);
		}
	      if ((hop == 1) &&
		  ((is_not_h_optimized(arg1)) || (is_not_h_optimized(arg2))))
		hop = 0;

	      if ((((op == OP_SAFE_C_SP) || (op == OP_SAFE_C_CP)) &&
		   (is_fx_safe(sc, arg2))) ||
		  (((op == OP_SAFE_C_PS) || (op == OP_SAFE_C_PC)) &&
		   (is_fx_safe(sc, arg1))))
		{
		  set_safe_optimize_op(expr, hop + OP_SAFE_C_AA);
		  annotate_arg(sc, cdr(expr), e);
		  annotate_arg(sc, cddr(expr), e);
		}
	      else
		{
		  set_safe_optimize_op(expr, hop + op);
		  if ((op == OP_SAFE_C_SP) || (op == OP_SAFE_C_CP))
		    {
		      opt_sp_1(sc, c_function_call(func), expr);
		      set_opt3_any(cdr(expr), cadr(expr));
		    }
		  else
		    {
		      if (op == OP_SAFE_C_PC)
			set_opt2_con(cdr(expr), arg2);
		    }
		}
	      choose_c_function(sc, expr, func, 2);
	      return(OPT_T);
	    }

	  if (symbols == 1)
	    {
	      if (is_normal_symbol(arg1))
		{
		  if (is_safe_c_s(arg2))
		    {
		      set_unsafe_optimize_op(expr, hop + OP_C_S_opSq);
		      set_opt1_sym(cdr(expr), cadr(arg2));
		      choose_c_function(sc, expr, func, 2);
		      return(OPT_F);
		    }
		  if (optimize_op_match(arg2, OP_SAFE_C_D))
		    {
		      set_unsafe_optimize_op(expr, hop + OP_C_S_opDq);
		      set_opt1_pair(cdr(expr), cdr(arg2));
		      choose_c_function(sc, expr, func, 2);
		      return(OPT_F);
		    }
		}
	    }
	}

      if ((bad_pairs == 1) && (quotes == 1))
	{
	  if ((func_is_safe) ||
	      ((is_maybe_safe(func)) && (two_args_ok(sc, expr, e))))
	    {
	      if  (symbols == 1)
		{
		  set_optimized(expr);
		  if (is_normal_symbol(arg1))
		    {
		      set_opt2_con(cdr(expr), cadr(caddr(expr)));
		      set_optimize_op(expr, hop + OP_SAFE_C_SC);
		    }
		  else
		    {
		      set_opt1_con(cdr(expr), cadadr(expr));
		      set_optimize_op(expr, hop + OP_SAFE_C_CS);
		    }
		  choose_c_function(sc, expr, func, 2);
		  return(OPT_T);
		}
	      else
		{
		  if ((pairs == 1) && (is_pair(arg2))) /* QC never happens */
		    {
		      set_optimized(expr);
		      set_optimize_op(expr, hop + OP_SAFE_C_CQ);
		      set_opt2_con(cdr(expr), cadr(caddr(expr)));
		      choose_c_function(sc, expr, func, 2);
		      return(OPT_T);
		    }

		  if (!is_safe_c_s(arg1))
		    {
		      if ((is_fx_safe(sc, arg1)) && (is_fx_safe(sc, arg2)))
			{
			  set_optimize_op(expr, hop + OP_SAFE_C_AA);
			  annotate_args(sc, cdr(expr), e);
			  set_opt3_arglen(expr, small_int(2));
			  choose_c_function(sc, expr, func, 2);
			  return(OPT_T);
			}
		    }
		  /* *_AA here slow us down (presumably opsq_c below is faster) */
		}
	    }
	  else
	    {
	      if (pairs == 1)
		{
		  set_unsafe_optimize_op(expr, hop + OP_C_AA);
		  annotate_args(sc, cdr(expr), e);
		  set_opt3_arglen(expr, small_int(2));
		  choose_c_function(sc, expr, func, 2);
		  return(OPT_F);
		}
	    }
	}

      if (quotes == 2)
	{
	  if (func_is_safe)
	    set_optimize_op(expr, hop + OP_SAFE_C_AA);
	  else set_unsafe_optimize_op(expr, hop + OP_C_AA);
	  annotate_args(sc, cdr(expr), e);
	  set_opt3_arglen(expr, small_int(2));
	  choose_c_function(sc, expr, func, 2);
	  return((func_is_safe) ? OPT_T : OPT_F);
	}

      if ((pairs == 1) &&
	  (quotes == 0) &&
	  ((func_is_safe) ||
	   ((is_maybe_safe(func)) && (two_args_ok(sc, expr, e)))))
	{
	  if (symbols == 1)
	    {
	      set_optimized(expr);
	      if (is_normal_symbol(arg1))
		{
		  set_optimize_op(expr, hop + OP_SAFE_C_SP);
		  opt_sp_1(sc, c_function_call(func), expr);
		  choose_c_function(sc, expr, func, 2);
		  if (bad_pairs == 0)
		    return(OPT_T);
		  set_unsafe(expr);
		  return(OPT_F);
		}

	      /* arg2 is a symbol */
	      set_optimize_op(expr, hop + OP_SAFE_C_PS);
	      choose_c_function(sc, expr, func, 2);
	      if (bad_pairs == 0)
		return(OPT_T);
	      set_unsafe(expr);
	      return(OPT_F);
	    }
	  if (symbols == 0)
	    {
	      set_optimized(expr);
	      if ((is_fx_safe(sc, arg1)) && (is_fx_safe(sc, arg2)))
		{
		  set_optimize_op(expr, hop + OP_SAFE_C_AA);
		  annotate_args(sc, cdr(expr), e);
		  set_opt3_arglen(expr, small_int(2));
		  choose_c_function(sc, expr, func, 2);
		  return(OPT_T);
		}
	      if (is_pair(arg1))
		{
		  set_optimize_op(expr, hop + OP_SAFE_C_PC);
		  choose_c_function(sc, expr, func, 2);
		  set_opt2_con(cdr(expr), arg2);
		  if (bad_pairs == 0)
		    return(OPT_T);
		  set_unsafe(expr);
		  return(OPT_F);
		}
	      else
		{
		  set_optimize_op(expr, hop + OP_SAFE_C_CP);
		  opt_sp_1(sc, c_function_call(func), expr);
		  set_opt3_any(cdr(expr), arg1);
		  choose_c_function(sc, expr, func, 2);
		  if (bad_pairs == 0)
		    return(OPT_T);
		  set_unsafe(expr);
		  return(OPT_F);
		}
	    }
	}

      if ((pairs == 2) &&
	  ((func_is_safe) ||
	   ((is_maybe_safe(func)) && (two_args_ok(sc, expr, e)))))
	{
	  if ((bad_pairs == 1) &&
	      (is_safe_c_s(arg1)))
	    {
	      /* unsafe func here won't work unless we check that later and make the new arg list (for list-values etc)
	       *   (and it has to be the last pair else the unknown_g stuff can mess up)
	       */
	      if (car(arg2) == sc->quote_symbol)
		{
		  if ((!is_pair(cdr(arg2))) || (!is_null(cddr(arg2))))
		    return(OPT_OOPS);
		  set_safe_optimize_op(expr, hop + OP_SAFE_C_opSq_C);
		  set_opt1_con(cdr(expr), cadadr(expr));
		  set_opt2_con(cdr(expr), cadr(caddr(expr)));
		  choose_c_function(sc, expr, func, 2);
		  return(OPT_T);
		}
	      set_unsafe_optimize_op(expr, hop + OP_SAFE_C_opSq_P);
	      opt_sp_1(sc, c_function_call(func), expr);
	      choose_c_function(sc, expr, func, 2);
	      return(OPT_F);
	    }
	  else
	    {
	      if (quotes == 0)
		{
		  set_unsafely_optimized(expr);
		  if (is_fx_safe(sc, arg1))
		    {
		      if (is_fx_safe(sc, arg2))
			{
			  set_optimize_op(expr, hop + OP_SAFE_C_AA);
			  annotate_args(sc, cdr(expr), e);
			  set_opt3_arglen(expr, small_int(2));
			  choose_c_function(sc, expr, func, 2);
			  return(OPT_T);
			}
		      set_optimize_op(expr, hop + OP_SAFE_C_AP);
		      opt_sp_1(sc, c_function_call(func), expr);
		      annotate_arg(sc, cdr(expr), e);
		    }
		  else
		    {
		      if (is_fx_safe(sc, arg2))
			{
			  set_optimize_op(expr, hop + OP_SAFE_C_PA);
			  annotate_arg(sc, cddr(expr), e);
			}
		      else
			{
			  set_optimize_op(expr, hop + OP_SAFE_C_PP);
			  opt_sp_1(sc, c_function_call(func), expr);
			}
		    }
		  choose_c_function(sc, expr, func, 2);
		  return(OPT_F);
		}
	      if (quotes == 1)
		{
		  if (car(arg1) == sc->quote_symbol)
		    {
		      set_optimize_op(expr, hop + OP_SAFE_C_CP);
		      opt_sp_1(sc, c_function_call(func), expr);
		      set_opt3_any(cdr(expr), cadr(arg1));
		    }
		  else
		    {
		      set_optimize_op(expr, hop + OP_SAFE_C_PC);
		      set_opt2_con(cdr(expr), cadr(caddr(expr)));
		    }
		  set_unsafely_optimized(expr);
		  choose_c_function(sc, expr, func, 2);
		  return(OPT_F);
		}
	    }
	}

      if (func_is_safe)
	{
	  if (fx_count(sc, expr) == 2)
	    {
	      set_safe_optimize_op(expr, hop + OP_SAFE_C_AA);
	      annotate_args(sc, cdr(expr), e);
	      set_opt3_arglen(expr, small_int(2));
	      choose_c_function(sc, expr, func, 2);
	      return(OPT_T);
	    }
	}
      else
	{
	  if (is_fx_safe(sc, arg1))
	    {
	      if (is_fx_safe(sc, arg2))
		{
		  if ((c_function_call(func) == g_apply) &&
		      (is_normal_symbol(arg1)))
		    {
		      set_optimize_op(expr, hop + OP_APPLY_SA);
		      if (is_pair(arg2))
			{
			  s7_pointer lister;
			  lister = lookup(sc, car(arg2));
			  if ((is_c_function(lister)) &&
			      (is_pair(c_function_signature(lister))) &&
			      (car(c_function_signature(lister)) == sc->is_proper_list_symbol))
			    set_optimize_op(expr, hop + OP_APPLY_SL);
			}
		      set_opt1_cfunc(expr, func); /* not quite set_c_function */
		    }
		  else set_unsafe_optimize_op(expr, hop + OP_C_AA);
		  annotate_args(sc, cdr(expr), e);
		  set_opt3_arglen(expr, small_int(2));
		}
	      else
		{
		  set_unsafe_optimize_op(expr, hop + OP_C_AP);
		  annotate_arg(sc, cdr(expr), e);
		}
	      choose_c_function(sc, expr, func, 2);
	      return(OPT_F);
	    }

	  if ((car(expr) != sc->values_symbol) &&
	      (is_fx_safe(sc, arg2)))
	    {
	      if ((is_pair(arg1)) &&
		  (car(arg1) == sc->lambda_symbol))
		{
		  s7_pointer code;
		  annotate_arg(sc, cddr(expr), e);
		  set_unsafe_optimize_op(expr, hop + OP_C_FA);
		  code = sc->code;               /* save old -- not of direct interest here -- just avoiding unexpected clobberage */
		  sc->code = cadr(expr);
		  /* check_lambda here can cause the optimizer to ignore possible catches and exit eval! */
		  check_lambda(sc);
		  sc->code = code;
		  choose_c_function(sc, expr, func, 2);
		  if (((c_callee(expr) == g_for_each) || (c_callee(expr) == g_map)) &&
		      (is_pair(cadr(arg1))) &&
		      (is_null(cdadr(arg1))) &&
		      (is_pair(cddr(arg1))) &&
		      (is_null(cdddr(arg1))) &&
		      (!is_possibly_constant(caadr(arg1))))
		    {
		      set_c_call_unchecked(expr, (c_callee(expr) == g_for_each) ? g_for_each_closure : NULL);
		      set_opt3_pair(expr, cdadr(expr));
		      set_unsafe_optimize_op(expr, OP_C_FA_1);
		    }
		  return(OPT_F);
		}
	    }
	}
      return((is_optimized(expr)) ? OPT_T : OPT_F);
    }

  if (is_closure(func))
    {
      int32_t arit;
      bool one_form, safe_case;
      s7_pointer body;

      arit = closure_arity_to_int(sc, func);
      if (arit != 2)
	{
	  if ((arit == -1) &&
	      (is_symbol(closure_args(func))))
	    return(optimize_func_dotted_args(sc, expr, func, hop, 2, e));
	  return(OPT_F);
	}
      if (is_immutable(func)) hop = 1;

      body = closure_body(func);
      one_form = is_null(cdr(body));
      safe_case = is_safe_closure(func);

      if ((pairs == 0) &&
	  (symbols >= 1))
	{
	  bool s1;
	  set_unsafely_optimized(expr);
	  set_opt1_lambda(expr, func);
	  if (symbols == 2)
	    {
	      set_opt2_sym(expr, arg2);
	      if (one_form)
		{
		  if (safe_case)
		    {
		      if (is_fx_safe(sc, car(body)))
			{
			  annotate_arg(sc, body, e);
			  set_safe_optimize_op(expr, hop + OP_SAFE_CLOSURE_SS_A);
			  set_closure_has_fx(func);
			  return(OPT_T);
			}
		      set_optimize_op(expr, hop + OP_SAFE_CLOSURE_SS_P);
		    }
		  else set_optimize_op(expr, hop + OP_CLOSURE_SS_P);
		}
	      else set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_SS : OP_CLOSURE_SS));
	      return(OPT_F);
	    }
	  s1 = is_normal_symbol(arg1);
	  if (one_form)
	    {
	      if (safe_case)
		set_optimize_op(expr, hop + ((s1) ? OP_SAFE_CLOSURE_SC_P : OP_SAFE_CLOSURE_CS)); /* _A case is very rare */
	      else set_optimize_op(expr, hop + ((s1) ? OP_CLOSURE_SC_P : OP_CLOSURE_CS));
	    }
	  else set_optimize_op(expr, hop + ((s1) ? ((safe_case) ? OP_SAFE_CLOSURE_SC : OP_CLOSURE_SC) : ((safe_case) ? OP_SAFE_CLOSURE_CS : OP_CLOSURE_CS)));
	  if (s1)
	    set_opt2_con(expr, arg2);
	  else set_opt2_sym(expr, arg2);
	  return(OPT_F);
	}

      if ((!arglist_has_rest(sc, closure_args(func))) &&
	  (fx_count(sc, expr) == 2))
	{
	  if (one_form)
	    {
	      if (safe_case)
		{
		  if (is_fx_safe(sc, car(body)))
		    {
		      annotate_arg(sc, body, e);
		      set_optimize_op(expr, hop + OP_SAFE_CLOSURE_AA_A);
		      set_closure_has_fx(func);
		      annotate_args(sc, cdr(expr), e);
		      set_opt1_lambda(expr, func);
		      set_opt3_arglen(expr, small_int(2));
		      return(OPT_T);
		    }
		  set_optimize_op(expr, hop + OP_SAFE_CLOSURE_AA_P);
		}
	      else set_optimize_op(expr, hop + OP_CLOSURE_AA_P);
	    }
	  else
	    {
	      if ((safe_case) && (is_normal_symbol(arg1)))
		set_optimize_op(expr, hop + OP_SAFE_CLOSURE_SA);
	      else set_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_AA : OP_CLOSURE_AA));
	    }

	  annotate_args(sc, cdr(expr), e);
	  set_opt1_lambda(expr, func);
	  set_opt3_arglen(expr, small_int(2));
	  return(OPT_F);
	}

      if (is_fx_safe(sc, arg1))
	{
	  set_unsafely_optimized(expr);
	  annotate_arg(sc, cdr(expr), e);
	  set_optimize_op(expr, hop + ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_AP : OP_CLOSURE_AP));
	  set_opt1_lambda(expr, func);
	  return(OPT_F);
	}

      if ((is_pair(arg1)) &&
	  (car(arg1) == sc->lambda_symbol) &&
	  ((!is_pair(arg2)) ||
	   ((is_optimized(arg2)) &&
	    (is_fx_safe(sc, arg2)))) &&
	  (is_null(cdr(closure_body(func)))))
	{
	  s7_pointer code;
	  annotate_arg(sc, cddr(expr), e);
	  set_opt3_pair(expr, cdadr(expr));
	  set_unsafe_optimize_op(expr, hop + OP_CLOSURE_FA);
	  code = sc->code;
	  sc->code = cadr(expr);
	  check_lambda(sc);
	  clear_safe_closure_body(cdr(sc->code)); /* otherwise we need to fixup the local let for the optimizer */
	  sc->code = code;
	  set_opt1_lambda(expr, func);
	  return(OPT_F);
	}

      if (is_fx_safe(sc, arg2))
	{
	  set_unsafely_optimized(expr);
	  annotate_arg(sc, cddr(expr), e);
	  set_optimize_op(expr, hop + ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_PA : OP_CLOSURE_PA));
	  set_opt1_lambda(expr, func);
	  return(OPT_F);
	}

      return((is_optimized(expr)) ? OPT_T : OPT_F);
    }

  if (is_closure_star(func))
    {
      if (is_immutable(func)) hop = 1;
      if (fx_count(sc, expr) == 2)
	{
	  set_unsafely_optimized(expr);
	  if (lambda_has_simple_defaults(closure_body(func)))
	    {
	      if (closure_star_arity_to_int(sc, func) == 2)
		set_optimize_op(expr, hop + ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_STAR_AA : OP_CLOSURE_STAR_FX));
	      else set_optimize_op(expr, hop + ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_STAR_FX_2 : OP_CLOSURE_STAR_FX));
	    }
	  else
	    {
	      if (is_safe_closure(func))
		set_optimize_op(expr, hop + OP_SAFE_CLOSURE_STAR_FX_2);
	    }
	  annotate_args(sc, cdr(expr), e);
	  set_opt1_lambda(expr, func);
	  set_opt3_arglen(expr, small_int(2));
	  return(OPT_F);
	}
    }

  if ((is_c_function_star(func)) &&
      (fx_count(sc, expr) == 2))
    {
      if ((hop == 0) && (symbol_id(car(expr)) == 0)) hop = 1;
      set_optimized(expr);
      set_optimize_op(expr, hop + OP_SAFE_C_STAR_AA); /* k+c? = cc */
      annotate_args(sc, cdr(expr), e);
      set_opt3_arglen(expr, small_int(2));
      set_c_function(expr, func);
      return(OPT_T);
    }

  if ((is_any_vector(func)) &&
      (is_fx_safe(sc, arg1)) &&
      (is_fx_safe(sc, arg2)))
    {
      set_unsafe_optimize_op(expr, OP_VECTOR_AA);
      annotate_args(sc, cdr(expr), e);
      set_opt3_arglen(expr, small_int(2));
      return(OPT_T);
    }

  return((is_optimized(expr)) ? OPT_T : OPT_F);
}

static opt_t optimize_func_three_args(s7_scheme *sc, s7_pointer expr, s7_pointer func, int32_t hop, int32_t pairs, int32_t symbols, int32_t quotes, int32_t bad_pairs, s7_pointer e)
{
  s7_pointer arg1, arg2, arg3;

  if ((quotes > 0) &&
      (direct_memq(sc->quote_symbol, e)))
    return(OPT_OOPS);

  arg1 = cadr(expr);
  arg2 = caddr(expr);
  arg3 = cadddr(expr);

  if (((is_symbol(arg1)) &&
       (!arg_findable(sc, arg1, e))) ||
      ((is_symbol(arg2)) &&
       (!arg_findable(sc, arg2, e))) ||
      ((is_symbol(arg3)) &&
       (!arg_findable(sc, arg3, e))))
    {
      /* wrap bad args */
      if ((is_fx_safe(sc, arg1)) &&
	  (is_fx_safe(sc, arg2)) &&
	  (is_fx_safe(sc, arg3)) &&
	  (s7_is_aritable(sc, func, 3)))
	{
	  annotate_args(sc, cdr(expr), e);
	  set_opt3_arglen(expr, small_int(3));
	  if (is_c_function(func))
	    {
	      set_safe_optimize_op(expr, hop + ((is_safe_procedure(func)) ? OP_SAFE_C_AAA : OP_C_FX));
	      set_c_function(expr, func);
	      return(OPT_T);
	    }
	  if ((is_closure(func)) &&
	      (closure_arity_to_int(sc, func) == 3) &&
	      (!arglist_has_rest(sc, closure_args(func))))
	    {
	      set_unsafely_optimized(expr);
	      set_optimize_op(expr, hop + ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_FX : OP_CLOSURE_FX));
	      set_opt1_lambda(expr, func);
	      return(OPT_F);
	    }
	  if ((is_closure_star(func)) &&
	      (lambda_has_simple_defaults(closure_body(func))) &&
	      (closure_star_arity_to_int(sc, func) != 0) &&
	      (closure_star_arity_to_int(sc, func) != 1))
	    {
	      set_unsafely_optimized(expr);
	      set_optimize_op(expr, ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_STAR_FX : OP_CLOSURE_STAR_FX));
	      set_opt1_lambda(expr, func);
	    }
	}
      return(OPT_F);
    }
  /* end of bad symbol wrappers */

  if ((bad_pairs == quotes) &&
      (is_constant_symbol(sc, car(expr))))
    hop = 1;

  if ((is_c_function(func) &&
       (c_function_required_args(func) <= 3) &&
       (c_function_all_args(func) >= 3)) ||
      ((is_c_function_star(func)) &&
       (c_function_all_args(func) == 3) &&
       (!is_pair(arg1)) && (!is_symbol(arg1)) &&
       (!is_pair(arg2)) && (!is_symbol(arg2))))
    {
      if ((hop == 0) && (symbol_id(car(expr)) == 0))
	hop = 1;

      if ((is_safe_procedure(func)) ||
	  ((is_maybe_safe(func)) && (unsafe_is_safe(sc, arg3, e))))
	{
	  if (pairs == 0)
	    {
	      set_optimized(expr);
	      if (symbols == 0)
		set_optimize_op(expr, hop + OP_SAFE_C_D);
	      else
		{
		  if (symbols == 3)
		    {
		      set_optimize_op(expr, hop + OP_SAFE_C_SSS);
		      set_opt1_sym(cdr(expr), arg2);
		      set_opt2_sym(cdr(expr), arg3);
		    }
		  else
		    {
		      if (symbols == 2)
			{
			  if (!is_normal_symbol(arg1))
			    {
			      set_optimize_op(expr, hop + OP_SAFE_C_CSS);
			      set_opt1_sym(cdr(expr), arg2);
			      set_opt2_sym(cdr(expr), arg3);
			    }
			  else
			    {
			      if (!is_normal_symbol(arg3))
				{
				  set_opt2_con(cdr(expr), arg3);
				  set_opt1_sym(cdr(expr), arg2);
				  set_optimize_op(expr, hop + OP_SAFE_C_SSC);
				}
			      else
				{
				  set_opt1_con(cdr(expr), arg2);
				  set_opt2_sym(cdr(expr), arg3);
				  set_optimize_op(expr, hop + OP_SAFE_C_SCS);
				}
			    }
			}
		      else
			{
			  if (is_normal_symbol(arg1))
			    {
			      set_opt1_con(cdr(expr), arg2);
			      set_opt2_con(cdr(expr), arg3);
			      set_optimize_op(expr, hop + OP_SAFE_C_SCC);
			    }
			  else
			    {
			      if (is_normal_symbol(arg2))
				{
				  set_opt1_sym(cdr(expr), arg2);
				  set_opt2_con(cdr(expr), arg3);
				  set_optimize_op(expr, hop + OP_SAFE_C_CSC);
				}
			      else
				{
				  set_opt1_sym(cdr(expr), arg3);
				  set_opt2_con(cdr(expr), arg2);
				  set_optimize_op(expr, hop + OP_SAFE_C_CCS);
				}}}}}
	      choose_c_function(sc, expr, func, 3);
	      return(OPT_T);
	    }

	  /* pairs != 0 */
	  if (fx_count(sc, expr) == 3)
	    {
	      set_optimized(expr);
	      if (quotes == 1)
		{
		  if ((symbols == 2) &&
		      (is_normal_symbol(arg1)) &&
		      (is_normal_symbol(arg3)))
		    {
		      set_opt1_con(cdr(expr), cadr(arg2));        /* fx_c_scs uses opt1_con */
		      set_opt2_sym(cdr(expr), arg3);
		      set_optimize_op(expr, hop + OP_SAFE_C_SCS); /* used to be SQS */
		      choose_c_function(sc, expr, func, 3);
		      return(OPT_T);
		    }
		  if ((symbols == 1) &&
		      (is_normal_symbol(arg3)) &&
		      (is_proper_quote(sc, arg2)) &&
		      (is_safe_c_s(arg1)))
		    {
		      set_safe_optimize_op(expr, hop + OP_SAFE_C_opSq_CS);
		      set_opt1_con(cdr(expr), cadr(arg2)); /* opt1_con is T_Pos (unchecked) */
		      set_opt2_sym(cdr(expr), arg3);
		      set_opt3_sym(cdr(expr), cadr(arg1));
		      choose_c_function(sc, expr, func, 3);
		      return(OPT_T);
		    }
		}
	      annotate_args(sc, cdr(expr), e);
	      set_opt3_arglen(expr, small_int(3));
	      set_optimize_op(expr, hop + OP_SAFE_C_AAA);

	      if (pairs == 1)
		{
		  if ((symbols == 0) && (is_pair(arg2)))
		    set_optimize_op(expr, hop + OP_SAFE_C_CAC);
		  else
		    {
		      if ((symbols == 1) && (is_pair(arg3)))
			set_optimize_op(expr, hop + ((is_normal_symbol(arg2)) ? OP_SAFE_C_CSA : OP_SAFE_C_SCA));
		      else
			{
			  if ((symbols == 2) && (is_normal_symbol(arg1)))
			    {
			      if (is_normal_symbol(arg2))
				set_optimize_op(expr, hop + OP_SAFE_C_SSA);
			      else set_optimize_op(expr, hop + OP_SAFE_C_SAS);
			    }
			}
		    }
		}
	      choose_c_function(sc, expr, func, 3);
	      return(OPT_T);
	    }
	  else
	    {
	      if ((is_normal_symbol(arg1)) && (is_normal_symbol(arg2)))
		{
		  set_opt3_pair(expr, cadddr(expr));
		  set_unsafe_optimize_op(expr, hop + OP_SAFE_C_SSP);
		  choose_c_function(sc, expr, func, 3);
		  return(OPT_F);
		}
	    }

	  /* op_safe_c_fp, similar to op_and_p etc, but we have C_AAA above (fx_count==3) so any_nils is not needed */
	  {
	    s7_pointer p;
	    for (p = cdr(expr); is_pair(p); p = cdr(p))
	      {
		s7_function callee;
		callee = fx_choose(sc, p, e, (is_list(e)) ? pair_symbol_is_safe : let_symbol_is_safe);
		set_c_call_checked(p, callee);
	      }
	    set_opt3_arglen(expr, small_int(3));
#if S7_DEBUGGING
	    if ((car(expr) == sc->vector_set_symbol) && (is_normal_symbol(arg1)) && (is_normal_symbol(arg2))) fprintf(stderr, "%s\n", DISPLAY(expr));
#endif
	    set_unsafe_optimize_op(expr, hop + OP_SAFE_C_FP);
	    choose_c_function(sc, expr, func, 3);
	    return(OPT_F);
	  }
	}
      else /* func is not safe */
	{
	  if (fx_count(sc, expr) == 3)
	    {
	      set_optimized(expr);
	      if ((symbols == 2) &&
		  (pairs == 0) &&
		  (is_normal_symbol(arg1)) &&
		  (is_normal_symbol(arg3)))
		set_optimize_op(expr, hop + OP_C_SCS);
	      else
		{
		  annotate_args(sc, cdr(expr), e);
		  set_opt3_arglen(expr, small_int(3));
		  set_optimize_op(expr, hop + OP_C_FX);
		}
	      choose_c_function(sc, expr, func, 3);
	      if (optimize_op(expr) != HOP_SAFE_C_D) /* did chooser fix it up? */
		{
		  set_unsafe(expr);
		  return(OPT_F);
		}
	      return(OPT_T);
	    }

	  /* (define (hi) (catch #t (lambda () 1) (lambda args 2)))
	   *   first arg list must be (), second a symbol
	   */
	  if (c_function_call(func) == g_catch)
	    {
	      if (((bad_pairs == 2) && (!is_pair(arg1))) ||
		  ((bad_pairs == 3) && (car(arg1) == sc->quote_symbol)))
		{
		  s7_pointer body_lambda, error_lambda;
		  body_lambda = arg2;
		  error_lambda = arg3;

		  if ((is_pair(body_lambda)) &&
		      (is_lambda(sc, car(body_lambda))) &&
		      (is_pair(error_lambda)) &&
		      (is_lambda(sc, car(error_lambda))) &&
		      (is_null(cadr(body_lambda))) &&
		      (is_not_null(cddr(body_lambda))) &&
		      (((is_symbol(cadr(error_lambda))) &&              /* (lambda args ... */
			(!is_probably_constant(cadr(error_lambda)))) ||
		       ((is_pair(cadr(error_lambda))) &&                /* (lambda (type info) ... */
			(is_pair(cdadr(error_lambda))) &&
			(is_null(cddadr(error_lambda))) &&
			(!is_probably_constant(caadr(error_lambda))) && /* (lambda (pi ...) ...) */
			(!is_probably_constant(cadadr(error_lambda))))) &&
		      (is_not_null(cddr(error_lambda))))
		    {
		      s7_pointer error_result;
		      error_result = caddr(error_lambda);
		      set_unsafely_optimized(expr);
		      if ((arg1 == sc->T) &&
			  (is_null(cdddr(error_lambda))) &&
			  ((!is_symbol(error_result)) ||                  /* (lambda args #f) */
			   ((is_pair(cadr(error_lambda))) &&
			    (error_result == caadr(error_lambda)))) &&    /* (lambda (type info) type) */
			  ((!is_pair(error_result)) ||
			   (car(error_result) == sc->quote_symbol) ||     /* (lambda args 'a) */
			   ((car(error_result) == sc->car_symbol) &&
			    (cadr(error_result) == cadr(error_lambda))))) /* (lambda args (car args) -> error-type */
			{
			  set_optimize_op(expr, hop + OP_C_CATCH_ALL);
			  set_c_function(expr, func);
			  set_opt2_con(expr, error_result);
			  set_opt1_pair(cdr(expr), cddr(body_lambda));
			  if (is_null(cdddr(body_lambda)))
			    {
			      if (is_fx_safe(sc, caddr(body_lambda)))
				{
				  set_optimize_op(expr, hop + OP_C_CATCH_ALL_FX);
				  set_c_call(cddr(body_lambda), fx_choose(sc, cddr(body_lambda), sc->envir, let_symbol_is_safe));
				}
			      else
				{
				  set_opt1_pair(cdr(expr), caddr(body_lambda));
				  set_optimize_op(expr, hop + OP_C_CATCH_ALL_P);
				}
			    }
			}
		      else
			{
			  set_optimize_op(expr, hop + OP_C_CATCH);
			  choose_c_function(sc, expr, func, 3);
			}
		      return(OPT_F);
		    }
		}
	    }
	}
      return((is_optimized(expr)) ? OPT_T : OPT_F);
    }

  /* not c func */
  if (is_closure(func))
    {
      int32_t arit;
      arit = closure_arity_to_int(sc, func);
      if (arit != 3)
	{
	  if ((arit == -1) &&
	      (is_symbol(closure_args(func))))
	    return(optimize_func_dotted_args(sc, expr, func, hop, 3, e));
	  return(OPT_F);
	}

      if (is_immutable(func)) hop = 1;

      if ((symbols == 3) &&
	  (!is_safe_closure(func)))
	{
	  set_unsafely_optimized(expr);
	  set_opt1_lambda(expr, func);
	  set_opt3_arglen(expr, small_int(3));
	  set_optimize_op(expr, hop + OP_CLOSURE_ALL_S);
	  return(OPT_F);
	}

      if (fx_count(sc, expr) == 3)
	{
	  if (is_safe_closure(func))
	    set_optimize_op(expr, hop + ((is_normal_symbol(arg1) ? OP_SAFE_CLOSURE_SAA : OP_SAFE_CLOSURE_FX)));
	  else set_optimize_op(expr, hop + OP_CLOSURE_FX);
	  set_unsafely_optimized(expr);
	  annotate_args(sc, cdr(expr), e);
	  set_opt1_lambda(expr, func);
	  set_opt3_arglen(expr, small_int(3));
	  return(OPT_F);
	}
    }

  if (is_closure_star(func))
    {
      if ((!lambda_has_simple_defaults(closure_body(func))) ||
	  (closure_star_arity_to_int(sc, func) == 0) ||
	  (closure_star_arity_to_int(sc, func) == 1))
	return(OPT_F);

      if (fx_count(sc, expr) == 3)
	{
	  if (is_immutable(func)) hop = 1;
	  set_unsafe_optimize_op(expr, hop + ((is_safe_closure(func) ? OP_SAFE_CLOSURE_STAR_FX : OP_CLOSURE_STAR_FX)));
	  annotate_args(sc, cdr(expr), e);
	  set_opt1_lambda(expr, func);
	  set_opt3_arglen(expr, small_int(3));
	  return(OPT_F);
	}
    }

  if ((is_c_function_star(func)) &&
      (fx_count(sc, expr) == 3))
    {
      set_optimized(expr);
      set_optimize_op(expr, hop + OP_SAFE_C_STAR_FX);
      annotate_args(sc, cdr(expr), e);
      set_opt3_arglen(expr, small_int(3));
      set_c_function(expr, func);
      return(OPT_T);
    }

  if (bad_pairs > quotes) return(OPT_F);
  return((is_optimized(expr)) ? OPT_T : OPT_F);
}

static bool symbols_are_safe(s7_scheme *sc, s7_pointer args, s7_pointer e)
{
  s7_pointer p;
  for (p = args; is_pair(p); p = cdr(p))
    {
      s7_pointer arg;
      arg = car(p);
      if ((is_normal_symbol(arg)) &&
	  (!arg_findable(sc, arg, e)))
	return(false);
    }
  return(true);
}

static opt_t optimize_func_many_args(s7_scheme *sc, s7_pointer expr, s7_pointer func, int32_t hop, int32_t args, int32_t pairs, int32_t symbols, int32_t quotes, int32_t bad_pairs, s7_pointer e)
{
  bool func_is_closure;

  if (bad_pairs > quotes) return(OPT_F);
  if (quotes > 0)
    {
      if (direct_memq(sc->quote_symbol, e))
	return(OPT_OOPS);
      if ((bad_pairs == quotes) &&
	  (is_constant_symbol(sc, car(expr))))
	hop = 1;
    }

  if ((is_c_function(func)) &&
      (c_function_required_args(func) <= args) &&
      (c_function_all_args(func) >= args))
    {
      if ((hop == 0) && (symbol_id(car(expr)) == 0)) hop = 1;

      if (is_safe_procedure(func))
	{
	  if (pairs == 0)
	    {
	      if (symbols == 0)
		{
		  set_safe_optimize_op(expr, hop + OP_SAFE_C_D);
		  choose_c_function(sc, expr, func, args);
		  return(OPT_T);
		}
	      if ((symbols == args) &&
		  (args < GC_TRIGGER_SIZE))
		{
		  if (symbols_are_safe(sc, cdr(expr), e))
		    set_safe_optimize_op(expr, hop + OP_SAFE_C_ALL_S);
		  else
		    {
		      set_optimized(expr);
		      if (args == 4)
			set_optimize_op(expr, hop + OP_SAFE_C_AAAA);
		      else set_optimize_op(expr, hop + OP_SAFE_C_FX);
		      annotate_args(sc, cdr(expr), e);
		    }
		  set_opt3_arglen(expr, make_permanent_integer(args));
		  choose_c_function(sc, expr, func, args);
		  return(OPT_T);
		}
	    }

	  if (args < GC_TRIGGER_SIZE)
	    {
	      if (fx_count(sc, expr) == args)
		{
		  s7_pointer p;
		  set_optimized(expr);
		  if (args == 4)
		    {
		      if ((symbols == 3) && (pairs == 0) &&
			  (!is_symbol(car(cddddr(expr)))) &&
			  (arg_findable(sc, cadr(expr), e)) &&
			  (arg_findable(sc, caddr(expr), e)) &&
			  (arg_findable(sc, cadddr(expr), e)))
			{
			  set_optimize_op(expr, hop + OP_SAFE_C_SSSC);
			  set_opt2_con(cdr(expr), car(cddddr(expr)));
			  set_opt1_sym(cdr(expr), caddr(expr));
			  set_opt3_sym(cdr(expr), cadddr(expr));
			  choose_c_function(sc, expr, func, 4);
			  return(OPT_T);
			}
		      set_optimize_op(expr, hop + OP_SAFE_C_AAAA);
		    }
		  else set_optimize_op(expr, hop + OP_SAFE_C_FX);
		  annotate_args(sc, cdr(expr), e);
		  set_opt3_arglen(expr, make_permanent_integer(args));
		  choose_c_function(sc, expr, func, args);

		  for (p = cdr(expr); (is_pair(p)) && (is_pair(cdr(p))); p = cddr(p))
		    {
		      if (is_normal_symbol(car(p)))
			break;
		      if ((is_pair(car(p))) &&
			  ((!is_pair(cdar(p))) || (caar(p) != sc->quote_symbol)))
			break;
		    }
		  if (is_null(p))
		    {
		      set_optimize_op(expr, hop + OP_SAFE_C_ALL_CA);
		      for (p = cdr(expr); is_pair(p); p = cddr(p))
			{
			  clear_has_fx(p);
			  set_opt2_any(p, (is_pair(car(p))) ? cadar(p) : car(p));
			}
		    }
		  return(OPT_T);
		}
	      else
		{
		  s7_pointer p;
		  for (p = cdr(expr); is_pair(p); p = cdr(p))
		    {
		      s7_function callee;
		      callee = fx_choose(sc, p, e, (is_list(e)) ? pair_symbol_is_safe : let_symbol_is_safe);
		      set_c_call_checked(p, callee);
		    }
		  set_opt3_arglen(expr, make_permanent_integer(args));
		  set_unsafe_optimize_op(expr, hop + OP_SAFE_C_FP);
		  choose_c_function(sc, expr, func, args);
		  return(OPT_F);
		}
	    }
	}
      else /* c_func is not safe */
	{
	  if ((args < GC_TRIGGER_SIZE) &&
	      (fx_count(sc, expr) == args))
	    {
	      set_unsafe_optimize_op(expr, hop + OP_C_FX);
	      annotate_args(sc, cdr(expr), e);
	      set_opt3_arglen(expr, make_permanent_integer(args));
	      choose_c_function(sc, expr, func, args);
	      return(OPT_F);
	    }
	}
      return((is_optimized(expr)) ? OPT_T : OPT_F);
    }

  func_is_closure = is_closure(func);
  if (func_is_closure)
    {
      int32_t arit;
      arit = closure_arity_to_int(sc, func);
      if (arit != args)
	{
	  if ((arit == -1) &&
	      (is_symbol(closure_args(func))))
	    return(optimize_func_dotted_args(sc, expr, func, hop, args, e));
	  return(OPT_F);
	}

      if (is_immutable(func)) hop = 1;

      if ((pairs == 0) &&
	  (args < GC_TRIGGER_SIZE))
	{
	  bool safe_case;
	  set_unsafely_optimized(expr);
	  safe_case = is_safe_closure(func);
	  set_unsafe_optimize_op(expr, hop + ((safe_case) ? OP_SAFE_CLOSURE_FX : OP_CLOSURE_FX));
	  annotate_args(sc, cdr(expr), e);
	  set_opt3_arglen(expr, make_permanent_integer(args));
	  set_opt1_lambda(expr, func);

	  if ((!safe_case) &&
	      (symbols == args) &&
	      (symbols_are_safe(sc, cdr(expr), e)))
	    set_optimize_op(expr, hop + OP_CLOSURE_ALL_S);
	  return(OPT_F);
	}
    }

  if ((is_closure_star(func)) &&
      ((!lambda_has_simple_defaults(closure_body(func))) ||
       (closure_star_arity_to_int(sc, func) == 0) ||
       (closure_star_arity_to_int(sc, func) == 1)))
    return(OPT_F);

  if ((is_c_function_star(func)) &&
      (fx_count(sc, expr) == args))
    {
      if (is_immutable(func)) hop = 1;
      set_optimized(expr);
      set_optimize_op(expr, hop + OP_SAFE_C_STAR_FX);
      annotate_args(sc, cdr(expr), e);
      set_opt3_arglen(expr, make_permanent_integer(args));
      set_c_function(expr, func);
      return(OPT_T);
    }

  if (args < GC_TRIGGER_SIZE)
    {
      if (((func_is_closure) ||
	   (is_closure_star(func))) &&
	  (fx_count(sc, expr) == args))
	{
	  set_unsafely_optimized(expr);
	  if (func_is_closure)
	    set_optimize_op(expr, hop + ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_FX : OP_CLOSURE_FX));
	  else set_optimize_op(expr, hop + ((is_safe_closure(func)) ? OP_SAFE_CLOSURE_STAR_FX : OP_CLOSURE_STAR_FX));
	  annotate_args(sc, cdr(expr), e);
	  set_opt3_arglen(expr, make_permanent_integer(args));
	  set_opt1_lambda(expr, func);
	  return(OPT_F);
	}
    }
  return((is_optimized(expr)) ? OPT_T : OPT_F);
}

static bool vars_syntax_ok(s7_pointer vars)
{
  s7_pointer p;
  for (p = vars; is_pair(p); p = cdr(p))
    {
      s7_pointer var;
      var = car(p);
      if ((!is_pair(var)) ||
	  (!is_symbol(car(var))) ||
	  (!is_pair(cdr(var))))
	return(false);
    }
  return(true);
}

static opt_t optimize_expression(s7_scheme *sc, s7_pointer expr, int32_t hop, s7_pointer e, bool export_ok);

static bool vars_opt_ok(s7_scheme *sc, s7_pointer vars, int32_t hop, s7_pointer e)
{
  s7_pointer p;
  for (p = vars; is_pair(p); p = cdr(p))
    {
      s7_pointer init;
      init = cadar(p);
      if ((is_pair(init)) &&
	  (!is_checked(init)) &&
	  (optimize_expression(sc, init, hop, e, false) == OPT_OOPS))
	return(false);
    }
  return(true);
}

static opt_t optimize_syntax(s7_scheme *sc, s7_pointer expr, s7_pointer func, int32_t hop, s7_pointer e, bool export_ok)
{
  opcode_t op;
  s7_pointer p, body, vars;
  bool body_export_ok = true;
#if OPTIMIZE_PRINT
  fprintf(stderr, "optimize_syntax %s %d %s\n", DISPLAY(expr), hop, DISPLAY(e));
#endif

  op = (opcode_t)syntax_opcode(func);
  sc->w = e;
  body = cdr(expr);

  switch (op)
    {
    case OP_QUOTE:
    case OP_MACROEXPAND:
      return(((is_pair(body)) && (is_null(cdr(body)))) ? OPT_F : OPT_OOPS);

    case OP_LET:
    case OP_LETREC:
    case OP_LET_STAR:
    case OP_LETREC_STAR:
      if (is_symbol(cadr(expr)))
	{
	  if (!is_pair(cddr(expr))) /* (let name . x) */
	    return(OPT_F);
	  vars = caddr(expr);
	  if (!is_list(vars)) return(OPT_OOPS);
	  body = cdddr(expr);
	}
      else
	{
	  vars = cadr(expr);
	  body = cddr(expr);
	  if (is_null(vars))
	    e = cons(sc, sc->nil, e);
	  else
	    {
	      if (!is_pair(vars))
		return(OPT_OOPS);
	    }
	}
      if (!is_pair(body)) return(OPT_OOPS);

      if (!vars_syntax_ok(vars))
	return(OPT_OOPS);

      if ((op == OP_LETREC) || (op == OP_LETREC_STAR))
	{
	  e = collect_variables(sc, vars, e);
	  if (!vars_opt_ok(sc, vars, hop, e))
	    return(OPT_OOPS);
	}
      else
	{
	  if (op == OP_LET)
	    {
	      if (!vars_opt_ok(sc, vars, hop, e))
		return(OPT_OOPS);
	      e = collect_variables(sc, vars, e);
	    }
	  else
	    {
	      for (p = vars; is_pair(p); p = cdr(p))
		{
		  s7_pointer var;
		  var = car(p);
		  if ((is_pair(cadr(var))) &&
		      (!is_checked(cadr(var))) &&
		      (optimize_expression(sc, cadr(var), hop, e, false) == OPT_OOPS))
		    return(OPT_OOPS);
		  e = cons(sc, add_symbol_to_list(sc, car(var)), e);
		  sc->w = e;
		}
	    }
	}
      if (is_symbol(cadr(expr)))
	{
	  e = cons(sc, add_symbol_to_list(sc, cadr(expr)), e);
	  sc->w = e;
	}
      break;

    case OP_LET_TEMPORARILY:
      vars = cadr(expr);
      if (!is_list(vars)) return(OPT_OOPS);
      body = cddr(expr);
      for (p = vars; is_pair(p); p = cdr(p))
	{
	  s7_pointer var;
	  var = car(vars);
	  if ((is_pair(var)) &&
	      (is_pair(cdr(var))) &&
	      (is_pair(cadr(var))) &&
	      (!is_checked(cadr(var))))
	    {
	      if (optimize_expression(sc, cadr(var), hop, e, false) == OPT_OOPS)
		return(OPT_OOPS);
	    }
	}
      /* e = cons(sc, sc->nil, e); */ /* !? currently let-temporarily does not make a new let, so it is like begin? */
      body_export_ok = export_ok;     /* (list x (let-temporarily () (define x 0))) just as in begin */
      break;

    case OP_DO:
      vars = cadr(expr);
      if (is_null(vars))
	e = cons(sc, sc->nil, e);
      else
	{
	  if (!is_pair(vars))
	    return(OPT_OOPS);
	}
      body = cddr(expr);

      for (p = vars; is_pair(p); p = cdr(p))
	{
	  s7_pointer var;
	  var = car(p);
	  if ((!is_pair(var)) ||
	      (!is_symbol(car(var))) ||
	      (!is_pair(cdr(var))))
	    return(OPT_OOPS);
	  if ((is_pair(cadr(var))) &&
	      (!is_checked(cadr(var))) &&
	      (optimize_expression(sc, cadr(var), hop, e, false) == OPT_OOPS)) /* the init field -- locals are not defined yet */
	    return(OPT_OOPS);
	}
      e = collect_variables(sc, vars, e);
      for (p = vars; is_pair(p); p = cdr(p))
	{
	  s7_pointer var;
	  var = cddar(p);
	  if ((is_pair(var)) &&
	      (is_pair(car(var))) &&
	      (!is_checked(car(var))) &&
	      (optimize_expression(sc, car(var), hop, e, false) == OPT_OOPS)) /* the step field -- locals are defined */
	    return(OPT_OOPS);
	}
      break;

    case OP_BEGIN:
      body_export_ok = export_ok; /* (list x (begin (define x 0))) */
      break;

    case OP_WITH_BAFFLE:
      e = cons(sc, sc->nil, e);
      break;

    case OP_DEFINE_MACRO:    case OP_DEFINE_MACRO_STAR:
    case OP_DEFINE_BACRO:    case OP_DEFINE_BACRO_STAR:
    case OP_DEFINE_CONSTANT: case OP_DEFINE_EXPANSION:
    case OP_DEFINE:          case OP_DEFINE_STAR:
      /* define adds a name to the incoming env (e), the added name is inserted into e after the first, so the caller
       *   can flush added symbols by maintaining its own pointer into the list if blockers set the car.
       * the list is used both to see local symbols and to catch "complicated" functions (find_uncomplicated_symbol).
       * In cases like (if expr (define...)) we can't tell at this level whether the define takes place, so
       *   its name should not be in "e", but it needs to be marked for find_uncomplicated_symbol in a way
       *   that can be distinguished from members of "e".  So in that (rare) case, we use the associated keyword.
       *   Then find_uncomplicated_symbol can use has_keyword to tell if the keyword search is needed.
       * export_ok is trying to protect against optimizing (list x (define x 0)) as op_safe_c_sp and all related cases
       */
      vars = cadr(expr);
      body = cddr(expr);
      if (is_pair(vars))
	{
	  if ((export_ok) &&
	      (is_symbol(car(vars))))
	    {
	      add_symbol_to_list(sc, car(vars));
	      if (is_pair(e))
		{
		  if (car(e) != sc->key_if_symbol)
		    set_cdr(e, cons(sc, car(vars), cdr(e))); /* export it */
		  else add_symbol_to_list(sc, symbol_to_keyword(sc, car(vars)));
		}
	      else e = cons(sc, car(vars), e);
	    }
	  e = collect_parameters(sc, cdr(vars), e);
	  body_export_ok = export_ok;
	}
      else
	{
	  if ((export_ok) &&
	      (is_symbol(vars)))
	    {
	      /* actually if this is defining a function, the name should probably be included in the local env
	       *   but that's next-to-impossible to guarantee unless it's (define x (lambda...)) of course.
	       */
	      sc->temp9 = e;
	      for (p = body; is_pair(p); p = cdr(p))
		if ((is_pair(car(p))) &&
		    (!is_checked(car(p))) && /* ((typeflag & (TYPE_MASK | T_CHECKED)) == T_PAIR) is not faster */
		    (optimize_expression(sc, car(p), hop, e, false) == OPT_OOPS)) /* "body" here is not body in terms of export_ok */
		  return(OPT_OOPS);
	      sc->temp9 = sc->nil;

	      add_symbol_to_list(sc, vars);
	      if (is_pair(e))
		{
		  if (car(e) != sc->key_if_symbol)
		    set_cdr(e, cons(sc, vars, cdr(e)));     /* export it */
		  else add_symbol_to_list(sc, symbol_to_keyword(sc, vars));
		}
	      /* else e = cons(sc, vars, e); */ /* ?? should this be set-cdr etc? */
	      return(OPT_F);
	    }
	  body_export_ok = false;
	}
      break;

    case OP_LAMBDA:
    case OP_LAMBDA_STAR:
      vars = cadr(expr);
      if (is_null(vars))
	e = cons(sc, sc->nil, e);
      else
	{
	  if ((!is_pair(vars)) && (!is_symbol(vars)))
	    return(OPT_OOPS);
	}
      e = collect_parameters(sc, vars, e);
      body = cddr(expr);
      break;

    case OP_SET:
      if ((is_pair(cadr(expr))) &&
	  (caadr(expr) == sc->outlet_symbol))
	return(OPT_OOPS);
      body = cddr(expr);
      body_export_ok = false; /* (list x (set! y (define x 0))) -- can body here have more than one expression? */
      break;

    case OP_WITH_LET:
      /* we can't trust anything here, so hop ought to be off.  For example,
       *   (define (hi)
       *     (let ((e (sublet (curlet)
       *                (cons :abs (lambda (a) (- a 1))))))
       *       (with-let e (abs -1))))
       * returns 1 if hop is 1, but -2 otherwise
       */
      {
	bool old_with_let;
	old_with_let = sc->in_with_let;
	sc->in_with_let = true;
	for (p = body; is_pair(p); p = cdr(p))
	  if ((is_pair(car(p))) &&
	      (!is_checked(car(p))) &&
	      (optimize_expression(sc, car(p), 0, sc->nil, body_export_ok) == OPT_OOPS))
	    {
	      sc->in_with_let = old_with_let;
	      return(OPT_OOPS);
	    }
	sc->in_with_let = old_with_let;
	return(OPT_F);
      }

    case OP_CASE:
      if ((is_pair(cadr(expr))) &&
	  (!is_checked(cadr(expr))) &&
	  (optimize_expression(sc, cadr(expr), hop, e, false) == OPT_OOPS))
	return(OPT_OOPS);
      for (p = cddr(expr); is_pair(p); p = cdr(p))
	if ((is_pair(car(p))) &&
	    (is_pair(cdar(p))))
	  {
	    s7_pointer rst;
	    for (rst = cdar(p); is_pair(rst); rst = cdr(rst))
	      if ((is_pair(car(rst))) &&
		  (!is_checked(car(rst))) &&
		  (optimize_expression(sc, car(rst), hop, e, false) == OPT_OOPS))
		return(OPT_OOPS);
	  }
      return(OPT_F);

    case OP_COND: /* split opt is necessary: (cond (lambda (x) ...)) */
      for (p = cdr(expr); is_pair(p); p = cdr(p))
	if (is_pair(car(p)))
	  {
	    s7_pointer test, rst;
	    test = caar(p);
	    e = cons(sc, sc->key_if_symbol, e);  /* I think this is a marker in case define is encountered? (see above) */
	    if ((is_pair(test)) &&
		(!is_checked(test)) &&
		(optimize_expression(sc, test, hop, e, false) == OPT_OOPS))
	      return(OPT_OOPS);
	    for (rst = cdar(p); is_pair(rst); rst = cdr(rst))
	      if ((is_pair(car(rst))) &&
		  (!is_checked(car(rst))) &&
		  (optimize_expression(sc, car(rst), hop, e, false) == OPT_OOPS))
		return(OPT_OOPS);
	  }
      return(OPT_F);

    case OP_IF:
    case OP_WHEN:
    case OP_UNLESS:
    case OP_OR:
    case OP_AND:
      e = cons(sc, sc->key_if_symbol, e);
      break;

    default:
      break;
    }

  sc->temp9 = e;
  for (p = body; is_pair(p); p = cdr(p))
    if ((is_pair(car(p))) &&
	(!is_checked(car(p))) && /* ((typeflag & (TYPE_MASK | T_CHECKED)) == T_PAIR) is not faster */
	(optimize_expression(sc, car(p), hop, e, body_export_ok) == OPT_OOPS))
      {
	sc->temp9 = sc->nil;
	return(OPT_OOPS);
      }
  sc->temp9 = sc->nil;
  
  if ((hop == 1) &&
      (symbol_id(car(expr)) == 0))
    {
      if ((op == OP_IF) || (op == OP_OR) || (op == OP_AND))
	{
	  bool happy = true;
	  for (p = cdr(expr); (happy) && (is_pair(p)); p = cdr(p))
	    happy = is_fx_safe(sc, car(p));

	  if ((happy) &&       /* fx* will work */
	      (is_null(p)))    /* catch the syntax error later: (or #f . 2) etc */
	    {
	      int32_t args, pairs = 0;
	      s7_pointer sym = NULL;
	      bool c_s_is_ok = true;

	      for (args = 0, p = cdr(expr); is_pair(p); p = cdr(p), args++)
		{
		  if (is_pair(car(p)))
		    {
		      pairs++;
		      if ((c_s_is_ok) &&
			  ((!is_h_safe_c_s(car(p))) ||
			   ((sym) && (sym != cadar(p)))))
			c_s_is_ok = false;
		      else
			{
			  if (is_pair(cdar(p)))
			    sym = cadar(p);
			  else sym = sc->unspecified;
			}
		    }
		}

	      if ((op == OP_IF) &&
		  ((args < 2) || (args > 3))) /* syntax error */
		return(OPT_F);

	      if ((pairs == args) &&
		  (c_s_is_ok))
		{
		  if (op == OP_OR)
		    {
		      set_safe_optimize_op(expr, hop + OP_SAFE_C_D);
		      if (args == 2)
			{
			  if ((symbol_type(caadr(expr)) > 0) && (is_global(caadr(expr))) &&
			      ((symbol_type(caaddr(expr)) > 0) && (is_global(caaddr(expr)))))
			    set_c_function(expr, sc->or_s_type_2);
			  else set_c_function(expr, sc->or_s_direct_2);
			}
		      else set_c_function(expr, sc->or_s_direct);
		    }
		  else
		    {
		      if (op == OP_AND)
			{
			  set_safe_optimize_op(expr, hop + OP_SAFE_C_D);
			  set_c_function(expr, (args == 2) ? sc->and_s_direct_2 : sc->and_s_direct);
			}
		    }
		  return(OPT_F);
		}

	      set_safe_optimize_op(expr, hop + OP_SAFE_C_D);

	      for (p = cdr(expr); is_pair(p); p = cdr(p))
		set_c_call(p, fx_choose(sc, p, e, pair_symbol_is_safe));

	      if (op == OP_OR)
		{
		  if (s7_list_length(sc, cdr(expr)) == 2)
		    {
		      set_c_function(expr, sc->or_2);
		      add_optimizer_fixup(sc, expr, hop + OP_SAFE_C_OR2);
		    }
		  else
		    {
		      if (s7_list_length(sc, cdr(expr)) == 3)
			set_c_function(expr, sc->or_3);
		      else set_c_function(expr, sc->or_n);
		    }
		}
	      else
		{
		  if (op == OP_AND)
		    {
		      if (s7_list_length(sc, cdr(expr)) == 2)
			{
			  set_c_function(expr, sc->and_2);
			  add_optimizer_fixup(sc, expr, hop + OP_SAFE_C_AND2);
			}
		      else
			{
			  if (s7_list_length(sc, cdr(expr)) == 3)
			    set_c_function(expr, sc->and_3);
			  else set_c_function(expr, sc->and_n);
			}
		    }
		  else
		    {
		      s7_pointer test, b1, b2;
		      test = cdr(expr);
		      b1 = cdr(test);
		      b2 = cdr(b1);
		      if ((c_callee(b1) == fx_q) &&
			  (is_pair(b2)))
			{
			  set_opt3_any(test, cadar(b1));
			  if (c_callee(b2) == fx_q)
			    {
			      set_opt3_any(cdr(test), cadar(b2));
			      set_c_function(expr, sc->if_x_qq);
			    }
			  else set_c_function(expr, sc->if_x_qa);
			}
		      else
			{
			  if ((is_pair(car(test))) &&
			      (caar(test) == sc->not_symbol) &&
			      (is_fx_safe(sc, cadar(test))))
			    {
			      set_c_call(test, fx_choose(sc, cdar(test), e, pair_symbol_is_safe));
			      if (is_null(b2))
				set_c_function(expr, sc->if_not_a_a);
			      else set_c_function(expr, sc->if_not_a_aa);
			    }
			  else
			    {
			      if (is_null(b2))
				set_c_function(expr, sc->if_a_a);
			      else set_c_function(expr, sc->if_a_aa);
			    }
			}
		    }
		}
	      return(OPT_T);
	    }
	  /* else we could check other if cases here (test is often fx_safe) */
	}
    }
  return(OPT_F);
}

static opt_t optimize_expression(s7_scheme *sc, s7_pointer expr, int32_t hop, s7_pointer e, bool export_ok)
{
  s7_pointer car_expr;
#if OPTIMIZE_PRINT
  fprintf(stderr, "optimize_expression %s %d %s\n", DISPLAY(expr), hop, DISPLAY(e));
#endif
  set_checked(expr);
  car_expr = car(expr);

  if (is_symbol(car_expr))
    {
      s7_pointer slot;
      if (is_syntactic_symbol(car_expr))
	{
	  if (!is_pair(cdr(expr)))
	    return(OPT_OOPS);
	  return(optimize_syntax(sc, expr, T_Syn(slot_value(global_slot(car_expr))), hop, e, export_ok));
	}

      slot = find_uncomplicated_symbol(sc, car_expr, e); /* local vars (recursive calls too??) are considered "complicated" */
#if OPTIMIZE_PRINT
      if (!is_slot(slot)) fprintf(stderr, "  %s is not simple\n", DISPLAY(expr));
#endif
      if (is_slot(slot))
	{
	  s7_pointer func;
	  func = slot_value(slot);
	  if (is_syntax(func))                           /* 12-8-16 was is_syntactic, but that is only appropriate above -- here we have the value */
	    {
	      if (!is_pair(cdr(expr)))
		return(OPT_OOPS);
	      return(optimize_syntax(sc, expr, func, hop, e, export_ok));  /* e can be extended via set-cdr! here */
	    }
	  if (is_any_macro(func)) return(OPT_F);

	  /* we miss implicit indexing here because at this time, the data are not set */
	  if ((is_t_procedure(func)) ||
	      /* (is_c_function(func)) || */
	      (is_safe_procedure(func)))                 /* built-in applicable objects like vectors */
	    {
	      int32_t pairs = 0, symbols = 0, args = 0, bad_pairs = 0, quotes = 0, orig_hop;
	      s7_pointer p;

	      orig_hop = hop;
	      if ((hop != 0) &&
		  ((is_any_closure(func)) ||
		   ((!is_global(car_expr)) &&
		    ((!is_slot(global_slot(car_expr))) ||
		     (slot_value(global_slot(car_expr)) != func)))) &&
		  (!is_immutable(car_expr)) && /* list|apply-values -- can't depend on opt1 here because it might not be global, or might be redefined locally */
		  (!is_immutable(slot)))       /* (define-constant...) */
		{
		  /* (let () (define (f2 a) (+ a 1)) (define (f1 a) (f2 a)) (define (f2 a) (- a)) (f1 12))
		   * (let () (define (f2 a) (+ a 1)) (define (f1 a) (f2 a)) (define (f2 a) (- a 1)) (f1 12))
		   * and similar define* cases
		   */

		  hop = 0;
		  /* this is very tricky!  See s7test for some cases.  Basically, we need to protect a recursive call
		   *   of the current function being optimized from being confused with some previous definition
		   *   of the same name.  But method lists have global names so the global bit is off even though the
		   *   thing is actually a safe global.  But no closure can be considered safe in the hop sense --
		   *   even a global function might be redefined at any time, and previous uses of it in other functions
		   *   need to reflect its new value.
		   *   So, closures are always checked, but built-in functions are used as if never redefined until that redefinition.
		   * Syntax handling is already impure in s7, so the special handling of built-in functions doesn't
		   *   offend me much.  Consider each a sort of reader macro until someone redefines it -- previous
		   *   uses may not be affected because they might have been optimized away -- the result depends on the
		   *   current optimizer.
		   * Another case (from K Matheussen):
		   *   (define (call-func func arg1 arg2) (define (call) (func arg1 arg2)) (call)) (call-func + 1 2.5) (call-func - 5 2)
		   *   when we get here originally "func" is +, hop=1, but just checking for !is_global(car_expr) is
		   *   not good enough -- if we load mockery.scm, nothing is global!
		   * Yet another case (define (test-abs) (define (abs x) (+ x 1)) (format *stderr* "abs ~A~%" (abs -1)))
		   *   when optimize_syntax sees the (define abs ...), it inserts abs into e so that the caller's e is extended (set-cdr!)
		   *   so that find_uncomplicated_symbol above will be unhappy when we reach (abs -1) as the format arg.
		   *   This can be confused if lambda is redefined at some point, but...
		   */
		}
	      /* but if we make a recursive call on a func, we've obviously already looked up that function, and
	       *   if it has not been shadowed, then we don't need to check it -- so the hop bit should be on
	       *   for that one case.
	       */

	      for (p = cdr(expr); is_pair(p); p = cdr(p), args++) /* check the args (the calling expression) */
		{
		  s7_pointer car_p;
		  car_p = car(p);
		  if (is_normal_symbol(car_p)) /* for opt func */
		    symbols++;
		  else
		    {
		      if (is_pair(car_p))
			{
			  pairs++;
			  if (!is_checked(car_p))
			    {
			      opt_t res;
			      res = optimize_expression(sc, car_p, orig_hop, e, false);
			      if (res == OPT_F)
				{
				  bad_pairs++;
				  if (is_proper_quote(sc, car_p))
				    quotes++;
				}
			      else
				{
				  if (res == OPT_OOPS)
				    return(OPT_OOPS);
				}
			    }
			  else
			    {
			      if ((!is_optimized(car_p)) ||
				  (is_unsafe(car_p)))
				{
				  bad_pairs++;
				  if (is_proper_quote(sc, car_p))
				    quotes++;
				}}}}}
	      if (is_null(p))                    /* if not null, dotted list of args? */
		{
		  switch (args)
		    {
		    case 0:  return(optimize_thunk(sc, expr, func, hop, e));
		    case 1:  return(optimize_func_one_arg(sc, expr, func, hop, pairs, symbols, quotes, bad_pairs, e));
		    case 2:  return(optimize_func_two_args(sc, expr, func, hop, pairs, symbols, quotes, bad_pairs, e));
		    case 3:  return(optimize_func_three_args(sc, expr, func, hop, pairs, symbols, quotes, bad_pairs, e));
		    default: return(optimize_func_many_args(sc, expr, func, hop, args, pairs, symbols, quotes, bad_pairs, e));
		    }
		}
	      return(OPT_F);
	    }
	}
      else
	{
	  if ((sc->undefined_identifier_warnings) &&
	      (slot == sc->undefined) &&           /* car_expr is not in e or global */
	      (symbol_tag(car_expr) == 0))         /*    and we haven't looked it up earlier */
	    {
	      s7_pointer p;
	      p = sc->input_port;
	      if ((is_input_port(p)) &&
		  (port_file(p) != stdin) &&
		  (!port_is_closed(p)) &&
		  (port_filename(p)))
		s7_warn(sc, 1024, "%s might be undefined (%s %u)\n", DISPLAY(car_expr), port_filename(p), port_line_number(p));
	      else s7_warn(sc, 1024, "; %s might be undefined\n", DISPLAY(car_expr));
	      symbol_set_tag(car_expr, 1);             /* one warning is enough */
	    }
	}
#if OPTIMIZE_PRINT
      fprintf(stderr, "  at line %d for %s\n", __LINE__, DISPLAY(car_expr));
#endif
      /* car_expr is a symbol but it's not a built-in procedure or a "safe" case = vector etc */
      {
	/* else maybe it's something like a let variable binding: (sqrtfreq (sqrt frequency)) */
	s7_pointer p;
	int32_t len = 0, pairs = 0, symbols = 0;

	for (p = cdr(expr); is_pair(p); p = cdr(p), len++)
	  {
	    s7_pointer car_p;
	    car_p = car(p);
	    if (is_pair(car_p))
	      {
		pairs++;
		if ((!is_checked(car_p)) &&
		    (optimize_expression(sc, car_p, hop, e, false) == OPT_OOPS))
		  return(OPT_OOPS);
	      }
	    else
	      {
		if (is_symbol(car_p))
		  symbols++;
	      }
	  }

	if ((is_null(p)) &&              /* (+ 1 . 2) */
	    (!is_optimized(expr)))
	  {
	    /* len=0 case is almost entirely arglists */
	    set_opt1_con(expr, sc->unused);

	    if (pairs == 0)
	      {
		if (len == 0)
		  {
		    /* hoping to catch object application here, as in readers in Snd */
		    set_unsafe_optimize_op(expr, OP_UNKNOWN);
		    return(OPT_F);
		  }

		if (len == 1)
		  {
		    if (car_expr != sc->quote_symbol) /* !! quote can be redefined locally, unsetting the T_SYNTACTIC flag -- can this happen elsewhere? */
		      {
			set_unsafe_optimize_op(expr, OP_UNKNOWN_G);
			set_opt3_ctr(expr, 0);
		      }
		    return(OPT_F);
		  }

		if (len == 2)
		  {
		    set_unsafely_optimized(expr);
		    set_optimize_op(expr, OP_UNKNOWN_GG);
		    return(OPT_F);
		  }

		if ((len >= 3) &&
		    (len == symbols))
		  {
		    set_unsafe_optimize_op(expr, OP_UNKNOWN_ALL_S);
		    set_opt3_arglen(expr, make_permanent_integer(len));
		    return(OPT_F);
		  }
	      }
	    else /* pairs != 0 */
	      {
		s7_pointer arg1;
		arg1 = cadr(expr);
		if (pairs == 1)
		  {
		    if (len == 1)
		      {

			if ((car(expr) == sc->quote_symbol) &&
			    (direct_memq(sc->quote_symbol, e)))
			  return(OPT_OOPS);

			if (is_fx_safe(sc, arg1))
			  {
			    set_opt3_arglen(expr, small_int(1));
			    annotate_arg(sc, cdr(expr), e);
			    set_unsafe_optimize_op(expr, OP_UNKNOWN_A);
			    return(OPT_F);
			  }
		      }
		    else
		      {
			if (len == 2)
			  {
			    if ((is_fx_safe(sc, arg1)) &&
				(is_fx_safe(sc, caddr(expr))))
			      {
				set_opt3_arglen(expr, small_int(2));
				set_unsafe_optimize_op(expr, OP_UNKNOWN_AA);
				return(OPT_F);
			      }}}}

		if ((len == 2) &&
		    (is_fx_safe(sc, arg1)) &&
		    (is_fx_safe(sc, caddr(expr))))
		  {
		    set_opt3_arglen(expr, small_int(2));
		    set_unsafe_optimize_op(expr, OP_UNKNOWN_AA);
		    return(OPT_F);
		  }

		if ((fx_count(sc, expr) == len) &&
		    (len < GC_TRIGGER_SIZE))
		  {
		    if ((len == 1) &&
			(car(expr) == sc->quote_symbol) &&
			(direct_memq(sc->quote_symbol, e)))
		      return(OPT_OOPS);

		    set_unsafe_optimize_op(expr, (len == 1) ? OP_UNKNOWN_A : OP_UNKNOWN_FX);
		    set_opt3_arglen(expr, make_permanent_integer(len));
		    if (len == 1)
		      annotate_arg(sc, cdr(expr), e);
		    return(OPT_F);
		  }}}}
    }
  else
    {
      /* car(expr) is not a symbol, but there might be interesting stuff here */
      /* (define (hi a) (case 1 ((1) (if (> a 2) a 2)))) */
      s7_pointer p;

      for (p = expr; is_pair(p); p = cdr(p))
	{
	  if ((is_pair(car(p))) &&
	      (!is_checked(car(p))) &&
	      (optimize_expression(sc, car(p), hop, e, false) == OPT_OOPS))
	    return(OPT_OOPS);
	}

      if ((is_pair(cdr(expr))) &&
	  (is_null(cddr(expr))) &&
	  (is_pair(car_expr)) &&
	  (car(car_expr) == sc->if_symbol) &&
	  (is_pair(cdr(car_expr))) &&
	  (is_pair(cddr(car_expr))) &&
	  (is_symbol(caddr(car_expr))) &&
	  (is_pair(cdddr(car_expr))) &&
	  (is_symbol(cadddr(car_expr))) &&
	  ((!is_pair(cadr(car_expr))) || (is_fx_safe(sc, cadr(car_expr)))) &&
	  ((!is_pair(cadr(expr))) || (is_fx_safe(sc, cadr(expr)))))
	{
	  s7_pointer ptrue;
	  ptrue = find_uncomplicated_symbol(sc, caddr(car_expr), e);
	  if (is_slot(ptrue))
	    {
	      ptrue = slot_value(ptrue);
	      if ((is_c_function(ptrue)) &&
		  (is_safe_procedure(ptrue)))
		{
		  s7_pointer pfalse;
		  pfalse = find_uncomplicated_symbol(sc, cadddr(car_expr), e);
		  if (is_slot(pfalse))
		    {
		      pfalse = slot_value(pfalse);
		      if ((is_c_function(pfalse)) &&
			  (is_safe_procedure(pfalse)))
			{
			  set_opt1_con(expr, ptrue);
			  set_opt2_con(expr, pfalse);
			  set_safe_optimize_op(expr, hop + OP_SAFE_IFA_SS_A);
			  annotate_arg(sc, cdr(car_expr), e);
			  annotate_arg(sc, cdr(expr), e);
			  return(OPT_T);
			}}}}}
    }
  return(OPT_F);
}

static opt_t optimize(s7_scheme *sc, s7_pointer code, int32_t hop, s7_pointer e)
{
  s7_pointer x;
#if OPTIMIZE_PRINT
  fprintf(stderr, "optimize: %s %s\n", DISPLAY_80(code), DISPLAY(e));
#endif
  for (x = code; (is_pair(x)) && (!is_checked(x)); x = cdr(x))
    {
      set_checked(x);
      if ((is_pair(car(x))) &&
	  (!is_checked(car(x))))
	{
	  if (optimize_expression(sc, car(x), hop, e, true) == OPT_OOPS)
	    {
	      s7_pointer p;
	      for (p = cdr(x); is_pair(p); p = cdr(p));
	      if (!is_null(p))
		eval_error_no_return(sc, sc->syntax_error_symbol, "stray dot in function body: ~S", 30, code);
	      return(OPT_OOPS);
	    }
	}
    }
  handle_optimizer_fixups(sc);
  if (!is_list(x))
    eval_error_no_return(sc, sc->syntax_error_symbol, "stray dot in function body: ~S", 30, code);
  return(OPT_F);
}


/* ---------------------------------------- error checks ---------------------------------------- */

enum {goto_START, goto_BEGIN, fall_through, goto_DO_END_CLAUSES, goto_SAFE_DO_END_CLAUSES, goto_EVAL, goto_TOP_NO_POP, goto_APPLY, goto_EVAL_ARGS, goto_DO_UNCHECKED};

static s7_pointer check_lambda_args(s7_scheme *sc, s7_pointer args, int32_t *arity)
{
  s7_pointer x;
  int32_t i;

  if (!is_list(args))
    {
      if (is_constant(sc, args))                       /* (lambda :a ...) */
	eval_error(sc, "lambda parameter '~S is a constant", 34, args); /* not ~A here, (lambda #\null do) for example */

      /* we currently accept (lambda i i . i) (lambda quote i)  (lambda : : . #()) (lambda : 1 . "")
       *   at this level, but when the lambda form is evaluated, it will trigger an error.
       */
      if (is_symbol(args))
	set_local(args);

      if (arity) (*arity) = -1;
      return(sc->F);
    }

  for (i = 0, x = args; is_pair(x); i++, x = cdr(x))
    {
      s7_pointer car_x;
      car_x = car(x);
      if (is_constant(sc, car_x))                      /* (lambda (pi) pi), constant here means not a symbol */
	{
	  if (is_pair(car_x))                          /* (lambda ((:hi . "hi") . "hi") 1) */
	    eval_error(sc, "lambda parameter '~S is a pair (perhaps you want define* or lambda*?)", 69, car_x);
	  eval_error(sc, "lambda parameter '~S is a constant", 34, car_x);
	}
      if (symbol_is_in_arg_list(car_x, cdr(x)))       /* (lambda (a a) ...) or (lambda (a . a) ...) */
	eval_error(sc, "lambda parameter '~S is used twice in the parameter list", 56, car_x);
      set_local(car_x);
    }
  if (is_not_null(x))
    {
      if (is_constant(sc, x))                         /* (lambda (a . 0.0) a) or (lambda (a . :b) a) */
	eval_error(sc, "lambda :rest parameter '~S is a constant", 40, x);
      i = -i - 1;
    }

  if (arity) (*arity) = i;
  return(sc->F);
}

static s7_pointer check_lambda_star_args(s7_scheme *sc, s7_pointer args, int32_t *arity)
{
  s7_pointer top, v, w;
  int32_t i;

  if (!is_list(args))
    {
      if (is_constant(sc, args))                                  /* (lambda* :a ...) */
	eval_error(sc, "lambda* parameter '~S is a constant", 35, args);
      if (is_symbol(args))
	set_local(args);
      if (arity) (*arity) = -1;
      return(args);
    }

  top = args;
  v = args;
  for (i = 0, w = args; is_pair(w); i++, v = w, w = cdr(w))
    {
      s7_pointer car_w;
      car_w = car(w);
      if (is_pair(car_w))
	{
	  if (is_constant(sc, car(car_w)))                            /* (lambda* ((:a 1)) ...) */
	    eval_error(sc, "lambda* parameter '~A is a constant", 35, car(car_w));
	  if (symbol_is_in_arg_list(caar(w), cdr(w)))             /* (lambda* ((a 1) a) ...) */
	    eval_error(sc, "lambda* parameter '~A is used twice in the argument list", 56, car(car_w));

	  if (!is_pair(cdr(car_w)))                                  /* (lambda* ((a . 0.0)) a) */
	    {
	      if (is_null(cdr(car_w)))                               /* (lambda* ((a)) ...) */
		eval_error(sc, "lambda* parameter default value missing? '~A", 44, car_w);
	      eval_error(sc, "lambda* parameter is a dotted pair? '~A",39,  car_w);
	    }
	  else
	    {
	      if ((is_pair(cadr(car_w))) &&                          /* (lambda* ((a (quote . -1))) ...) */
		  (s7_list_length(sc, cadr(car_w)) < 0))
		eval_error(sc, "lambda* parameter default value is improper? ~A", 47, car_w);
	    }

	  if (is_not_null(cddr(car_w)))                              /* (lambda* ((a 0.0 'hi)) a) */
	    eval_error(sc, "lambda* parameter has multiple default values? '~A", 50, car_w);

	  set_local(car(car_w));
	}
      else
	{
	  if (car_w != sc->key_rest_symbol)
	    {
	      if (is_constant(sc, car_w))
		{
		  if (car_w == sc->key_allow_other_keys_symbol)
		    {
		      if (is_not_null(cdr(w)))                /* (lambda* (:allow-other-keys x) x) */
			eval_error(sc, ":allow-other-keys should be the last parameter: ~A", 50, args);
		      if (w == top)
			eval_error(sc, ":allow-other-keys can't be the only parameter: ~A", 49, args);
		      set_allow_other_keys(top);
		      set_cdr(v, sc->nil);
		    }
		  else                                        /* (lambda* (pi) ...) */
		    eval_error(sc, "lambda* parameter '~A is a constant", 35, car_w);
		}
	      if (symbol_is_in_arg_list(car_w, cdr(w)))       /* (lambda* (a a) ...) or (lambda* (a . a) ...) */
		eval_error(sc, "lambda* parameter '~A is used twice in the argument list", 56, car_w);

	      if (!is_keyword(car_w)) set_local(car_w);
	    }
	  else
	    {
	      if (!is_pair(cdr(w)))                               /* (lambda* (:rest) ...) */
		eval_error(sc, "lambda* :rest parameter missing? ~A", 35, w);
	      if (!is_symbol(cadr(w)))                         /* (lambda* (:rest (a 1)) ...) */
		{
		  if (!is_pair(cadr(w)))                          /* (lambda* (:rest 1) ...) */
		    eval_error(sc, "lambda* :rest parameter is not a symbol? ~A", 43, w);
		  eval_error(sc, "lambda* :rest parameter can't have a default value. ~A", 54, w);
		}
	      else
		{
		  if (is_constant(sc, cadr(w)))                   /* (lambda* (a :rest x)...) where x is locally a constant */
		    return(s7_error(sc, sc->wrong_type_arg_symbol,
				    set_elist_2(sc, wrap_string(sc, "can't bind an immutable object: ~S", 34), w)));
		}
	      set_local(cadr(w));
	    }
	}
    }
  if (is_not_null(w))
    {
      if (is_constant(sc, w))                             /* (lambda* (a . 0.0) a) or (lambda* (a . :b) a) */
	eval_error(sc, "lambda* :rest parameter '~A is a constant", 41, w);
      if (is_symbol(w))
	set_local(w);
      i = -1;
    }
  if (arity) (*arity) = i;
  return(top);
}

typedef enum {UNSAFE_BODY=0, SAFE_BODY=1, VERY_SAFE_BODY=2} body_t;
static body_t min_body(body_t b1, body_t b2) {return((b1 < b2) ? b1 : b2);}

static body_t body_is_safe(s7_scheme *sc, s7_pointer func, s7_pointer body, bool at_end);

static body_t form_is_safe(s7_scheme *sc, s7_pointer func, s7_pointer x, bool at_end)
{
  s7_pointer expr;
  body_t result = VERY_SAFE_BODY;
#if S7_DEBUGGING
  if (!is_pair(x)) {fprintf(stderr, "form_is_safe x is not a pair! %s\n", DISPLAY(x)); abort();}
#endif
  expr = car(x);
  if (is_syntactic_symbol(expr))
    {
      if (!is_pair(cdr(x))) return(UNSAFE_BODY);
      /* lambda_unchecked, if_d_p_p define_funchecked */
      switch (symbol_syntax_op_checked(x))
	{
	case OP_OR:
	case OP_AND:
	case OP_BEGIN:
	case OP_WITH_BAFFLE:
	  return(body_is_safe(sc, func, cdr(x), at_end));

	case OP_MACROEXPAND:
	  return(UNSAFE_BODY);

	case OP_QUOTE:
	  if ((!is_pair(cdr(x))) || (!is_null(cddr(x))))  /* (quote . 1) or (quote 1 2) etc */
	    return(UNSAFE_BODY);
	  return(VERY_SAFE_BODY);

	case OP_IF:
	  if (!is_pair(cddr(x))) return(UNSAFE_BODY);
	  if (is_pair(cadr(x)))
	    {
	      result = form_is_safe(sc, func, cadr(x), false);
	      if (result == UNSAFE_BODY)
		return(UNSAFE_BODY);
	    }
	  if (is_pair(caddr(x)))
	    {
	      result = min_body(result, form_is_safe(sc, func, caddr(x), at_end));
	      if (result == UNSAFE_BODY)
		return(UNSAFE_BODY);
	    }
	  if ((is_pair(cdddr(x))) &&
	      (is_pair(cadddr(x))))
	    return(min_body(result, form_is_safe(sc, func, cadddr(x), at_end)));
	  return(result);

	case OP_WHEN:
	case OP_UNLESS:
	  if (!is_pair(cddr(x))) return(UNSAFE_BODY);
	  if (is_pair(cadr(x)))
	    {
	      result = form_is_safe(sc, func, cadr(x), false);
	      if (result == UNSAFE_BODY)
		return(UNSAFE_BODY);
	    }
	  return(min_body(result, body_is_safe(sc, func, cddr(x), at_end)));

	case OP_COND:
	  {
	    bool follow = false;
	    s7_pointer sp, p;
	    for (p = cdr(x), sp = x; is_pair(p); p = cdr(p))
	      {
		s7_pointer ex;
		ex = car(p);
		if (!is_pair(ex))
		  return(UNSAFE_BODY);
		if (is_pair(car(ex)))
		  {
		    result = min_body(result, form_is_safe(sc, func, car(ex), false));
		    if (result == UNSAFE_BODY)
		      return(UNSAFE_BODY);
		  }
		if (is_pair(cdr(ex)))
		  {
		    result = min_body(result, body_is_safe(sc, func, cdr(ex), at_end));
		    if (result == UNSAFE_BODY)
		      return(UNSAFE_BODY);
		  }
		if (follow) {sp = cdr(sp); if (p == sp) return(UNSAFE_BODY);}
		follow = (!follow);
	      }
	    if (is_not_null(p))
	      return(UNSAFE_BODY);
	    return(result);
	  }

	case OP_CASE:
	  {
	    bool follow = false;
	    s7_pointer sp, p;
	    if (!is_pair(cddr(x))) return(UNSAFE_BODY);
	    if (is_pair(cadr(x)))
	      {
		result = form_is_safe(sc, func, cadr(x), false);
		if (result == UNSAFE_BODY)
		  return(UNSAFE_BODY);
	      }
	    sp = cdr(x);
	    p = cdr(sp);
	    for (; is_pair(p); p = cdr(p))
	      {
		if (!is_pair(car(p))) return(UNSAFE_BODY);
		if (is_pair(cdar(p)))
		  {
		    result = min_body(result, body_is_safe(sc, func, cdar(p), at_end)); /* null cdar(p) ok here */
		    if (result == UNSAFE_BODY)
		      return(UNSAFE_BODY);
		  }
		if (follow) {sp = cdr(sp); if (p == sp) return(UNSAFE_BODY);}
		follow = (!follow);
	      }
	    return(result);
	  }

	case OP_SET:
	  /* if we set func, we have to make sure we abandon the tail call scan:
	   * (let () (define (hi a) (let ((v (vector 1 2 3))) (set! hi v) (hi a))) (hi 1))
	   */
	  if (!is_pair(cddr(x))) return(UNSAFE_BODY);
	  if (cadr(x) == func)
	    return(UNSAFE_BODY);

	  /* car(x) is set!, cadr(x) is settee or obj, caddr(x) is val */
	  if (is_pair(caddr(x)))
	    {
	      result = form_is_safe(sc, func, caddr(x), false);
	      if (result == UNSAFE_BODY)
		return(UNSAFE_BODY);
	    }
	  if (is_pair(cadr(x)))
	    return(min_body(result, form_is_safe(sc, func, cadr(x), false)));
	  return(result);

	  /* not OP_DEFINE even in simple cases (safe_closure assumes constant funclet) */

	case OP_WITH_LET:
	  if (!is_pair(cddr(x))) return(UNSAFE_BODY);
	  if (is_pair(cadr(x))) return(UNSAFE_BODY);
	  return(min_body(body_is_safe(sc, sc->F, cddr(x), at_end), SAFE_BODY));
	  /* shadowing can happen in with-let -- symbols are global so local_slots are shadowable */

	case OP_LET_TEMPORARILY:
	  {
	    s7_pointer p;
	    if (!is_pair(cadr(x))) return(UNSAFE_BODY);
	    for (p = cadr(x); is_pair(p); p = cdr(p))
	      {
		if ((!is_pair(car(p))) ||
		    (!is_pair(cdar(p))))
		  return(UNSAFE_BODY);
		if (is_pair(cadar(p)))
		  {
		    result = min_body(result, form_is_safe(sc, sc->F, cadar(p), false));
		    if (result == UNSAFE_BODY)
		      return(UNSAFE_BODY);
		  }
	      }
	    return(min_body(result, body_is_safe(sc, sc->F, cddr(x), at_end)));
	  }

	  /* in the name binders, we first have to check that "func" actually is the same thing as the caller's func */
	case OP_LET:
	case OP_LET_STAR:
	case OP_LETREC:
	case OP_LETREC_STAR:
	  {
	    bool follow = false;
	    s7_pointer vars, body, let_name, sp;

	    vars = cadr(x);
	    body = cddr(x);
	    if (is_symbol(vars))
	      {
		if (!is_pair(body))
		  return(UNSAFE_BODY);        /* (let name . res) */
		if (vars == func)             /* named let shadows caller */
		  return(UNSAFE_BODY);
		let_name = vars;
		vars = caddr(x);
		body = cdddr(x);
	      }
	    else let_name = func;

	    for (sp = NULL; is_pair(vars); vars = cdr(vars))
	      {
		s7_pointer let_var, var_name;

		let_var = car(vars);
		if ((!is_pair(let_var)) ||
		    (!is_pair(cdr(let_var))))
		  return(UNSAFE_BODY);
		var_name = car(let_var);
		if ((!is_symbol(var_name)) ||
		    (var_name == let_name) || /* let var shadows caller */
		    (var_name == func))
		  return(UNSAFE_BODY);

		add_symbol_to_list(sc, var_name);

		if (is_pair(cadr(let_var)))
		  {
		    result = min_body(result, form_is_safe(sc, let_name, cadr(let_var), false));
		    if (result == UNSAFE_BODY)
		      return(UNSAFE_BODY);
		  }
		follow = (!follow);
		if (follow)
		  {
		    if (!sp)
		      sp = vars;
		    else
		      {
			sp = cdr(sp);
			if (vars == sp) return(UNSAFE_BODY);
		      }
		  }
	      }
	    return(min_body(result, body_is_safe(sc, let_name, body, at_end)));
	  }

	case OP_DO:	  /* (do (...) (...) ...) */
	  {
	    if (!is_pair(cddr(x))) return(UNSAFE_BODY);
	    if (is_pair(cadr(x)))
	      {
		bool follow = false;
		s7_pointer vars, sp;
		vars = cadr(x);
		sp = vars;
		for (; is_pair(vars); vars = cdr(vars))
		  {
		    s7_pointer do_var;
		    do_var = car(vars);
		    if ((!is_pair(do_var)) ||
			(!is_pair(cdr(do_var))) ||   /* (do ((a . 1) (b . 2)) ...) */
			(car(do_var) == func) ||
			(!is_symbol(car(do_var))))
		      return(UNSAFE_BODY);

		    add_symbol_to_list(sc, car(do_var));

		    if (is_pair(cadr(do_var)))
		      result = min_body(result, form_is_safe(sc, func, cadr(do_var), false));
		    if ((is_pair(cddr(do_var))) &&
			(is_pair(caddr(do_var))))
		      result = min_body(result, form_is_safe(sc, func, caddr(do_var), false));
		    if (result == UNSAFE_BODY)
		      return(UNSAFE_BODY);
		    if (sp != vars)
		      {
			if (follow) {sp = cdr(sp); if (vars == sp) return(UNSAFE_BODY);}
			follow = (!follow);
		      }
		  }
	      }
	    if (is_pair(caddr(x)))
	      result = min_body(result, body_is_safe(sc, func, caddr(x), at_end));
	    return(min_body(result, body_is_safe(sc, func, cdddr(x), false)));
	  }

	  /* define and friends are not safe: (define (a) (define b 3)...) tries to put b in the current env,
	   *   but in a safe func, that's a constant.  See s7test L 1865 for an example.
	   */
	default:
	  /* try to catch weird cases like:
	   * (let () (define (hi1 a) (define (hi1 b) (+ b 1)) (hi1 a)) (hi1 1))
	   * (let () (define (hi1 a) (define (ho1 b) b) (define (hi1 b) (+ b 1)) (hi1 a)) (hi1 1))
	   */
	  return(UNSAFE_BODY);
	}
    }
  else /* car(x) is not syntactic ?? */
    {
      if (expr == func) /* try to catch tail call, expr is car(x) */
	{
	  bool follow = false;
	  s7_pointer sp, p;
	  p = cdr(x);
	  sp = x;
	  for (; is_pair(p); p = cdr(p))
	    {
	      if (is_pair(car(p)))
		{
		  if (caar(p) == func)    /* func called as arg, so not tail call */
		    return(UNSAFE_BODY);
		  result = min_body(result, form_is_safe(sc, func, car(p), false));
		  if (result == UNSAFE_BODY)
		    return(UNSAFE_BODY);
		}
	      else
		{
		  if (car(p) == func)
		    return(UNSAFE_BODY);
		}
	      if (follow) {sp = cdr(sp); if (p == sp) return(UNSAFE_BODY);}
	      follow = (!follow);
	    }
	  if ((at_end) && (is_null(p))) /* tail call, so safe */
	    return(result);
          return(UNSAFE_BODY);
	}

      if (is_symbol(expr)) /* expr=car(x) */
	{
	  s7_pointer f, f_slot;
	  bool c_safe;

	  if (symbol_is_in_list(sc, expr))
	    return(UNSAFE_BODY);

	  f_slot = symbol_to_slot(sc, expr);
	  if (!is_slot(f_slot))
	    return(UNSAFE_BODY);
	  f = slot_value(f_slot);
	  c_safe = (is_c_function(f)) && (is_safe_or_scope_safe_procedure(f));
	  result = ((is_sequence(f)) ||
		    ((is_closure(f)) && (is_very_safe_closure(f))) ||
		    ((c_safe) && ((is_immutable(f_slot)) || (is_global(expr))))) ? VERY_SAFE_BODY : SAFE_BODY;

	  if ((c_safe) ||
	      ((is_any_closure(f)) && (is_safe_closure(f))) ||
	      (is_sequence(f)))
	    {
	      bool follow = false;
	      s7_pointer sp, p;
	      p = cdr(x);
	      sp = x;
	      for (; is_pair(p); p = cdr(p))
		{
		  if (is_unquoted_pair(car(p)))
		    {
		      if (caar(p) == func)
			return(UNSAFE_BODY);
		      if ((is_c_function(f)) && (is_scope_safe(f)) &&
			  (caar(p) == sc->lambda_symbol))
			{
			  s7_pointer largs, lbody, q;
			  body_t lresult;

			  if (!is_pair(cdar(p))) /* (lambda . /) */
			    return(UNSAFE_BODY);
			  largs = cadar(p);
			  lbody = cddar(p);
			  for (q = largs; is_pair(q); q = cdr(q))
			    {
			      if (!is_symbol(car(q)))
				return(UNSAFE_BODY);
			      add_symbol_to_list(sc, car(q));
			    }
			  lresult = body_is_safe(sc, func, lbody, false);
			  result = min_body(result, lresult);
			}
		      else result = min_body(result, form_is_safe(sc, func, car(p), false));
		      if (result == UNSAFE_BODY)
			return(UNSAFE_BODY);
		    }
		  else
		    {
		      if (car(p) == func)          /* the current function passed as an argument to something */
			return(UNSAFE_BODY);
		    }
		  if (follow) {sp = cdr(sp); if (p == sp) return(UNSAFE_BODY);}
		  follow = (!follow);
		}
	      if (!is_null(p))
		return(UNSAFE_BODY);
	      return(result);
	    }
	}
      return(UNSAFE_BODY);
    }
  return(result);
}

static body_t body_is_safe(s7_scheme *sc, s7_pointer func, s7_pointer body, bool at_end)
{
  bool follow = false;
  s7_pointer p, sp;
  body_t result = VERY_SAFE_BODY;
  for (p = body, sp = body; is_pair(p); p = cdr(p))
    {
      if (is_pair(car(p)))
	{
	  result = min_body(result, form_is_safe(sc, func, car(p), (at_end) && (is_null(cdr(p)))));
	  if (result == UNSAFE_BODY) return(UNSAFE_BODY);
	}
      if (p != body)
	{
	  if (follow) {sp = cdr(sp); if (p == sp) return(UNSAFE_BODY);}
	  follow = (!follow);
	}
    }
  if (!is_null(p))
    return(UNSAFE_BODY);
  return(result);
}

static inline bool tree_has_definers(s7_scheme *sc, s7_pointer tree)
{
  s7_pointer p;
  for (p = tree; is_pair(p); p = cdr(p))
    if (tree_has_definers(sc, car(p)))
      return(true);
  return((is_symbol(tree)) &&
	 (is_definer(tree)));
}

static bool tree_has_definers_or_binders(s7_scheme *sc, s7_pointer tree)
{
  s7_pointer p;
  for (p = tree; is_pair(p); p = cdr(p))
    if (tree_has_definers_or_binders(sc, car(p)))
      return(true);
  return((is_symbol(tree)) &&
	 (is_definer_or_binder(tree)));
}

static void fx_tree(s7_scheme *sc, s7_pointer tree, s7_pointer stepper, s7_pointer previous_stepper) /* previous_stepper can be NULL */
{
  s7_pointer p;
  /* fprintf(stderr, "fx_tree %d %s %s: %s\n", has_fx(tree), DISPLAY(stepper), (previous_stepper) ? DISPLAY(previous_stepper) : "", DISPLAY(tree)); */
  
  p = car(tree);

  if ((has_fx(tree)) && (is_pair(p)) && (is_pair(cdr(p)))) /* confusion between c|d_call I think */
    {
      if ((c_callee(tree) == fx_c_sc) && (cadr(p) == stepper)) {set_c_call(tree, fx_c_tc); return;}
      if ((c_callee(tree) == fx_cdr_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_cdr_t); return;}
      if ((c_callee(tree) == fx_cdr_s) && (cadr(p) == previous_stepper)) {set_c_call(tree, fx_cdr_u); return;}
      if ((c_callee(tree) == fx_car_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_car_t); return;}
#if (!WITH_GMP)
      if ((c_callee(tree) == fx_geq_ss) && (cadr(p) == stepper) && (is_pair(cddr(p))))
	{
	  if (caddr(p) == previous_stepper) 
	    set_c_call(tree, fx_geq_tu); 
	  else set_c_call(tree, fx_geq_ts);
	  return;
	}
      if (c_callee(tree) == fx_equal_ss)
	{
	  if (cadr(p) == stepper)
	    {
	      if (caddr(p) == previous_stepper) {set_c_call(tree, fx_equal_tu); return;}
	      set_c_call(tree, fx_equal_ts); 
	      return;
	    }
	  if (cadr(p) == previous_stepper) {set_c_call(tree, fx_equal_us); return;}
	}
      if (c_callee(tree) == fx_c_equal_s_ic)
	{
	  if (cadr(p) == stepper) {set_c_call(tree, fx_c_equal_t_ic); return;}
	  if (cadr(p) == previous_stepper) {set_c_call(tree, fx_c_equal_u_ic); return;}
	}
      if ((c_callee(tree) == fx_c_d) && (is_pair(p)) && (is_pair(cdr(p))))
	{
	  if (c_callee(p) == g_equal_s_ic)
	    {
	      if (cadr(p) == stepper) {set_c_call(tree, fx_c_equal_t_ic); return;}
	      if (cadr(p) == previous_stepper) {set_c_call(tree, fx_c_equal_u_ic); return;}
	    }
	  if ((c_callee(p) == g_add_sf) && (cadr(p) == stepper)) {set_c_call(tree, fx_c_add_tf); return;}
	}
#endif
      if ((c_callee(tree) == fx_c_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_c_t); return;}
      if ((c_callee(tree) == fx_not_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_not_t); return;}
      if ((c_callee(tree) == fx_is_null_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_is_null_t); return;}
      if ((c_callee(tree) == fx_is_pair_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_is_pair_t); return;}
      if ((c_callee(tree) == fx_is_symbol_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_is_symbol_t); return;}
      if ((c_callee(tree) == fx_is_type_s) && (cadr(p) == stepper)) {set_c_call(tree, fx_is_type_t); return;}
      if ((c_callee(tree) == fx_is_eq_ss) && (cadr(p) == stepper)) {set_c_call(tree, fx_is_eq_ts); return;}
      if ((c_callee(tree) == fx_is_pair_cdr_s) && (cadadr(p) == stepper)) {set_c_call(tree, fx_is_pair_cdr_t); return;}
      if ((c_callee(tree) == fx_not_is_pair_s) && (cadadr(p) == stepper)) {set_c_call(tree, fx_not_is_pair_t); return;}

      if (c_callee(tree) == fx_add_ss)
	{
	  if (cadr(p) == stepper) {set_c_call(tree, fx_add_ts); return;}
	  if (cadr(p) == previous_stepper) {set_c_call(tree, fx_add_us); return;}
	}
      if ((c_callee(tree) == fx_c_add_si) && (cadr(p) == stepper)) {set_c_call(tree, fx_c_add_ti); return;}
      if (c_callee(tree) == fx_c_add_s1)
	{
	  if (cadr(p) == stepper) {set_c_call(tree, fx_c_add_t1); return;}
	  if (cadr(p) == previous_stepper) {set_c_call(tree, fx_c_add_u1); return;}
	}
      if ((c_callee(tree) == fx_c_sub_s1) && (cadr(p) == stepper)) {set_c_call(tree, fx_c_sub_t1); return;}

      if (is_pair(cddr(p)))
	{
	  if ((c_callee(tree) == fx_c_cs) && (caddr(p) == stepper)) {set_c_call(tree, fx_c_ct); return;}
	  if (c_callee(tree) == fx_c_ss)
	    {
	      if (cadr(p) == stepper) {set_c_call(tree, fx_c_ts); return;}
	      if (caddr(p) == stepper) {set_c_call(tree, fx_c_st); return;}
	    }
	}
      if ((c_callee(tree) == fx_c_opssq) && (caddr(cadr(p)) == stepper))
	{
	  if ((s7_p_p_function(slot_value(global_slot(car(p))))) &&
	      (s7_p_pp_function(slot_value(global_slot(caadr(p))))))
	    {
	      set_direct_x_opt(p);
	      set_opt2_direct_x_call(cdr(p), (s7_pointer)(s7_p_p_function(slot_value(global_slot(car(p))))));
	      set_opt3_direct_x(cdr(p), (s7_pointer)(s7_p_pp_function(slot_value(global_slot(caadr(p))))));
	      set_c_call(tree, fx_c_opstq_direct);
	    }
	  else set_c_call(tree, fx_c_opstq);
	  return;
	}
      if (((c_callee(tree) == fx_c_opsq_c) || (c_callee(tree) == fx_c_optq_c)) && (cadadr(p) == stepper))
	{
	  if (c_callee(car(tree)) == g_lint_let_ref) 
	    set_c_call(tree, fx_c_lint_let_ref);
	  else set_c_call(tree, fx_c_optq_c);
	  return;
	}
    }
  if ((is_pair(p)) && (is_pair(cdr(p))))
    {
      if (is_pair(cadr(p)))
	fx_tree(sc, cdr(p), stepper, previous_stepper);
      if ((is_pair(cddr(p))) && (is_pair(caddr(p))))
	fx_tree(sc, cddr(p), stepper, previous_stepper);
    }
}

static void optimize_lambda(s7_scheme *sc, bool unstarred_lambda, s7_pointer func, s7_pointer args, s7_pointer body)
{
  s7_int len;
#if OPTIMIZE_PRINT
  fprintf(stderr, "%s[%d]: %s %s\n", __func__, __LINE__, DISPLAY(func), DISPLAY(args));
#endif
  len = s7_list_length(sc, body);
  if (len < 0)                /* (define (hi) 1 . 2) */
    s7_error(sc, sc->syntax_error_symbol,
	     set_elist_3(sc, wrap_string(sc, "~A: function body messed up, ~A", 31),
			 (unstarred_lambda) ? sc->lambda_symbol : sc->lambda_star_symbol,
			 sc->code));

  if (len > 0)  /* i.e. not circular */
    {
      body_t result;
      s7_pointer p, lst;

      clear_symbol_list(sc);
      for (p = args; is_pair(p); p = cdr(p))
	add_symbol_to_list(sc, (is_symbol(car(p))) ? car(p) : caar(p));
      if (!is_null(p))
	add_symbol_to_list(sc, p);
      result = body_is_safe(sc, func, body, true);
      clear_symbol_list(sc);

      /* if the body is safe, we can optimize the calling sequence */
      if (!unstarred_lambda)
	{
	  bool happy = true;
	  /* check default vals -- if none is an expression or symbol, set simple args */
	  for (p = args; is_pair(p); p = cdr(p))
	    {
	      s7_pointer arg;
	      arg = car(p);
	      if ((is_pair(arg)) &&                   /* has default value */
		  (is_pair(cdr(arg))) &&              /*   is not a ridiculous improper list */
		  ((is_symbol(cadr(arg))) ||          /*   if default value might involve eval in any way, it isn't simple */
		   (is_unquoted_pair(cadr(arg)))))    /*   pair as default only ok if it is (quote ...) */
		{
		  happy = false;
		  break;
		}
	    }
	  if (happy)
	    lambda_set_simple_defaults(body);
	}
      if (result > UNSAFE_BODY)
	{
	  set_safe_closure_body(body);	  /* this bit is set on the function itself in make_closure and friends */
	  if (result == VERY_SAFE_BODY)
	    set_very_safe_closure_body(body);
	}

      if (is_symbol(func))
	{
	  lst = cons(sc, add_symbol_to_list(sc, func), sc->nil);
	  sc->temp10 = lst;
	}
      else lst = sc->nil;
      if (optimize(sc, body, 1, collect_parameters(sc, args, lst)) == OPT_OOPS)
	clear_all_optimizations(sc, body);
      else
	{
	  if ((is_pair(args)) &&
	      (is_null(cdr(args))) &&
	      (is_very_safe_closure_body(body)) &&
	      (!tree_has_definers_or_binders(sc, body)))
	    fx_tree(sc, body, car(args), NULL);
	}
      if (is_symbol(func))
	{
	  sc->temp10 = sc->nil;
	  free_cell(sc, lst);
	}
    }
}

static void check_lambda(s7_scheme *sc)
{
  /* code is a lambda form minus the "lambda": ((a b) (+ a b)) */
  /* this includes unevaluated symbols (direct symbol table refs) in macro arg list */
  s7_pointer code, body, form;

  /* fprintf(stderr, "check_lambda %s\n", DISPLAY(sc->code)); */

  form = sc->code;
  if ((sc->safety > NO_SAFETY) &&
      (tree_is_cyclic(sc, form)))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "lambda: body is cyclic", 22));

  sc->code = cdr(sc->code);
  code = sc->code;
  if (!is_pair(code))                                 /* (lambda) or (lambda . 1) */
    eval_error_no_return(sc, sc->syntax_error_symbol, "lambda: no args? ~A", 19, form);

  body = cdr(code);
  if (!is_pair(body))                                 /* (lambda #f) */
    eval_error_no_return(sc, sc->syntax_error_symbol, "lambda: no body? ~A", 19, form);

  /* in many cases, this is a no-op -- we already checked at define */
  check_lambda_args(sc, car(code), NULL);
  clear_symbol_list(sc);

  /* look for (define f (let (...) (lambda ...))) and treat as equivalent to (define (f ...)...)
   *   one problem the hop=0 fixes is that safe closures assume the old frame exists, so we need to check for define below
   *   I wonder about apply define...
   */
  if ((main_stack_op(sc) == OP_DEFINE1) ||
      (((sc->stack_end - sc->stack_start) > 4) &&
       (((opcode_t)(sc->stack_end[-5])) == OP_DEFINE1) &&  /* surely if define is ok, so is define dilambda? 16-Apr-16 */
       (sc->op_stack_now > sc->op_stack) &&
       ((*(sc->op_stack_now - 1)) == (s7_pointer)slot_value(global_slot(sc->dilambda_symbol)))))
    optimize_lambda(sc, true, sc->unused, car(code), body); /* why was lambda the func? */
  else
    {
      if (optimize(sc, body, 0,
		   /* ((sc->op_stack_now > sc->op_stack) && (is_c_function((*(sc->op_stack_now - 1)))) && (is_scope_safe((*(sc->op_stack_now - 1))))) ? 1 : 0, */
		   /* this works except when someone resets outlet(curlet) after defining a local function! */
		   collect_parameters(sc, car(sc->code), sc->nil)) == OPT_OOPS)
	clear_all_optimizations(sc, body);
    }
  pair_set_syntax_op(form, OP_LAMBDA_UNCHECKED);
}

static void check_lambda_star(s7_scheme *sc)
{
  s7_pointer form;
  form = sc->code;
  if ((sc->safety > NO_SAFETY) &&
      (tree_is_cyclic(sc, form)))
    s7_error(sc, sc->wrong_type_arg_symbol, wrap_string(sc, "lambda*: body is cyclic", 23));

  sc->code = cdr(sc->code);
  if ((!is_pair(sc->code)) ||
      (!is_pair(cdr(sc->code))))                                          /* (lambda*) or (lambda* #f) */
    eval_error_no_return(sc, sc->syntax_error_symbol, "lambda*: no args or no body? ~A", 31, form);

  set_car(sc->code, check_lambda_star_args(sc, car(sc->code), NULL));
  clear_symbol_list(sc);

  if ((sc->safety > NO_SAFETY) ||
      (main_stack_op(sc) != OP_DEFINE1))
    {
      if (optimize(sc, cdr(sc->code), 0, collect_parameters(sc, car(sc->code), sc->nil)) == OPT_OOPS)
	clear_all_optimizations(sc, cdr(sc->code));
    }
  else optimize_lambda(sc, false, sc->unused, car(sc->code), cdr(sc->code));

  pair_set_syntax_op(form, OP_LAMBDA_STAR_UNCHECKED);
}


/* -------------------------------- case -------------------------------- */
static s7_pointer check_case(s7_scheme *sc)
{
  /* we're not checking repeated or ridiculous (non-eqv?) keys here because they aren't errors */
  bool keys_simple = true, has_feed_to = false, keys_single = true, bodies_simple = true, has_else = false;
  int32_t key_type = T_FREE;
  s7_pointer x, form, carc;

  form = sc->code;
  sc->code = cdr(sc->code);

  if (!is_pair(sc->code))                                            /* (case) or (case . 1) */
    eval_error(sc, "case has no selector:  ~A", 25, form);
  if (!is_pair(cdr(sc->code)))                                       /* (case 1) or (case 1 . 1) */
    eval_error(sc, "case has no clauses?:  ~A", 25, form);
  if (!is_pair(cadr(sc->code)))                                      /* (case 1 1) */
    eval_error(sc, "case clause is not a list? ~A", 29, form);
  set_opt3_any(sc->code, sc->unspecified);

  for (x = cdr(sc->code); is_pair(x); x = cdr(x))
    {
      s7_pointer y, car_x;
      if ((!is_pair(x)) ||                                           /* (case 1 ((2) 1) . 1) */
	  (!is_pair(car(x))))
	eval_error(sc, "case clause ~A messed up", 24, x);
      car_x = car(x);

      if (!is_list(cdr(car_x)))                                       /* (case 1 ((1))) */
	eval_error(sc, "case clause result messed up: ~A", 32, car_x);

      if ((bodies_simple) &&
	  ((is_null(cdr(car_x))) || (!is_null(cddr(car_x)))))
	bodies_simple = false;

      y = car(car_x);
      if (!is_pair(y))
	{
	  if ((y != sc->else_symbol) &&                              /* (case 1 (2 1)) */
	      ((!is_symbol(y)) ||
	       (s7_symbol_value(sc, y) != sc->else_symbol)))         /* "proper list" below because: (case 1 (() 2) ... */
	    eval_error(sc, "case clause key list ~A is not a proper list or 'else'", 54, y);
	  else has_else = true;
	  if (is_not_null(cdr(x)))                                  /* (case 1 (else 1) ((2) 1)) */
	    eval_error(sc, "case 'else' clause, ~A, is not the last clause", 46, x);
	  if (is_null(cdr(car_x)))                                  /* (else) so return selector */
	    {
	      /* opt3_any?? */
	    }
	  else
	    {
	      if (is_pair(cddr(car_x)))
		{
		  set_opt3_any(sc->code, cdr(car_x));
		  bodies_simple = false;
		}
	      else
		{
		  if ((bodies_simple) &&
		      (keys_single))
		    set_opt3_any(sc->code, cadr(car_x));
		  else set_opt3_any(sc->code, cdr(car_x));
		  set_opt1_clause(x, cadr(car_x));
		}
	    }
	}
      else
	{
	  if (!is_simple(car(y)))
	    keys_simple = false;
	  if (!is_null(cdr(y)))
	    keys_single = false;
	  if (key_type == T_FREE)
	    key_type = type(car(y));
	  else
	    {
	      if (key_type != type(car(y)))
		key_type = NUM_TYPES;
	    }
	  if (key_type == T_SYMBOL) set_case_key(car(y));

	  for (y = cdr(y); is_pair(y); y = cdr(y))
	    {
	      if (!is_simple(car(y)))
		keys_simple = false;
	      if (key_type != type(car(y)))
		key_type = NUM_TYPES;
	      if (key_type == T_SYMBOL) set_case_key(car(y));
	    }
	  if (!is_null(y))                                        /* (case () ((1 . 2) . hi) . hi) */
	    eval_error(sc, "case key list is improper? ~A", 29, x);
	}
      y = car_x;
      if (!s7_is_proper_list(sc, cdr(y)))
	eval_error(sc, "case: stray dot? ~A", 19, y);
      if ((is_pair(cdr(y))) &&
	  (cadr(y) == sc->feed_to_symbol) &&
	  (s7_symbol_value(sc, sc->feed_to_symbol) == sc->undefined))
	{
	  has_feed_to = true;
	  if (!is_pair(cddr(y)))                                  /* (case 1 (else =>)) */
	    eval_error(sc, "case: '=>' target missing?  ~A", 30, y);
	  if (is_pair(cdddr(y)))                                  /* (case 1 (else => + - *)) */
	    eval_error(sc, "case: '=>' has too many targets: ~A", 35, y);
	}
    }
  if (is_not_null(x))                                             /* (case x ((1 2)) . 1) */
    eval_error(sc, "case: stray dot? ~A", 19, form);

  if ((keys_single) &&
      (bodies_simple))
    {
      for (x = cdr(sc->code); is_not_null(x); x = cdr(x))
	{
	  set_opt2_any(x, caar(x));
	  if (is_pair(opt2_any(x)))
	    {
	      set_opt2_any(x, car(opt2_any(x)));
	      if (is_pair(cdar(x)))
		set_opt1_clause(x, cadar(x));
	    }
	}
    }
  else
    {
      for (x = cdr(sc->code); is_not_null(x); x = cdr(x))
	{
	  set_opt2_any(x, caar(x));
	  if ((is_pair(opt2_any(x))) &&
	      (is_pair(cdar(x))))
	    set_opt1_clause(x, cadar(x));
	}
    }

  pair_set_syntax_op(form, OP_CASE_P_G_G); /* fallback on this */
  if ((has_feed_to) ||
      (!bodies_simple) ||  /* x_x_g g=general keys or bodies */
      (!keys_single))
    {
      if (!keys_simple)  /* x_g_g (no int32_t case here) */
	{
	  if (is_symbol(car(sc->code)))
	    pair_set_syntax_op(form, OP_CASE_S_G_G);
	  else
	    {
	      if (is_fx_safe(sc, car(sc->code)))
		{
		  pair_set_syntax_op(form, OP_CASE_A_G_G);
		  set_c_call(sc->code, fx_choose(sc, sc->code, sc->envir, let_symbol_is_safe));
		}
	      else pair_set_syntax_op(form, OP_CASE_P_G_G);
	    }
	}
      else             /* x_e_g */
	{
	  if (!has_else) set_opt3_any(sc->code, sc->unused); /* affects all that goto CASE_E_G */
	  if (is_symbol(car(sc->code)))
	    pair_set_syntax_op(form, (key_type == T_SYMBOL) ? OP_CASE_S_S_G : OP_CASE_S_E_G);
	  else
	    {
	      if (is_fx_safe(sc, car(sc->code)))
		{
		  pair_set_syntax_op(form, (key_type == T_SYMBOL) ? OP_CASE_A_S_G : OP_CASE_A_E_G);
		  set_c_call(sc->code, fx_choose(sc, sc->code, sc->envir, let_symbol_is_safe));
		}
	      else pair_set_syntax_op(form, (key_type == T_SYMBOL) ? OP_CASE_P_S_G: OP_CASE_P_E_G);
	    }
	}
    }
  else                /* x_x_s */
    {
      if (!keys_simple)  /* x_g|i_s */
	{
	  if (is_symbol(car(sc->code)))
	    pair_set_syntax_op(form, (key_type == T_INTEGER) ? OP_CASE_S_I_S : OP_CASE_S_G_S);
	  else
	    {
	      if (is_fx_safe(sc, car(sc->code)))
		{
		  pair_set_syntax_op(form, (key_type == T_INTEGER) ? OP_CASE_A_I_S : OP_CASE_A_G_S);
		  set_c_call(sc->code, fx_choose(sc, sc->code, sc->envir, let_symbol_is_safe));
		}
	      else pair_set_syntax_op(form, (key_type == T_INTEGER) ? OP_CASE_P_I_S : OP_CASE_P_G_S);
	    }
	}
      else             /* x_e_s */
	{
	  if (is_symbol(car(sc->code)))
	    pair_set_syntax_op(form, (key_type == T_SYMBOL) ? OP_CASE_S_S_S : OP_CASE_S_E_S);
	  else
	    {
	      if (is_fx_safe(sc, car(sc->code)))
		{
		  pair_set_syntax_op(form, (key_type == T_SYMBOL) ? OP_CASE_A_S_S : OP_CASE_A_E_S);
		  set_c_call(sc->code, fx_choose(sc, sc->code, sc->envir, let_symbol_is_safe));
		}
	      else pair_set_syntax_op(form, (key_type == T_SYMBOL) ? OP_CASE_P_S_S : OP_CASE_P_E_S);
	    }
	}
    }

  set_current_code(sc, form);
  sc->code = cdr(form);
  carc = car(sc->code);
  if (!is_pair(carc))
    {
      if (is_symbol(carc))
	sc->value = lookup_checked(sc, carc);
      else sc->value = carc;
      return(NULL);
    }
  push_stack_no_args(sc, OP_CASE_G_G, sc->code);
  sc->code = carc;
  return(carc);
}

static bool op_case_i_s(s7_scheme *sc)
{
  s7_pointer x, selector, else_clause;
  selector = sc->value;
  else_clause = opt3_any(sc->code);
  if (else_clause != sc->unspecified)
    {
      if (is_t_integer(selector))
	{
	  s7_int val;
	  val = integer(selector);
	  for (x = cdr(sc->code); is_pair(x); x = cdr(x))
	    {
	      if (is_t_integer(opt2_any(x)))
		{
		  if (integer(opt2_any(x)) == val)
		    {
		      sc->code = opt1_clause(x);
		      return(false);
		    }
		}
	      else break;
	    }
	}
      sc->code = else_clause;
      return(false);
    }
  if (is_t_integer(selector))
    {
      s7_int val;
      val = integer(selector);
      for (x = cdr(sc->code); is_pair(x); x = cdr(x))
	{
	  if (integer(opt2_any(x)) == val)
	    {
	      sc->code = opt1_clause(x);
	      return(false);
	    }
	}
    }
  sc->value = sc->unspecified;
  return(true);
}

static bool op_case_e_g_1(s7_scheme *sc, s7_pointer selector, bool ok)
{
  s7_pointer x, y;
  if (ok)
    {
      for (x = cdr(sc->code); is_pair(x); x = cdr(x))
	{
	  y = opt2_any(x);
	  if (!is_pair(y))
	    goto ELSE_CASE_1;
	  do {
	    if (car(y) == selector)
	      goto ELSE_CASE_1;
	    y = cdr(y);
	  } while (is_pair(y));
	}
    }
  else
    {
      sc->code = opt3_any(sc->code);
      if (sc->code == sc->unused)    /* set in check_case if no else clause */
	sc->value = sc->unspecified;
      else
	{
	  if (is_pair(sc->code))
	    goto ELSE_CASE_2;
	}
      pop_stack(sc);
      return(true);
    }
  /* x is the entire matching clause, (case 2 ((2) 3)), x: (((2) 3)) */
 ELSE_CASE_1:
  if (is_not_null(x))
    {
      sc->code = T_Lst(cdar(x));
      if (is_null(sc->code))  /* sc->value is already the selector */
	{
	  pop_stack(sc);
	  return(true);
	}
    ELSE_CASE_2:
      if (is_null(cdr(sc->code)))
	{
	  sc->code = car(sc->code);
	  sc->cur_op = optimize_op(sc->code);
	  return(true);
	}
      if ((car(sc->code) == sc->feed_to_symbol) &&
	  (s7_symbol_value(sc, sc->feed_to_symbol) == sc->undefined))
	return(false);
      push_stack_no_args(sc, sc->begin_op, T_Pair(cdr(sc->code)));
      sc->code = car(sc->code);
      sc->cur_op = optimize_op(sc->code);
      return(true);
    }
  sc->value = sc->unspecified;
  pop_stack(sc);
  return(true);
}

static bool op_case_g_g(s7_scheme *sc)
{
  s7_pointer x, y;
  sc->code = cdr(sc->code);
  if (is_simple(sc->value))
    {
      for (x = sc->code; is_pair(x); x = cdr(x))
	{
	  y = caar(x);
	  if (!is_pair(y))
	    goto ELSE_CASE;
	  do {
	    if (car(y) == sc->value)
	      goto ELSE_CASE;
	    y = cdr(y);
	  } while (is_pair(y));
	}
    }
  else
    {
      for (x = sc->code; is_pair(x); x = cdr(x))
	{
	  y = caar(x);
	  if (!is_pair(y))
	    goto ELSE_CASE;
	  for (; is_pair(y); y = cdr(y))
	    if (s7_is_eqv(car(y), sc->value))
	      goto ELSE_CASE;
	}
    }
  /* x is the entire matching clause, (case 2 ((2) 3)), x: (((2) 3)) */
 ELSE_CASE:
  if (is_not_null(x))
    {
      sc->code = T_Lst(cdar(x));
      if (is_null(sc->code))  /* sc->value is already the selector */
	{
	  pop_stack(sc);
	  return(true);
	}
      if (is_null(cdr(sc->code)))
	{
	  sc->code = car(sc->code);
	  sc->cur_op = optimize_op(sc->code);
	  return(true);
	}
      if ((car(sc->code) == sc->feed_to_symbol) &&
	  (s7_symbol_value(sc, sc->feed_to_symbol) == sc->undefined))
	return(false);
      if (is_pair(cdr(T_Pair(sc->code))))
	push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
      sc->code = car(sc->code);
      sc->cur_op = optimize_op(sc->code);
      return(true);
    }
  /* no match found */
  sc->value = sc->unspecified; /* this was sc->nil but the spec says case value is unspecified if no clauses match */
  pop_stack(sc);
  return(true);
}

static void op_case_e_s(s7_scheme *sc)
{
  s7_pointer x, selector;
  selector = sc->value;
  if (is_simple(selector))
    {
      for (x = cdr(sc->code); is_pair(x); x = cdr(x))
	if (opt2_any(x) == selector)
	  {
	    sc->code = opt1_clause(x);
	    return;
	  }
    }
  sc->code = opt3_any(sc->code);
}

static void op_case_s_s(s7_scheme *sc)
{
  s7_pointer x, selector;
  selector = sc->value;
  if (is_symbol(selector))
    {
      for (x = cdr(sc->code); is_pair(x); x = cdr(x))
	if (opt2_any(x) == selector)
	  {
	    sc->code = opt1_clause(x);
	    return;
	  }
    }
  sc->code = opt3_any(sc->code);
}

static void op_case_g_s(s7_scheme *sc)
{
  s7_pointer x, selector;
  selector = sc->value;
  for (x = cdr(sc->code); is_pair(x); x = cdr(x))
    if (s7_is_eqv(opt2_any(x), selector))
      {
	sc->code = opt1_clause(x);
	return;
      }
  sc->code = opt3_any(sc->code);
}


/* -------------------------------- let -------------------------------- */
static void check_let_a_body(s7_scheme *sc, s7_pointer form)
{
  if (is_fx_safe(sc, cadr(sc->code)))
    {
      annotate_arg(sc, cdr(sc->code), sc->envir);
      fx_tree(sc, cdr(sc->code), caaar(sc->code), NULL);
      pair_set_syntax_op(form, OP_LET_A_A);

      if (not_in_heap(form))
	set_opt3_any(sc->code, make_permanent_let(sc, car(sc->code)));
      else set_opt3_any(sc->code, sc->F);
    }
  else
    {
      if ((is_optimized(cadr(sc->code))) ||
	  (is_syntactic_pair(cadr(sc->code))))
	pair_set_syntax_op(form, OP_LET_A_P);
      else
	{
	  if ((is_pair(cadr(sc->code))) &&
	      (is_syntactic(caadr(sc->code))))
	    {
	      pair_set_syntax_op(form, OP_LET_A_P);
	      set_optimize_op(cadr(sc->code), syntax_opcode(slot_value(global_slot(caadr(sc->code)))));
	    }
	}
    }
}

static s7_pointer check_let_one_var(s7_scheme *sc, s7_pointer form, s7_pointer start)
{
  s7_pointer binding;
#if S7_DEBUGGING
  if (cdr(form) != sc->code) fprintf(stderr, "%s[%d]: form: %s, code: %s\n", __func__, __LINE__, DISPLAY_80(form), DISPLAY_80(sc->code));
#endif

  binding = car(start);
  if (is_pair(cadr(binding)))
    {
      /* this is not a named let */
      pair_set_syntax_op(form, ((is_pair(cdr(sc->code))) && (is_null(cddr(sc->code)))) ? OP_LET_ONE_P : OP_LET_ONE);
      set_opt2_sym(cdr(sc->code), car(binding)); /* these don't collide -- cdr(code) and code */
      set_opt2_pair(sc->code, cadr(binding));

      if (is_h_optimized(cadr(binding)))
	{
	  /* if (not_in_heap(form)) fprintf(stderr, "unheap %s\n", DISPLAY_80(form)); */

	  if (is_null(cddr(sc->code)))                   /* one statement body */
	    {
	      /* fprintf(stderr, "form: %d\n", (int)form_is_safe(sc, sc->unused, cadr(sc->code), true)); */

	      if (optimize_op(cadr(binding)) == HOP_SAFE_C_SS)
		{
		  /* no lt fx here, 4 s7test */
		  set_opt2_pair(sc->code, cadr(binding));
		  pair_set_syntax_op(form, OP_LET_opSSq_E);
		  if (c_callee(cadr(binding)) == g_assq)
		    pair_set_syntax_op(form, OP_LET_opaSSq_E);
		  set_opt3_sym(sc->code, caddr(cadr(binding)));
		  return(sc->code);
		}
	      if (is_fx_safe(sc, cadr(binding)))
		{
		  pair_set_syntax_op(form, OP_LET_A);
		  annotate_arg(sc, cdr(binding), sc->envir);
		  check_let_a_body(sc, form);
		  return(sc->code);
		}
	    }
	  /* else fprintf(stderr, "body: %d\n", (int)body_is_safe(sc, sc->unused, cdr(sc->code), true)); */

	  if (optimize_op(cadr(binding)) == HOP_SAFE_C_SS)
	    {
	      if (c_callee(cadr(binding)) == g_assq)
		pair_set_syntax_op(form, OP_LET_opaSSq);
	      else pair_set_syntax_op(form, OP_LET_opSSq);
	      set_opt3_sym(sc->code, caddr(cadr(binding)));
	    }
	  else
	    {
	      if (is_fx_safe(sc, cadr(binding)))
		{
		  pair_set_syntax_op(form, OP_LET_A);
		  annotate_arg(sc, cdr(binding), sc->envir);
		  if (is_null(cddr(sc->code))) check_let_a_body(sc, form);
		}
	    }
	}
      /* else fprintf(stderr, "let_one: %s body: %d\n", DISPLAY_80(form), (int)body_is_safe(sc, sc->unused, cdr(sc->code), true)); */

      if ((optimize_op(form) == OP_LET_ONE) || (optimize_op(form) == OP_LET_ONE_P))
	{
	  if ((not_in_heap(form)) &&
	      (body_is_safe(sc, sc->unused, cdr(sc->code), true) == VERY_SAFE_BODY))
	    set_opt3_any(sc->code, make_permanent_let(sc, car(sc->code)));             /* TODO: fx_tree?? needs preceding annotate? */
	  else set_opt3_any(sc->code, sc->F);
	}
    }
  else
    {
      pair_set_syntax_op(form, OP_LET_A);
      annotate_arg(sc, cdr(binding), sc->envir);
      if (is_null(cddr(sc->code))) check_let_a_body(sc, form);
    }
  return(sc->code);
}

static s7_pointer check_let(s7_scheme *sc)
{
  s7_pointer x, start, form;
  bool named_let;
  int32_t vars;

  form = sc->code;
  sc->code = cdr(sc->code);

  if (!is_pair(sc->code))               /* (let . 1) */
    {
      if (is_null(sc->code))            /* (let) */
	eval_error(sc, "let has no variables or body: ~A", 32, form);
      eval_error(sc, "let form is an improper list? ~A", 32, form);
    }

  if (!is_pair(cdr(sc->code)))          /* (let () ) */
    eval_error(sc, "let has no body: ~A", 19, form);

  if ((!is_list(car(sc->code))) &&      /* (let 1 ...) */
      (!is_symbol(car(sc->code))))
    eval_error(sc, "let variable list is messed up or missing: ~A", 45, form);

  named_let = (is_symbol(car(sc->code)));
  if (named_let)
    {
      if (!s7_is_list(sc, cadr(sc->code)))      /* (let hi #t) */
	eval_error(sc, "let variable list is messed up: ~A", 34, form);
      if (!is_pair(cddr(sc->code)))             /* (let hi () . =>) or (let hi () ) */
	{
	  if (is_null(cddr(sc->code)))
	    eval_error(sc, "named let has no body: ~A", 25 , form);
	  else eval_error(sc, "named let stray dot? ~A", 23, form);
	}
      if (is_constant_symbol(sc, car(sc->code)))
	return(s7_error(sc, sc->wrong_type_arg_symbol,
			set_elist_2(sc, wrap_string(sc, "can't bind an immutable object: ~S", 34), form)));
      set_local(car(sc->code));
      start = cadr(sc->code);
    }
  else start = car(sc->code);

  clear_symbol_list(sc);
  for (vars = 0, x = start; is_pair(x); vars++, x = cdr(x))
    {
      s7_pointer y, carx;
      carx = car(x);

      if ((!is_pair(carx)) || (is_null(cdr(carx))))  /* (let ((x)) ...) or (let ((x 1) . (y 2)) ...) */
	eval_error(sc, "let variable declaration, but no value?: ~A", 43, x);

      if (!(is_pair(cdr(carx))))                     /* (let ((x . 1))...) */
	eval_error(sc, "let variable declaration is not a proper list?: ~A", 50, x);

      if (is_not_null(cddr(carx)))                   /* (let ((x 1 2 3)) ...) */
	eval_error(sc, "let variable declaration has more than one value?: ~A", 53, x);

      y = car(carx);
      if (!(is_symbol(y)))
	eval_error(sc, "bad variable ~S in let", 22, carx);

      if (is_constant_symbol(sc, y))
	return(s7_error(sc, sc->wrong_type_arg_symbol,
			set_elist_2(sc, wrap_string(sc, "can't bind an immutable object: ~S", 34), x)));

      /* check for name collisions -- not sure this is required by Scheme */
      if (symbol_is_in_list(sc, y))
	s7_error(sc, sc->syntax_error_symbol,
		 set_elist_3(sc, wrap_string(sc, "duplicate identifier in let: ~S in ~S", 37), y, form));
      add_symbol_to_list(sc, y);
      set_local(y);
    }

  /* (let ('1) quote) -> 1 */

  if (is_not_null(x))                  /* (let* ((a 1) . b) a) */
    eval_error(sc, "let variable list improper?: ~A", 31, form);

  if (!s7_is_proper_list(sc, cdr(sc->code)))
    eval_error(sc, "stray dot in let body: ~S", 25, cdr(sc->code));

  if (named_let)
    {
      if (vars == 0)
	{
	  pair_set_syntax_op(form, OP_NAMED_LET_NO_VARS);
	  optimize_lambda(sc, true, car(sc->code), sc->nil, cddr(sc->code));
	}
      else 
	{
	  s7_pointer ex, exp;
	  pair_set_syntax_op(form, OP_NAMED_LET);
	  /* this is (let name ...) so the initial values need to be removed from the closure arg list */

	  sc->args = safe_list_if_possible(sc, vars);
	  for (ex = start, exp = sc->args; is_pair(ex); ex = cdr(ex), exp = cdr(exp))
	    car(exp) = caar(ex);

	  optimize_lambda(sc, true, car(sc->code), sc->args, cddr(sc->code)); /* car(sc->code) is the name */
	  /* cddr(sc->code) == body in optimize_lambda, will had very_safe_closure bit */
	  /* if opt, while (sc->pc == 0)..., need frame (via funclet(func)?) */
	  /* but how to tell check_let caller to run the loop? OP_OPT_NAMED_LET? */
	  /* or put it off until unchecked_let+no no_opt_pair? -- see op_let_unchecked */

	  clear_list_in_use(sc->args);
	  sc->current_safe_list = 0;
	}
      return(sc->code);
    }

  /* not named let */
  if (vars == 0)
    pair_set_syntax_op(form, OP_LET_NO_VARS);
  else
    {
      pair_set_syntax_op(form, OP_LET_UNCHECKED);
      if (vars == 1)
	check_let_one_var(sc, form, start);
      else
	{
	  if (vars < GC_TRIGGER_SIZE)
	    {
	      s7_pointer p;
	      opcode_t opt;

	      opt = OP_UNOPT;
	      for (p = start; is_pair(p); p = cdr(p))
		{
		  x = car(p);
		  if (is_fx_safe(sc, cadr(x)))
		    opt = OP_LET_FX;
		  else
		    {
		      opt = OP_LET_UNCHECKED;
		      break;
		    }
		}
	      pair_set_syntax_op(form, opt);
	      if (opt == OP_LET_FX)
		{
		  for (p = start; is_pair(p); p = cdr(p))      /* optimizing the value form here: car(p)=var+val, cdar(p)=val */
		    set_c_call(cdar(p), fx_choose(sc, cdar(p), sc->envir, let_symbol_is_safe));

		  if (is_null(cddr(sc->code)))
		    {
		      if (vars == 2)
			pair_set_syntax_op(form, OP_LET_FX_2);
		      else
			{
			  if (vars == 3)
			    pair_set_syntax_op(form, OP_LET_FX_3);
			}
		    }
		}
	    }
	  else pair_set_syntax_op(form, OP_LET_UNCHECKED);
	}
    }
  return(sc->code);
}

static bool op_let(s7_scheme *sc)
{
  /* sc->code is everything after the let: (let ((a 1)) a) so sc->code is (((a 1)) a) */
  /*   car can be either a list or a symbol ("named let") */
  bool named_let;
  set_current_code(sc, sc->code);
  check_let(sc);
  sc->args = sc->nil;
  sc->value = sc->code;
  named_let = is_symbol(car(sc->code));

  sc->code = (named_let) ? cadr(sc->code) : car(sc->code);
  if (is_null(sc->code))                    /* (let [name] () ...):  no bindings, so skip that step */
    {
      sc->code = sc->value;
      new_frame(sc, sc->envir, sc->envir);
      if (named_let)  /* see also below -- there are 3 cases */
	{
	  s7_pointer body;
	  body = cddr(sc->code);
	  sc->x = make_closure(sc, sc->nil, body, T_CLOSURE | T_COPY_ARGS, 0);
	  /* args = () in new closure, see NAMED_LET_NO_VARS above */
	  /* if this is a safe closure, we can build its env in advance and name it (a thunk in this case) */
	  set_funclet(closure_let(sc->x));
	  funclet_set_function(closure_let(sc->x), car(sc->code));
	  make_slot_1(sc, sc->envir, car(sc->code), sc->x);
	  sc->code = T_Pair(body);
	  sc->x = sc->nil;
	}
      else sc->code = T_Pair(cdr(sc->code));
      return(true);
    }
  return(false);
}

static bool op_let_unchecked(s7_scheme *sc)
{
  s7_pointer x;
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  new_cell(sc, x, T_PAIR);
  set_car(x, sc->code);
  set_cdr(x, sc->nil);
  sc->args = x;
  sc->code = car(sc->code);

  x = cadar(sc->code);
  if (is_pair(x))
    {
      push_stack(sc, OP_LET1, sc->args, cdr(sc->code));
      sc->code = x;
      return(true);
      /* this push_stack/goto can't be optimized away via a local optimize_op case statement
       *    because any c_call can trigger an embedded call on the evaluator (for example,
       *    open-sound involves both hooks, and s7_load if the corresponding .scm code exists),
       *    so we have to protect sc->code and sc->args via the stack.  (I subsequently added
       *    some protection here, but debugging this is hard, and the gain is not huge).
       */
    }
  if (is_symbol(x))
    sc->value = lookup_checked(sc, x);
  else sc->value = T_Pos(x);
  sc->code = cdr(sc->code);
  return(false);
}

static bool op_let1(s7_scheme *sc)
{
  s7_pointer x, y;
  bool named_let;

  while (true)
    {
      new_cell(sc, x, T_PAIR);
      set_car(x, sc->value); /* the first time (now handled above), this saves the entire let body across the evaluations -- we pick it up later */
      set_cdr(x, sc->args);
      sc->args = x;

      if (is_pair(sc->code))
	{
	  x = cadar(sc->code);
	  if (is_pair(x))
	    {
	      push_stack(sc, OP_LET1, sc->args, cdr(sc->code));
	      sc->code = x;
	      return(false);
	    }
	  if (is_symbol(x))
	    sc->value = lookup_checked(sc, x);
	  else sc->value = T_Pos(x);
	  sc->code = cdr(sc->code);
	}
      else break;
    }

  x = safe_reverse_in_place(sc, sc->args);
  sc->code = car(x); /* restore the original form */
  y = cdr(x);        /* use sc->args as the new frame */
  sc->y = y;
  sc->envir = reuse_as_let(sc, x, sc->envir);

  named_let = is_symbol(car(sc->code));
  if (named_let)
    {
      /* we need to check the current environment for ridiculous cases like
       *    (let hiho ((hiho 4)) hiho) -- I guess hiho is 4
       * it's possible to package the entire named-let in fx_* (see rc-a-s7.c), but
       *    it's complicated code, and gains about 1/4 total compute time.  The overhead
       *    is in eval -- goto BEGIN;, all the eval switches, etc -- probably 500 of the 700
       *    can be regained directly.
       */
      s7_pointer let_name, body;
      s7_int n;
      let_name = car(sc->code);
      body = cddr(sc->code);
      sc->envir = new_frame_in_env(sc, sc->envir);

      sc->w = sc->nil;
      for (n = 0, x = cadr(sc->code); is_pair(x); n++, x = cdr(x))
	sc->w = cons(sc, caar(x), sc->w);

      if (is_safe_closure_body(body))
	{
	  s7_pointer arg, new_env;
 	  sc->x = make_closure(sc, sc->w = safe_reverse_in_place(sc, sc->w), body, T_CLOSURE | T_COPY_ARGS, n);
	  new_env = new_frame_in_env(sc, sc->envir);
	  closure_set_let(sc->x, new_env);
	  for (arg = closure_args(sc->x); is_pair(arg); arg = cdr(arg))
	    make_slot_1(sc, new_env, car(arg), sc->nil);
	  let_set_slots(new_env, reverse_slots(sc, let_slots(new_env)));
	}
      else sc->x = make_closure(sc, sc->w = safe_reverse_in_place(sc, sc->w), body, T_CLOSURE | T_COPY_ARGS, n);
      make_slot_1(sc, sc->envir, let_name, sc->x);
      sc->envir = new_frame_in_env(sc, sc->envir);
      for (x = cadr(sc->code); is_not_null(y); x = cdr(x))
	{
	  s7_pointer sym, args;
	  /* reuse the value cells as the new frame slots */

	  sym = caar(x);
	  if (sym == let_name) let_name = sc->nil;
	  args = cdr(y);
	  reuse_as_slot(y, sym, unchecked_car(y)); /* y=slot, sym=symbol, car(y)=value */
	  set_next_slot(y, let_slots(sc->envir));
	  let_set_slots(sc->envir, y);
	  symbol_set_local(sym, let_id(sc->envir), y);
	  y = args;
	}

      sc->code = T_Pair(body);
      sc->w = sc->nil;
      sc->x = sc->nil;
    }
  else
    {
      s7_pointer e;
      uint64_t id;

      e = sc->envir;
      id = let_id(e);

      for (x = car(sc->code); is_not_null(y); x = cdr(x))
	{
	  s7_pointer sym, args;
	  /* reuse the value cells as the new frame slots */

	  sym = caar(x);
	  args = cdr(y);
	  reuse_as_slot(y, sym, unchecked_car(y));
	  symbol_set_local(sym, id, y);
	  set_next_slot(y, let_slots(e));
	  let_set_slots(e, y);

	  y = args;
	}
      sc->code = T_Pair(cdr(sc->code));
    }
  sc->y = sc->nil;
  return(true);
}

#define start_let(Sc) do {set_current_code(Sc, Sc->code); Sc->code = cdr(Sc->code);} while (0)

static void op_let_no_vars(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  new_frame(sc, sc->envir, sc->envir);
  sc->code = T_Pair(cddr(sc->code));         /* ignore the () */
}

static void op_named_let_no_vars(s7_scheme *sc)
{
  s7_pointer body;
  start_let(sc);
  new_frame(sc, sc->envir, sc->envir);
  body = cddr(sc->code);
  sc->args = make_closure(sc, sc->nil, body, T_CLOSURE | T_COPY_ARGS, 0);  /* sc->args is a temp here */
  make_slot_1(sc, sc->envir, car(sc->code), sc->args);
  sc->code = T_Pair(body);
}

static void op_named_let(s7_scheme *sc)
{
  start_let(sc);
  sc->args = sc->nil;
  sc->value = sc->code;
  sc->code = cadr(sc->code);
}

static void op_let_one(s7_scheme *sc)
{
  start_let(sc);
  if (is_let(opt3_any(sc->code)))
    push_stack(sc, OP_LET_ONE_2, opt2_sym(cdr(sc->code)), sc->code);
  else push_stack(sc, OP_LET_ONE_1, opt2_sym(cdr(sc->code)), cdr(sc->code)); /* args code */
  sc->code = opt2_pair(sc->code);
}

static void op_let_one_p(s7_scheme *sc)
{
  start_let(sc);
  if (is_let(opt3_any(sc->code)))
    push_stack(sc, OP_LET_ONE_P_2, opt2_sym(cdr(sc->code)), sc->code);
  else push_stack(sc, OP_LET_ONE_P_1, opt2_sym(cdr(sc->code)), cadr(sc->code)); /* caaar(sc->code) */
  sc->code = T_Pair(opt2_pair(sc->code));
}

static inline void op_let_a(s7_scheme *sc)
{
  s7_pointer binding;
  start_let(sc);
  binding = caar(sc->code);
  new_frame_with_slot(sc, sc->envir, sc->envir, car(binding), fx_call(sc, cdr(binding)));
}

static void op_let_a_a(s7_scheme *sc)
{
  s7_pointer binding;
  start_let(sc);
  binding = caar(sc->code);
  if (is_let(opt3_any(sc->code)))
    {
      s7_pointer frame;
      frame = old_frame_with_slot(sc, opt3_any(sc->code), fx_call(sc, cdr(binding)));
      set_outlet(frame, sc->envir);
      sc->envir = frame;
      sc->value = fx_call(sc, cdr(sc->code));
    }
  else 
    {
      new_frame_with_slot(sc, sc->envir, sc->envir, car(binding), fx_call(sc, cdr(binding)));
      sc->value = fx_call(sc, cdr(sc->code));
      free_cell(sc, let_slots(sc->envir));
      free_cell(sc, sc->envir);
    }
  /* upon return, we goto START, so sc->envir should be ok */
}

static inline void op_let_opssq(s7_scheme *sc)
{
  s7_pointer largs, in_val;
  start_let(sc);
  largs = T_Pair(opt2_pair(sc->code));                              /* cadr(caar(sc->code)); */
  in_val = lookup(sc, cadr(largs));
  set_car(sc->t2_2, lookup(sc, opt3_sym(sc->code))); /* caddr(largs)); */
  set_car(sc->t2_1, in_val);
  sc->value = c_call(largs)(sc, sc->t2_1);
}

static inline void op_let_opassq(s7_scheme *sc)
{
  s7_pointer largs, in_val, lst;
  start_let(sc);
  largs = T_Pair(opt2_pair(sc->code));                              /* cadr(caar(sc->code)); */
  in_val = lookup(sc, cadr(largs));
  lst = lookup(sc, opt3_sym(sc->code));
  if (is_pair(lst))
    sc->value = s7_assq(sc, in_val, lst);
  else
    {
      if (is_null(lst))
	sc->value = sc->F;
      else sc->value = g_assq(sc, set_plist_2(sc, in_val, lst));
    }
}

static void op_let_fx(s7_scheme *sc)
{
  s7_pointer p, frame;
  start_let(sc);
  frame = make_simple_let(sc);
  sc->args = frame;
  for (p = car(sc->code); is_pair(p); p = cdr(p))
    {
      s7_pointer arg;
      arg = cdar(p);
      sc->value = fx_call(sc, arg);
      add_slot(frame, caar(p), sc->value);
    }
  sc->let_number++;
  sc->envir = frame;
  sc->code = T_Pair(cdr(sc->code));
}

static void op_let_fx_2(s7_scheme *sc) /* 2 vars, 1 expr in body */
{
  s7_pointer a1, a2;
  start_let(sc);
  a1 = caar(sc->code);
  a2 = cadar(sc->code);
  new_frame_with_two_slots(sc, sc->envir, sc->envir, car(a1), fx_call(sc, cdr(a1)), car(a2), fx_call(sc, cdr(a2)));
  sc->code = cadr(sc->code);
}

static void op_let_fx_3(s7_scheme *sc) /* 3 vars, 1 expr in body */
{
  s7_pointer a1, a2, a3;
  start_let(sc);
  a1 = caar(sc->code);
  a2 = cadar(sc->code);
  a3 = caddar(sc->code);
  new_frame_with_two_slots(sc, sc->envir, sc->envir, car(a1), fx_call(sc, cdr(a1)), car(a2), fx_call(sc, cdr(a2)));
  add_slot(sc->envir, car(a3), fx_call(sc, cdr(a3)));
  sc->code = cadr(sc->code);
}


/* -------------------------------- let* -------------------------------- */
static bool check_let_star(s7_scheme *sc)
{
  s7_pointer vars, form;
  bool named_let;

  form = sc->code;
  sc->code = cdr(sc->code);  /* sc->code is cdr of let* form (no let*) */

  if (!is_pair(sc->code))                           /* (let* . 1) */
    eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable list is messed up: ~A", 35, form);
  if (!is_pair(cdr(sc->code)))                      /* (let* ()) */
    eval_error_no_return(sc, sc->syntax_error_symbol, "let* has no body: ~A", 20, form);

  named_let = (is_symbol(car(sc->code)));

  if (named_let)
    {
      if (!s7_is_list(sc, cadr(sc->code)))          /* (let* hi #t) */
	eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable list is messed up: ~A", 35, form);
      if (!is_pair(cddr(sc->code)))                 /* (let* hi () . =>) or (let* hi () ) */
	{
	  if (is_null(cddr(sc->code)))
	    eval_error_no_return(sc, sc->syntax_error_symbol, "named let* has no body: ~A", 26, form);
	  else eval_error_no_return(sc, sc->syntax_error_symbol, "named let* stray dot? ~A", 24, form);
	}
      if (is_constant_symbol(sc, car(sc->code)))
	s7_error(sc, sc->wrong_type_arg_symbol,
		 set_elist_2(sc, wrap_string(sc, "can't bind an immutable object: ~S", 34), form));
      set_local(car(sc->code));
    }
  else
    {
      if (!is_list(car(sc->code)))                  /* (let* x ... ) */
	eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable declaration value is missing: ~A", 46, form);
    }

  for (vars = ((named_let) ? cadr(sc->code) : car(sc->code)); is_pair(vars); vars = cdr(vars))
    {
      s7_pointer var_and_val, var;
      var_and_val = car(vars);

      if (!is_pair(var_and_val))                    /* (let* (3) ... */
	eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable list is messed up? ~A", 35, var_and_val);

      if (!(is_pair(cdr(var_and_val))))             /* (let* ((x . 1))...) */
	{
	  if (is_null(cdr(var_and_val)))
	    eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable declaration, but no value?: ~A", 44, var_and_val);
	  else eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable declaration is not a proper list?: ~A", 51, var_and_val);
	}
      if (!is_null(cddr(var_and_val)))              /* (let* ((c 1 2)) ...) */
	eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable declaration has more than one value?: ~A", 54, var_and_val);

      var = car(var_and_val);

      if (!(is_symbol(var)))                        /* (let* ((3 1)) 1) */
	eval_error_no_return(sc, sc->syntax_error_symbol, "bad variable ~S in let*", 23, var);

      if (is_constant_symbol(sc, var))                 /* (let* ((pi 3)) ...) */
	s7_error(sc, sc->wrong_type_arg_symbol,
		 set_elist_2(sc, wrap_string(sc, "can't bind an immutable object: ~S", 34), var_and_val));

      /* currently (let* ((a 1) (a (+ a 1))) a) is 2, not an error. */
      set_local(var);
    }
  if (!is_null(vars))
    eval_error_no_return(sc, sc->syntax_error_symbol, "let* variable list is not a proper list?: ~A", 44, vars);

  if (!s7_is_proper_list(sc, cdr(sc->code)))
    eval_error_no_return(sc, sc->syntax_error_symbol, "stray dot in let* body: ~S", 26, cdr(sc->code));

  if (named_let)
    {
      if (is_null(cadr(sc->code)))
	pair_set_syntax_op(form, OP_NAMED_LET_NO_VARS);
      else
	{
	  pair_set_syntax_op(form, OP_NAMED_LET_STAR);
	  set_opt2_con(sc->code, cadr(caadr(sc->code)));
	}
    }
  else
    {
      if (is_null(car(sc->code)))
	pair_set_syntax_op(form, OP_LET_NO_VARS);       /* (let* () ...) */
      else
	{
	  if (is_null(cdar(sc->code)))
	    check_let_one_var(sc, form, car(sc->code)); /* (let* ((var...))...) -> (let ((var...))...) */
	  else  /* more than one entry */
	    {
	      s7_pointer p;
	      opcode_t opt;
	      clear_symbol_list(sc);
	      opt = OP_LET_STAR_FX;                     /* 2 var fx case is common */
	      set_opt2_con(sc->code, cadaar(sc->code));
	      for (p = car(sc->code); is_pair(p); p = cdr(p))
		{
		  s7_pointer x;
		  x = car(p);
		  add_symbol_to_list(sc, car(x));
		  if ((is_unquoted_pair(cadr(x))) &&
		      (!is_fx_safe(sc, cadr(x))))
		    {
		      opt = OP_LET_STAR2;
		      break;
		    }
		}
	      pair_set_syntax_op(form, opt);
	    }
	}
      if (optimize_op(form) == OP_LET_STAR_FX)
	{
	  s7_pointer p;
	  clear_symbol_list(sc);
	  p = car(sc->code);
	  for (; is_pair(p); p = cdr(p))
	    {
	      set_c_call(cdar(p), fx_choose(sc, cdar(p), sc->envir, let_star_symbol_is_safe));
	      add_symbol_to_list(sc, caar(p));
	    }
	  
	  if ((is_null(cddr(sc->code))) &&
	      (is_fx_safe(sc, cadr(sc->code))))
	    {
	      annotate_arg(sc, cdr(sc->code), sc->envir);
	      /* fprintf(stderr, "let*_fx_a: %s\n", DISPLAY(form)); */
	      pair_set_syntax_op(form, OP_LET_STAR_FX_A);
	      if (not_in_heap(form))
		set_opt3_any(sc->code, make_permanent_let(sc, car(sc->code)));
	      else set_opt3_any(sc->code, sc->F);
	    }
	}
    }

  /* let_star_unchecked... */
  set_current_code(sc, form);
  if (is_symbol(car(sc->code)))
    {
      sc->value = cdr(sc->code);
      if (is_null(car(sc->value)))
	{
	  s7_pointer cx;
	  cx = car(sc->code);
	  sc->envir = new_frame_in_env(sc, sc->envir);
	  sc->code = T_Pair(cdr(sc->value));
	  make_slot_1(sc, sc->envir, cx, make_closure(sc, sc->nil, sc->code, T_CLOSURE_STAR, 0));
	  return(false);
	}
    }
  else
    {
      if (is_null(car(sc->code)))
	{
	  sc->envir = new_frame_in_env(sc, sc->envir);
	  sc->code = T_Pair(cdr(sc->code));
	  return(false);
	}
    }

  if (is_symbol(car(sc->code)))
    {
      push_stack(sc, OP_LET_STAR1, sc->code, cadr(sc->code));
      sc->code = cadr(caadr(sc->code));
    }
  else
    {
      push_stack(sc, OP_LET_STAR1, sc->code, car(sc->code));
      /* args is the let body, saved for later, code is the list of vars+initial-values */
      sc->code = cadr(caar(sc->code));
      /* caar(code) = first var/val pair, we've checked that all these guys are legit, so cadr of that is the value */
    }
  return(true);
}

static bool op_let_star1(s7_scheme *sc)
{
  /* we can't skip (or reuse) this new frame -- we have to imitate a nested let, otherwise
   *   (let ((f1 (lambda (arg) (+ arg 1))))
   *     (let* ((x 32)
   *            (f1 (lambda (arg) (f1 (+ x arg)))))
   *       (f1 1)))
   * will hang.
   * To get around this requires find_symbol or s7_tree_memq in check_let_star,
   *   both (much) more expensive than making a useless frame!.
   */
  while (true)
    {
      new_frame_with_slot(sc, sc->envir, sc->envir, caar(sc->code), sc->value);
      sc->code = cdr(sc->code);
      if (is_pair(sc->code))
	{
	  s7_pointer x;
	  x = cadar(sc->code);
	  if (is_pair(x))
	    {
	      push_stack(sc, OP_LET_STAR1, sc->args, sc->code);
	      sc->code = x;
	      return(true);
	    }
	  if (is_symbol(x))
	    sc->value = lookup_checked(sc, x);
	  else sc->value = T_Pos(x);
	}
      else break;
    }
  sc->code = sc->args; /* original sc->code set in push_stack above */
  if (is_symbol(car(sc->code)))
    {
      /* now we need to declare the new function */
      s7_pointer body, args;
      body = cddr(sc->code);
      args = cadr(sc->code);
      make_slot_1(sc, sc->envir, car(sc->code), make_closure(sc, args, body, T_CLOSURE_STAR, (is_null(args)) ? 0 : CLOSURE_ARITY_NOT_SET));
      sc->code = body;
    }
  else sc->code = T_Pair(cdr(sc->code));
  return(false);
}

static void op_let_star_fx(s7_scheme *sc)
{
  s7_pointer e, p;
  start_let(sc);
  new_frame(sc, sc->envir, e);
  /* since each value is fx safe, there are no internal closures over the on-going stack of lets here (so use one frame) */
  sc->envir = e;
  for (p = car(sc->code); is_pair(p); p = cdr(p))
    make_slot_1(sc, e, caar(p), fx_call(sc, cdar(p)));
  sc->code = T_Pair(cdr(sc->code));
}

static void op_let_star_fx_a(s7_scheme *sc)
{
  s7_pointer e, p;
  start_let(sc);
  if (is_let(opt3_any(sc->code)))
    activate_permanent_let_star(sc, opt3_any(sc->code), car(sc->code));
  else 
    {
      new_frame(sc, sc->envir, e);
      sc->envir = e;
      for (p = car(sc->code); is_pair(p); p = cdr(p))
	make_slot_1(sc, e, caar(p), fx_call(sc, cdar(p)));
    }
  sc->value = fx_call(sc, cdr(sc->code));
}

static void op_named_let_star(s7_scheme *sc)
{
  start_let(sc);
  push_stack(sc, OP_LET_STAR1, sc->code, cadr(sc->code));
  sc->code = opt2_con(sc->code);
}

static void op_let_star2(s7_scheme *sc)
{
  start_let(sc);
  push_stack(sc, OP_LET_STAR1, sc->code, car(sc->code));
  sc->code = opt2_con(sc->code);
}


/* -------------------------------- letrec, letrec* -------------------------------- */
static s7_pointer check_letrec(s7_scheme *sc, bool letrec)
{
  s7_pointer x, caller, form;

  form = sc->code;
  sc->code = cdr(sc->code);

  caller = (letrec) ? sc->letrec_symbol : sc->letrec_star_symbol;

  if ((!is_pair(sc->code)) ||                 /* (letrec . 1) */
      (!is_list(car(sc->code))))              /* (letrec 1 ...) */
    eval_error_with_caller(sc, "~A: variable list is messed up: ~A", 34, caller, form);

  if (!is_pair(cdr(sc->code)))               /* (letrec ()) */
    eval_error_with_caller(sc, "~A has no body: ~A", 18, caller, form);

  clear_symbol_list(sc);
  for (x = car(sc->code); is_not_null(x); x = cdr(x))
    {
      s7_pointer y, carx;
      if (!is_pair(x))                        /* (letrec ((a 1) . 2) ...) */
	eval_error_with_caller(sc, "~A: improper list of variables? ~A", 34, caller, form);

      carx = car(x);
      if ((!is_pair(carx)) ||                 /* (letrec (1 2) #t) */
	  (!(is_symbol(car(carx)))))
	eval_error_with_caller(sc, "~A: bad variable ~S", 19, caller, carx);

      y = car(carx);
      if (is_constant_symbol(sc, y))
	return(s7_error(sc, sc->wrong_type_arg_symbol,
			set_elist_2(sc, wrap_string(sc, "can't bind an immutable object: ~S", 34), x)));

      if (!is_pair(cdr(carx)))                /* (letrec ((x . 1))...) */
	{
	  if (is_null(cdr(carx)))             /* (letrec ((x)) x) -- perhaps this is legal? */
	    eval_error_with_caller(sc, "~A: variable declaration has no value?: ~A", 42, caller, carx);
	  eval_error_with_caller(sc, "~A: variable declaration is not a proper list?: ~A", 50, caller, carx);
	}
      if (is_not_null(cddr(carx)))            /* (letrec ((x 1 2 3)) ...) */
	eval_error_with_caller(sc, "~A: variable declaration has more than one value?: ~A", 53, caller, carx);

      /* check for name collisions -- this is needed in letrec* else which of the two legit values does our "rec" refer to, so to speak */
      if (symbol_is_in_list(sc, y))
	eval_error_with_caller(sc, "~A: duplicate identifier: ~A", 28, caller, y);
      add_symbol_to_list(sc, y);
      set_local(y);
    }

  if (!s7_is_proper_list(sc, cdr(sc->code)))
    eval_error_with_caller(sc, "stray dot in ~A body: ~S", 24, caller, cdr(sc->code));

  pair_set_syntax_op(form, (letrec) ? OP_LETREC_UNCHECKED : OP_LETREC_STAR_UNCHECKED);
  sc->code = form;
  return(sc->code);
}

static bool op_letrec_unchecked(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  /*   get all local vars and set to #<undefined>
   *   get parallel list of values
   *   eval each member of values list with env still full of #<undefined>'s
   *   assign each value to its variable
   *   eval body
   * which means that (letrec ((x x)) x) is not an error!
   * but this assumes the environment is not changed by evaluating the exprs?
   * (letrec ((a (define b 1))) b) -- if let, the define takes place in the calling env, not the current env
   * (letrec ((f1 (lambda (x) (f2 (* 2 x))))) (define (f2 y) (- y 1)) (f1 3)) -> 5 (Guile says unbound f2)
   * I think I need to check here that slot_pending_value is set (using the is_checked bit below).
   */
  sc->envir = new_frame_in_env(sc, sc->envir);
  if (is_pair(car(sc->code)))
    {
      s7_pointer x;
      for (x = car(sc->code); is_not_null(x); x = cdr(x))
	{
	  s7_pointer slot;
	  slot = make_slot_1(sc, sc->envir, caar(x), sc->undefined);
	  slot_set_pending_value(slot, sc->undefined);
	  slot_set_expression(slot, cadar(x));
	  set_checked_slot(slot);
	}
      sc->args = let_slots(sc->envir);
      if (!(sc->args)) sc->args = sc->nil;
      push_stack(sc, OP_LETREC1, sc->args, sc->code);
      sc->code = slot_expression(sc->args);
      return(true);
    }
  sc->code = T_Pair(cdr(sc->code));
  return(false);
}

static bool op_letrec1(s7_scheme *sc)
{
  s7_pointer slot;
  slot_set_pending_value(sc->args, sc->value);
  sc->args = next_slot(sc->args);
  if (tis_slot(sc->args))
    {
      push_stack(sc, OP_LETREC1, sc->args, sc->code);
      sc->code = slot_expression(sc->args);
      return(false);
    }
  sc->args = sc->nil;
  for (slot = let_slots(sc->envir); tis_slot(slot); slot = next_slot(slot))
    if (is_checked_slot(slot))
      slot_set_value(slot, slot_pending_value(slot));
  sc->code = T_Pair(cdr(sc->code));
  return(true);
}

static bool op_letrec_star_unchecked(s7_scheme *sc)
{
  start_let(sc);
  /* get all local vars and set to #<undefined>
   * eval each member of values list and assign immediately, as in let*
   * eval body
   */
  sc->envir = new_frame_in_env(sc, sc->envir);
  if (is_pair(car(sc->code)))
    {
      s7_pointer x, p, q;
      for (x = car(sc->code); is_not_null(x); x = cdr(x))
	{
	  s7_pointer slot;
	  slot = make_slot_1(sc, sc->envir, caar(x), sc->undefined);
	  slot_set_expression(slot, cadar(x));
	}
      /* these are reversed, and for letrec*, they need to be in order, so... (reverse_in_place on the slot list) */
      p = let_slots(sc->envir);
      x = slot_end(sc);
      while (tis_slot(p))
	{
	  q = next_slot(p);
	  set_next_slot(p, x);
	  x = p;
	  p = q;
	}
      let_set_slots(sc->envir, x);
      sc->args = let_slots(sc->envir);
      if (!(sc->args)) sc->args = sc->nil;
      push_stack(sc, OP_LETREC_STAR1, sc->args, sc->code);
      sc->code = slot_expression(sc->args);
      return(true);
    }
  sc->code = T_Pair(cdr(sc->code));
  return(false);
}

static bool op_letrec_star1(s7_scheme *sc)
{
  s7_pointer slot;
  slot = sc->args;
  slot_set_value(slot, sc->value);
  slot = next_slot(slot);
  if (tis_slot(slot))
    {
      push_stack(sc, OP_LETREC_STAR1, slot, sc->code);
      sc->code = slot_expression(slot);
      return(true);
    }
  sc->code = T_Pair(cdr(sc->code));
  return(false);
}


/* -------------------------------- let-temporarily -------------------------------- */
static s7_pointer check_let_temporarily(s7_scheme *sc)
{
  s7_pointer x, form;
  form = sc->code;
  sc->code = cdr(sc->code);

  if ((!is_pair(sc->code)) ||                 /* (let-temporarily . 1) */
      (!is_list(car(sc->code))))              /* (let-temporarily 1 ...) */
    eval_error(sc, "let-temporarily: variable list is messed up: ~A", 47, form);
  /* cdr(sc->code) = body can be nil */

  for (x = car(sc->code); is_not_null(x); x = cdr(x))
    {
      s7_pointer carx;
      if (!is_pair(x))                        /* (let-temporarily ((a 1) . 2) ...) */
	eval_error(sc, "let-temporarily: improper list of variables? ~A", 47, form);

      carx = car(x);
      if (!is_pair(carx))                     /* (let-temporarily (1 2) #t) */
	eval_error(sc, "let-temporarily: bad variable ~S", 32, carx);

      if (is_symbol(car(carx)))
	{
	  if (is_constant_symbol(sc, car(carx))) /* (let-temporarily ((pi 3)) ...) */
	    return(s7_error(sc, sc->wrong_type_arg_symbol,
			    set_elist_2(sc, wrap_string(sc, "can't bind an immutable object: ~S", 34), x)));
	  if (is_syntactic_symbol(car(carx)))    /* (let-temporarily ((if 3)) ...) */
	    return(s7_error(sc, sc->wrong_type_arg_symbol,
			    set_elist_2(sc, wrap_string(sc, "can't set! ~S", 13), car(carx))));
	}

      if (!is_pair(cdr(carx)))                /* (let-temporarily ((x . 1))...) */
	eval_error(sc, "let-temporarily: variable declaration value is messed up: ~S", 60, carx);

      if (is_not_null(cddr(carx)))            /* (let-temporarily ((x 1 2 3)) ...) */
	eval_error(sc, "let-temporarily: variable declaration has more than one value?: ~A", 66, carx);
    }
  if (!s7_is_proper_list(sc, cdr(sc->code)))
    eval_error(sc, "stray dot in let-temporarily body: ~S", 37, cdr(sc->code));

  pair_set_syntax_op(form, OP_LET_TEMP_UNCHECKED);
  sc->code = form;
  return(sc->code);
}

static void op_let_temp_unchecked(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  push_stack(sc, OP_GC_PROTECT, sc->args = list_4(sc, car(sc->code), sc->nil, sc->nil, sc->nil), sc->code);
  /* sc->args: varlist, settees, old_values, new_values */
}

static bool op_let_temp_init1(s7_scheme *sc)
{
  while (is_pair(car(sc->args)))
    {
      /* eval car, add result to old-vals list, if any vars undefined, error */
      s7_pointer binding, settee, new_value;
      binding = caar(sc->args);
      settee = car(binding);
      new_value = cadr(binding);
      cadr(sc->args) = cons(sc, settee, cadr(sc->args));
      cadddr(sc->args) = cons(sc, new_value, cadddr(sc->args));
      car(sc->args) = cdar(sc->args);
      if (is_symbol(settee))
	caddr(sc->args) = cons(sc, lookup_checked(sc, settee), caddr(sc->args));
      else
	{
	  if (is_pair(settee))
	    {
	      push_stack(sc, OP_LET_TEMP_INIT1, sc->args, sc->code);
	      sc->code = settee;
	      return(true);
	    }
	  caddr(sc->args) = cons(sc, new_value, caddr(sc->args));
	}
    }
  car(sc->args) = cadr(sc->args);
  return(false);
}

static s7_pointer op_let_temp_init2(s7_scheme *sc)
{
  /* now eval set car new-val, cadr=settees, cadddr= new_values */
  while (is_pair(car(sc->args)))
    {
      s7_pointer settee, new_value, slot;
      settee = caar(sc->args);
      new_value = car(cadddr(sc->args));
      cadddr(sc->args) = cdr(cadddr(sc->args));
      car(sc->args) = cdar(sc->args);
      if ((!is_symbol(settee)) ||
	  (symbol_has_setter(settee)) ||
	  (is_pair(new_value)))
	{
	  push_stack(sc, OP_LET_TEMP_INIT2, sc->args, sc->code);
	  sc->code = list_3(sc, sc->set_symbol, settee, new_value);
	  return(NULL);
	}
      slot = symbol_to_slot(sc, settee);
      if (!is_slot(slot))
	eval_error_no_return(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, settee);
      if (is_immutable_slot(slot))
	immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->let_temporarily_symbol, settee));
      if (is_symbol(new_value))
	new_value = lookup_checked(sc, new_value);
      slot_set_value(slot, new_value);
    }
  car(sc->args) = cadr(sc->args);
  pop_stack(sc);
  push_stack(sc, OP_LET_TEMP_DONE, sc->args, sc->code);
  sc->code = cdr(sc->code);
  if (is_pair(sc->code))
    return(sc->unused);
  sc->value = sc->nil; /* so (let-temporarily (<vars)) -> () like begin I guess */
  return(sc->code);
}

static bool op_let_temp_done1(s7_scheme *sc)
{
  while (is_pair(car(sc->args)))
    {
      s7_pointer settee, slot;
      settee = caar(sc->args);
      sc->value = caaddr(sc->args);
      caddr(sc->args) = cdaddr(sc->args);
      car(sc->args) = cdar(sc->args);
      if ((!is_symbol(settee)) ||
	  (symbol_has_setter(settee)))
	{
	  push_stack(sc, OP_LET_TEMP_DONE1, sc->args, sc->code);
	  if ((is_pair(sc->value)) || (is_symbol(sc->value)))
	    sc->code = list_3(sc, sc->set_symbol, settee, list_2(sc, sc->quote_symbol, sc->value));
	  else sc->code = list_3(sc, sc->set_symbol, settee, sc->value);
	  return(false);
	}
      slot = symbol_to_slot(sc, settee);
      if (is_immutable_slot(slot))
	immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->let_temporarily_symbol, settee));
      slot_set_value(slot, sc->value);
    }
  pop_stack(sc);
  sc->value = sc->code;
  if (is_multiple_value(sc->value))
    sc->value = splice_in_values(sc, multiple_value(sc->value));
  return(true);
}


/* -------------------------------- quote -------------------------------- */
static inline s7_pointer check_quote(s7_scheme *sc, s7_pointer code)
{
  s7_pointer form;
  form = code;
  code = cdr(code);
  if (!is_pair(code))                    /* (quote . -1) */
    {
      if (is_null(code))
	eval_error(sc, "quote: not enough arguments: ~A", 31, form);
      eval_error(sc, "quote: stray dot?: ~A", 21, form);
    }
  if (is_not_null(cdr(code)))             /* (quote . (1 2)) or (quote 1 1) */
    eval_error(sc, "quote: too many arguments ~A", 28, form);
  return(code);
}


/* -------------------------------- and -------------------------------- */
static bool check_and(s7_scheme *sc)
{
  /* this and check_or and check_if may not be called -- optimize_syntax can short-circuit it to return fx* choices */
  s7_pointer p, form;
  int32_t any_nils = 0, len;

  form = sc->code;
  sc->code = cdr(sc->code);

  if (is_null(sc->code))
    {
      sc->value = sc->T;
      return(true);
    }
  for (len = 0, p = sc->code; is_pair(p); p = cdr(p), len++)
    {
      s7_function callee;
      callee = fx_choose(sc, p, sc->envir, let_symbol_is_safe);  /* c_callee can be nil! */
      if (!callee)
	any_nils++;
      set_c_call_checked(p, callee);
    }

  if (is_not_null(p))                                    /* (and . 1) (and #t . 1) */
    eval_error_no_return(sc, sc->syntax_error_symbol, "and: stray dot?: ~A", 19, form);

  if ((c_callee(sc->code)) &&
      (is_pair(cdr(sc->code))) &&
      (is_null(cddr(sc->code))))
    {
      if ((c_callee(sc->code) == fx_is_pair_s) || (c_callee(sc->code) == fx_is_pair_t))
	{
	  pair_set_syntax_op(form, OP_AND_PAIR_P);
	  set_opt3_sym(form, cadar(sc->code));
	  set_opt2_con(form, cadr(sc->code));
	}
      else pair_set_syntax_op(form, (any_nils > 0) ? OP_AND_AP : OP_AND_SAFE_AA);
    }
  else 
    {
      pair_set_syntax_op(form, (any_nils > 0) ? OP_AND_P : OP_AND_SAFE_P);
      if ((any_nils == 1) && (len > 2))
	{
	  if (!has_fx(sc->code))
	    pair_set_syntax_op(form, OP_AND_SAFE_P1);
	  else
	    {
	      if (!has_fx(cdr(sc->code)))
		pair_set_syntax_op(form, OP_AND_SAFE_P2);
	      else
		{
		  if ((!has_fx(cddr(sc->code))) && (len == 3))
		    pair_set_syntax_op(form, OP_AND_SAFE_P3);
		}}}}
  sc->code = form;
  return(false);
}

static bool op_and_pair_p(s7_scheme *sc)
{
  if (!is_pair(lookup(sc, opt3_sym(sc->code)))) /* cadadr(sc->code) */
    {
      sc->value = sc->F;
      return(true);
    }
  sc->code = opt2_con(sc->code);                /* caddr(sc->code); */
  return(false);
}

static bool op_and_ap(s7_scheme *sc)
{
  /* we know c_callee is set on sc->code, and there are only two branches */
  sc->code = cdr(sc->code);
  if (is_false(sc, fx_call(sc, sc->code)))
    {
      sc->value = sc->F;
      return(true);
    }
  sc->code = cadr(sc->code);
  return(false);
}

static void op_and_safe_aa(s7_scheme *sc)
{
  sc->code = cdr(sc->code);
  sc->value = fx_call(sc, sc->code);
  if (is_true(sc, sc->value))
    sc->value = fx_call(sc, cdr(sc->code));
}

static void op_and_safe_p(s7_scheme *sc)
{
  while (true)
    {
      sc->value = fx_call(sc, sc->code);
      if (is_false(sc, sc->value))
	return;
      sc->code = cdr(sc->code);
      if (is_null(sc->code))
	return;
    }
}


/* -------------------------------- or -------------------------------- */
static bool check_or(s7_scheme *sc)
{
  s7_pointer p, form;
  bool any_nils = false;

  form = sc->code;
  sc->code = cdr(sc->code);

  if (is_null(sc->code))
    {
      sc->value = sc->F;
      return(true);
    }

  for (p = sc->code; is_pair(p); p = cdr(p))
    {
      s7_function callee;
      callee = fx_choose(sc, p, sc->envir, let_symbol_is_safe);
      if (!callee) any_nils = true;
      set_c_call_checked(p, callee);
    }

  if (is_not_null(p))
    eval_error_no_return(sc, sc->syntax_error_symbol, "or: stray dot?: ~A", 18, form);

  if ((c_callee(sc->code)) &&
      (is_pair(cdr(sc->code))) &&
      (is_null(cddr(sc->code))))
    pair_set_syntax_op(form, (any_nils) ? OP_OR_AP : OP_OR_SAFE_AA);
  else pair_set_syntax_op(form, (any_nils) ? OP_OR_P : OP_OR_SAFE_P);

  sc->code = form;
  return(false);
}

static bool op_or_ap(s7_scheme *sc)
{
  /* we know c_callee is set on sc->code, and there are only two branches */
  sc->code = cdr(sc->code);
  sc->value = fx_call(sc, sc->code);
  if (is_true(sc, sc->value))
    return(true);
  sc->code = cadr(sc->code);
  return(false);
}

static void op_or_safe_aa(s7_scheme *sc)
{
  sc->code = cdr(sc->code);
  sc->value = fx_call(sc, sc->code);
  if (is_false(sc, sc->value))
    sc->value = fx_call(sc, cdr(sc->code));
}

static void op_or_safe_p(s7_scheme *sc)
{
  sc->code = cdr(sc->code);
  while (true)
    {
      sc->value = fx_call(sc, sc->code);
      if (is_true(sc, sc->value))
	return;
      sc->code = cdr(sc->code);
      if (is_null(sc->code))
	return;
    }
}


/* -------------------------------- if -------------------------------- */
#define choose_if_optc(Opc, One, Reversed, Not) ((One) ? ((Reversed) ? OP_ ## Opc ## _R : ((Not) ? OP_ ## Opc ## _N : OP_ ## Opc ## _P)) :  ((Not) ? OP_ ## Opc ## _N_N : OP_ ## Opc ## _P_P))

static void set_if_opts(s7_scheme *sc, s7_pointer form, bool one_branch, bool reversed)
{
  s7_pointer test;
  bool not_case = false;
  test = car(sc->code);
  if ((!reversed) &&
      (is_pair(test)) &&
      (car(test) == sc->not_symbol))
    {
      if ((!is_pair(cdr(test))) || (!is_null(cddr(test)))) return; /* (not) or (not a b) */
      not_case = true;
      test = cadr(test);
    }
  if (is_pair(test))
    {
      if (is_h_optimized(test))
	{
	  if (is_h_safe_c_d(test))
	    {
	      clear_has_fx(sc->code);
	      if (c_callee(test) == g_and_2)
		{
		  pair_set_syntax_op(form, choose_if_optc(IF_AND2, one_branch, reversed, not_case));
		  set_opt2_pair(sc->code, cdr(test));
		  set_opt3_pair(sc->code, cddr(test));
		  return;
		}
	      if (c_callee(test) == g_and_3)
		{
		  pair_set_syntax_op(form, choose_if_optc(IF_AND3, one_branch, reversed, not_case));
		  set_opt2_pair(sc->code, cdr(test));
		  set_opt3_pair(sc->code, cddr(test));
		  return;
		}
	      if (c_callee(test) == g_or_2)
		{
		  pair_set_syntax_op(form, choose_if_optc(IF_OR2, one_branch, reversed, not_case));
		  set_opt2_pair(sc->code, cdr(test));
		  set_opt3_pair(sc->code, cddr(test));
		  return;
		}
	      set_opt2_pair(sc->code, cdr(test));
	      pair_set_syntax_op(form, choose_if_optc(IF_D, one_branch, reversed, not_case));
	      return;
	    }

	  if (is_h_safe_c_s(test))
	    {
	      uint8_t typ;
	      typ = symbol_type(car(test));
	      if (typ > 0)
		{
		  pair_set_syntax_op(form, choose_if_optc(IF_IS_TYPE_S, one_branch, reversed, not_case));
		  set_opt3_con(sc->code, typ);
		}
	      else pair_set_syntax_op(form, choose_if_optc(IF_CS, one_branch, reversed, not_case));
	      clear_has_fx(sc->code);
	      set_opt2_sym(sc->code, cadr(test));
	      return;
	    }

	  if (optimize_op(test) == HOP_SAFE_C_SS)
	    {
	      pair_set_syntax_op(form, choose_if_optc(IF_CSS, one_branch, reversed, not_case));
	      clear_has_fx(sc->code);
	      set_opt2_sym(sc->code, caddr(test));
	      set_opt3_sym(sc->code, cadr(test));
	      return;
	    }
	  if (optimize_op(test) == HOP_SAFE_C_SC)
	    {
	      pair_set_syntax_op(form, choose_if_optc(IF_CSC, one_branch, reversed, not_case));
	      clear_has_fx(sc->code);
	      set_opt2_con(sc->code, (is_pair(caddr(test))) ? cadr(caddr(test)) : caddr(test));
	      set_opt3_sym(sc->code, cadr(test));
	      return;
	    }
	  if (optimize_op(test) == HOP_SAFE_C_S_opDq)
	    {
	      pair_set_syntax_op(form, choose_if_optc(IF_S_opDq, one_branch, reversed, not_case));
	      clear_has_fx(sc->code);
	      set_opt2_pair(sc->code, caddr(test));
	      set_opt3_sym(sc->code, cadr(test));
	      return;
	    }
	  if (optimize_op(test) == HOP_SAFE_C_opSq)
	    {
	      uint8_t typ;
	      typ = symbol_type(car(test));
	      clear_has_fx(sc->code);
	      if (typ > 0)
		{
		  pair_set_syntax_op(form, choose_if_optc(IF_IS_TYPE_opSq, one_branch, reversed, not_case));
		  set_opt2_sym(sc->code, cadadr(test));
		  set_opt3_con(sc->code, typ);
		}
	      else
		{
		  pair_set_syntax_op(form, choose_if_optc(IF_opSq, one_branch, reversed, not_case));
		  set_opt2_pair(sc->code, cadr(test));
		  set_opt3_sym(sc->code, cadadr(test));
		}
	      return;
	    }
	  if (is_fx_safe(sc, test))
	    {
	      /* if (one_branch) fprintf(stderr, "%s\n", DISPLAY_80(sc->code)); */
	      pair_set_syntax_op(form, choose_if_optc(IF_A, one_branch, reversed, not_case));
	      if (not_case)
		set_c_call(cdar(sc->code), fx_choose(sc, cdar(sc->code), sc->envir, let_symbol_is_safe));
	      else set_c_call(sc->code, fx_choose(sc, sc->code, sc->envir, let_symbol_is_safe));
	    }
	  else pair_set_syntax_op(form, choose_if_optc(IF_P, one_branch, reversed, not_case));
	}
      else
	{
	  pair_set_syntax_op(form, choose_if_optc(IF_P, one_branch, reversed, not_case));
	  if (is_syntactic_symbol(car(test)))
	    {
	      pair_set_syntax_op(test, symbol_syntax_op_checked(test));
	      if ((symbol_syntax_op(car(test)) == OP_AND) ||
		  (symbol_syntax_op(car(test)) == OP_OR))
		{
		  opcode_t new_op;
		  s7_pointer old_code;
		  old_code = sc->code;
		  sc->code = test;
		  if (symbol_syntax_op(car(test)) == OP_AND) check_and(sc); else check_or(sc);
		  new_op = symbol_syntax_op_checked(test);
		  sc->code = old_code;
		  if ((new_op == OP_AND_P) || (new_op == OP_AND_AP) || (new_op == OP_AND_PAIR_P) || (new_op == OP_AND_SAFE_AA) ||
		      (new_op == OP_AND_SAFE_P) || (new_op == OP_AND_SAFE_P1) || (new_op == OP_AND_SAFE_P2) || (new_op == OP_AND_SAFE_P3))
		    pair_set_syntax_op(form, choose_if_optc(IF_ANDP, one_branch, reversed, not_case));
		  else
		    {
		      if ((new_op == OP_OR_P) || (new_op == OP_OR_AP) ||
			  (new_op == OP_OR_SAFE_P) || (new_op == OP_OR_SAFE_AA))
			pair_set_syntax_op(form, choose_if_optc(IF_ORP, one_branch, reversed, not_case));
		    }}}}
    }
  else /* test is symbol or constant, but constant here is nutty */
    {
      if (is_safe_symbol(test))
	pair_set_syntax_op(form, choose_if_optc(IF_S, one_branch, reversed, not_case));
    }
}

/* (cond <> (else <>)) only happens in old-fashioned code, so set_if_opts covers if/when/unless but not cond
 * g_and_3 and g_or_3 are slightly slower here??
 */

static s7_pointer check_if(s7_scheme *sc)
{
  s7_pointer cdr_code, form;
  form = sc->code;
  sc->code = cdr(sc->code);

  if (!is_pair(sc->code))                                /* (if) or (if . 1) */
    eval_error(sc, "(if): if needs at least 2 expressions: ~A", 41, form);

  cdr_code = cdr(sc->code);
  if (!is_pair(cdr_code))                                /* (if 1) */
    eval_error(sc, "(if ~A): if needs another clause", 32, car(sc->code));

  if (is_pair(cdr(cdr_code)))
    {
      if (is_not_null(cddr(cdr_code)))                   /* (if 1 2 3 4) */
	eval_error(sc, "too many clauses for if: ~A", 27, form);
    }
  else
    {
      if (is_not_null(cdr(cdr_code)))                    /* (if 1 2 . 3) */
	eval_error(sc, "if: ~A has improper list?", 25, form);
    }

  pair_set_syntax_op(form, OP_IF_UNCHECKED);
  set_if_opts(sc, form, is_null(cdr(cdr_code)), false);
  return(sc->code);
}


/* -------------------------------- when -------------------------------- */
static s7_pointer check_when(s7_scheme *sc)
{
  s7_pointer form;
  form = sc->code;
  set_current_code(sc, form);
  sc->code = cdr(sc->code);

  if (!is_pair(sc->code))                                            /* (when) or (when . 1) */
    eval_error(sc, "when has no expression or body:  ~A", 35, form);
  if (!is_pair(cdr(sc->code)))                                       /* (when 1) or (when 1 . 1) */
    eval_error(sc, "when has no body?:  ~A", 22, form);
  else
    {
      if (!s7_is_proper_list(sc, cddr(sc->code)))
	eval_error(sc, "when: stray dot?", 16, form);
    }

  pair_set_syntax_op(form, OP_WHEN_P);
  if (is_null(cddr(sc->code)))
    set_if_opts(sc, form, true, false);
  else
    {
      s7_pointer test;
      test = car(sc->code);
      if (is_safe_symbol(test))
	{
	  pair_set_syntax_op(form, OP_WHEN_S);
	  set_opt2_con(form, cadr(sc->code));
	  set_opt3_pair(form, cddr(sc->code));
	}
      else
	{
	  if (is_fx_safe(sc, test))
	    {
	      pair_set_syntax_op(form, OP_WHEN_A);
	      set_opt2_con(form, cadr(sc->code));
	      set_opt3_pair(form, cddr(sc->code));
	      set_c_call(sc->code, fx_choose(sc, sc->code, sc->envir, let_symbol_is_safe));
	    }
	  else
	    {
	      if ((is_pair(test)) && (car(test) == sc->and_symbol))
		{
		  /* an experiment... */
		  opcode_t new_op;
		  s7_pointer old_code;
		  pair_set_syntax_op(test, symbol_syntax_op_checked(test));
		  old_code = sc->code;
		  sc->code = test;
		  check_and(sc);
		  sc->code = old_code;
		  new_op = symbol_syntax_op_checked(test);
		  if (new_op == OP_AND_AP)
		    pair_set_syntax_op(form, OP_WHEN_AND_AP);
		}
	    }
	}
    }
  sc->code = cdr(form);
  push_stack_no_args(sc, OP_WHEN_PP, cdr(sc->code));
  sc->code = car(sc->code);
  return(NULL);
}

static bool op_when_s(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  if (is_true(sc, lookup(sc, cadr(sc->code))))
    {
      push_stack_no_args(sc, sc->begin_op, opt3_pair(sc->code)); /* cdddr(sc->code) */
      sc->code = opt2_con(sc->code);                             /* caddr(sc->code) */
      return(false);
    }
  sc->value = sc->unspecified;
  return(true);
}

static bool op_when_a(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  if (is_true(sc, fx_call(sc, cdr(sc->code))))
    {
      push_stack_no_args(sc, sc->begin_op, opt3_pair(sc->code)); /* cdddr(sc->code) */
      sc->code = opt2_con(sc->code);                             /* caddr(sc->code) */
      return(false);
    }
  sc->value = sc->unspecified;
  return(true);
}

static void op_when_p(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  push_stack_no_args(sc, OP_WHEN_PP, cddr(sc->code));
  sc->code = cadr(sc->code);
}

static bool op_when_and_ap(s7_scheme *sc)
{
  s7_pointer andp;
  set_current_code(sc, sc->code);
  andp = cdadr(sc->code);
  if (is_true(sc, fx_call(sc, andp)))
    {
      push_stack_no_args(sc, OP_WHEN_PP, cddr(sc->code));
      sc->code = cadr(andp);
      return(false);
    }
  sc->value = sc->unspecified;
  return(true);
}

static bool op_when_pp(s7_scheme *sc)
{
  if (is_true(sc, sc->value))
    {
      if (is_pair(cdr(sc->code)))
	push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
      sc->code = car(sc->code);
      return(false);
    }
  sc->value = sc->unspecified;
  return(true);
}


/* -------------------------------- unless -------------------------------- */
static s7_pointer check_unless(s7_scheme *sc)
{
  s7_pointer form;
  form = sc->code;
  set_current_code(sc, form);
  sc->code = cdr(sc->code);

  if (!is_pair(sc->code))                                            /* (unless) or (unless . 1) */
    eval_error(sc, "unless has no expression or body:  ~A", 37, form);
  if (!is_pair(cdr(sc->code)))                                       /* (unless 1) or (unless 1 . 1) */
    eval_error(sc, "unless has no body?:  ~A", 24, form);
  else
    {
      if (!s7_is_proper_list(sc, cddr(sc->code)))
	eval_error(sc, "unless: stray dot?", 18, form);
    }

  pair_set_syntax_op(form, OP_UNLESS_P);
  if (is_null(cddr(sc->code)))
    set_if_opts(sc, form, true, true);
  else
    {
      if (is_safe_symbol(car(sc->code)))
	{
	  pair_set_syntax_op(form, OP_UNLESS_S);
	  set_opt2_con(form, cadr(sc->code));
	  set_opt3_pair(form, cddr(sc->code));
	}
      else
	{
	  if (is_fx_safe(sc, car(sc->code)))
	    {
	      pair_set_syntax_op(form, OP_UNLESS_A);
	      set_opt2_con(form, cadr(sc->code));
	      set_opt3_pair(form, cddr(sc->code));
	      set_c_call(sc->code, fx_choose(sc, sc->code, sc->envir, let_symbol_is_safe));
	    }
	}
    }
  sc->code = cdr(form);
  push_stack_no_args(sc, OP_UNLESS_PP, cdr(sc->code));
  sc->code = car(sc->code);
  return(NULL);
}

static bool op_unless_s(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  if (is_false(sc, lookup(sc, cadr(sc->code))))
    {
      push_stack_no_args(sc, sc->begin_op, opt3_pair(sc->code)); /* cdddr(sc->code) */
      sc->code = opt2_con(sc->code);                             /* caddr(sc->code) */
      return(false);
    }
  sc->value = sc->unspecified;
  return(true);
}

static bool op_unless_a(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  if (is_false(sc, fx_call(sc, cdr(sc->code))))
    {
      push_stack_no_args(sc, sc->begin_op, opt3_pair(sc->code)); /* cdddr(sc->code) */
      sc->code = opt2_con(sc->code);                             /* caddr(sc->code) */
      return(false);
    }
  sc->value = sc->unspecified;
  return(true);
}

static void op_unless_p(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  push_stack_no_args(sc, OP_UNLESS_PP, cddr(sc->code));
  sc->code = cadr(sc->code);
}

static bool op_unless_pp(s7_scheme *sc)
{
  if (is_false(sc, sc->value))
    {
      if (is_pair(cdr(sc->code)))
	push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
      sc->code = car(sc->code);
      return(false);
    }
  sc->value = sc->unspecified;
  return(true);
}


/* -------------------------------- define -------------------------------- */
static s7_pointer print_truncate(s7_scheme *sc, s7_pointer code)
{
  if (tree_len(sc, code) > sc->print_length)
    return(object_to_truncated_string(sc, code, sc->print_length * 10));
  return(code);
}

static s7_pointer check_define(s7_scheme *sc)
{
  s7_pointer func, caller, form;
  bool starred;
  int32_t arity = CLOSURE_ARITY_NOT_SET;

  form = sc->code;
  sc->code = cdr(sc->code);

  starred = (sc->cur_op == OP_DEFINE_STAR);
  if (starred)
    {
      caller = sc->define_star_symbol;
      sc->cur_op = OP_DEFINE_STAR_UNCHECKED;
    }
  else
    {
      if (sc->cur_op == OP_DEFINE)
	caller = sc->define_symbol;
      else caller = sc->define_constant_symbol;
    }

  if (!is_pair(sc->code))
    eval_error_with_caller(sc, "~A: nothing to define? ~A", 25, caller, form);     /* (define) */

  if (!is_pair(cdr(sc->code)))
    {
      if (is_null(cdr(sc->code)))
	eval_error_with_caller(sc, "~A: no value? ~A", 16, caller, form);          /* (define var) */
      eval_error_with_caller(sc, "~A: stray dot? ~A", 17, caller, form);            /* (define var . 1) */
    }
  if (!is_pair(car(sc->code)))
    {
      if (is_not_null(cddr(sc->code)))                                           /* (define var 1 . 2) */
	return(s7_error(sc, sc->syntax_error_symbol,
			set_elist_3(sc, wrap_string(sc, "~A: more than one value? ~A", 27), caller, print_truncate(sc, form))));
      if (starred)
	eval_error(sc, "define* is restricted to functions: (define* ~{~S~^ ~})", 55, form);

      func = car(sc->code);
      if (!is_symbol(func))                                                      /* (define 3 a) */
	eval_error_with_caller(sc, "~A: define a non-symbol? ~S", 27, caller, func);
      if (is_keyword(func))                                                      /* (define :hi 1) */
	eval_error_with_caller(sc, "~A ~A: keywords are constants", 29, caller, func);
      if (is_syntactic_symbol(func))                                             /* (define and a) */
	{
	  if (sc->safety > NO_SAFETY)
	    s7_warn(sc, 128, "%s: syntactic keywords tend to behave badly if redefined\n", DISPLAY(func));
	  set_local(func);
	}
      if ((is_pair(cadr(sc->code))) &&               /* look for (define sym (lambda ...)) and treat it like (define (sym ...)...) */
	  ((caadr(sc->code) == sc->lambda_symbol) ||
	   (caadr(sc->code) == sc->lambda_star_symbol)) &&
	  (symbol_id(caadr(sc->code)) == 0))
	{
	  /* not is_global here because that bit might not be set for initial symbols (why not? -- redef as method etc) */
	  if (!is_pair(cdadr(sc->code)))                                         /* (define x (lambda . 1)) */
	    eval_error_with_caller(sc, "~A: stray dot? ~A", 17, caller, form);
	  if (!is_pair(cddr(cadr(sc->code))))                                    /* (define (f (arg))) or (define f (lambda (arg))) */
	    eval_error_with_caller(sc, "~A: no body: ~A", 15, caller, form);
	  if (caadr(sc->code) == sc->lambda_star_symbol)
	    check_lambda_star_args(sc, cadadr(sc->code), &arity);
	  else check_lambda_args(sc, cadadr(sc->code), &arity);
	  optimize_lambda(sc, caadr(sc->code) == sc->lambda_symbol, func, cadadr(sc->code), cddr(cadr(sc->code)));
	}
    }
  else
    {
      func = caar(sc->code);
      if (!is_symbol(func))                                                      /* (define (3 a) a) */
	eval_error_with_caller(sc, "~A: define a non-symbol? ~S", 27, caller, func);
      if (is_syntactic_symbol(func))                                             /* (define (and a) a) */
	{
	  if (sc->safety > NO_SAFETY)
	    s7_warn(sc, 128, "%s: syntactic keywords tend to behave badly if redefined\n", DISPLAY(func));
	  set_local(func);
	}
      if (starred)
	set_cdar(sc->code, check_lambda_star_args(sc, cdar(sc->code), &arity));
      else check_lambda_args(sc, cdar(sc->code), &arity);
      optimize_lambda(sc, !starred, func, cdar(sc->code), cdr(sc->code));
    }

  if ((sc->cur_op == OP_DEFINE) ||
      (sc->cur_op == OP_DEFINE_CONSTANT)) /* ?? 10-May-18 */
    {
      if ((is_pair(car(sc->code))) &&
	  (!symbol_has_setter(func)) &&
	  (!is_possibly_constant(func)))
	pair_set_syntax_op(form, OP_DEFINE_FUNCHECKED);
      else pair_set_syntax_op(form, OP_DEFINE_UNCHECKED);
    }
  else
    {
      if (starred)
	pair_set_syntax_op(form, OP_DEFINE_STAR_UNCHECKED);
      else pair_set_syntax_op(form, OP_DEFINE_CONSTANT_UNCHECKED);
    }
  sc->code = form;
  return(sc->code);
}

static bool define_unchecked_ex(s7_scheme *sc)
{
  if (sc->cur_op == OP_DEFINE_STAR_UNCHECKED)
    {
      s7_pointer x;
      uint64_t typ;
      if (is_pair(cdar(sc->code))) typ = T_CLOSURE_STAR | closure_bits(cdr(sc->code)); else typ = T_CLOSURE;
      new_cell(sc, x, typ);
      closure_set_args(x, cdar(sc->code));
      closure_set_body(x, cdr(sc->code));
      if (is_pair(cddr(sc->code))) set_closure_has_multiform(x); else set_closure_has_one_form(x);
      closure_set_let(x, sc->envir);
      closure_set_arity(x, CLOSURE_ARITY_NOT_SET);
      closure_set_setter(x, sc->F);
      sc->capture_let_counter++;
      sc->value = x;
      sc->code = caar(sc->code);
      return(false);
    }

  if (!is_pair(car(sc->code)))
    {
      s7_pointer x;
      x = car(sc->code);
      sc->code = cadr(sc->code);
      if (is_pair(sc->code))
	{
	  push_stack(sc, OP_DEFINE1, sc->nil, x);
	  sc->cur_op = optimize_op(sc->code);
	  return(true);
	}

      if (is_symbol(sc->code))
	sc->value = find_global_symbol_checked(sc, sc->code);
      else sc->value = sc->code;
      sc->code = x;
    }
  else
    {
      s7_pointer x,args;
      /* a closure.  If we called this same code earlier (a local define), the only thing
       *   that is new here is the environment -- we can't blithely save the closure object
       *   in opt2 somewhere, and pick it up the next time around (since call/cc might take
       *   us back to the previous case).  We also can't re-use opt2(sc->code) because opt2
       *   is not cleared in the gc.
       */
      args = cdar(sc->code);
      make_closure_with_let(sc, x, args, cdr(sc->code), sc->envir, (is_null(args)) ? 0 : CLOSURE_ARITY_NOT_SET);
      sc->value = T_Pos(x);
      sc->code = caar(sc->code);
    }
  return(false);
}

static s7_pointer make_funclet(s7_scheme *sc, s7_pointer new_func, s7_pointer func_name, s7_pointer outer_env)
{
  s7_pointer new_env;
  new_cell_no_check(sc, new_env, T_LET | T_FUNCLET);
  let_id(new_env) = ++sc->let_number;
  let_set_slots(new_env, slot_end(sc));
  set_outlet(new_env, outer_env);
  closure_set_let(new_func, new_env);
  funclet_set_function(new_env, func_name); /* __func__ returns at least funclet_function */
  if (is_safe_closure(new_func))
    {
      s7_pointer arg, first_default;
      first_default = sc->nil;
      if (is_closure(new_func))
	{
	  for (arg = closure_args(new_func); is_pair(arg); arg = cdr(arg))
	    make_slot_1(sc, new_env, car(arg), sc->nil);
	  if (is_symbol(arg))
	    {
	      s7_pointer slot;
	      slot = make_slot_1(sc, new_env, arg, sc->nil);
	      set_is_rest_slot(slot);
	    }
	  let_set_slots(new_env, reverse_slots(sc, let_slots(new_env)));
	}
      else
	{
	  s7_pointer slot;
	  for (arg = closure_args(new_func); is_pair(arg); arg = cdr(arg))
	    {
	      if (is_pair(car(arg)))
		{
		  s7_pointer val;
		  val = cadar(arg);
		  slot = make_slot_1(sc, new_env, caar(arg), sc->nil);
		  slot_set_expression(slot, val);
		  if ((is_symbol(val)) || (is_pair(val)))
		    {
		      if (is_null(first_default))
			first_default = slot;
		      set_slot_defaults(slot);
		    }
		}
	      else
		{
		  if (is_keyword(car(arg)))
		    {
		      if (car(arg) == sc->key_rest_symbol)
			{
			  arg = cdr(arg);
			  slot = make_slot_1(sc, new_env, car(arg), sc->nil);
			  slot_set_expression(slot, sc->nil);
			}
		    }
		  else
		    {
		      slot = make_slot_1(sc, new_env, car(arg), sc->nil);
		      slot_set_expression(slot, sc->F);
		    }
		}
	    }
	  if (is_symbol(arg))
	    {
	      slot = make_slot_1(sc, new_env, arg, sc->nil);     /* set up rest arg */
	      set_is_rest_slot(slot);
	      slot_set_expression(slot, sc->nil);
	    }
	  if (tis_slot(let_slots(new_env)))
	    {
	      let_set_slots(new_env, reverse_slots(sc, let_slots(new_env)));
	      slot_set_pending_value(let_slots(new_env), first_default);
	    }
	}
    }
  return(new_env);
}

static bool op_define_constant(s7_scheme *sc)
{
  s7_pointer code;
  code = cdr(sc->code);
  if ((!is_pair(code)) || (!is_pair(cdr(code)))) /* (define-constant) */
    eval_error(sc, "define-constant: not enough arguments: ~S", 41, sc->code);

  if ((is_symbol(car(code))) &&                /* (define-constant abs abs): "abs will not be touched" */
      (car(code) == cadr(code)) &&
      (symbol_id(car(code)) == 0) &&           /* else (let iter ... (define-constant iter iter) ...) -> segfault on later calls */
      (is_null(cddr(code))))
    {
      s7_pointer sym;
      sym = car(code);
      set_immutable(global_slot(sym)); /* id == 0 so its global */
      set_possibly_constant(sym);
      sc->value = lookup_checked(sc, car(code));
      return(true);
    }
  push_stack_no_args(sc, OP_DEFINE_CONSTANT1, car(code));
  return(false);
}

static void define_funchecked(s7_scheme *sc)
{
  s7_pointer new_func, code, slot;
  code = cdr(sc->code);
  sc->value = caar(code);

  new_cell(sc, new_func, T_CLOSURE | T_COPY_ARGS);
  closure_set_args(new_func, cdar(code));
  closure_set_body(new_func, cdr(code));
  if (is_pair(cddr(code))) set_closure_has_multiform(new_func); else set_closure_has_one_form(new_func);
  closure_set_setter(new_func, sc->F);
  closure_set_arity(new_func, CLOSURE_ARITY_NOT_SET);
  sc->capture_let_counter++;

  if (is_safe_closure_body(cdr(code)))
    {
      set_safe_closure(new_func);
      if (is_very_safe_closure_body(cdr(code)))
	set_very_safe_closure(new_func);
      make_funclet(sc, new_func, sc->value, sc->envir);
    }
  else closure_set_let(new_func, sc->envir);  /* unsafe closures created by other functions do not support __func__ */

  if (let_id(sc->envir) < symbol_id(sc->value))
    sc->let_number++; /* dummy let, force symbol lookup */

  /* add_slot(sc->envir, sc->value, new_func); but with local id */
  new_cell_no_check(sc, slot, T_SLOT);
  slot_set_symbol(slot, sc->value);
  slot_set_value(slot, new_func);
  symbol_set_local(sc->value, sc->let_number, slot);
  set_next_slot(slot, let_slots(sc->envir));
  let_set_slots(sc->envir, slot);

  set_local(sc->value);
  sc->value = new_func;
}

static s7_pointer check_define_macro(s7_scheme *sc, opcode_t op)
{
  s7_pointer x, y, caller;
  caller = sc->define_macro_symbol;
  switch (op)
    {
    case OP_DEFINE_MACRO:      caller = sc->define_macro_symbol;      break;
    case OP_DEFINE_MACRO_STAR: caller = sc->define_macro_star_symbol; break;
    case OP_DEFINE_BACRO:      caller = sc->define_bacro_symbol;      break;
    case OP_DEFINE_BACRO_STAR: caller = sc->define_bacro_star_symbol; break;
    case OP_DEFINE_EXPANSION:  caller = sc->define_expansion_symbol;  break;
    }

  if (!is_pair(sc->code))                                               /* (define-macro . 1) */
    eval_error_with_caller(sc, "~A name missing (stray dot?): ~A", 32, caller, sc->code);
  if (!is_pair(car(sc->code)))                                          /* (define-macro a ...) */
    return(wrong_type_argument_with_type(sc, caller, 1, car(sc->code), wrap_string(sc, "a list: (name ...)", 18)));

  x = caar(sc->code);
  if (!is_symbol(x))
    eval_error_with_caller(sc, "~A: ~S is not a symbol?", 23, caller, x);
  if (is_syntactic_symbol(x))
    {
      if (sc->safety > NO_SAFETY)
	s7_warn(sc, 128, "%s: syntactic keywords tend to behave badly if redefined\n", DISPLAY(x));
      set_local(x);
    }
  if (is_constant_symbol(sc, x))
    eval_error_with_caller(sc, "~A: ~S is constant", 18, caller, x);

  if (!is_pair(cdr(sc->code)))                                        /* (define-macro (...)) */
    eval_error_with_caller(sc, "~A ~A, but no body?", 19, caller, x);

  y = cdar(sc->code);                                                 /* the arglist */
  if ((!is_list(y)) &&
      (!is_symbol(y)))
    return(s7_error(sc, sc->syntax_error_symbol,                      /* (define-macro (mac . 1) ...) */
		    set_elist_3(sc, wrap_string(sc, "macro ~A argument list is ~S?", 29), x, y)));

  for ( ; is_pair(y); y = cdr(y))
    if ((!is_symbol(car(y))) &&
	((op == OP_DEFINE_MACRO) || (op == OP_DEFINE_BACRO) || (op == OP_DEFINE_EXPANSION)))
      return(s7_error(sc, sc->syntax_error_symbol,                    /* (define-macro (mac 1) ...) */
		      set_elist_3(sc, wrap_string(sc, "define-macro ~A argument name is not a symbol: ~S", 49), x, y)));

  if ((op == OP_DEFINE_MACRO_STAR) || (op == OP_DEFINE_BACRO_STAR))
    set_cdar(sc->code, check_lambda_star_args(sc, cdar(sc->code), NULL));
  else check_lambda_args(sc, cdar(sc->code), NULL);

  return(sc->code);
}

static s7_pointer op_define_macro_with_setter(s7_scheme *sc)
{
  sc->code = sc->value;
  if ((!is_pair(sc->code)) ||
      (!is_pair(car(sc->code))) ||
      (!is_symbol(caar(sc->code))))
    eval_error(sc, "define-macro: ~S does not look like a macro?", 44, sc->code);
  if ((is_immutable(sc->envir)) &&
      (is_let(sc->envir))) /* not () */
    eval_error_no_return(sc, sc->syntax_error_symbol, "define-macro ~S: let is immutable", 33, caar(sc->code));
  sc->value = make_macro(sc, sc->cur_op);
  return(NULL);
}

static bool op_define_macro(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  check_define_macro(sc, sc->cur_op);
  if (symbol_has_setter(caar(sc->code)))
    {
      s7_pointer x;
      x = symbol_to_slot(sc, caar(sc->code));
      if ((is_slot(x)) &&
	  (slot_has_setter(x)))
	{
	  sc->value = bind_symbol_with_setter(sc, OP_DEFINE_MACRO_WITH_SETTER, caar(sc->code), sc->code);
	  if (sc->value == sc->no_value)
	    return(false);
	  sc->code = sc->value;
	}
    }
  if ((is_immutable(sc->envir)) &&
      (is_let(sc->envir))) /* not () */
    eval_error_no_return(sc, sc->syntax_error_symbol, "define-macro ~S: let is immutable", 33, caar(sc->code)); /* need eval_error_no_return_with_caller? */
  sc->value = make_macro(sc, sc->cur_op);
  return(true);
}

static int32_t expansion_ex(s7_scheme *sc)
{
  int64_t loc;
  s7_pointer caller;

  /* read-time macro expansion:
   *   (define-macro (hi a) (format #t "hi...") `(+ ,a 1))
   *   (define (ho b) (+ 1 (hi b)))
   * here sc->value is: (ho b), (hi b), (+ 1 (hi b)), (define (ho b) (+ 1 (hi b)))
   * but... first we can't tell for sure at this point that "hi" really is a macro
   *   (letrec ((hi ... (hi...))) will be confused about the second hi,
   *   or (call/cc (lambda (hi) (hi 1))) etc.
   * second, figuring out that we're quoted is not easy -- we have to march all the
   * way to the bottom of the stack looking for op_read_quote or op_read_vector
   *    #(((hi)) 2) or '(((hi)))
   * or op_read_list with args not equal (quote) or (macroexpand)
   *    '(hi 3) or (macroexpand (hi 3) or (quote (hi 3))
   * and those are only the problems I noticed!
   *
   * The hardest of these problems involve shadowing, so Rick asked for "define-expansion"
   *   which is like define-macro, but the programmer guarantees that the macro
   *   name will not be shadowed.
   *
   * to make expansion recognition fast here, define-expansion sets the T_EXPANSION
   *   bit in the symbol as well as the value:
   *   set_type(sc->code, T_EXPANSION | T_SYMBOL)
   * but this can lead to confusion because the expansion name is now globally identified as an expansion.
   *    (let () (define-expansion (ex1 a) `(+ ,a 1)) (display (ex1 3)))
   *    (define (ex1 b) (* b 2)) (display (ex1 3))
   * since this happens at the top level, the first line is evaluated, ex1 becomes an expansion.
   * but the reader has no idea about lets and whatnot, so in the second line, ex1 is still an expansion
   * to the reader, so it sees (define (+ b 1) ...) -- error!  To support tail-calls, there's no
   * way in eval to see the let close, so we can't clear the expansion flag when the let is done.
   * But we don't want define-expansion to mimic define-constant (via T_IMMUTABLE) because programs
   * like lint need to cancel reader-cond (for example).  So, we allow an expansion to be redefined,
   * and check here that the expander symbol still refers to an expansion.
   *
   * but in (define (ex1 b) b), the reader doesn't know we're in a define call (or it would be
   *   a bother to notice), so to redefine an expansion, first (set! ex1 #f) or (define ex1 #f),
   *   then (define (ex1 b) b).
   *
   * This is a mess!  Maybe we should insist that expansions are always global.
   *
   * run-time expansion and splicing into the code as in CL won't work in s7 because macros
   *   are first-class objects.  For example (define (f m) (m 1)), call it with a macro, say `(+ ,arg 1),
   *   and in CL-style, you'd now have the body (+ ,arg 1) or maybe even 2, now call f with a function,
   *   or some other macro -- oops!
   */

  loc = s7_stack_top(sc) - 1;
  if (is_pair(stack_args(sc->stack, loc)))
    caller = car(stack_args(sc->stack, loc)); /* this can be garbage */
  else caller = sc->F;
  if ((loc >= 3) &&
      (stack_op(sc->stack, loc) != OP_READ_QUOTE) &&             /* '(hi 1) for example */
      (stack_op(sc->stack, loc) != OP_READ_VECTOR) &&            /* #(reader-cond) for example */
      (caller != sc->quote_symbol) &&          /* (quote (hi 1)) */
      (caller != sc->macroexpand_symbol) &&    /* (macroexpand (hi 1)) */
      (caller != sc->define_expansion_symbol)) /* (define-expansion ...) being reloaded/redefined */
    {
      s7_pointer symbol, slot;
      /* we're playing fast and loose with sc->envir in the reader, so here we need a disaster check */
#if S7_DEBUGGING
      if (unchecked_type(sc->envir) != T_LET) sc->envir = sc->nil;
#else
      if (!is_let(sc->envir)) sc->envir = sc->nil;
#endif
      symbol = car(sc->value);

      if ((symbol_id(symbol) == 0) ||
	  (sc->envir == sc->nil))
	slot = global_slot(symbol);
      else slot = symbol_to_slot(sc, symbol);

      if (is_slot(slot))
	sc->code = slot_value(slot);
      else sc->code = sc->undefined;

      if ((!is_macro(sc->code)) || (!is_expansion(sc->code)))
	clear_expansion(symbol);
      else
	{
	  sc->args = copy_list(sc, cdr(sc->value));
	  return(goto_APPLY);
	}
    }
  return(fall_through);
}


/* -------------------------------- with-let -------------------------------- */
static s7_pointer check_with_let(s7_scheme *sc)
{
  s7_pointer form;
  form = cdr(sc->code);

  if (!is_pair(form))                            /* (with-let . "hi") */
    eval_error(sc, "with-let takes an environment argument: ~A", 42, sc->code);
  if (!is_pair(cdr(form)))                       /* (with-let e) -> an error? */
    eval_error(sc, "with-let body is messed up: ~A", 30, sc->code);
  if ((!is_pair(cddr(form))) &&
      (!is_null(cddr(form))))
    eval_error(sc, "with-let body has stray dot? ~A", 31, sc->code);
  if (!s7_is_proper_list(sc, cdr(form)))
    eval_error(sc, "stray dot in with-let body: ~S", 30, sc->code);

  pair_set_syntax_op(sc->code, OP_WITH_LET_UNCHECKED);
  if ((is_symbol(car(form))) &&
      (is_pair(cadr(form))))
    pair_set_syntax_op(sc->code, OP_WITH_LET_S);

  return(form);
}

static bool op_with_let_unchecked(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  sc->value = car(sc->code);
  if (!is_pair(sc->value))
    {
      if (is_symbol(sc->value))
	sc->value = lookup_checked(sc, sc->value);
      sc->code = cdr(sc->code);
      return(false);
    }
  push_stack_no_args(sc, OP_WITH_LET1, cdr(sc->code));
  sc->code = sc->value;   /* eval env arg */
  return(true);
}

static s7_pointer op_with_let_s(s7_scheme *sc)
{
  s7_pointer e;
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  e = lookup_checked(sc, car(sc->code));
  if (e == sc->rootlet)
    sc->envir = sc->nil;
  else
    {
      if (!is_let(e))
	eval_type_error(sc, "with-let takes an environment argument: ~A", 42, e);
      set_with_let_let(e);
      let_id(e) = ++sc->let_number;
      sc->envir = e;
      /* if the let in question has 10,000 names (e.g. *gtk*) this loop (which can't be avoided currently)
       *   will be noticeable in a few cases.  So, instead of saying (with-let *gtk* ...) use something
       *   equivalent to (with-let (sublet *gtk*) ...) which is cleaner anyway.  (In my timing tests, even
       *   when pounding on this one block, the loop only amounts to 1% of the time.  Normally it's
       *   negligible).
       */
      update_symbol_ids(sc, e);
    }
  sc->code = T_Pair(cdr(sc->code));
  return(NULL);
}


/* -------------------------------- cond -------------------------------- */
static s7_pointer check_cond(s7_scheme *sc)
{
  bool has_feed_to = false;
  s7_pointer x, form;

  form = sc->code;
  sc->code = cdr(sc->code);

  if (!is_pair(sc->code))                                             /* (cond) or (cond . 1) */
    eval_error(sc, "cond, but no body: ~A", 21, form);

  for (x = sc->code; is_pair(x); x = cdr(x))
    {
      if (!is_pair(car(x)))                                           /* (cond 1) or (cond (#t 1) 3) */
	eval_error(sc, "every clause in cond must be a list: ~A", 39, car(x));
      else
	{
	  s7_pointer y;
	  y = car(x);
	  if (!s7_is_proper_list(sc, cdr(y)))
	    eval_error(sc, "stray dot? ~A", 13, y);
	  if (is_pair(cdr(y)))
	    {
	      if ((cadr(y) == sc->feed_to_symbol) &&
		  (s7_symbol_value(sc, sc->feed_to_symbol) == sc->undefined))
		{
		  has_feed_to = true;
		  if (!is_pair(cddr(y)))                                  /* (cond (#t =>)) or (cond (#t => . 1)) */
		    eval_error(sc, "cond: '=>' target missing?  ~A", 30, x);
		  if (is_pair(cdddr(y)))                                  /* (cond (1 => + abs)) */
		    eval_error(sc, "cond: '=>' has too many targets: ~A", 35, x);
		}
	    }
	}
    }
  if (is_not_null(x))                                             /* (cond ((1 2)) . 1) */
    eval_error(sc, "cond: stray dot? ~A", 19, form);

  if (has_feed_to)
    {
      pair_set_syntax_op(form, OP_COND_UNCHECKED);
      if (is_null(cdr(sc->code)))
	{
	  s7_pointer expr, f;
	  expr = car(sc->code);
	  f = caddr(expr);
	  if ((is_pair(f)) &&
	      (car(f) == sc->lambda_symbol) &&
	      (is_pair(cdr(f))) &&            /* not => (lambda) */
	      (is_pair(cddr(f))) &&
	      (is_null(cdddr(f))))
	    {
	      s7_pointer arg;
	      arg = cadr(f);
	      if ((is_pair(arg)) &&
		  (is_null(cdr(arg))) &&
		  (is_symbol(car(arg))))
		{
		  /* (define (hi) (cond (#t => (lambda (s) s)))) */
		  set_opt2_lambda(sc->code, caddar(sc->code));  /* (lambda ...) above */
		  pair_set_syntax_op(form, OP_COND_FEED);
		}
	    }
	}
    }
  else
    {
      s7_pointer p;
      bool xopt = true;
      pair_set_syntax_op(form, OP_COND_SIMPLE);

      for (p = sc->code; xopt && (is_pair(p)); p = cdr(p))
	xopt = is_fx_safe(sc, caar(p)); /* caar=test */
      if (xopt)
	{
	  int32_t i;
	  bool eopt = true;

	  pair_set_syntax_op(form, OP_COND_FX);
	  for (i = 0, p = sc->code; is_pair(p); i++, p = cdr(p))
	    set_c_call(car(p), fx_choose(sc, car(p), (is_null(sc->envir)) ? sc->rootlet : sc->envir, let_symbol_is_safe));
	  if (i == 2)
	    pair_set_syntax_op(form, OP_COND_FX_2);

	  for (p = sc->code; eopt && (is_pair(p)); p = cdr(p))
	    eopt = ((!is_pair(cdar(p))) || (!is_pair(cddar(p))));
	  if (eopt)
	    {
	      pair_set_syntax_op(form, OP_COND_FX_P);
	      if (i == 2)
		{
		  p = caadr(sc->code);
		  if ((p == sc->else_symbol) ||
		      (p == sc->T))
		    pair_set_syntax_op(form, OP_COND_FX_1P_ELSE);
		}
	      else
		{
		  if (i == 3)
		    {
		      p = caaddr(sc->code);
		      if ((p == sc->else_symbol) ||
			  (p == sc->T))
			pair_set_syntax_op(form, OP_COND_FX_2P_ELSE);
		    }
		}
	    }
	}
      else
	{
	  bool eopt = true;
	  for (p = sc->code; eopt && (is_pair(p)); p = cdr(p))
	    eopt = ((is_pair(cdar(p))) && (!is_pair(cddar(p))));
	  if (eopt)
	    pair_set_syntax_op(form, OP_COND_SIMPLE_P);
	}
    }
  sc->code = form;
  return(sc->code);
}

static void op_cond_unchecked(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  push_stack_no_args(sc, OP_COND1, sc->code);
  sc->code = caar(sc->code);
}

static bool op_cond_simple(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  sc->value = caar(sc->code);
  if (is_pair(sc->value))
    {
      push_stack_no_args(sc, OP_COND1_SIMPLE, sc->code);
      sc->code = sc->value;
      return(true);
    }
  if ((is_symbol(sc->value)) &&
      ((sc->value != sc->else_symbol) || (symbol_id(sc->else_symbol) != 0)))
    sc->value = lookup_checked(sc, sc->value);
  return(false);
}

static bool op_cond_simple_p(s7_scheme *sc)
{
  set_current_code(sc, sc->code);
  sc->code = cdr(sc->code);
  sc->value = caar(sc->code);
  if (is_pair(sc->value))
    {
      push_stack_no_args(sc, OP_COND1_SIMPLE_P, sc->code);
      sc->code = sc->value;
      return(true);
    }
  if ((is_symbol(sc->value)) &&
      ((sc->value != sc->else_symbol) || (symbol_id(sc->else_symbol) != 0)))
    sc->value = lookup_checked(sc, sc->value);
  return(false);
}

static bool op_cond1(s7_scheme *sc)
{
  if (is_true(sc, sc->value))
    {
    COND1:
      sc->code = cdar(sc->code);
      if (is_pair(sc->code))
	{
	  if (is_null(cdr(sc->code)))
	    {
	      sc->code = car(sc->code);
	      sc->cur_op = optimize_op(sc->code);
	      return(true);
	    }
	  /* check_cond catches stray dots */
	  if ((car(sc->code) == sc->feed_to_symbol) &&
	      (s7_symbol_value(sc, sc->feed_to_symbol) == sc->undefined))
	    return(false);
	  push_stack_no_args(sc, sc->begin_op, T_Pair(cdr(sc->code)));
	  sc->code = car(sc->code);
	  sc->cur_op = optimize_op(sc->code);
	  return(true);
	}
      if (is_null(sc->code))
	{
	  if (is_multiple_value(sc->value))                             /* (+ 1 (cond ((values 2 3)))) */
	    sc->value = splice_in_values(sc, multiple_value(sc->value));
	  /* no result clause, so return test, (cond (#t)) -> #t, (cond ((+ 1 2))) -> 3 */
	  pop_stack(sc);
	  return(true);
	}
    }
  sc->code = cdr(sc->code);
  if (is_null(sc->code))
    {
      sc->value = sc->unspecified; /* changed 31-Dec-15 */
      /* r7rs sez the value if no else clause is unspecified, and this choice makes cond consistent with if and case,
       *   and rewrite choices between the three are simpler if they are consistent.
       */
      pop_stack(sc);
      return(true);
    }
  if ((caar(sc->code) == sc->else_symbol) &&
      (symbol_id(sc->else_symbol) == 0))
    {
      sc->value = sc->else_symbol;
      goto COND1;
    }
  push_stack_no_args(sc, OP_COND1, sc->code);
  sc->code = caar(sc->code);
  sc->cur_op = optimize_op(sc->code);
  return(true);
}

static bool op_cond1_simple(s7_scheme *sc)
{
  while (true)
    {
      if (is_true(sc, sc->value))
	{
	  sc->code = T_Lst(cdar(sc->code));
	  if (is_null(sc->code))
	    {
	      if (is_multiple_value(sc->value))
		sc->value = splice_in_values(sc, multiple_value(sc->value));
	      pop_stack(sc);
	      return(true);
	    }
	  return(false);
	}
      sc->code = cdr(sc->code);
      if (is_null(sc->code))
	{
	  sc->value = sc->unspecified;
	  pop_stack(sc);
	  return(true);
	}
      sc->value = caar(sc->code);
      if (is_pair(sc->value))
	{
	  push_stack_no_args(sc, OP_COND1_SIMPLE, sc->code);
	  sc->code = sc->value;
	  sc->cur_op = optimize_op(sc->code);
	  return(true);
	}
      if ((is_symbol(sc->value)) &&
	  ((sc->value != sc->else_symbol) || (symbol_id(sc->else_symbol) != 0)))
	sc->value = lookup_checked(sc, sc->value);
    }
}

static bool op_cond1_simple_p(s7_scheme *sc)
{
  while (true)
    {
      if (is_true(sc, sc->value))
	{
	  sc->code = cadar(sc->code);
	  return(false);
	}
      sc->code = cdr(sc->code);
      if (is_null(sc->code))
	{
	  sc->value = sc->unspecified;
	  return(true);
	}
      sc->value = caar(sc->code);
      if (is_pair(sc->value))
	{
	  push_stack_no_args(sc, OP_COND1_SIMPLE_P, sc->code);
	  sc->code = sc->value;
	  return(false);
	}
      if ((is_symbol(sc->value)) &&
	  ((sc->value != sc->else_symbol) || (symbol_id(sc->else_symbol) != 0)))
	sc->value = lookup_checked(sc, sc->value);
    }
}

static bool op_cond_fx(s7_scheme *sc)
{
  s7_pointer p;
  for (p = cdr(sc->code); is_pair(p); p = cdr(p))
    {
      sc->value = fx_call(sc, car(p));
      if (is_true(sc, sc->value))
	{
	  sc->code = T_Lst(cdar(p));
	  return(is_null(sc->code));
	}
    }
  sc->value = sc->unspecified;
  return(true);
}

static bool op_cond_fx_2(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->value = fx_call(sc, car(p));
  if (!is_true(sc, sc->value))
    {
      p = cdr(p);
      sc->value = fx_call(sc, car(p));
      if (!is_true(sc, sc->value))
	{
	  sc->value = sc->unspecified;
	  return(true);
	}
    }
  sc->code = T_Lst(cdar(p));
  return(is_null(sc->code));
}

static inline bool fx_cond_value(s7_scheme *sc)
{
  if (is_null(sc->code))
    return(true);
  sc->code = car(sc->code);
  if (is_pair(sc->code))
    return(false);
  if (is_symbol(sc->code))
    sc->value = lookup_checked(sc, sc->code);
  else sc->value = sc->code;
  return(true);
}

static bool op_cond_fx_p(s7_scheme *sc)
{
  s7_pointer p;
  /* set_current_code(sc, sc->code); */
  for (p = cdr(sc->code); is_pair(p); p = cdr(p))
    {
      sc->value = fx_call(sc, car(p));
      if (is_true(sc, sc->value))
	{
	  sc->code = T_Lst(cdar(p));
	  return(fx_cond_value(sc));
	}
    }
  sc->value = sc->unspecified;
  return(true);
}

static bool op_cond_fx_1p_else(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->value = fx_call(sc, car(p));
  if (is_true(sc, sc->value))
    sc->code = T_Lst(cdar(p));
  else
    {
      sc->code = cdadr(p);
      sc->value = sc->else_symbol;
    }
  return(fx_cond_value(sc));
}

static bool op_cond_fx_2p_else(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->value = fx_call(sc, car(p));
  if (is_true(sc, sc->value))
    sc->code = T_Lst(cdar(p));
  else
    {
      p = cdr(p);
      sc->value = fx_call(sc, car(p));
      if (is_true(sc, sc->value))
	sc->code = T_Lst(cdar(p));
      else
	{
	  sc->code = cdadr(p);
	  sc->value = sc->else_symbol; /* in case (else) */
	}
    }
  return(fx_cond_value(sc));
}


/* -------------------------------- set! -------------------------------- */
static void set_dilambda_opt(s7_scheme *sc, s7_pointer form, opcode_t opt, s7_pointer expr)
{
  s7_pointer func;
  func = lookup_checked(sc, car(expr));
  if ((is_closure(func)) &&
      (is_closure(closure_setter(func))) &&
      (is_safe_closure(closure_setter(func))))
    {
      s7_pointer setter;
      setter = closure_setter(func);
      pair_set_syntax_op(form, opt);
      if ((!(is_let(closure_let(setter)))) ||
	  (!(is_funclet(closure_let(setter)))))
	make_funclet(sc, setter, car(expr), closure_let(setter));
    }
}

static inline s7_pointer check_set(s7_scheme *sc)
{
  s7_pointer form;
  form = sc->code;
  sc->code = cdr(sc->code);

  if (!is_pair(sc->code))
    {
      if (is_null(sc->code))                                             /* (set!) */
	eval_error(sc, "set!: not enough arguments: ~A", 30, form);
      eval_error(sc, "set!: stray dot? ~A",19,  form);                   /* (set! . 1) */
    }
  if (!is_pair(cdr(sc->code)))
    {
      if (is_null(cdr(sc->code)))                                        /* (set! var) */
	eval_error(sc, "set!: not enough arguments: ~A", 30, form);
      eval_error(sc, "set!: stray dot? ~A", 19, form);                   /* (set! var . 1) */
    }
  if (is_not_null(cddr(sc->code)))                                       /* (set! var 1 2) */
    eval_error(sc, "~A: too many arguments to set!", 30, form);

  /* cadr (the value) has not yet been evaluated */

  if (is_pair(car(sc->code)))
    {
      if (is_pair(caar(sc->code)))
	{
	  if (!s7_is_list(sc, cdar(sc->code)))                          /* (set! ('(1 2) . 0) 1) */
	    eval_error(sc, "improper list of args to set!: ~A", 33, form);
	}
      if (!s7_is_proper_list(sc, car(sc->code)))                        /* (set! ("hi" . 1) #\a) or (set! (#(1 2) . 1) 0) */
	eval_error(sc, "set! target is an improper list: (set! ~A ...)", 46, car(sc->code));
    }
  else
    {
      if (!is_symbol(car(sc->code)))                                    /* (set! 12345 1) */
	eval_error(sc, "set! can't change ~S", 20, car(sc->code));
      else
	{
	  if (is_constant_symbol(sc, car(sc->code)))                    /* (set! pi 3) */
	    eval_error(sc, "set!: can't alter constant binding: ~S", 38, car(sc->code));
	}
    }

  if (is_pair(car(sc->code)))
    {
      /* here we have (set! (...) ...) */
      s7_pointer inner, value;
      inner = car(sc->code);
      value = cadr(sc->code);

      pair_set_syntax_op(form, OP_SET_UNCHECKED);
      if (is_symbol(car(inner)))
	{
	  if ((is_null(cdr(inner))) &&
	      (!is_pair(value)) &&
	      (is_global(car(inner))) &&
	      (is_c_function(slot_value(global_slot(car(inner))))) &&
	      (c_function_required_args(slot_value(global_slot(car(inner)))) == 0))
	    pair_set_syntax_op(form, OP_SET_PWS);
	  else
	    {
	      if ((is_pair(cdr(inner))) &&
		  (!is_pair(cddr(inner)))) /* we check cddr(sc->code) above */  /* this leaves (set! (vect i j) 1) unhandled so we go to OP_SET_UNCHECKED */
		{
		  if (!is_pair(cadr(inner)))
		    {
		      /* (set! (f s) ...) */
		      if (!is_pair(value))
			{
			  pair_set_syntax_op(form, OP_SET_PAIR);
			  if (is_symbol(car(inner)))
			    set_dilambda_opt(sc, form, OP_SET_DILAMBDA, inner);
			}
		      else
			{
			  pair_set_syntax_op(form, OP_SET_PAIR_P);  /* splice_in_values protects us here from values */
			  if (is_fx_safe(sc, value))
			    {
			      s7_pointer obj;
			      annotate_arg(sc, cdr(sc->code), sc->envir);
			      pair_set_syntax_op(form, OP_SET_PAIR_ZA);
			      obj = lookup_checked(sc, car(inner));
			      if ((is_c_function(obj)) &&
				  (is_c_function(c_function_setter(obj))))
				pair_set_syntax_op(form, OP_SET_PAIR_A);
			    }
			  else
			    {
			      if (is_symbol(car(inner)))
				set_dilambda_opt(sc, form, OP_SET_DILAMBDA_P, inner);
			    }
			}
		    }
		  else
		    {
		      if ((caadr(inner) == sc->quote_symbol) &&
			  (is_symbol(car(inner))) &&
			  ((is_normal_symbol(value)) ||
			   (is_fx_safe(sc, value))))
			{
			  if (is_safe_symbol(value))
			    pair_set_syntax_op(form, OP_SET_LET_S);
			  else
			    {
			      pair_set_syntax_op(form, OP_SET_LET_FX);
			      set_c_call(cdr(sc->code), fx_choose(sc, cdr(sc->code), sc->envir, let_symbol_is_safe));
			    }}}}}}
      sc->code = form;
      return(sc->code);
    }

  pair_set_syntax_op(form, OP_SET_NORMAL);
  if (is_symbol(car(sc->code)))
    {
      s7_pointer settee, value;
      settee = car(sc->code);
      value = cadr(sc->code);

      if ((!symbol_has_setter(settee)) &&
	  (!is_syntactic_symbol(settee)))
	{
	  if (is_normal_symbol(value))
	    {
	      if (is_slot(symbol_to_slot(sc, value)))
		pair_set_syntax_op(form, OP_SET_SYMBOL_S);
	    }
	  else
	    {
	      if ((!is_pair(value)) ||
		  ((car(value) == sc->quote_symbol) && (is_pair(cdr(value))))) /* (quote . 1) ? */
		{
		  pair_set_syntax_op(form, OP_SET_SYMBOL_C);
		  set_opt2_con(sc->code, (is_pair(value)) ? cadr(value) : value);
		}
	      else
		{
		  /* if cadr(cadr) == car, or cdr(cadr) not null and cadr(cadr) == car, and cddr(cadr) == null,
		   *   it's (set! <var> (<op> <var> val)) or (<op> val <var>) or (<op> <var>)
		   *   in the set code, we get the slot as usual, then in case 1 above,
		   *   car(sc->t2_1) = slot_value(slot), car(sc->t2_2) = increment, call <op>, set slot_value(slot)
		   * this can be done in all combined cases where a symbol is repeated (do in particular)
		   */

		  /* (define (hi) (let ((x 1)) (set! x (+ x 1))))
		   *   but the value might be values:
		   *   (let () (define (hi) (let ((x 0)) (set! x (values 1 2)) x)) (catch #t hi (lambda a a)) (hi))
		   *   which is caught in splice_in_values
		   */
		  pair_set_syntax_op(form, OP_SET_SYMBOL_P);
		  if (is_h_safe_c_s(value))
		    {
		      pair_set_syntax_op(form, OP_SET_SYMBOL_opSq);
		      set_opt2_sym(sc->code, cadr(value));
		      /* using direct_x_call here via OP_SET_SYMBOL_opSq_direct was not faster */
		    }
		  else
		    {
		      if (is_optimized(value))
			{
			  if (is_h_safe_c_d(value))
			    {
			      pair_set_syntax_op(form, OP_SET_SYMBOL_opDq);
			      set_opt2_pair(sc->code, cdr(value));
			    }
			  else
			    {
			      /* most of these special cases probably don't matter; set_symbol_opscq called 500k times barely registered in callgrind */
			      if (optimize_op(value) == HOP_SAFE_C_SS)
				{
				  if (settee == cadr(value))
				    pair_set_syntax_op(form, OP_INCREMENT_SS);
				  else pair_set_syntax_op(form, OP_SET_SYMBOL_opSSq);
				  set_opt2_pair(sc->code, cdr(value));
				}
			      else
				{
				  if ((optimize_op(value) == HOP_SAFE_C_SSS) &&
				      (settee == cadr(value)) &&
				      (car(value) == sc->add_symbol))
				    {
				      pair_set_syntax_op(form, OP_INCREMENT_SSS);
				      set_opt2_pair(sc->code, cdr(value));
				    }
				  else
				    {
				      if (is_fx_safe(sc, value)) /* value = cadr(sc->code) */
					{
					  pair_set_syntax_op(form, OP_SET_SYMBOL_A);
					  annotate_arg(sc, cdr(sc->code), sc->envir);
					}
				      if ((is_safe_c_op(optimize_op(value))) &&
					  (is_pair(cdr(value))) &&
					  (settee == cadr(value)) &&
					  (!is_null(cddr(value))))
					{
					  if (is_null(cdddr(value)))
					    {
					      if (is_fx_safe(sc, caddr(value)))
						{
						  pair_set_syntax_op(form, OP_INCREMENT_SA);
						  annotate_arg(sc, cddr(value), sc->envir); /* this sets c_callee(arg) */
						  /* increment_sc does not happen much here */
						  set_opt2_pair(sc->code, cddr(value));
						}
					      else
						{
						  pair_set_syntax_op(form, OP_INCREMENT_SP);
						  set_opt2_pair(sc->code, caddr(value));
						}
					    }
					  else
					    {
					      if ((is_null(cddddr(value))) &&
						  (is_fx_safe(sc, caddr(value))) &&
						  (is_fx_safe(sc, cadddr(value))))
						{
						  pair_set_syntax_op(form, OP_INCREMENT_SAA);
						  annotate_arg(sc, cddr(value), sc->envir);
						  annotate_arg(sc, cdddr(value), sc->envir);
						  set_opt2_pair(sc->code, cddr(value));
						}}}}}}}
		    }
		  if ((is_h_optimized(value)) &&
		      (!is_unsafe(value)) &&                   /* is_unsafe(value) can happen! */
		      (is_not_null(cdr(value))))               /* (set! x (y)) */
		    {
		      if (is_not_null(cddr(value)))
			{
			  if ((caddr(value) == small_int(1)) &&
			      (cadr(value) == settee))
			    {
			      if ((opt1_cfunc(value) == sc->add_s1) ||
				  (opt1_cfunc(value) == sc->add_cs1))
				pair_set_syntax_op(form, OP_INCREMENT_1);
			      else
				{
				  if ((opt1_cfunc(value) == sc->subtract_s1) ||
				      (opt1_cfunc(value) == sc->subtract_cs1))
				    pair_set_syntax_op(form, OP_DECREMENT_1);
				}
			    }
			  else
			    {
			      if ((cadr(value) == small_int(1)) &&
				  (caddr(value) == settee) &&
				  (opt1_cfunc(value) == sc->add_1s))
				pair_set_syntax_op(form, OP_INCREMENT_1);
			      else
				{
				  if ((settee == caddr(value)) &&
				      (is_safe_symbol(cadr(value))) &&
				      (caadr(sc->code) == sc->cons_symbol))
				    {
				      pair_set_syntax_op(form, OP_SET_CONS);
				      set_opt2_sym(sc->code, cadr(value));
				    }}}}}}}}}
  sc->code = form;
  return(sc->code);
}

static void op_set_pair_a(s7_scheme *sc)
{
  s7_pointer obj, val;
  sc->code = cdr(sc->code);
  obj = lookup_checked(sc, caar(sc->code));
  val = fx_call(sc, cdr(sc->code));                /* this call can step on sc->tx_x */
  set_car(sc->t2_1, cadar(sc->code));              /* might be a constant: (set! (mus-sound-srate "oboe.snd") 12345) */
  if (is_symbol(car(sc->t2_1)))
    set_car(sc->t2_1, lookup_checked(sc, cadar(sc->code)));
  set_car(sc->t2_2, val);
  sc->value = c_function_call(c_function_setter(obj))(sc, sc->t2_1);
}

static void op_set_pair_p(s7_scheme *sc)
{
  /* ([set!] (car a) (cadr a)) */
  /* here the pair can't generate multiple values, or if it does, it's an error (caught below)
   *  splice_in_values will notice the OP_SET_PAIR_P_1 and complain.
   * (let () (define (hi) (let ((str "123")) (set! (str 0) (values #\a)) str)) (hi) (hi)) is "a23"
   * (let () (define (hi) (let ((str "123")) (set! (str 0) (values #\a #\b)) str)) (hi) (hi)) is an error from the first call (caught elsewhere)
   * (let () (define (hi) (let ((str "123")) (set! (str 0) (values #\a #\b)) str)) (catch #t hi (lambda a a)) (hi)) is an error from the second call
   * (let ((v (make-vector '(2 3) 0))) (set! (v (values 0 1)) 23) v) -> #2D((0 23 0) (0 0 0))
   */
  sc->code = cdr(sc->code);
  push_stack_no_args(sc, OP_SET_PAIR_P_1, sc->code);
  sc->code = cadr(sc->code);
}

static bool set_pair_p_3(s7_scheme *sc, s7_pointer obj, s7_pointer arg, s7_pointer value)
{
  if (is_slot(obj))
    obj = slot_value(obj);
  else eval_error(sc, "no generalized set for ~A", 25, caar(sc->code));

  switch (type(obj))
    {
    case T_C_OBJECT:
      set_car(sc->t3_1, obj);
      set_car(sc->t3_2, arg);
      set_car(sc->t3_3, value);
      sc->value = (*(c_object_set(sc, obj)))(sc, sc->t3_1);
      break;

      /* some of these are wasteful -- we know the object type! (list hash-table) */
    case T_INT_VECTOR:
    case T_FLOAT_VECTOR:
    case T_VECTOR:
    case T_BYTE_VECTOR:
#if WITH_GMP
      set_car(sc->t3_1, obj);
      set_car(sc->t3_2, arg);
      set_car(sc->t3_3, value);
      sc->value = g_vector_set(sc, sc->t3_1);
#else
      if (vector_rank(obj) > 1)
	{
	  set_car(sc->t3_1, obj);
	  set_car(sc->t3_2, arg);
	  set_car(sc->t3_3, value);
	  sc->value = g_vector_set(sc, sc->t3_1);
	}
      else
	{
	  s7_int index;

	  if (!is_t_integer(arg))
	    eval_type_error(sc, "vector-set!: index must be an integer: ~S", 41, sc->code);
	  index = integer(arg);
	  if (index < 0)
	    eval_range_error(sc, "vector-set!: index must not be negative: ~S", 43, sc->code);
	  if (index >= vector_length(obj))
	    eval_range_error(sc, "vector-set!: index must be less than vector length: ~S", 54, sc->code);
	  if (is_immutable(obj))
	    immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->vector_set_symbol, obj));
	  if (is_typed_vector(obj))
	    {
	      if ((sc->safety < 0) || /* or == 0?? */
		  (c_function_call(typed_vector_typer(obj))(sc, set_plist_1(sc, value)) != sc->F))
		vector_element(obj, index) = value;
	      else return(s7_wrong_type_arg_error(sc, "vector-set!", 3, value,
						  make_type_name(sc, c_function_name(typed_vector_typer(obj)), INDEFINITE_ARTICLE)));
	    }
	  else vector_setter(obj)(sc, obj, index, value);
	  sc->value = T_Pos(value);
	}
#endif
      break;

    case T_STRING:
#if WITH_GMP
      set_car(sc->t3_1, obj);
      set_car(sc->t3_2, arg);
      set_car(sc->t3_3, value);
      sc->value = g_string_set(sc, sc->t3_1);
#else
      {
	s7_int index;
	if (!is_t_integer(arg))
	  eval_type_error(sc, "index must be an integer: ~S", 28, sc->code);
	index = integer(arg);
	if (index < 0)
	  eval_range_error(sc, "index must not be negative: ~S", 30, sc->code);
	if (index >= string_length(obj))
	  eval_range_error(sc, "index must be less than sequence length: ~S", 43, sc->code);
	if (is_immutable(obj))
	  immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->string_set_symbol, obj));

	if (s7_is_character(value))
	  {
	    string_value(obj)[index] = (char)s7_character(value);
	    sc->value = value;
	  }
	else eval_type_error(sc, "(string-)set!: value must be a character: ~S", 44, sc->code);
      }
#endif
      break;

    case T_PAIR:
      set_car(sc->t3_1, obj);
      set_car(sc->t3_2, arg);
      set_car(sc->t3_3, value);
      sc->value = g_list_set(sc, sc->t3_1);
      break;

    case T_HASH_TABLE:
      if (is_immutable(obj))
	immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->hash_table_set_symbol, obj));
      sc->value = s7_hash_table_set(sc, obj, arg, value);
      break;

    case T_LET:
      sc->value = s7_let_set(sc, obj, arg, value); /* this checks immutable */
      break;

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:                       /* (let ((lst (list 1 2))) (set! (list-ref lst 1) 2) lst) */
    case T_C_FUNCTION:
    case T_C_FUNCTION_STAR:
      /* obj here is a c_function, but its setter could be a closure and vice versa below */
      if (is_procedure_or_macro(c_function_setter(obj)))
	{
	  if (is_c_function(c_function_setter(obj)))
	    {
	      set_car(sc->t2_1, arg);
	      set_car(sc->t2_2, value);
	      sc->value = c_function_call(c_function_setter(obj))(sc, sc->t2_1);
	    }
	  else
	    {
	      sc->code = c_function_setter(obj);
	      if (needs_copied_args(sc->code))
		sc->args = list_2(sc, arg, value);
	      else sc->args = set_plist_2(sc, arg, value);
	      return(true); /* goto APPLY; */
	    }
	}
      else eval_error(sc, "no generalized set for ~A", 25, obj);
      break;

    case T_MACRO:   case T_MACRO_STAR:
    case T_BACRO:   case T_BACRO_STAR:
    case T_CLOSURE: case T_CLOSURE_STAR:
      if (is_procedure_or_macro(closure_setter(obj)))
	{
	  if (is_c_function(closure_setter(obj)))
	    {
	      set_car(sc->t2_1, arg);
	      set_car(sc->t2_2, value);
	      sc->value = c_function_call(closure_setter(obj))(sc, sc->t2_1);
	    }
	  else
	    {
	      sc->code = closure_setter(obj);
	      if (needs_copied_args(sc->code))
		sc->args = list_2(sc, arg, value);
	      else sc->args = set_plist_2(sc, arg, value);
	      return(true); /* goto APPLY; */
	    }
	}
      else eval_error(sc, "no generalized set for ~A", 25, obj);
      break;

    default:                                         /* (set! (1 2) 3) */
      eval_error(sc, "no generalized set for ~A", 25, obj);
    }
  return(false);
}

static bool op_set_pair_p_1(s7_scheme *sc)
{
  /* car(sc->code) is a pair, caar(code) is the object with a setter, it has one (safe) argument, and one safe value to set
   *   (set! (str i) #\a) in a function (both inner things need to be symbols (or the second can be a quoted symbol) to get here)
   *   the inner list is a proper list, with no embedded list at car.
   */
  s7_pointer arg, value;
  value = sc->value;
  arg = cadar(sc->code);
  if (is_symbol(arg))
    arg = lookup_checked(sc, arg);
  else
    {
      if (is_pair(arg))
	arg = cadr(arg); /* can only be (quote ...) in this case */
    }
  return(set_pair_p_3(sc, symbol_to_slot(sc, caar(sc->code)), arg, value));
}

static bool op_set_pair(s7_scheme *sc)
{
  /* ([set!] (setter g) s) or ([set!] (str 0) #\a) */
  s7_pointer obj, arg, value;
  sc->code = cdr(sc->code);
  value = cadr(sc->code);
  if (is_symbol(value))
    value = lookup_checked(sc, value);

  arg = cadar(sc->code);
  if (is_symbol(arg))
    arg = lookup_checked(sc, arg);
  else
    {
      if (is_pair(arg))
	arg = cadr(arg); /* can only be (quote ...) in this case */
    }
  obj = caar(sc->code);
  if (is_symbol(obj))
    obj = symbol_to_slot(sc, obj);
  return(set_pair_p_3(sc, obj, arg, value));
}

static void op_set_safe(s7_scheme *sc)
{
  s7_pointer lx;
  lx = symbol_to_slot(sc, sc->code);   /* SET_CASE above looks for car(sc->code) */
  slot_set_value(lx, sc->value);
  sc->value = slot_value(lx);
}

static s7_pointer op_set1(s7_scheme *sc)
{
  s7_pointer lx;
  /* if unbound variable hook here, we need the binding, not the current value */
  lx = symbol_to_slot(sc, sc->code);
  if (is_slot(lx))
    {
      if (slot_has_setter(lx))
	{
	  s7_pointer func;
	  func = slot_setter(lx);
	  if (is_procedure_or_macro(func))
	    {
	      if (has_let_arg(func))
		{
		  if (is_c_function(func))
		    {
		      set_car(sc->t3_1, sc->code);
		      set_car(sc->t3_2, sc->value);
		      set_car(sc->t3_3, sc->envir);
		      sc->value = c_function_call(func)(sc, sc->t3_1);
		    }
		  else
		    {
		      sc->args = list_3(sc, sc->code, sc->value, sc->envir);
		      push_stack(sc, OP_SET_WITH_SETTER, sc->args, lx); /* op, args, code */
		      sc->code = func;
		      return(NULL);
		    }
		}
	      else
		{
		  if (is_c_function(func))
		    {
		      set_car(sc->t2_1, sc->code);
		      set_car(sc->t2_2, sc->value);
		      sc->value = c_function_call(func)(sc, sc->t2_1);
		    }
		  else
		    {
		      sc->args = list_2(sc, sc->code, sc->value);
		      push_stack(sc, OP_SET_WITH_SETTER, sc->args, lx); /* op, args, code */
		      sc->code = func;
		      return(NULL);
		    }
		}
	    }
	}
      else
	{
	  if ((is_syntactic_symbol(sc->code)) ||              /* (set! case 3) */
	      ((global_slot(sc->code) == lx) &&               /* (begin (let ((case 2)) case) (set! case 3)) */
	       (is_syntax(slot_value(lx))) &&
	       (sc->code == syntax_symbol(slot_value(lx)))))
	    eval_error(sc, "can't set! ~A", 13, sc->code);
	}
      if (is_immutable(lx))
	immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->set_symbol, lx));
      slot_set_value(lx, sc->value);
      return(sc->value);
    }
  else
    {
      if (has_let_set_fallback(sc->envir))                    /* (with-let (mock-hash-table 'b 2) (set! b 3)) */
	return(call_let_set_fallback(sc, sc->envir, sc->code, sc->value));
    }
  eval_type_error(sc, "set! ~A: unbound variable", 25, sc->code);
}

static s7_pointer op_set2(s7_scheme *sc)
{
  if (is_pair(sc->value))
    {
      /* (let ((L '((1 2 3)))) (set! ((L 0) 1) 32) L)
       * (let ((L '(((1 2 3))))) (set! ((L 0) 0 1) 32) L)
       * any deeper nesting was handled already by the first eval
       *   set! looks at its first argument, if it's a symbol, it sets the associated value,
       *   if it's a list, it looks at the car of that list to decide which setter to call,
       *   if it's a list of lists, it passes the embedded lists to eval, then looks at the
       *   car of the result.  This means that we can do crazy things like:
       *   (let ((x '(1)) (y '(2))) (set! ((if #t x y) 0) 32) x)
       * the other args need to be evaluated (but not the list as if it were code):
       *   (let ((L '((1 2 3))) (index 1)) (set! ((L 0) index) 32) L)
       */

      if (!s7_is_proper_list(sc, sc->args))                              /* (set! ('(1 2) 1 . 2) 1) */
	eval_error(sc, "set! target arguments are an improper list: ~A", 46, sc->args);

      /* in all of these cases, we might need to GC protect the temporary lists */

      if (is_multiple_value(sc->value))
	sc->code = cons(sc, sc->set_symbol, s7_append(sc, multiple_value(sc->value), s7_append(sc, sc->args, sc->code))); /* drop into OP_SET */
      else
	{
	  if (sc->args != sc->nil)
	    {
	      push_op_stack(sc, sc->list_set_function);
	      push_stack(sc, OP_EVAL_ARGS1, list_1(sc, sc->value), s7_append(sc, cdr(sc->args), sc->code));
	      sc->code = car(sc->args);
	    }
	  else eval_error(sc, "list set!: not enough arguments: ~S", 35, sc->code);
	  return(sc->code); /* goto EVAL; */
	}
    }
  else
    {
      if (is_any_vector(sc->value))
	{
	  /* (let ((L #(#(1 2 3) #(4 5 6)))) (set! ((L 1) 0) 32) L)
	   * bad case when args is nil: (let ((L #(#(1 2 3) #(4 5 6)))) (set! ((L 1)) 32) L)
	   */
	  if (sc->args != sc->nil)
	    {
	      push_op_stack(sc, sc->vector_set_function);
	      push_stack(sc, OP_EVAL_ARGS1, list_1(sc, sc->value), s7_append(sc, cdr(sc->args), sc->code));
	      sc->code = car(sc->args);
	    }
	  else eval_error(sc, "vector set!: not enough arguments: ~S", 37, sc->code);
	  return(sc->code); /* goto EVAL; */
	}
      sc->code = cons_unchecked(sc, sc->set_symbol, cons_unchecked(sc, cons(sc, sc->value, sc->args), sc->code));
    }
  return(NULL); /* i.e. goto SET1 */
}

static bool op_set_with_let_1(s7_scheme *sc)
{
  s7_pointer e, b, x;
  /* from the T_SYNTAX branch of set_pair_ex: (set! (with-let e b) x) as in let-temporarily
   *   here sc->value is the new value for the settee = x, args has the (as yet unevaluated) let and settee-expression.
   *   'b above can be a pair = generalized set in the 'e environment.
   */
  if (!is_pair(sc->args))                /* (set! (with-let) ...) */
    eval_error(sc, "set! (with-let)? ~A", 19, current_code(sc));
  if (!is_pair(cdr(sc->args)))           /* (set! (with-let e) ...) */
    eval_error(sc, "set! (with-let ...) has no symbol to set? ~A", 44, current_code(sc));
  e = car(sc->args);
  b = cadr(sc->args);
  x = sc->value;
  if (is_symbol(e))
    {
      if (is_symbol(b))
	{
	  e = lookup_checked(sc, e); /* the let */
	  if (!is_let(e))
	    wrong_type_argument_with_type(sc, sc->let_set_symbol, 1, e, a_let_string);
	  sc->value = let_set_1(sc, e, b, x);
	  pop_stack(sc);
	  return(true);
	}
      sc->value = lookup_checked(sc, e);
      sc->code = list_2(sc, b, ((is_symbol(x)) || (is_pair(x))) ? set_plist_2(sc, sc->quote_symbol, x) : x);
      return(false);
    }
  sc->code = e;                       /* 'e above, an expression we need to evaluate */
  sc->args = list_2(sc, b, x);        /* can't reuse sc->args here via set-car! etc */
  push_stack(sc, OP_SET_WITH_LET_2, sc->args, sc->code);
  sc->cur_op = optimize_op(sc->code);
  return(true);
}

static bool op_set_with_let_2(s7_scheme *sc)
{
  s7_pointer b, x;
  /* here sc->value = let = 'e, args = '(b x) where 'b might be a pair */
  if (!is_let(sc->value))
    wrong_type_argument_with_type(sc, sc->let_set_symbol, 1, sc->value, a_let_string);
  b = car(sc->args);
  x = cadr(sc->args);
  if (is_symbol(b))   /* b is a symbol -- everything else is ready so call let-set! */
    {
      sc->value = let_set_1(sc, sc->value, b, x);
      return(true);
    }
  if ((is_symbol(x)) || (is_pair(x)))
    sc->code = list_2(sc, b, ((is_symbol(x)) || (is_pair(x))) ? set_plist_2(sc, sc->quote_symbol, x) : x);
  else sc->code = sc->args;
  return(false);
}

static bool op_set_normal(s7_scheme *sc)
{
  s7_pointer x;
  sc->code = cdr(sc->code);
  x = cadr(sc->code);
  if (is_pair(x))
    {
      push_stack_no_args(sc, OP_SET1, car(sc->code));
      sc->code = x;
      return(true);
    }

  if (is_symbol(x))
    sc->value = lookup_checked(sc, x);
  else sc->value = T_Pos(x);
  sc->code = car(sc->code);
  return(false);
}

static void op_set_symbol_p(s7_scheme *sc)
{
  sc->code = cdr(sc->code);
  push_stack_no_args(sc, OP_SET_SAFE, car(sc->code));
  sc->code = cadr(sc->code);
}

static void op_increment_sp(s7_scheme *sc)
{
  s7_pointer sym;
  sc->code = cdr(sc->code);
  sym = symbol_to_slot(sc, car(sc->code));
  push_stack(sc, OP_INCREMENT_SP_1, sym, sc->code);
  sc->code = T_Pair(opt2_pair(sc->code)); /* caddr(cadr(sc->code)); */
}

static void op_increment_sp_1(s7_scheme *sc)
{
  set_car(sc->t2_1, slot_value(sc->args));
  set_car(sc->t2_2, sc->value);
  sc->value = c_call(cadr(sc->code))(sc, sc->t2_1);
  slot_set_value(sc->args, sc->value);
}

static void op_increment_sp_mv(s7_scheme *sc)
{
  sc->value = c_call(cadr(sc->code))(sc, cons(sc, slot_value(sc->args), sc->value));
  slot_set_value(sc->args, sc->value);
}


/* -------------------------------- do -------------------------------- */
static bool safe_stepper_expr(s7_pointer expr, s7_pointer vars)
{
  /* for now, just look for stepper as last element of any list
   *    any embedded set is handled by do-is-safe, so we don't need to descend into the depths
   */
  s7_pointer p;
  if (direct_memq(cadr(expr), vars))
    return(false);

  for (p = cdr(expr); is_pair(cdr(p)); p = cdr(p));

  if (is_pair(p))
    {
      if ((is_optimized(p)) &&
	  ((optimize_op(p) & 1) != 0) &&
	  (is_safe_c_op(optimize_op(p))))
	return(true);

      if (direct_memq(car(p), vars))
	return(false);
    }
  else
    {
      if (direct_memq(p, vars))
	return(false);
    }
  return(true);
}

static int32_t set_c_object_ex(s7_scheme *sc, s7_pointer cx)
{
  s7_pointer settee, index, val;
  
  if (is_null(cdr(sc->code)))
    s7_wrong_number_of_args_error(sc, "no value for object-set!: ~S", sc->code);
  if (!is_null(cddr(sc->code)))
    s7_wrong_number_of_args_error(sc, "too many values for object-set!: ~S", sc->code);
  
  settee = car(sc->code);
  if ((is_null(cdr(settee))) ||
      (!is_null(cddr(settee))))
    {
      push_op_stack(sc, sc->c_object_set_function);
      if (is_null(cdr(settee)))
	{
	  push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), cddr(sc->code));
	  sc->code = cadr(sc->code);
	}
      else
	{
	  push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), s7_append(sc, cddr(settee), cdr(sc->code)));
	  sc->code = cadr(settee);
	}
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  
  index = cadr(settee);
  if (!is_pair(index))
    {
      if (is_symbol(index))
	index = lookup_checked(sc, index);
      
      val = cadr(sc->code);
      if (!is_pair(val))
	{
	  if (is_symbol(val))
	    val = lookup_checked(sc, val);
	  set_car(sc->t3_1, cx);
	  set_car(sc->t3_2, index);
	  set_car(sc->t3_3, val);
	  sc->value = (*(c_object_set(sc, cx)))(sc, sc->t3_1);
	  return(goto_START);
	}
      push_op_stack(sc, sc->c_object_set_function);
      sc->args = list_2(sc, index, cx);
      sc->code = cdr(sc->code);
      return(goto_EVAL_ARGS);
    }
  push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), cdr(sc->code));
  push_op_stack(sc, sc->c_object_set_function);
  sc->code = cadr(settee);
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_vector_ex(s7_scheme *sc, s7_pointer cx)
{
  /* cx is the vector, sc->code is expr without the set! */
  /*  args have not been evaluated! */
  
  s7_pointer settee, index, val;
  s7_int argnum;
  
  if (is_null(cdr(sc->code)))     /* (set! (v 0)) */
    s7_wrong_number_of_args_error(sc, "no value for vector-set!: ~S", sc->code);
  if (!is_null(cddr(sc->code)))   /* (set! (v 0) 1 2) */
    s7_wrong_number_of_args_error(sc, "too many values for vector-set!: ~S", sc->code);
  
  settee = car(sc->code);
  if (is_null(cdr(settee)))
    s7_wrong_number_of_args_error(sc, "no index for vector-set!: ~S", sc->code);
  if (is_immutable(cx))
    immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->vector_set_symbol, cx));
  
  argnum = safe_list_length(cdr(settee));
  if ((argnum > 1) &&
      (is_normal_vector(cx)) &&
      (argnum != vector_rank(cx)))
    {
      /* this block needs to be first to handle (eg):
       *   (let ((v (vector (inlet 'a 0)))) (set! (v 0 'a) 32) v): #((inlet 'a 32))
       */
      push_stack(sc, OP_SET2, cddr(settee), cdr(sc->code));
      sc->code = list_2(sc, car(settee), cadr(settee));
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  
  if ((argnum > 1) || (vector_rank(cx) > 1))
    {
      if ((argnum == vector_rank(cx)) &&
	  (!is_pair(cadr(sc->code))))
	{
	  s7_pointer p;
	  for (p = cdr(settee); is_pair(p); p = cdr(p))
	    if (is_pair(car(p))) break;
	  if (is_null(p))
	    {
	      s7_pointer args, pa;
	      args = safe_list_if_possible(sc, argnum + 2);
	      car(args) = cx;
	      for (p = cdr(settee), pa = cdr(args); is_pair(p); p = cdr(p), pa = cdr(pa))
		{
		  index = car(p);
		  if (is_symbol(index))
		    index = lookup_checked(sc, index);
		  if (!s7_is_integer(index))
		    eval_error_no_return(sc, sc->wrong_type_arg_symbol, "vector-set!: index must be an integer: ~S", 41, sc->code);
		  car(pa) = index;
		}
	      car(pa) = cadr(sc->code);
	      if (is_symbol(car(pa)))
		car(pa) = lookup_checked(sc, car(pa));
	      sc->value = g_vector_set(sc, args);
	      clear_list_in_use(args);
	      return(goto_START);
	    }
	}
      push_op_stack(sc, sc->vector_set_function); /* vector_setter(cx) has wrong args */
      push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), s7_append(sc, cddr(settee), cdr(sc->code))); /* i.e. rest(args) + val */
      sc->code = cadr(settee);
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  
  /* one index, rank == 1 */
  index = cadr(settee);
  if (!is_pair(index))
    {
      s7_int ind;
      
      if (is_symbol(index))
	index = lookup_checked(sc, index);
      if (!s7_is_integer(index))
	eval_error_no_return(sc, sc->wrong_type_arg_symbol, "vector-set!: index must be an integer: ~S", 41, sc->code);
      ind = s7_integer(index);
      if ((ind < 0) ||
	  (ind >= vector_length(cx)))
	out_of_range(sc, sc->vector_set_symbol, small_int(2), index, (ind < 0) ? its_negative_string : its_too_large_string);
      val = cadr(sc->code);
      if (!is_pair(val))
	{
	  if (is_symbol(val))
	    val = lookup_checked(sc, val);
	  if (is_typed_vector(cx))
	    typed_vector_setter(sc, cx, ind, val);
	  else vector_setter(cx)(sc, cx, ind, val);
	  sc->value = T_Pos(val);
	  return(goto_START);
	}
      push_op_stack(sc, sc->vector_set_function);
      sc->args = list_2(sc, index, cx);
      sc->code = cdr(sc->code);
      return(goto_EVAL_ARGS);
    }
  /* here the index calc might be trivial -- (+ i 1) or (- j 1) but this branch hardly ever happens */
  push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), cdr(sc->code));
  push_op_stack(sc, sc->vector_set_function);
  sc->code = cadr(settee);
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_string_ex(s7_scheme *sc, s7_pointer cx)
{
  /* sc->code = cons(sc, sc->string_set_function, s7_append(sc, car(sc->code), cdr(sc->code)));
   *
   * here only one index makes sense, and it is required, so
   *   (set! ("str") #\a), (set! ("str" . 1) #\a) and (set! ("str" 1 2) #\a)
   *   are all errors (but see below!).
   */
  s7_pointer settee, index, val;
  
  if (is_null(cdr(sc->code))) s7_wrong_number_of_args_error(sc, "no value for string-set!: ~S", sc->code);
  if (!is_null(cddr(sc->code))) s7_wrong_number_of_args_error(sc, "too many values for string-set!: ~S", sc->code);
  
  settee = car(sc->code);
  if (is_null(cdr(settee))) s7_wrong_number_of_args_error(sc, "no index for string-set!: ~S", sc->code);
  if (!is_null(cddr(settee))) s7_wrong_number_of_args_error(sc, "too many indices for string-set!: ~S", sc->code);
  
  /* if there's one index (the standard case), and it is not a pair, and there's one value (also standard)
   *    and it is not a pair, let's optimize this thing!
   *    cx is what we're setting, cadar is the index, cadr is the new value
   */
  index = cadr(settee);
  if (!is_pair(index))
    {
      s7_int ind;
      
      if (is_symbol(index))
	index = lookup_checked(sc, index);
      if (!s7_is_integer(index))
	eval_error_no_return(sc, sc->wrong_type_arg_symbol, "index must be an integer: ~S", 28, sc->code);
      ind = s7_integer(index);
      if ((ind < 0) ||
	  (ind >= string_length(cx)))
	out_of_range(sc, sc->string_set_symbol, small_int(2), index, (ind < 0) ? its_negative_string : its_too_large_string);
      if (is_immutable(cx))
	immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->string_set_symbol, cx));
      
      val = cadr(sc->code);
      if (!is_pair(val))
	{
	  if (is_symbol(val))
	    val = lookup_checked(sc, val);
	  if (s7_is_character(val))
	    {
	      string_value(cx)[ind] = character(val);
	      sc->value = val;
	      return(goto_START);
	    }
	  eval_error_no_return(sc, sc->wrong_type_arg_symbol, "value must be a character: ~S", 29, sc->code);
	}
      push_op_stack(sc, sc->string_set_function);
      sc->args = list_2(sc, index, cx);
      sc->code = cdr(sc->code);
      return(goto_EVAL_ARGS);
    }
  push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), cdr(sc->code));
  push_op_stack(sc, sc->string_set_function);
  sc->code = cadar(sc->code);
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_cons_ex(s7_scheme *sc, s7_pointer cx)      /* code: ((lst 1) 32) from (let ((lst (list 1 2 3))) (set! (lst 1) 32)) */
{
  s7_pointer settee, index, val;
  
  if (is_null(cdr(sc->code)))
    s7_wrong_number_of_args_error(sc, "no value for list-set!: ~S", sc->code);
  if (!is_null(cddr(sc->code)))
    s7_wrong_number_of_args_error(sc, "too many values for list-set!: ~S", sc->code);
  
  settee = car(sc->code);
  if (is_null(cdr(settee)))
    s7_wrong_number_of_args_error(sc, "no index for list-set!: ~S", sc->code);
  
  if (!is_null(cddr(settee)))
    {
      /* split (set! (a b c...) v) into (set! ((a b) c ...) v), eval (a b), return
       *    (let ((L (list (list 1 2)))) (set! (L 0 0) 3) L)
       */
      push_stack(sc, OP_SET2, cddr(settee), cdr(sc->code));
      sc->code = list_2(sc, car(settee), cadr(settee));
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  
  index = cadr(settee);
  val = cadr(sc->code);
  
  if ((is_pair(index)) ||
      (is_pair(val)))
    {
      push_op_stack(sc, sc->list_set_function);
      push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), s7_append(sc, cddr(settee), cdr(sc->code)));
      sc->code = index;
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  
  if (is_symbol(index))
    index = lookup_checked(sc, index);
  if (is_symbol(val))
    val = lookup_checked(sc, val);
  
  set_car(sc->t2_1, index);
  set_car(sc->t2_2, val);
  sc->value = g_list_set_1(sc, cx, sc->t2_1, 2);
  return(goto_START);
}

static int32_t set_hash_table_ex(s7_scheme *sc, s7_pointer cx)
{
  s7_pointer settee, key;
  
  if (is_null(cdr(sc->code)))
    s7_wrong_number_of_args_error(sc, "no value for hash-table-set!: ~S", sc->code);
  if (!is_null(cddr(sc->code)))
    s7_wrong_number_of_args_error(sc, "too many values for hash-table-set!: ~S", sc->code);
  
  settee = car(sc->code);
  if (is_null(cdr(settee)))
    s7_wrong_number_of_args_error(sc, "no key for hash-table-set!: ~S", sc->code);
  if (is_immutable(cx))
    immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->hash_table_set_symbol, cx));
  
  if (!is_null(cddr(settee)))
    {
      push_stack(sc, OP_SET2, cddr(settee), cdr(sc->code));
      sc->code = list_2(sc, car(settee), cadr(settee));
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  
  key = cadr(settee);
  if (!is_pair(key))
    {
      s7_pointer val;
      if (is_symbol(key))
	key = lookup_checked(sc, key);
      val = cadr(sc->code);
      if (!is_pair(val))
	{
	  if (is_symbol(val))
	    val = lookup_checked(sc, val);
	  sc->value = s7_hash_table_set(sc, cx, key, val);
	  return(goto_START);
	}
      push_op_stack(sc, sc->hash_table_set_function);
      sc->args = list_2(sc, key, cx);
      sc->code = cdr(sc->code);
      return(goto_EVAL_ARGS);
    }
  push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), cdr(sc->code));
  push_op_stack(sc, sc->hash_table_set_function);
  sc->code = cadar(sc->code);
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_let_ex(s7_scheme *sc, s7_pointer cx)     /* sc->code = cons(sc, sc->let_set_function, s7_append(sc, car(sc->code), cdr(sc->code))); */
{
  s7_pointer settee, key;
  /* code: ((gen 'input) input) from (set! (gen 'input) input) */
  
  if (is_null(cdr(sc->code)))
    s7_wrong_number_of_args_error(sc, "no value for let-set!: ~S", sc->code);
  if (!is_null(cddr(sc->code)))
    s7_wrong_number_of_args_error(sc, "too many values for let-set!: ~S", sc->code);
  
  settee = car(sc->code);
  if (is_null(cdr(settee)))
    s7_wrong_number_of_args_error(sc, "no symbol (variable name) for let-set!: ~S", sc->code);
  if (is_immutable(cx))
    immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->let_set_symbol, cx));
  
  if (!is_null(cddr(settee)))
    {
      push_stack(sc, OP_SET2, cddr(settee), cdr(sc->code));
      sc->code = list_2(sc, car(settee), cadr(settee));
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  
  key = cadr(settee);
  if (is_proper_quote(sc, key))
    {
      s7_pointer val;
      key = cadr(key);
      val = cadr(sc->code);
      if (!is_pair(val))
	{
	  if (is_symbol(val))
	    val = lookup_checked(sc, val);
	  sc->value = s7_let_set(sc, cx, key, val);
	  return(goto_START);
	}
      push_op_stack(sc, sc->let_set_function);
      sc->args = list_2(sc, key, cx);
      sc->code = cdr(sc->code);
      return(goto_EVAL_ARGS);
    }
  push_stack(sc, OP_EVAL_ARGS1, list_1(sc, cx), cdr(sc->code));
  push_op_stack(sc, sc->let_set_function);
  sc->code = cadar(sc->code);
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_function_ex(s7_scheme *sc, s7_pointer cx)  /* (let ((lst (list 1 2))) (set! (list-ref lst 0) 2) lst) */
{
  /* perhaps it has a setter */
  if (is_t_procedure(c_function_setter(cx)))
    {
      /* here the setter can be anything, so we need to check the needs_copied_args bit
       *    (set! ((dilambda / (let ((x 3)) (lambda (y) (+ x y))))) 3)!
       */
      /* sc->code = cons(sc, c_function_setter(cx), s7_append(sc, cdar(sc->code), cdr(sc->code))); */
      if (is_pair(cdar(sc->code)))
	{
	  if ((is_symbol(cadr(sc->code))) &&
	      (is_symbol(cadar(sc->code))))
	    {
	      if (is_null(cddar(sc->code)))
		{
		  if (needs_copied_args(c_function_setter(cx)))
		    sc->args = list_2(sc, lookup_checked(sc, cadar(sc->code)), lookup_checked(sc, cadr(sc->code)));
		  else
		    {
		      set_car(sc->t2_1, lookup_checked(sc, cadar(sc->code)));
		      set_car(sc->t2_2, lookup_checked(sc, cadr(sc->code)));
		      sc->args = sc->t2_1;
		    }
		  sc->code = c_function_setter(cx);
		  return(goto_APPLY); /* check arg num etc */
		}
	      if ((is_symbol(caddar(sc->code))) &&
		  (is_null(cdddar(sc->code))))
		{
		  if (needs_copied_args(c_function_setter(cx)))
		    sc->args = list_3(sc,
				      lookup_checked(sc, cadar(sc->code)),
				      lookup_checked(sc, caddar(sc->code)),
				      lookup_checked(sc, cadr(sc->code)));
		  else
		    {
		      set_car(sc->t3_1, lookup_checked(sc, cadar(sc->code)));
		      set_car(sc->t3_2, lookup_checked(sc, caddar(sc->code)));
		      set_car(sc->t3_3, lookup_checked(sc, cadr(sc->code)));
		      sc->args = sc->t3_1;
		    }
		  sc->code = c_function_setter(cx);
		  return(goto_APPLY); /* check arg num etc */
		}
	    }
	  push_op_stack(sc, c_function_setter(cx));
	  push_stack(sc, OP_EVAL_ARGS1, sc->nil, s7_append(sc, cddar(sc->code), cdr(sc->code)));
	  sc->code = cadar(sc->code);
	}
      else
	{
	  if ((is_null(cddr(sc->code))) &&
	      (!is_pair(cadr(sc->code))))
	    {
	      if (needs_copied_args(c_function_setter(cx)))
		sc->args = list_1(sc, (is_symbol(cadr(sc->code))) ? lookup_checked(sc, cadr(sc->code)) : cadr(sc->code));
	      else
		{
		  if (is_symbol(cadr(sc->code)))
		    set_car(sc->t1_1, lookup_checked(sc, cadr(sc->code)));
		  else set_car(sc->t1_1, cadr(sc->code));
		  sc->args = sc->t1_1;
		}
	      sc->code = c_function_setter(cx);
	      return(goto_APPLY); /* check arg num etc */
	    }
	  push_op_stack(sc, c_function_setter(cx));
	  push_stack(sc, OP_EVAL_ARGS1, sc->nil, cddr(sc->code));
	  sc->code = cadr(sc->code);
	}
    }
  else
    {
      if (is_any_macro(c_function_setter(cx)))
	{
	  if (is_null(cdar(sc->code)))
	    sc->args = copy_list(sc, cdr(sc->code));
	  else sc->args = s7_append(sc, cdar(sc->code), copy_list(sc, cdr(sc->code)));
	  /* append copies except for its last arg, but for macros, we have to copy everything, hence the extra copy_list */
	  sc->code = c_function_setter(cx);
	  return(goto_APPLY);
	}
      eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, caar(sc->code));
    }
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_closure_ex(s7_scheme *sc, s7_pointer cx)
{
  s7_pointer setter;
  setter = closure_setter(cx);
  if ((setter == sc->F) &&
      (!closure_no_setter(cx)))
    setter = g_setter(sc, set_plist_1(sc, cx));
  if (is_t_procedure(setter))          /* appears to be caar_code */
    {
      /* (set! (o g) ...), here cx = o, sc->code = ((o g) ...) */
      push_op_stack(sc, setter);
      if (is_null(cdar(sc->code)))
	{
	  push_stack(sc, OP_EVAL_ARGS1, sc->nil, cddr(sc->code));
	  sc->code = cadr(sc->code);
	}
      else
	{
	  if (is_null(cddar(sc->code)))
	    push_stack(sc, OP_EVAL_ARGS1, sc->nil, cdr(sc->code));
	  else push_stack(sc, OP_EVAL_ARGS1, sc->nil, s7_append(sc, cddar(sc->code), cdr(sc->code)));
	  sc->code = cadar(sc->code);
	}
    }
  else
    {
      if (is_any_macro(setter))
	{
	  if (is_null(cdar(sc->code)))
	    sc->args = copy_list(sc, cdr(sc->code));
	  else sc->args = s7_append(sc, cdar(sc->code), copy_list(sc, cdr(sc->code)));
	  sc->code = setter;
	  return(goto_APPLY);
	}
      eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, caar(sc->code));
    }
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_iterator_ex(s7_scheme *sc, s7_pointer cx)
{
  s7_pointer setter;
  setter = iterator_sequence(cx);
  if ((is_any_closure(setter)) || (is_any_macro(setter)))
    setter = closure_setter(iterator_sequence(cx));
  else setter = sc->F;
  if (is_procedure(setter))
    {
      push_op_stack(sc, setter);
      push_stack(sc, OP_EVAL_ARGS1, sc->nil, sc->nil);
      sc->code = cadr(sc->code);    /* the (as yet unevaluated) value, incoming code was ((obj) val) */
    }
  else
    {
      if (is_any_macro(setter))
	{
	  sc->args = list_1(sc, cadr(sc->code));
	  sc->code = setter;
	  return(goto_APPLY);
	}
      eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, caar(sc->code));
    }
  sc->cur_op = optimize_op(sc->code);
  return(goto_TOP_NO_POP);
}

static int32_t set_syntax_ex(s7_scheme *sc, s7_pointer cx)
{
  if (cx == slot_value(global_slot(sc->with_let_symbol)))
    {
      /* (set! (with-let a b) x), cx = with-let, sc->code = ((with-let a b) x)
       *   a and x are in the current env, b is in a, we need to evaluate a and x, then
       *   call (with-let a-value (set! b x-value))
       */
      sc->args = cdar(sc->code);
      sc->code = cadr(sc->code);
      push_stack(sc, OP_SET_WITH_LET_1, sc->args, sc->code);
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }
  eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, caar(sc->code));
  return(goto_TOP_NO_POP);
}

static int32_t set_pair_ex(s7_scheme *sc)
{
  s7_pointer caar_code, cx;

  caar_code = caar(sc->code);
  if (is_pair(caar_code))
    {
      push_stack(sc, OP_SET2, cdar(sc->code), cdr(sc->code));
      sc->code = caar_code;
      sc->cur_op = optimize_op(sc->code);
      return(goto_TOP_NO_POP);
    }

  if (is_symbol(caar_code))
    {
      /* this was cx = s7_symbol_value(sc, caar_code) but the function call overhead is noticeable */
      cx = symbol_to_slot(sc, caar_code);
      if (is_slot(cx))
	cx = slot_value(cx);
      else eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, caar_code);
    }
  else cx = caar_code;

  /* code here is the setter and the value without the "set!": ((window-width) 800) */
  /*    (set! (hi 0) (* 2 3)) -> ((hi 0) (* 2 3)) */

  /* for these kinds of objects, some Schemes restrict set!
   * (list-set! '(1 2 3) 1 32) is accepted but does it make sense?
   * (string-set! "hiho" 1 #\z)
   * (vector-set! #(1 2 3) 1 32)
   * (let ((x (lambda () #(1 2 3)))) (vector-set! (x) 1 32))
   * (let ((str "hiho")) (string-set! str 1 #\x) str)
   * (let ((x (lambda () "hiho"))) (string-set! (x) 1 #\x) (x))
   * (let ((xx (let ((x '(1 2 3))) (lambda () x)))) (list-set! (xx) 1 32) (xx)) -> '(1 32 3)
   * (let* ((x '(1 2)) (y (list x)) (z (car y))) (list-set! z 1 32) (list x y z)) -> '((1 32) ((1 32)) (1 32))
   */
  /* for gmp case, indices need to be decoded via s7_integer, not just integer */

  switch (type(cx))
    {
    case T_C_OBJECT:
      return(set_c_object_ex(sc, cx));

    case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_VECTOR: case T_BYTE_VECTOR:
      return(set_vector_ex(sc, cx));

    case T_STRING:
      return(set_string_ex(sc, cx));

    case T_PAIR:
      return(set_cons_ex(sc, cx));

    case T_HASH_TABLE:
      return(set_hash_table_ex(sc, cx));

    case T_LET:
      return(set_let_ex(sc, cx));

    case T_C_MACRO: case T_C_OPT_ARGS_FUNCTION: case T_C_RST_ARGS_FUNCTION: 
    case T_C_ANY_ARGS_FUNCTION: case T_C_FUNCTION: case T_C_FUNCTION_STAR:
      return(set_function_ex(sc, cx));

    case T_MACRO: case T_MACRO_STAR: case T_BACRO: case T_BACRO_STAR: 
    case T_CLOSURE: case T_CLOSURE_STAR:
      return(set_closure_ex(sc, cx));

    case T_ITERATOR:     /* not sure this makes sense */
      return(set_iterator_ex(sc, cx));

    case T_SYNTAX:
      return(set_syntax_ex(sc, cx));

    default:                                         /* (set! (1 2) 3) */
      eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, caar_code);
    }
  return(goto_TOP_NO_POP);
}

static void activate_let(s7_scheme *sc, s7_pointer e)
{
  if (!is_let(e))                    /* (with-let . "hi") */
    eval_error_no_return(sc, sc->wrong_type_arg_symbol, "with-let takes an environment argument: ~A", 42, e);
  if (e == sc->rootlet)
    sc->envir = sc->nil;                             /* (with-let (rootlet) ...) */
  else
    {
      set_with_let_let(e);
      let_id(e) = ++sc->let_number;
      sc->envir = e;
      update_symbol_ids(sc, e);
    }
}

static bool tree_match(s7_pointer tree)
{
  if (is_symbol(tree))
    return(is_matched_symbol(tree));
  if (is_pair(tree))
    return((tree_match(car(tree))) || (tree_match(cdr(tree))));
  return(false);
}

#define DO_PRINT 0

static bool do_is_safe(s7_scheme *sc, s7_pointer body, s7_pointer steppers, s7_pointer var_list, bool *has_set)
{
  /* here any (unsafe?) closure or jumping-op (call/cc) or shadowed variable is trouble */
  s7_pointer p;
  if (DO_PRINT) fprintf(stderr, "do_is_safe: %s\n", DISPLAY_80(body));

  for (p = body; is_pair(p); p = cdr(p))
    {
      s7_pointer expr;
      expr = car(p);
      if (DO_PRINT) fprintf(stderr, "    %s\n", DISPLAY_80(expr));
      if (is_pair(expr))
	{
	  s7_pointer x;
	  x = car(expr);
	  if (is_symbol(x))
	    {
	      if (is_syntactic_symbol(x))
		{
		  opcode_t op;
		  s7_pointer func, vars;
		  func = slot_value(global_slot(x));
		  op = (opcode_t)syntax_opcode(func);
		  switch (op)
		    {
		    case OP_MACROEXPAND:
		      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}

		    case OP_QUOTE:
		      if ((!is_pair(cdr(expr))) || (!is_null(cddr(expr))))  /* (quote . 1) or (quote 1 2) etc */
			{if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
		      break;

		    case OP_LET:
		    case OP_LET_STAR:
		    case OP_LETREC:
		    case OP_LETREC_STAR:
		      {
			s7_pointer nv;
			nv = var_list;

			if (!is_pair(cdr(expr)))
			  {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			if (!s7_is_list(sc, cadr(expr)))
			  {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			if (!is_pair(cddr(expr)))
			  {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}

			for (vars = cadr(expr); is_pair(vars); vars = cdr(vars))
			  {
			    s7_pointer var;
			    if (!is_pair(car(vars)))
			      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			    var = caar(vars);
			    if (direct_memq(var, ((op == OP_LET) || (op == OP_LETREC)) ? nv : var_list))
			      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			    nv = cons(sc, var, nv);
			    sc->x = nv;
			  }
			sc->x = sc->nil;
			if (!do_is_safe(sc, cddr(expr), steppers, nv, has_set))
			  {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			break;
		      }

		    case OP_DO:
		      {
			s7_pointer nv;
			if ((!is_pair(cdr(expr))) || (!is_pair(cddr(expr))))  /* (do) or (do (...)) */
			  {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			nv = var_list;
			for (vars = cadr(expr); is_pair(vars); vars = cdr(vars))
			  {
			    s7_pointer var;
			    if (!is_pair(car(vars)))
			      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			    var = caar(vars);
			    if ((direct_memq(var, nv)) ||
				(direct_memq(var, steppers)))
			      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}

			    nv = cons(sc, var, nv);
			    sc->x = nv;
			    if ((is_pair(cdar(vars))) &&
				(!do_is_safe(sc, cdar(vars), steppers, nv, has_set)))
			      {
				sc->x = sc->nil;
				{if (DO_PRINT) fprintf(stderr, "%d, step %s\n", __LINE__, DISPLAY_80(cdar(vars))); return(false);}
			      }
			  }
			sc->x = sc->nil;
			if ((!do_is_safe(sc, caddr(expr), steppers, nv, has_set)) ||
			    (!do_is_safe(sc, cdddr(expr), steppers, nv, has_set)))
			  {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			if (DO_PRINT) fprintf(stderr, "do is ok\n");
			break;
		      }

		    case OP_SET:
		      {
			s7_pointer settee;
			if (!is_pair(cdr(expr)))            /* (set!) */
			  {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			settee = cadr(expr);
			if (!is_symbol(settee))             /* (set! (...) ...) which is tricky due to setter functions/macros */
			  {
			    s7_pointer setv;
			    if ((!is_pair(settee)) ||
				(!is_symbol(car(settee))))
			      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			    setv = lookup_unexamined(sc, car(settee));
			    if (!((setv) &&
				  ((is_sequence(setv)) ||
				   ((is_c_function(setv)) &&
				    (is_safe_procedure(c_function_setter(setv)))))))
			      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			    (*has_set) = true;
			  }
			else
			  {
			    if ((is_pair(cadr(sc->code))) &&
				(is_pair(caadr(sc->code))))
			      {
				bool res;
				set_match_symbol(settee);
				res = tree_match(caadr(sc->code)); /* (set! end ...) in some fashion */
				clear_match_symbol(settee);
				if (res) {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			      }

			    if (!direct_memq(cadr(expr), var_list)) /* is some non-local variable being set? */
			      (*has_set) = true;
			  }
			if (!do_is_safe(sc, cddr(expr), steppers, var_list, has_set))
			  {if (DO_PRINT) fprintf(stderr, "end-test: %d\n", __LINE__); return(false);}
			if (!safe_stepper_expr(expr, steppers))  /* is step var's value used as the stored value by set!? */
			  {if (DO_PRINT) fprintf(stderr, "unsafe stepper: %d\n", __LINE__); return(false);}
		      }
		      break;

		    case OP_LET_TEMPORARILY:
		      {
			s7_pointer lp;
			if ((!is_pair(cdr(expr))) ||
			    (!is_pair(cadr(expr))) ||
			    (!is_pair(cddr(expr))))
			  return(false);
			for (lp = cadr(expr); is_pair(lp); lp = cdr(lp))
			  if ((!is_pair(car(lp))) ||
			      (!is_pair(cdar(lp))) ||
			      (!do_is_safe(sc, cdar(lp), steppers, var_list, has_set)))
			    return(false);
			if (!do_is_safe(sc, cddr(expr), steppers, var_list, has_set))
			  return(false);
			break;
		      }

		    case OP_COND:
		      {
			s7_pointer cp;
			for (cp = cdr(expr); is_pair(cp); cp = cdr(cp))
			  if (!do_is_safe(sc, car(cp), steppers, var_list, has_set))
			    return(false);
			break;
		      }

		    case OP_CASE:
		      {
			s7_pointer cp;
			if (!is_pair(cdr(expr))) return(false);
			if (!do_is_safe(sc, cadr(expr), steppers, var_list, has_set))
			  return(false);
			for (cp = cddr(expr); is_pair(cp); cp = cdr(cp))
			  if ((!is_pair(car(cp))) ||      /* (case x #(123)...) */
			      (!do_is_safe(sc, cdar(cp), steppers, var_list, has_set)))
			    return(false);
			break;
		      }

		    case OP_IF:
		    case OP_WHEN:
		    case OP_UNLESS:
		    case OP_AND:
		    case OP_OR:
		    case OP_BEGIN:
		      if (!do_is_safe(sc, cdr(expr), steppers, var_list, has_set))
			{if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
		      break;

		    case OP_WITH_LET:
		      return(true);

		    default:
		      {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
		    }
		} /* is_syntactic(x=car(expr)) */
	      else
		{
		  /* if a macro, we'll eventually expand it (if *_optimize), but that requires a symbol lookup here and s7_macroexpand */
		  if ((!is_optimized(expr)) ||
		      (!do_is_safe(sc, cdr(expr), steppers, var_list, has_set)))
		    {if (DO_PRINT) fprintf(stderr, "%d, opt: %d\n", __LINE__, is_optimized(expr)); return(false);}
		  else
		    {
		      if (is_setter(x))           /* "setter" includes stuff like cons and vector -- x is a symbol */
			{
			  /* (hash-table-set! ht i 0) -- caddr is being saved, so this is not safe
			   *   similarly (vector-set! v 0 i) etc
			   */
			  if (is_null(cdr(expr)))                         /* (vector) for example */
			    {
			      return((x == sc->vector_symbol) ||
				     (x == sc->list_symbol) ||
				     (x == sc->string_symbol));
			    }
			  if (!direct_memq(cadr(expr), var_list))         /* non-local is being changed */
			    {
			      if ((direct_memq(cadr(expr), steppers)) ||  /* stepper is being set? */
				  (!is_pair(cddr(expr))) ||
				  (!is_pair(cdddr(expr))) ||
				  (is_pair(cddddr(expr))) ||
				  ((x == sc->hash_table_set_symbol) &&
				   (is_symbol(caddr(expr))) &&
				   (direct_memq(caddr(expr), steppers))) ||
				  ((is_symbol(cadddr(expr))) &&
				   (direct_memq(cadddr(expr), steppers))) ||
				  ((is_pair(cadddr(expr))) &&
				   (tree_set_memq_b_7pp(sc, steppers, cadddr(expr)))))
				(*has_set) = true;
			    }
			  if (!do_is_safe(sc, cddr(expr), steppers, var_list, has_set))
			    {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			  if (!safe_stepper_expr(expr, steppers))
			    {if (DO_PRINT) fprintf(stderr, "%d\n", __LINE__); return(false);}
			}
		    }
		}
	    } /* is_symbol(x=car(expr)) */
	  else
	    {
	      {if (DO_PRINT) fprintf(stderr, "%d, %s not a symbol\n", __LINE__, DISPLAY_80(x)); return(false);}
	      /* car(expr) ("x") is not a symbol: ((mus-data loc) chan) for example
	       *   but that's actually safe since it's just in effect vector-ref
	       *   there are several examples in dlocsig: ((group-speakers group) i) etc
	       */
	    }
	}
    }
  return(true);
}

static bool preserves_type(s7_scheme *sc, uint32_t x)
{
  return((x == sc->add_class) ||
	 (x == sc->subtract_class) ||
	 (x == sc->multiply_class));
}

static bool is_simple_expression(s7_scheme *sc, s7_pointer x)
{
  return((!is_pair(x)) ||
	 ((is_optimized(x)) &&
	  (is_fx_safe(sc, x))));
}

static s7_pointer simple_stepper(s7_scheme *sc, s7_pointer v)
{
  if ((safe_list_length(v) == 3) &&
      ((!is_pair(cadr(v))) ||
       (is_h_safe_c_d(cadr(v)))))
    {
      s7_pointer step_expr;
      step_expr = caddr(v);
      if ((is_optimized(step_expr)) &&
	  (((optimize_op(step_expr) == HOP_SAFE_C_SC) && (car(v) == cadr(step_expr))) ||
	   ((is_h_safe_c_d(step_expr)) &&
	    (is_pair(cdr(step_expr))) &&         /* ((v 0 (+))) */
	    (car(v) == cadr(step_expr)) &&
	    ((opt1_cfunc(step_expr) == sc->add_cs1) || (opt1_cfunc(step_expr) == sc->subtract_cs1))) ||
	   ((optimize_op(step_expr) == HOP_SAFE_C_CS) && (car(v) == caddr(step_expr)))))
	return(step_expr);
    }
  return(NULL);
}

static bool is_simple_end(s7_scheme *sc, s7_pointer end)
{
  return((is_optimized(end)) &&
	 (is_pair(cddr(end))) &&      /* end: (zero? n) */
	 (cadr(end) != caddr(end)) &&
#if (!WITH_GMP)
	 ((opt1_any(end) == sc->equal_s_ic) ||
	  (optimize_op(end) == HOP_SAFE_C_SS) || (optimize_op(end) == HOP_SAFE_C_SC)));
#else
         ((optimize_op(end) == HOP_SAFE_C_SS) || (optimize_op(end) == HOP_SAFE_C_SC)));
#endif
}

static s7_pointer check_do(s7_scheme *sc)
{
  s7_pointer x, form, code, vars, end, body, p;
  form = sc->code;
  code = cdr(sc->code);

  if ((!is_pair(code)) ||                             /* (do . 1) */
      ((!is_pair(car(code))) &&                       /* (do 123) */
       (is_not_null(car(code)))))                     /* (do () ...) is ok */
    eval_error(sc, "do: variable list is not a list: ~S", 35, form);

  if (!is_pair(cdr(code)))                            /* (do () . 1) */
    eval_error(sc, "do body is messed up: ~A", 24, form);

  if ((!is_pair(cadr(code))) &&                       /* (do ((i 0)) 123) */
      (is_not_null(cadr(code))))                      /* no end-test? */
    eval_error(sc, "do: end-test and end-value list is not a list: ~A", 49, form);

  if (is_pair(car(code)))
    {
      clear_symbol_list(sc);
      for (x = car(code); is_pair(x); x = cdr(x))
	{
	  s7_pointer y;
	  y = car(x);
	  if (!(is_pair(y)))                             /* (do (4) (= 3)) */
	    eval_error(sc, "do: variable name missing? ~A", 29, form);

	  if (!is_symbol(car(y)))                        /* (do ((3 2)) ()) */
	    eval_error(sc, "do step variable: ~S is not a symbol?", 37, y);

	  if (is_constant_symbol(sc, car(y)))            /* (do ((pi 3 (+ pi 1))) ((= pi 4)) pi) */
	    eval_error(sc, "do step variable: ~S is immutable", 33, y);

	  if (is_pair(cdr(y)))
	    {
	      if (!is_pair(cddr(y)))
		{
		  if (is_not_null(cddr(y)))             /* (do ((i 0 . 1)) ...) */
		    eval_error(sc, "do: step variable info is an improper list?: ~A", 47, x);
		}
	      else
		{
		  if (is_not_null(cdddr(y)))            /* (do ((i 0 1 (+ i 1))) ...) */
		    eval_error(sc, "do: step variable info has extra stuff after the increment: ~A", 62, x);
		}
	    }
	  else eval_error(sc, "do: step variable has no initial value: ~A", 42, x);
	  set_local(car(y));

	  if (symbol_is_in_list(sc, car(y)))            /* (do ((i 0 (+ i 1)) (i 2))...) */
	    eval_error(sc, "duplicate identifier in do: ~A", 30, x);
	  add_symbol_to_list(sc, car(y));
	}
      if (is_not_null(x))                               /* (do ((i 0 i) . 1) ((= i 1))) */
	eval_error(sc, "do: list of variables is improper: ~A", 37, form);
    }

  if (is_pair(cadr(code)))
    {
      for (x = cadr(code); is_pair(x); x = cdr(x));
      if (is_not_null(x))
	eval_error(sc, "stray dot in do end section? ~A", 31, form);
    }

  for (x = cddr(code); is_pair(x); x = cdr(x));
  if (is_not_null(x))
    eval_error(sc, "stray dot in do body? ~A", 24, form);

  pair_set_syntax_op(form, OP_DO_UNCHECKED);
  
  end = cadr(code);
  if (!is_pair(end))              /* () as end+result -- uncommon, normally not optimizable anyway -- use (#f) instead */
    return(code);
  if (is_simple_expression(sc, car(end)))
    set_c_call(end, fx_choose(sc, end, sc->envir, let_symbol_is_safe));
  else return(code);              /* if end is not fxable, give up */
  vars = car(code);
  if (is_null(vars))
    {
      pair_set_syntax_op(form, OP_DO_NO_VARS);
      return(sc->nil);
    }
  
  /* an annoying kludge -- define in the body can clobber (move) the step expressions set up below!
   *      (let ((x 2)) (do ((i 0 (+ i x))) ((= i 4)) (define x 1) (display i)) (newline)) -- steps by 1
   *  or much trickier: (apply (inlet) (func)) as do body where func returns '(define y 32)!
   *  tree_has_definers can't ignore a quoted list because the 'quote might be interpreted separately:
   *   ... (cond '(define x 0)) ...
   */
  if (tree_has_definers(sc, form))       /* we don't want definers in body, vars, or end test */
    return(code);
  
  /* -------------------------------------------------------------------------------- */
  /* old version from here */
  
  /* (define (hi) (do ((i 0 (+ i 1))) ((= i 3)) (display i)) (newline)) */
  /* (define (hi) (do ((i 1.5 (+ i 1))) ((= i 2.5)) (display i) (newline)))
   *   in OP_SAFE_DOTIMES, for example, if init value is not an integer, it goes to OP_SIMPLE_DO
   * remaining optimizable cases: we can step by 1 and use = for end, and yet simple_do(_p) calls the functions
   * geq happens as often as =, and -1 as step, also cdr as step to is_null as end
   * also do body is optimized expr: vector_set_3 via hop_safe_c_sss for example or (vset v i (vref w i))
   */
  
  body = cddr(code);
  if ((is_pair(end)) && (is_pair(car(end))) &&
      (is_pair(vars)) && (is_null(cdr(vars))) &&
      (is_pair(body)) && (is_pair(car(body))) && (is_symbol(caar(body))))
    {
      /* loop has one step variable, and normal-looking end test */
      s7_pointer v, step_expr;
      v = car(vars);
      step_expr = simple_stepper(sc, v);
      if (step_expr)
	{
	  /* step var is (var const|symbol (op var const)|(op const var)) */
	  end = car(end);
	  if ((is_simple_end(sc, end)) &&
	      (car(v) == cadr(end)))
	    {
	      /* end var is (op var const|symbol) using same var as step so at least we can use SIMPLE_DO */
	      bool has_set = false, one_line;
	      one_line = ((is_null(cdr(body))) && (is_pair(car(body))));
	      
	      if (opt1_cfunc(step_expr) == sc->add_cs1)
		{
		  set_c_function(step_expr, sc->add_s1);
		  set_optimize_op(step_expr, HOP_SAFE_C_SC);
		  set_opt2_con(cdr(step_expr), caddr(step_expr));
		}
	      if (opt1_cfunc(step_expr) == sc->subtract_cs1)
		{
		  set_c_function(step_expr, sc->subtract_s1);
		  set_optimize_op(step_expr, HOP_SAFE_C_SC);
		  set_opt2_con(cdr(step_expr), caddr(step_expr));
		}
#if (!WITH_GMP)
	      if (opt1_cfunc(end) == sc->equal_s_ic)
		{
		  set_c_function(end, sc->equal_2);
		  set_optimize_op(end, HOP_SAFE_C_SC);
		  set_opt2_con(cdr(end), caddr(end));
		}
#endif
	      pair_set_syntax_op(form, OP_SIMPLE_DO);              /* simple_do: 1 var easy step/end */
	      
	      if ((one_line) &&
		  ((!is_optimized(car(body))) || (op_no_hop(car(body)) != OP_SAFE_C_D)) &&
		  (is_syntactic_symbol(caar(body))) &&
		  (s7_is_integer(caddr(step_expr))) &&
		  (s7_integer(caddr(step_expr)) == 1) &&
		  (c_function_class(opt1_cfunc(step_expr)) == sc->add_class) &&
		  /* we check above that (car(v) == cadr(step_expr)) and (car(v) == cadr(end)) */
		  ((c_function_class(opt1_cfunc(end)) == sc->equal_class) ||
		   (opt1_cfunc(end) == sc->geq_2)))
		{
		  pair_set_syntax_op(car(body), symbol_syntax_op_checked(car(body)));
		  set_opt2_pair(code, caddr(caar(code)));
		  pair_set_syntax_op(form, OP_DOTIMES_P);          /* dotimes_p: simple + syntax body + 1 expr */
		}
	      
	      /* now look for the very common dotimes case */
	      if ((((s7_is_integer(caddr(step_expr))) &&
		    (s7_integer(caddr(step_expr)) == 1)) ||
		   ((s7_is_integer(cadr(step_expr))) &&
		    (s7_integer(cadr(step_expr)) == 1))) &&
		  (c_function_class(opt1_cfunc(step_expr)) == sc->add_class) &&
		  ((c_function_class(opt1_cfunc(end)) == sc->equal_class) ||
		   (opt1_cfunc(end) == sc->geq_2)))
		{
		  if (do_is_safe(sc, body, sc->w = list_1(sc, car(v)), sc->nil, &has_set))
		    {
		      /* we're stepping by +1 and going to =
		       *   the final integer check has to wait until run time (symbol value dependent)
		       */
		      pair_set_syntax_op(form, OP_SAFE_DO);          /* safe_do: body is safe, step by 1 */
		      if ((!has_set) &&
			  (c_function_class(opt1_cfunc(end)) == sc->equal_class))
			pair_set_syntax_op(form, OP_SAFE_DOTIMES);   /* safe_dotimes: end is = */
		    }
		}
	      return(sc->nil);
	    }
	}
    }
  
  /* we get here if there is more than one local var or anything "non-simple" about the rest
   */
  /* (define (hi) (do ((i 0 (+ i 1))) ((= i 3)) (display i)) (newline))
   * (define (hi) (do ((i 0 (+ i 1)) (j 1 (+ j 1))) ((= i 3)) (display j))(newline))
   */
  for (p = vars; is_pair(p); p = cdr(p))
    {
      s7_pointer var;
      var = car(p);
      
      if ((!is_fx_safe(sc, cadr(var))) ||
	  ((is_pair(cddr(var))) &&
	   (!is_fx_safe(sc, caddr(var)))))
	{
	  s7_pointer q;
	  for (q = vars; q != p; q = cdr(q))
	    clear_match_symbol(caar(q));
	  return(code);
	}
      if (is_pair(cddr(var))) /* if no step expr it's safe in other step exprs 16-Apr-19 */
	set_match_symbol(car(var));
    }
  
  {
    s7_pointer last_stepper = NULL, previous_stepper = NULL, last_expr = NULL, previous_expr = NULL;
    
    for (p = vars; is_pair(p); p = cdr(p))
      {
	s7_pointer var, val;
	var = car(p);
	previous_stepper = last_stepper;
	previous_expr = last_expr;
	last_stepper = car(var);
	val = cddr(var);
	last_expr = val;
	if (is_pair(val))
	  {
	    var = car(var);
	    clear_match_symbol(var); /* ignore current var */
	    if (tree_match(car(val)))
	      {
		/* TODO: just set a flag for pending vars OP_DOX_PENDING 
		 *   t981 iter fib, but otherwise not common (a dozen in s7test)
		 */
		s7_pointer q;
		for (q = vars; is_pair(q); q = cdr(q))
		  clear_match_symbol(caar(q));
		return(code);
	      }
	    set_match_symbol(var);
	  }
      }
    for (p = vars; is_pair(p); p = cdr(p))
      clear_match_symbol(caar(p));
    
    /* end and steps look ok! */
    pair_set_syntax_op(form, OP_DOX);                                     /* dox: vars/end are fxable */
    /* TODO: split out the constant cases from OP_DOX so dox_ex is less repetitive
     *    1-var, no body, 1-expr body, steppers=1|2
     */
    for (p = vars; is_pair(p); p = cdr(p))
      {
	s7_pointer var;
	var = car(p);
	set_c_call(cdr(var), fx_choose(sc, cdr(var), sc->envir, let_symbol_is_safe)); /* init val */
	if (is_pair(cddr(var)))
	  {
	    s7_pointer step_expr;
	    step_expr = caddr(var);
	    set_c_call(cddr(var), fx_choose(sc, cddr(var), vars, do_symbol_is_safe)); /* sets opt2(cddr(var)), not opt1 */
	    
	    if (!is_pair(step_expr))                /* (i 0 0) */
	      {
		if (cadr(var) == caddr(var))        /* not types match: (i x y) etc */
		  set_safe_stepper_expr(cddr(var));
	      }
	    else
	      {
		if ((car(step_expr) != sc->quote_symbol) &&     /* opt1_cfunc(==opt1) might not be set in this case (sigh) */
		    ((preserves_type(sc, c_function_class(opt1_cfunc(step_expr)))) || /* add etc */
		     (car(step_expr) == sc->cdr_symbol) ||
		     (car(step_expr) == sc->cddr_symbol) ||
		     ((is_pair(cadr(var))) &&
		      (is_pair(c_function_signature(c_function_base(opt1_cfunc(step_expr))))) &&
		      (car(c_function_signature(c_function_base(opt1_cfunc(step_expr)))) != sc->T) &&
		      (caadr(var) == car(step_expr)))))	       /* i.e. accept char-position as init/step, but not iterate */
		  set_safe_stepper_expr(cddr(var));
	      }
	  }
      }
    /* there are only a couple of cases in snd-test where a multi-statement do body is completely fx-able */
    
    if ((is_null(body)) &&
	(is_null(cdr(vars))) &&
	(is_pair(cdr(end))) &&
	(is_null(cddr(end))) &&
	(is_simple_expression(sc, cadr(end))) &&
	(is_pair(cdar(vars))) &&
	(is_pair(cddar(vars))))
      {
	s7_function stepf;
	set_c_call(cdr(end), fx_choose(sc, cdr(end), sc->envir, let_symbol_is_safe_or_listed));

	if (not_in_heap(cdr(form)))
	  set_opt3_any(cdr(form), make_permanent_let(sc, vars));
	else set_opt3_any(cdr(form), sc->F);

	pair_set_syntax_op(form, OP_DOX_NO_BODY);

	stepf = c_callee(cddar(vars));
	if ((is_safe_stepper_expr(cddar(vars))) &&
	    ((stepf == fx_c_sub_s1) || (stepf == fx_c_add_s1) || (stepf == fx_c_add_t1) || (stepf == fx_c_sub_t1) || (stepf == fx_c_add_u1)))
	  set_opt2_con(cdr(form), ((stepf == fx_c_sub_s1) || (stepf == fx_c_sub_t1)) ? minus_one : small_int(1));
	else set_opt2_con(cdr(form), small_int(0));
      }

    if (last_stepper)
      {
	fx_tree(sc, end, last_stepper, previous_stepper);
	if ((last_expr) && (is_pair(last_expr)))
	  fx_tree(sc, last_expr, last_stepper, previous_stepper);
	if ((previous_expr) && (is_pair(previous_expr)))
	  fx_tree(sc, previous_expr, last_stepper, previous_stepper);
      }
  }
  return(sc->nil);
}

static bool has_safe_steppers(s7_scheme *sc, s7_pointer frame)
{
  s7_pointer slot;
  for (slot = let_slots(frame); tis_slot(slot); slot = next_slot(slot))
    {
      s7_pointer step_expr, val;
      val = slot_value(slot);
      if (slot_has_expression(slot))
	{
	  step_expr = slot_expression(slot);
	  if (!is_pair(step_expr))
	    {
	      if ((is_null(step_expr)) ||
		  (type(step_expr) == type(val)))
		set_safe_stepper(slot);
	      else clear_safe_stepper(slot);
	    }
	  else
	    {
	      if (is_safe_stepper_expr(step_expr))
		{
		  if (is_t_integer(val))
		    {
		      sc->pc = 0;
		      if (int_optimize(sc, step_expr))
			set_safe_stepper(slot);
		      else clear_safe_stepper(slot);
		    }
		  else
		    {
		      if (is_real(val))
			{
			  sc->pc = 0;
			  if (float_optimize(sc, step_expr))
			    set_safe_stepper(slot);
			  else clear_safe_stepper(slot);
			}
		      else set_safe_stepper(slot);  /* ?? shouldn't this check types ?? */
		    }
		}
	    }
	}
      else 
	{
	  if (is_t_real(val))
	    slot_set_value(slot, s7_make_mutable_real(sc, real(val)));
	  if (is_t_integer(val))
	    slot_set_value(slot, make_mutable_integer(sc, integer(val)));
	  set_safe_stepper(slot);
	}
      if (!is_safe_stepper(slot))
	return(false);
    }
  return(true);
}

static int32_t dox_ex(s7_scheme *sc)
{
  /* any number of steppers using dox exprs, end also dox, body and end result arbitrary.
   *    since all these exprs are local, we don't need to jump until the body
   */
  int64_t id, steppers = 0;
  s7_pointer frame, vars, slot, code, end, endp, stepper = NULL;
  s7_function endf;

  new_frame(sc, sc->envir, frame);   /* new frame is not tied into the symbol lookup process yet */
  sc->temp10 = frame;
  for (vars = car(sc->code); is_pair(vars); vars = cdr(vars))
    {
      s7_pointer expr, val, stp;
      expr = cdar(vars);
      val = fx_call(sc, expr);
      new_cell_no_check(sc, slot, T_SLOT);
      slot_set_symbol(slot, caar(vars));
      slot_set_value(slot, val);
      stp = cdr(expr); /* cddar(vars) */
      if (is_pair(stp))
	{
	  steppers++;
	  stepper = slot;
	  slot_set_expression(slot, stp);
	}
      else slot_just_set_expression(slot, sc->nil);
      set_next_slot(slot, let_slots(frame));
      let_set_slots(frame, slot);
    }
  sc->envir = frame;
  sc->temp10 = sc->nil;
  id = let_id(frame);
  /* the c_calls above could have redefined a previous stepper, so that its symbol_id is > frame let_id when we get here,
   *   so we use symbol_set_local_unchecked below to sidestep the debugger (see zauto.scm: i is a stepper, but then mock-vector-ref uses i as its index)
   */
  for (slot = let_slots(frame); tis_slot(slot); slot = next_slot(slot))
    symbol_set_local_unchecked(slot_symbol(slot), id, slot);

  end = cadr(sc->code);
  endp = car(end);
  endf = c_callee(end);
  if (is_true(sc, sc->value = endf(sc, endp)))
    {
      sc->code = cdr(end);
      return(goto_DO_END_CLAUSES);
    }

  code = cddr(sc->code);
  if (is_null(code)) /* no body? */
    {
      if (endf == fx_c_d)
	{
	  endf = c_callee(endp);
	  endp = cdr(endp);
	}
      if (steppers == 1)
	{
	  s7_function f;
	  s7_pointer a;

	  f = c_callee(slot_expression(stepper)); /* e.g. fx_c_add_s1 */
	  a = car(slot_expression(stepper));
	  if (f == fx_c_d)
	    {
	      f = c_callee(a);
	      a = cdr(a);
	    }
	  if ((f == fx_cdr_s) &&
	      (cadr(a) == slot_symbol(stepper)))
	    {
	      while (true)
		{
		  slot_set_value(stepper, cdr(slot_value(stepper)));
		  if (endf(sc, endp) != sc->F)
		    {
		      sc->value = sc->T;
		      sc->code = cdr(end);
		      return(goto_DO_END_CLAUSES);
		    }
		}
	    }
	  while (true)
	    {
	      slot_set_value(stepper, f(sc, a));
	      if (is_true(sc, sc->value = endf(sc, endp)))
		{
		  sc->code = cdr(end);
		  return(goto_DO_END_CLAUSES);
		}
	    }
	}
      else
	{
	  s7_pointer slots;
	  slots = let_slots(sc->envir);

	  if ((steppers == 2) &&
	      (!tis_slot(next_slot(next_slot(slots)))))
	    {
	      s7_pointer step1, step2, expr1, expr2;
	      step1 = slots;
	      expr1 = slot_expression(step1);
	      step2 = next_slot(step1);
	      expr2 = slot_expression(step2); /* presetting c_call/car(expr) is not faster */
	      while (true)
		{
		  slot_set_value(step1, fx_call(sc, expr1));
		  slot_set_value(step2, fx_call(sc, expr2));
		  if (is_true(sc, sc->value = endf(sc, endp)))
		    {
		      sc->code = cdr(end);
		      if (is_symbol(car(sc->code)))
			{
			  step1 = symbol_to_slot(sc, car(sc->code));
			  sc->value = slot_value(step1);
			  if (is_t_real(sc->value))
			    clear_mutable(sc->value);
			  return(goto_START);
			}
		      return(goto_DO_END_CLAUSES);
		    }
		}
	    }

	  while (true)
	    {
	      s7_pointer slt;
	      for (slt = slots; tis_slot(slt); slt = next_slot(slt))
		if (slot_has_expression(slt))
		  slot_set_value(slt, fx_call(sc, slot_expression(slt)));
	      if (is_true(sc, sc->value = endf(sc, endp)))
		{
		  sc->code = cdr(end);
		  return(goto_DO_END_CLAUSES);
		}
	    }
	}
    }
  else /* there is a body */
    {
      s7_pointer slots;
      slots = let_slots(sc->envir);
      /* is let activated? also multiexpr body  and other fx? */

      if ((is_null(cdr(code))) &&
	  (is_pair(car(code))))
	{
	  s7_pointer lcode;
	  s7_function body = NULL;
	  lcode = car(code);

	  if ((!pair_no_opt(code)) &&
	      (has_safe_steppers(sc, sc->envir)))
	    body = s7_optimize_nr(sc, code);

	  if ((!body) &&
	      (is_fx_safe(sc, lcode)))
	    body = fx_choose(sc, code, sc->envir, let_symbol_is_safe);

	  if (body)
	    {
	      if (steppers == 1)                                /* one expr body, 1 stepper */
		{
		  s7_pointer stepa;
		  s7_function stepf;
		  stepf = c_callee(slot_expression(stepper));
		  stepa = car(slot_expression(stepper));

		  if (body == opt_float_any_nr)
		    {
		      s7_double (*fd)(void *o);
		      opt_info *o;
		      o = sc->opts[0];
		      fd = o->v[0].fd;
		      while (true)
			{
			  sc->pc = 0;
			  fd(o);
			  slot_set_value(stepper, stepf(sc, stepa));
			  if (is_true(sc, sc->value = endf(sc, endp)))
			    {
			      sc->code = cdr(end);
			      return(goto_DO_END_CLAUSES);
			    }
			}
		    }
		  /* split out opt_cell_any_nr gained nothing (see tmp) */
		  while (true)
		    {
		      body(sc, lcode);
		      slot_set_value(stepper, stepf(sc, stepa));
		      if (is_true(sc, sc->value = endf(sc, endp)))
			{
			  sc->code = cdr(end);
			  return(goto_DO_END_CLAUSES);
			}
		    }
		}

	      if ((steppers == 2) &&
		  (!tis_slot(next_slot(next_slot(slots)))))
		{
		  s7_pointer s1, s2, p1, p2;
		  s7_function f1, f2;
		  s1 = slots;
		  s2 = next_slot(slots);
		  f1 = c_callee(slot_expression(s1));
		  f2 = c_callee(slot_expression(s2));
		  p1 = car(slot_expression(s1));
		  p2 = car(slot_expression(s2));
		  /* split out opt_float_any_nr gained nothing (see tmp) */
		  while (true)
		    {
		      body(sc, lcode);
 		      slot_set_value(s1, f1(sc, p1));
 		      slot_set_value(s2, f2(sc, p2));
		      if (is_true(sc, sc->value = endf(sc, endp)))
			{
			  sc->code = cdr(end);
			  return(goto_DO_END_CLAUSES);
			}
		    }
		}
	      while (true)
		{
		  s7_pointer slot1;
		  body(sc, lcode);
		  for (slot1 = slots; tis_slot(slot1); slot1 = next_slot(slot1))
		    if (slot_has_expression(slot1))
		      slot_set_value(slot1, fx_call(sc, slot_expression(slot1)));
		  if (is_true(sc, sc->value = endf(sc, endp)))
		    {
		      sc->code = cdr(end);
		      return(goto_DO_END_CLAUSES);
		    }
		}
	    }
	}
      else /* more than one expr */
	{
	  s7_pointer p;
	  bool use_opts = false;
	  int32_t body_len = 0;
	  p = code;

	  if ((!pair_no_opt(code)) &&
	      (has_safe_steppers(sc, sc->envir)))
	    {
	      if (setjmp(sc->opt_exit) == 0)
		{
		  sc->pc = 0;
		  for (; is_pair(p); p = cdr(p), body_len++)
		    {
		      opt_info *start;
		      start = sc->opts[sc->pc];
		      if (!cell_optimize(sc, p))
			{
			  set_pair_no_opt(code);
			  p = code;
			  break;
			}
		      oo_idp_nr_fixup(start);
		    }
		  use_opts = is_null(p);
		}
	    }

	  if (p == code)
	    {
	      for (; is_pair(p); p = cdr(p))
		if (!is_fx_safe(sc, car(p)))
		  break;
	    }

	  if (is_null(p))
	    {
	      int32_t i;
	      s7_pointer stepa;
	      s7_function stepf;
	      if (!use_opts)
		annotate_args(sc, code, sc->envir);

	      if (stepper)
		{
		  stepf = c_callee(slot_expression(stepper));
		  stepa = car(slot_expression(stepper));
		}

	      while (true)
		{
		  if (use_opts)
		    {
		      sc->pc = 0;
		      for (i = 0; i < body_len; i++)
			{
			  opt_info *o;
			  o = sc->opts[sc->pc];
			  o->v[0].fp(o);
			  sc->pc++;
			}
		    }
		  else
		    {
		      for (p = code; is_pair(p); p = cdr(p))
			fx_call(sc, p);
		    }

		  if (steppers == 1)
		    slot_set_value(stepper, stepf(sc, stepa));
		  else
		    {
		      s7_pointer slot;
		      for (slot = slots; tis_slot(slot); slot = next_slot(slot))
			if (slot_has_expression(slot))
			  slot_set_value(slot, fx_call(sc, slot_expression(slot)));
		    }
		  if (is_true(sc, sc->value = endf(sc, endp)))
		    {
		      sc->code = cdr(end);
		      return(goto_DO_END_CLAUSES);
		    }}}}}

  if ((is_null(cdr(code))) && /* one expr */
      (is_pair(car(code))))
    {
      code = car(code);

      if ((is_syntactic_pair(code)) ||
	  (is_syntactic_symbol(car(code))))
	{
	  
	  /* fprintf(stderr, "step: %ld, code: %s\n", steppers, DISPLAY_80(code)); */
	  /* an experiment -- need to expand this to increments, fxable? -- on the second pass all should be optimized?
	   *   op_let_a_a(1), op_set_symbol_a(10), closure_c|s|a_a, dox? -- need fxable synops
	   */
	  if ((steppers == 1) &&
	      (is_syntactic_pair(code)) &&
	      (optimize_op(code) == OP_SET_SYMBOL_opSq) &&
	      (car(caddr(code)) == sc->cdr_symbol) &&
	      (cadr(code) == cadr(caddr(code))))
	    {
	      s7_pointer stepa, var_loc;
	      s7_function stepf;
	      stepf = c_callee(slot_expression(stepper));
	      stepa = car(slot_expression(stepper));
	      var_loc = symbol_to_slot(sc, cadr(code));
	      while (true)
		{
		  if (is_pair(slot_value(var_loc)))
		    slot_set_value(var_loc, cdr(slot_value(var_loc)));
		  else slot_set_value(var_loc, g_cdr(sc, list_1(sc, slot_value(var_loc))));
		  slot_set_value(stepper, stepf(sc, stepa));
		  if (is_true(sc, sc->value = endf(sc, endp)))
		    {
		      sc->code = cdr(end);
		      return(goto_DO_END_CLAUSES);
		    }
		}
	    }
	  push_stack_no_args(sc, OP_DOX_STEP_P, sc->code);

	  if (is_syntactic_pair(code))
	    sc->cur_op = (opcode_t)optimize_op(code);
	  else
	    {
	      sc->cur_op = (opcode_t)symbol_syntax_op_checked(code);
	      pair_set_syntax_op(code, sc->cur_op);
	    }
	  sc->code = code;
	  return(goto_TOP_NO_POP);
	}
    }
  return(fall_through);
}

static void op_dox_no_body(s7_scheme *sc)
{
  s7_pointer slot, var, step, test, result;
  s7_function testf, stepf;

  sc->code = cdr(sc->code);
  var = caar(sc->code);
  testf = c_callee(cadr(sc->code));
  test = caadr(sc->code);
  result = cdadr(sc->code);

  if (not_in_heap(sc->code))
    {
      s7_pointer frame;
      frame = old_frame_with_slot(sc, opt3_any(sc->code), fx_call(sc, cdr(var)));
      set_outlet(frame, sc->envir);
      sc->envir = frame;
    }
  else new_frame_with_slot(sc, sc->envir, sc->envir, car(var), fx_call(sc, cdr(var)));

  slot = let_slots(sc->envir);
  if ((is_t_integer(slot_value(slot))) &&
      ((integer(opt2_con(sc->code))) != 0))
    {
      s7_int incr;
      s7_pointer istep;
      incr = integer(opt2_con(sc->code));
      istep = make_mutable_integer(sc, integer(slot_value(slot)));
      slot_set_value(slot, istep);
      while (true)
	{
	  if (is_true(sc, testf(sc, test)))
	    {
	      clear_mutable(slot_value(slot));
	      sc->value = fx_call(sc, result);
	      return;
	    }
	  integer(istep) += incr;
	}
    }

  stepf = c_callee(cddr(var));
  step = caddr(var);
  while (true)
    {
      if (is_true(sc, testf(sc, test)))
	{
	  sc->value = fx_call(sc, result);
	  return;
	}
      slot_set_value(slot, stepf(sc, step));
    }
}

static bool op_do_no_vars(s7_scheme *sc)
{
  s7_pointer p, form;
  int32_t i;
  form = sc->code;
  set_current_code(sc, form);
  sc->code = cdr(sc->code);
  sc->pc = 0;
  for (i = 0, p = cddr(sc->code); is_pair(p); i++, p = cdr(p))
    if (!cell_optimize(sc, p))
      break;
  if (is_null(p))
    {
      s7_pointer end;
      end = cadr(sc->code);
      new_frame(sc, sc->envir, sc->envir);
      if (i == 1)
	{
	  while (true)
	    {
	      sc->value = fx_call(sc, end); 
	      if (is_true(sc, sc->value)) 
		{
		  sc->code = cdr(end);
		  return(true);
		}
	      sc->pc = 0;
	      sc->opts[0]->v[0].fp(sc->opts[0]);
	    }
	}
      else
	{
	  if (i == 0) /* null body! */
	    {
	      s7_function endf;
	      s7_pointer endp;
	      endf = c_call(end);
	      endp = car(end);
	      while (!is_true(sc, sc->value = endf(sc, endp))); /* the assignment is (normally) in the noise */
	      sc->code = cdr(end);
	      return(true);
	    }
	  while (true)
	    {
	      int32_t k;
	      sc->value = fx_call(sc, end); 
	      if (is_true(sc, sc->value)) 
		{
		  sc->code = cdr(end);
		  return(true);
		}
	      sc->pc = -1;
	      for (k = 0; k < i; k++)
		{
		  opt_info *o;
		  o = sc->opts[++sc->pc];
		  o->v[0].fp(o);
		}
	    }
	}
    }
  /* back out */
  pair_set_syntax_op(form, OP_DO_NO_VARS_NO_OPT);
  sc->envir = new_frame_in_env(sc, sc->envir);
  sc->value = fx_call(sc, cadr(sc->code));
  if (is_true(sc, sc->value)) 
    {
      sc->code = cdadr(sc->code);
      return(true);
    }
  push_stack_no_args(sc, OP_DO_NO_VARS_NO_OPT_1, sc->code);
  sc->code = T_Pair(cddr(sc->code));
  return(false);
}

static int32_t simple_do_ex(s7_scheme *sc, s7_pointer code)
{
#if (!WITH_GMP)
  s7_pointer body, step_expr, step_var, ctr, end;
  s7_function stepf, endf;
  s7_function func;

  code = cdr(code);
  body = caddr(code);

  if (pair_no_opt(cddr(code)))
    return(fall_through);

  func = s7_optimize_nr(sc, cddr(code));
  if (!func)  /* thash hits this */
    {
      set_pair_no_opt(cddr(code));
      return(fall_through);
    }

  /* func must be set */
  step_expr = caddr(caar(code));
  stepf = c_callee(step_expr);
  endf = c_callee(caadr(code));
  ctr = dox_slot1(sc->envir);
  end = dox_slot2(sc->envir);
  step_var = caddr(step_expr);

  if (((stepf == g_subtract_s1) && (endf == g_less_s0)) ||
      ((stepf == g_add_s1) && ((endf == g_equal_2) || (endf == g_equal_2i))))
    set_safe_stepper(ctr);

  if ((stepf == g_add_s1) &&
      (is_t_integer(slot_value(ctr))) &&
      ((endf == g_equal_2) || (endf == g_equal_2i)) &&
      (is_t_integer(slot_value(end))))
    {
      s7_int i, start, stop;
      start = integer(slot_value(ctr));
      stop = integer(slot_value(end));

      if (func == opt_cell_any_nr)
	{
	  opt_info *o;
	  s7_pointer (*fp)(void *o);
	  o = sc->opts[0];
	  fp = o->v[0].fp;
	  if (fp == opt_p_ppp_sss)
	    {
	      s7_p_ppp_t fp;
	      fp = o->v[4].p_ppp_f;
	      for (i = start; i < stop; i++)
		{
		  slot_set_value(ctr, make_integer(sc, i));
		  fp(sc, slot_value(o->v[1].p), slot_value(o->v[2].p), slot_value(o->v[3].p));
		}
	    }
	  else
	    {
	      if (fp == opt_p_ppp_sfs)
		{
		  s7_p_ppp_t fp;
		  opt_info *o1;
		  fp = o->v[3].p_ppp_f;
		  o1 = sc->opts[1];
		  for (i = start; i < stop; i++)
		    {
		      slot_set_value(ctr, make_integer(sc, i));
		      sc->pc = 1;
		      fp(sc, slot_value(o->v[1].p), o1->v[0].fp(o1), slot_value(o->v[2].p));
		    }
		}
	      else
		{
		  for (i = start; i < stop; i++)
		    {
		      slot_set_value(ctr, make_integer(sc, i));
		      sc->pc = 0;
		      fp(o);
		    }
		}
	    }
	}
      else
	{
	  /* splitting out opt_float_any_nr here saves almost nothing */
	  for (i = start; i < stop; i++)
	    {
	      slot_set_value(ctr, make_integer(sc, i));
	      func(sc, body);
	    }
	}
      sc->value = sc->T;
      sc->code = cdadr(code);
      return(goto_DO_END_CLAUSES);
    }

  while (true)
    {
      func(sc, body);

      set_car(sc->t2_1, slot_value(ctr));
      set_car(sc->t2_2, step_var);
      slot_set_value(ctr, stepf(sc, sc->t2_1));

      set_car(sc->t2_1, slot_value(ctr));
      set_car(sc->t2_2, slot_value(end));
      if (is_true(sc, sc->value = endf(sc, sc->t2_1)))
	{
	  sc->code = cdadr(code);
	  return(goto_DO_END_CLAUSES);
	}
    }
#endif
  return(fall_through);
}

static bool op_simple_do_step(s7_scheme *sc)
{
  s7_pointer step, ctr, end, code;
  ctr = dox_slot1(sc->envir);
  end = dox_slot2(sc->envir);
  code = sc->code;

  step = caddr(caar(code));
  if (is_symbol(cadr(step)))
    {
      set_car(sc->t2_1, slot_value(ctr));
      set_car(sc->t2_2, caddr(step));
    }
  else
    {
      set_car(sc->t2_2, slot_value(ctr));
      set_car(sc->t2_1, cadr(step));
    }
  slot_set_value(ctr, c_call(step)(sc, sc->t2_1));

  set_car(sc->t2_1, slot_value(ctr));
  set_car(sc->t2_2, slot_value(end));
  end = cadr(code);
  sc->value = c_call(car(end))(sc, sc->t2_1);

  if (is_true(sc, sc->value))
    {
      sc->code = cdr(end);
      return(false);
    }

  push_stack(sc, OP_SIMPLE_DO_STEP, sc->args, code);
  sc->code = T_Pair(cddr(code));
  return(true);
}

static bool op_safe_do_step(s7_scheme *sc)
{
  s7_int step, end;
  s7_pointer slot, code;
  code = sc->code;
  slot = dox_slot1(sc->envir);
  step = integer(slot_value(slot)) + 1;
  slot_set_value(slot, make_integer(sc, step));
  end = integer(slot_value(dox_slot2(sc->envir)));

  if ((step == end) ||
      ((step > end) &&
       (opt1_cfunc(caadr(code)) == sc->geq_2)))
    {
      sc->value = sc->T;
      sc->code = cdadr(code);
      return(false);
    }
  push_stack(sc, OP_SAFE_DO_STEP, sc->args, code);
  sc->code = T_Pair(opt2_pair(code));
  return(true);
}

static bool op_dotimes_step_p(s7_scheme *sc)
{
  s7_pointer ctr, now, end, end_test, code;
  code = sc->code;
  ctr = dox_slot1(sc->envir);
  now = slot_value(ctr);
  end = slot_value(dox_slot2(sc->envir));
  end_test = opt2_pair(code);

  if (is_t_integer(now))
    {
      slot_set_value(ctr, make_integer(sc, integer(now) + 1));
      now = slot_value(ctr);
      if (is_t_integer(end))
	{
	  if ((integer(now) == integer(end)) ||
	      ((integer(now) > integer(end)) &&
	       (opt1_cfunc(end_test) == sc->geq_2)))
	    {
	      sc->value = sc->T;
	      sc->code = cdadr(code);
	      return(false);
	    }
	}
      else
	{
	  set_car(sc->t2_1, now);
	  set_car(sc->t2_2, end);
	  end = cadr(code);
	  sc->value = c_call(car(end))(sc, sc->t2_1);
	  if (is_true(sc, sc->value))
	    {
	      sc->code = cdr(end);
	      return(false);
	    }
	}
    }
  else
    {
      set_car(sc->t1_1, now);
      slot_set_value(ctr, g_add_s1(sc, sc->t1_1));
      /* (define (hi) (let ((x 0.0) (y 1.0)) (do ((i y (+ i 1))) ((= i 6)) (do ((i i (+ i 1))) ((>= i 7)) (set! x (+ x i)))) x)) */
      set_car(sc->t2_1, slot_value(ctr));
      set_car(sc->t2_2, end);
      end = cadr(code);
      sc->value = c_call(car(end))(sc, sc->t2_1);
      if (is_true(sc, sc->value))
	{
	  sc->code = cdr(end);
	  return(false);
	}
    }
  push_stack(sc, OP_DOTIMES_STEP_P, sc->args, code);
  sc->code = caddr(code);
  return(true);
}

static bool opt_dotimes(s7_scheme *sc, s7_pointer code, s7_pointer scc, bool safe_step)
{
  s7_int end;
  if (safe_step)
    set_safe_stepper(sc->args);
  else set_safe_stepper(dox_slot1(sc->envir));

  /* I think safe_step means the stepper is completely unproblematic */
  if (is_null(cdr(code)))
    {
      s7_function func;

      if (pair_no_opt(code)) return(false);
      func = s7_optimize_nr(sc, code);
      if (!func)
	return(false);
      end = denominator(slot_value(sc->args));
      if (safe_step)
	{
	  s7_pointer stepper;
	  slot_set_value(sc->args, stepper = make_mutable_integer(sc, integer(slot_value(sc->args))));
	  if ((func == opt_float_any_nr) ||
	      (func == opt_cell_any_nr))
	    {
	      opt_info *o;
	      o = sc->opts[0];
	      if (func == opt_float_any_nr)
		{
		  s7_double (*fd)(void *o);
		  fd = o->v[0].fd;
		  if ((fd == opt_d_id_sf) && /* by far the most common case in clm: (outa i ...) etc */
		      (is_slot(o->v[1].p)) &&
		      (stepper == slot_value(o->v[1].p)))
		    {
		      opt_info *o1;
		      s7_int end8;
		      s7_d_id_t f0;
		      f0 = o->v[3].d_id_f;
		      o1 = sc->opts[1];
		      fd = o1->v[0].fd;
		      end8 = end - 8;
		      while (integer(stepper) < end8)
			LOOP_8(sc->pc = 1; f0(integer(stepper), fd(o1)); integer(stepper)++);
		      while (integer(stepper) < end)
			{
   			  sc->pc = 1;
   			  f0(integer(stepper), fd(o1));
			  integer(stepper)++;
			}
		    }
		  else
		    {
		      for (; integer(stepper) < end; integer(stepper)++)
			{
			  sc->pc = 0;
			  fd(o);
			}
		    }
		}
	      else
		{
		  s7_pointer (*fp)(void *o);
		  fp = o->v[0].fp;
		  /* an experiment -- altogether 100 times as fast! */
		  if ((fp == opt_p_pip_ssc) &&                     /* or any opt without f? */
		      (stepper == slot_value(o->v[2].p)) &&        /* i.e. index by do counter */
		      (o->v[3].p_pip_f == string_set_unchecked) && /* or any similar setter? */
		      (end <= string_length(slot_value(o->v[1].p))))
		    {
		      char *str;
		      str = (char *)(string_value(slot_value(o->v[1].p) + integer(stepper)));
		      local_memset((void *)str, character(o->v[4].p), end - integer(stepper));
		      integer(stepper) = end;
		    }
		  else
		    {
		      int32_t first_pc = 0;
		      if (fp == opt_if_bp)
			fp = opt_if_bp_nr;
		      else
			{
			  if (fp == opt_if_nbp_fs)
			    {
			      fp = opt_if_nbp_fs_nr;
			      first_pc = 2;
			    }
			}
		      for (; integer(stepper) < end; integer(stepper)++)
			{
			  sc->pc = first_pc;
			  fp(o);
			}
		    }
		}
	    }
	  else
	    {
	      if (func == opt_int_any_nr)
		{
		  s7_int (*fi)(void *o);
		  opt_info *o;
		  o = sc->opts[0];
		  fi = o->v[0].fi;
		  if ((fi == opt_i_7pii_ssc) &&
		      (stepper == slot_value(o->v[2].p)) &&
		      (o->v[3].i_7pii_f == int_vector_set_unchecked) &&
		      (end <= vector_length(slot_value(o->v[1].p))))
		    {
		      s7_int val;
		      s7_int *ex;
		      ex = int_vector_ints(slot_value(o->v[1].p));
		      val = o->v[4].i;
		      if (val == 0)
			{
			  memclr((void *)(ex + integer(stepper)), (end - integer(stepper)) * sizeof(s7_int)); /* memclr64 assumes multiple of 8 */
			  integer(stepper) = end;
			}
		      else
			{
			  for (; integer(stepper) < end; integer(stepper)++)
			    ex[integer(stepper)] = val;
			}
		    }
		  else
		    {
		      for (; integer(stepper) < end; integer(stepper)++)
			{
			  sc->pc = 0;
			  fi(o);
			}
		      /* if fi = opt_i_i_s for example, -> o->v[2].i_i_f(integer(slot_value(o->v[1].p)))
		       *   and o->v[2].i_i_f can be pulled out leaving a loop of sc->pc = 0; ov2(integer(slot_value(o->v[1].p)));
		       */
		    }
		}
	      else
		{
		  for (; integer(stepper) < end; integer(stepper)++)
		    func(sc, car(code));
		}
	    }
	}
      else
	{
	  s7_int step;
	  s7_pointer step_slot, end_slot;
	  step_slot = dox_slot1(sc->envir);
	  end_slot = dox_slot2(sc->envir);

	  if (func == opt_cell_any_nr)
	    {
	      opt_info *o;
	      s7_pointer (*fp)(void *o);
	      o = sc->opts[0];
	      fp = o->v[0].fp;
	      if (fp != opt_if_bp_ii_fc)
		{
		  while (true)
		    {
		      sc->pc = 0;
		      fp(o);
		      step = integer(slot_value(step_slot)) + 1;
		      slot_set_value(step_slot, make_integer(sc, step));
		      if (step == integer(slot_value(end_slot))) break;
		    }
		}
	      else
		{ /* can this call opt_if_bp_ii_fc directly and declare it inline? */
		  opt_info *o1, *o2;
		  s7_b_ii_t bif;
		  s7_int i1;
		  o1 = sc->opts[1];
		  bif = o1->v[3].b_ii_f;
		  i1 = o1->v[2].i;
		  o2 = sc->opts[2];
		  while (true)
		    {
		      sc->pc = 2;
		      if (bif(o2->v[0].fi(o2), i1))
			{
			  opt_info *o3;
			  o3 = sc->opts[++sc->pc];
			  o3->v[0].fp(o3);
			}
		      step = integer(slot_value(step_slot)) + 1;
		      slot_set_value(step_slot, make_integer(sc, step));
		      if (step == integer(slot_value(end_slot))) break;
		    }
		}
	    }
	  else
	    {
	      while (true)
		{
		  func(sc, car(code));
		  step = integer(slot_value(step_slot)) + 1;
		  slot_set_value(step_slot, make_integer(sc, step));
		  if (step == integer(slot_value(end_slot))) break;
		}
	    }
	}
      sc->value = sc->T;
      sc->code = cdadr(scc);
      return(true);
    }

  if (setjmp(sc->opt_exit) == 0)
    {
      s7_pointer p;
      s7_int body_len;

      body_len = s7_list_length(sc, code);
      sc->pc = 0;

      if (!no_float_opt(code))
	{
	  for (p = code; is_pair(p); p = cdr(p))
	    if (!float_optimize(sc, p))
	      break;
	  if (is_pair(p))
	    {
	      pc_fallback(sc, 0);
	      set_no_float_opt(code);
	    }
	  else
	    {
	      int32_t i;
	      end = denominator(slot_value(sc->args));
	      if (safe_step)
		{
		  s7_pointer stepper;
		  slot_set_value(sc->args, stepper = make_mutable_integer(sc, integer(slot_value(sc->args))));
		  for (; integer(stepper) < end; integer(stepper)++)
		    {
		      sc->pc = 0;
		      for (i = 0; i < body_len; i++)
			{
			  sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]);
			  sc->pc++;
			}
		    }
		}
	      else
		{
		  s7_pointer step_slot, end_slot;
		  step_slot = dox_slot1(sc->envir);
		  end_slot = dox_slot2(sc->envir);
		  while (true)
		    {
		      s7_int step;
		      sc->pc = 0;
		      for (i = 0; i < body_len; i++)
			{
			  sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]);
			  sc->pc++;
			}

		      step = integer(slot_value(step_slot)) + 1;
		      slot_set_value(step_slot, make_integer(sc, step));
		      if (step == integer(slot_value(end_slot))) break;
		    }
		}
	      sc->value = sc->T;
	      sc->code = cdadr(scc);
	      return(true);
	    }
	}

      /* not float opt */
      for (p = code; is_pair(p); p = cdr(p))
	{
	  opt_info *start;
	  start = sc->opts[sc->pc];
	  if (!cell_optimize(sc, p))
	    break;
	  if (start->v[0].fp == d_to_p)
	    start->v[0].fp = d_to_p_nr;
	}

      if (is_null(p))
	{
	  int32_t i;
	  end = denominator(slot_value(sc->args));
	  if (safe_step)
	    {
	      s7_pointer stepper;
	      slot_set_value(sc->args, stepper = make_mutable_integer(sc, integer(slot_value(sc->args))));
	      for (; integer(stepper) < end; integer(stepper)++)
		{
		  sc->pc = 0;
		  for (i = 0; i < body_len; i++)
		    {
		      opt_info *o;
		      o = sc->opts[sc->pc];
		      o->v[0].fp(o);
		      sc->pc++;
		    }
		}
	    }
	  else
	    {
	      s7_pointer step_slot, end_slot;
	      step_slot = dox_slot1(sc->envir);
	      end_slot = dox_slot2(sc->envir);
	      while (true)
		{
		  s7_int step;
		  sc->pc = 0;
		  for (i = 0; i < body_len; i++)
		    {
		      opt_info *o;
		      o = sc->opts[sc->pc];
		      o->v[0].fp(o);
		      sc->pc++;
		    }

		  step = integer(slot_value(step_slot)) + 1;
		  slot_set_value(step_slot, make_integer(sc, step));
		  if (step == integer(slot_value(end_slot))) break;
		}
	    }
	  sc->value = sc->T;
	  sc->code = cdadr(scc);
	  return(true);
	}
    }
  /* (((i 0 (+ i 1))) ((= i 10) 'gad) (set! ctr (+ ctr 1)) (if (= i 1) (exit arg)))
   * (((k j (+ k 1))) ((= k len2) obj) (set! (obj n) (seq2 k)) (set! n (+ n 1)))
   */
  return(false);
}

static int32_t do_let(s7_scheme *sc, s7_pointer step_slot, s7_pointer scc)
{
  s7_pointer let_body, p = NULL, let_vars, let_code, ip;
  bool let_star;
  s7_pointer old_e, stepper;
  s7_int body_len, var_len, k, end;

  /* do_let with non-float vars doesn't get many fixable hits */
  let_code = caddr(scc);
  if ((!is_pair(cdr(let_code))) || (!is_list(cadr(let_code)))) /* (do ((j 0 (+ j 1))) ((= j 1)) (let name 123)) */
    return(fall_through);
  let_body = cddr(let_code);
  body_len = s7_list_length(sc, let_body);
  if (body_len <= 0) return(fall_through);
  let_star = (symbol_syntax_op_checked(let_code) == OP_LET_STAR);
  let_vars = cadr(let_code);
  set_safe_stepper(step_slot);
  stepper = slot_value(step_slot);

  old_e = sc->envir;
  sc->envir = new_frame_in_env(sc, sc->envir);

  if (setjmp(sc->opt_exit) != 0)
    return(fall_through);

  sc->pc = 0;
  for (var_len = 0, p = let_vars; is_pair(p); var_len++, p = cdr(p))
    {
      s7_pointer expr;
      if ((!is_pair(car(p))) ||
	  (!is_symbol(caar(p))) ||
	  (!is_pair(cdar(p))))
	return(fall_through);
      expr = cdar(p);
      if (!float_optimize(sc, expr))   /* each of these needs to set the associated variable */
	{
	  sc->envir = old_e;
	  return(fall_through);
	}
      if (let_star)
	make_slot_1(sc, sc->envir, caar(p), s7_make_mutable_real(sc, 1.5));
    }

  if (!let_star)
    for (p = let_vars; is_pair(p); p = cdr(p))
      make_slot_1(sc, sc->envir, caar(p), s7_make_mutable_real(sc, 1.5));

  for (p = let_body; is_pair(p); p = cdr(p))
    if (!float_optimize(sc, p))
      {
	sc->envir = old_e;
	return(fall_through);
      }

  if (!is_null(p)) /* no hits in s7test or snd-test */
    {
      sc->envir = old_e;
      return(fall_through);
    }

  end = denominator(stepper);
  let_set_slots(sc->envir, reverse_slots(sc, let_slots(sc->envir)));
  ip = slot_value(step_slot);
  
  if (body_len == 1)
    {
      if (var_len == 1)
	{
	  s7_pointer xp;
	  int32_t pc2;
	  opt_info *first, *o;
	  s7_double (*f1)(void *p);
	  s7_double (*f2)(void *p);
	  xp = slot_value(let_slots(sc->envir));
	  first = sc->opts[0];
	  f1 = first->v[0].fd;
	  integer(ip) = numerator(stepper);
	  sc->pc = 0;
	  set_real(xp, f1(first));
	  pc2 = ++sc->pc;
	  o = sc->opts[pc2];
	  f2 = o->v[0].fd;
	  f2(o);
	  if ((f2 == opt_fmv) &&
	      (f1 == opt_d_dd_ff_o2) &&
	      (first->v[3].d_dd_f == add_d_dd) &&
	      (slot_symbol(step_slot) == slot_symbol(o->v[2].p))) /* and _dv et al throughout (so sc->pc ignored) etc */
	    {
	      /* gcc now refuses to inline opt_fmv -- we are not amused... */
	      opt_info *o1, *o2, *o3;
	      s7_d_v_t vf1, vf2, vf3, vf4;
	      s7_d_vd_t vf5, vf6;
	      s7_d_vid_t vf7;
	      void *obj1, *obj2, *obj3, *obj4, *obj5, *obj6, *obj7;
	      
	      sc->pc = pc2;
	      o1 = o->sc->opts[o->sc->pc + 1];
	      o2 = o->sc->opts[o->sc->pc + 3];
	      o3 = o->sc->opts[o->sc->pc + 5];
	      vf1 = first->v[4].d_v_f;
	      vf2 = first->v[5].d_v_f;
	      vf3 = o1->v[2].d_v_f;
	      vf4 = o3->v[5].d_v_f;
	      vf5 = o2->v[3].d_vd_f;
	      vf6 = o3->v[6].d_vd_f;
	      vf7 = o->v[4].d_vid_f;
	      obj1 = first->v[1].obj;
	      obj2 = first->v[2].obj;
	      obj3 = o1->v[1].obj;
	      obj4 = o3->v[1].obj;
	      obj5 = o->v[5].obj;
	      obj6 = o2->v[5].obj;
	      obj7 = o3->v[2].obj;
	      
	      for (k = numerator(stepper) + 1; k < end; k++)
		{
		  s7_double amp_env, vib;
		  vib = vf1(obj1) + vf2(obj2);
		  amp_env = vf3(obj3);
		  vf7(obj5, k, amp_env * vf5(obj6, vib + (vf4(obj4) * vf6(obj7, vib))));
		}
	    }
	  else
	    {
	      for (k = numerator(stepper) + 1; k < end; k++)
		{
		  integer(ip) = k;
		  sc->pc = 0;
		  set_real(xp, f1(first));
		  sc->pc = pc2;
		  f2(o);
		}
	    }
	} /* body_len == 1 and var_len == 1 */
      else
	{
	  if (var_len == 2)
	    {
	      s7_pointer s1, s2;
	      s1 = let_slots(sc->envir);
	      s2 = next_slot(s1);
	      for (k = numerator(stepper); k < end; k++)
		{
		  integer(ip) = k;
		  sc->pc = 0;
		  set_real(slot_value(s1), sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]));
		  sc->pc++;
		  set_real(slot_value(s2), sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]));
		  sc->pc++;
		  sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]);
		}
	    } /* body_len == 1 and var_len == 2 */
	  else
	    {
	      for (k = numerator(stepper); k < end; k++)
		{
		  integer(ip) = k;
		  sc->pc = 0;
		  for (p = let_slots(sc->envir); tis_slot(p); p = next_slot(p))
		    {
		      set_real(slot_value(p), sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]));
		      sc->pc++;
		    }
		  sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]);
		}
	    }
	}
    } /* body_len == 1 */
  else
    {
      if ((body_len == 2) && (var_len == 1))
	{
	  s7_pointer s1;
	  s1 = let_slots(sc->envir);
	  for (k = numerator(stepper); k < end; k++)
	    {
	      integer(ip) = k;
	      sc->pc = 0;
	      set_real(slot_value(s1), sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]));
	      sc->pc++;
	      sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]);
	      sc->pc++;
	      sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]);
	    }
	}
      else
	{
	  for (k = numerator(stepper); k < end; k++)
	    {
	      int32_t i;
	      integer(ip) = k;
	      sc->pc = 0;
	      for (p = let_slots(sc->envir); tis_slot(p); p = next_slot(p))
		{
		  set_real(slot_value(p), sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]));
		  sc->pc++;
		}
	      for (i = 0; i < body_len; i++)
		{
		  sc->opts[sc->pc]->v[0].fd(sc->opts[sc->pc]);
		  sc->pc++;
		}
	    }
	}
    }
  sc->envir = old_e;
  sc->value = sc->T;
  sc->code = cdadr(scc);
  return(goto_SAFE_DO_END_CLAUSES);
}

static bool dotimes(s7_scheme *sc, s7_pointer code, bool safe_case)
{
  s7_pointer body;
  body = caddr(code);   /* here we assume one expr in body */
  if (((is_syntactic_pair(body)) ||
       (is_syntactic_symbol(car(body)))) &&
      ((symbol_syntax_op_checked(body) == OP_LET) ||
       (symbol_syntax_op(car(body)) == OP_LET_STAR)))
    return(do_let(sc, sc->args, code) == goto_SAFE_DO_END_CLAUSES);
  return(opt_dotimes(sc, cddr(code), code, safe_case));
}

static int32_t safe_dotimes_ex(s7_scheme *sc)
{
  s7_pointer init_val;

  init_val = cadr(caar(sc->code));
  if (is_symbol(init_val))
    init_val = lookup_checked(sc, init_val);
  else
    {
      if (is_pair(init_val))
	init_val = d_call(sc, init_val);
    }
  if (s7_is_integer(init_val))
    {
      s7_pointer end_expr, end_val, code;

      code = sc->code;
      end_expr = caadr(code);
      end_val = caddr(end_expr);
      if (is_symbol(end_val))
	end_val = lookup_checked(sc, end_val);

      if (s7_is_integer(end_val))
	{
	  sc->code = cddr(code);
	  sc->envir = new_frame_in_env(sc, sc->envir);
	  sc->args = make_slot_1(sc, sc->envir, caaar(code), make_mutable_integer(sc, s7_integer(init_val)));

	  denominator(slot_value(sc->args)) = s7_integer(end_val);
	  set_step_end(sc->args);  /* safe_dotimes step is by 1 */

	  /* (define (hi) (do ((i 1 (+ 1 i))) ((= i 1) i))) -- we need the frame even if the loop is not evaluated */

	  /* safe_dotimes: (car(body) is known to be a pair here)
	   *   if 1-expr body look for syntactic case, if let(*) goto do_let, else opt_dotimes
	   *       if they are unhappy, got safe_dotimes_step_p
	   *   else goto opt_dotimes then safe_dotimes_step_o
	   *   if multi-line body, check opt_dotimes, then safe_dotimes_step
	   */

	  if (s7_integer(init_val) == s7_integer(end_val))
	    {
	      sc->value = sc->T;
	      sc->code = cdadr(code);
	      return(goto_SAFE_DO_END_CLAUSES);
	    }

	  if ((is_null(cdr(sc->code))) &&
	      (is_pair(car(sc->code))))
	    {
	      sc->code = car(sc->code);
	      set_opt2_pair(code, sc->code); /* is_pair above */

	      if ((is_syntactic_pair(sc->code)) ||
		  (is_syntactic_symbol(car(sc->code))))
		{
		  if (!is_unsafe_do(code))
		    {
		      if (dotimes(sc, code, true))
			return(goto_SAFE_DO_END_CLAUSES);
		      set_unsafe_do(code);
		    }
		  push_stack(sc, OP_SAFE_DOTIMES_STEP_P, sc->args, code);
		  if (is_syntactic_pair(sc->code))
		    sc->cur_op = (opcode_t)optimize_op(sc->code);
		  else
		    {
		      sc->cur_op = (opcode_t)symbol_syntax_op_checked(sc->code);
		      pair_set_syntax_op(sc->code, sc->cur_op);
		    }
		  return(goto_TOP_NO_POP);
		}
	      /* car not syntactic? */
	      if ((!is_unsafe_do(code)) &&
		  (opt_dotimes(sc, cddr(code), code, true)))
		return(goto_SAFE_DO_END_CLAUSES);
	      set_unsafe_do(code);
	      push_stack(sc, OP_SAFE_DOTIMES_STEP_O, sc->args, code);
	      return(goto_EVAL);
	    }

	  /* multi-line body */
	  if ((!is_unsafe_do(code)) &&
	      (opt_dotimes(sc, sc->code, code, true)))
	    return(goto_SAFE_DO_END_CLAUSES);
	  set_unsafe_do(code);

	  set_opt2_pair(code, sc->code);
	  push_stack(sc, OP_SAFE_DOTIMES_STEP, sc->args, code);
	  return(goto_BEGIN);
	}
    }
  /* no hits in s7test */
  return(fall_through);
}

static int32_t safe_do_ex(s7_scheme *sc)
{
  /* body is safe, step = +1, end is = or >=, but stepper and end might be set (or at least indirectly exported) in the body:
   *    (let ((lst ())) (do ((i 0 (+ i 1))) ((= i 10)) (let ((j (min i 100))) (set! lst (cons j lst)))) lst)
   *  however, we're very restrictive about this in check_do and do_is_safe; even this is considered trouble:
   *    (let ((x 0)) (do ((i i (+ i 1))) ((= i 7)) (set! x (+ x i))) x)
   * but end might not be an integer -- need to catch this earlier.
   */
  s7_pointer end, init_val, end_val, code, form, old_envir;

  /* inits, if not >= opt_dotimes else safe_do_step */
  form = sc->code;
  sc->code = cdr(sc->code);
  code = sc->code;
  init_val = cadaar(code);
  if (is_symbol(init_val))
    init_val = lookup_checked(sc, init_val);
  else
    {
      if (is_pair(init_val))
	init_val = d_call(sc, init_val);
    }

  end = caddr(caadr(code));
  if (is_symbol(end))
    end_val = lookup_checked(sc, end);
  else end_val = end;

  if ((!s7_is_integer(init_val)) || (!s7_is_integer(end_val))) /* this almost never happens */
    {
      pair_set_syntax_op(form, OP_DO_UNCHECKED);
      return(goto_DO_UNCHECKED);
    }

  /* (let ((sum 0)) (define (hi) (do ((i 10 (+ i 1))) ((= i 10) i) (set! sum (+ sum i)))) (hi)) */
  sc->envir = new_frame_in_env(sc, sc->envir);
  dox_set_slot1(sc->envir, make_slot_1(sc, sc->envir, caaar(code), init_val)); /* define the step var -- might be needed in the end clauses */

  if ((s7_integer(init_val) == s7_integer(end_val)) ||
      ((s7_integer(init_val) > s7_integer(end_val)) &&
       (opt1_cfunc(caadr(code)) == sc->geq_2)))
    {
      sc->value = sc->T;
      sc->code = cdadr(code);
      return(goto_SAFE_DO_END_CLAUSES);
    }

  if (is_symbol(end))
    dox_set_slot2(sc->envir, symbol_to_slot(sc, end));
  else dox_set_slot2(sc->envir, make_slot_1(sc, sc->envir, sc->dox_slot_symbol, end));
  sc->args = dox_slot2(sc->envir);  /* the various safe steps assume sc->args is the end slot */
  old_envir = sc->envir;

  if ((!is_unsafe_do(sc->code)) &&
      ((!is_optimized(caadr(code))) ||
       (opt1_cfunc(caadr(code)) != sc->geq_2)))
    {
      if (opt_dotimes(sc, cddr(sc->code), sc->code, false))
	return(goto_SAFE_DO_END_CLAUSES);
      set_unsafe_do(sc->code);
      /* opt_dotimes can change sc->envir (indirectly via s7_optimize I think), but OP_SAFE_DO_STEP assumes dox1 is ok (above), so we can't go on here */
      if (sc->envir != old_envir)
	return(goto_DO_UNCHECKED);
    }
  sc->code = cddr(code);
  set_unsafe_do(sc->code);
  set_opt2_pair(code, sc->code);
  push_stack(sc, OP_SAFE_DO_STEP, sc->args, code); /* (do ((i 0 (+ i 1))) ((= i 2)) (set! (str i) #\a)) */
  return(goto_BEGIN);
}

static int32_t dotimes_p_ex(s7_scheme *sc)
{
  s7_pointer init, end, code, init_val, end_val, slot, form;
  /* (do ... (set! args ...)) -- one line, syntactic */

  form = sc->code;
  sc->code = cdr(sc->code);
  code = sc->code;
  init = cadaar(code);
  if (is_symbol(init))
    init_val = lookup_checked(sc, init);
  else
    {
      if (is_pair(init))
	init_val = d_call(sc, init);
      else init_val = init;
    }
  sc->value = init_val;

  set_opt2_pair(code, caadr(code));
  end = caddr(opt2_pair(code));
  if (is_symbol(end))
    {
      slot = symbol_to_slot(sc, end);
      end_val = slot_value(slot);
    }
  else
    {
      slot = make_slot(sc, sc->dox_slot_symbol, end);
      end_val = end;
    }

  if ((!s7_is_integer(init_val)) || (!s7_is_integer(end_val)))
    {
      pair_set_syntax_op(form, OP_DO_UNCHECKED);
      return(goto_DO_UNCHECKED);
    }

  sc->envir = new_frame_in_env(sc, sc->envir);
  dox_set_slot1(sc->envir, make_slot_1(sc, sc->envir, caaar(code), init_val));
  dox_set_slot2(sc->envir, slot);
  if (!is_symbol(end))
    {
      next_slot(slot) = let_slots(sc->envir);
      let_slots(sc->envir) = slot;
    }
  set_car(sc->t2_1, slot_value(dox_slot1(sc->envir)));
  set_car(sc->t2_2, slot_value(dox_slot2(sc->envir)));
  if (is_true(sc, sc->value = c_call(caadr(code))(sc, sc->t2_1)))
    {
      sc->code = cdadr(code);
      return(goto_DO_END_CLAUSES);
    }

  if ((!is_unsafe_do(code)) &&
      (opt1_cfunc(caadr(code)) != sc->geq_2))
    {
      s7_pointer old_args, old_init;

      old_args = sc->args;
      old_init = slot_value(dox_slot1(sc->envir));
      sc->args = T_Slt(dox_slot1(sc->envir));  /* used in opt_dotimes */
      slot_set_value(sc->args, make_mutable_integer(sc, integer(slot_value(dox_slot1(sc->envir)))));
      denominator(slot_value(sc->args)) = integer(slot_value(dox_slot2(sc->envir)));
      set_step_end(sc->args);                  /* dotimes step is by 1 */

      if (dotimes(sc, code, false))
	return(goto_DO_END_CLAUSES);

      slot_set_value(sc->args, old_init);
      sc->args = old_args;
      set_unsafe_do(code);
      return(goto_DO_UNCHECKED);
    }
  push_stack(sc, OP_DOTIMES_STEP_P, sc->args, code);
  sc->code = caddr(code);
  return(goto_EVAL);
}

static int32_t do_init_ex(s7_scheme *sc)
{
  s7_pointer x, y, z;
  while (true)  /* at start, first value is the loop (for GC protection?), returning sc->value is the next value */
    {
      if (is_multiple_value(sc->value))           /* (do ((i (values 1 2)))...) */
	eval_error_no_return(sc, sc->wrong_type_arg_symbol, "do: variable initial value can't be ~S", 38, cons(sc, sc->values_symbol, sc->value));
      sc->args = cons(sc, sc->value, sc->args);    /* code will be last element (first after reverse), these cons's will be used below for the new frame/slots */
      if (is_pair(sc->code))
	{
	  /* here sc->code is a list like: ((i 0 (+ i 1)) ...) so cadar gets the init value. */
	  s7_pointer init;
	  init = cadar(sc->code);
	  if (is_pair(init))
	    {
	      push_stack(sc, OP_DO_INIT, sc->args, cdr(sc->code));
	      sc->code = init;
	      return(goto_EVAL);
	    }
	  if (is_symbol(init))
	    sc->value = lookup_checked(sc, init);
	  else sc->value = init;
	  sc->code = cdr(sc->code);
	}
      else break;
    }

  /* all the initial values are now in the args list */
  sc->args = safe_reverse_in_place(sc, sc->args);
  sc->code = car(sc->args);                       /* saved at the start */
  z = sc->args;
  sc->args = cdr(sc->args);                       /* init values */

  /* sc->args was cons'd above, so it should be safe to reuse it as the new frame */
  sc->envir = reuse_as_let(sc, z, sc->envir);     /* sc->envir = new_frame_in_env(sc, sc->envir); */

  /* run through sc->code and sc->args adding '( caar(car(code)) . car(args) ) to sc->envir, also reuse sc->args as the new frame slots */
  sc->value = sc->nil;
  y = sc->args;
  for (x = car(sc->code); is_not_null(y); x = cdr(x))
    {
      s7_pointer sym, args;
      sym = caar(x);
      args = cdr(y);
      reuse_as_slot(y, sym, unchecked_car(y));
      set_next_slot(y, let_slots(sc->envir));
      let_set_slots(sc->envir, y);
      symbol_set_local(sym, let_id(sc->envir), y);

      if (is_not_null(cddar(x)))                /* else no incr expr, so ignore it henceforth */
	{
	  s7_pointer p;
	  p = cons(sc, caddar(x), sc->unused);  /* this is where we store the new value */
	  set_opt1_slot(p, y);
	  sc->value = cons_unchecked(sc, p, sc->value);
	}
      y = args;
    }
  sc->args = cons(sc, sc->value = safe_reverse_in_place(sc, sc->value), cadr(sc->code));
  sc->code = cddr(sc->code);

  /* here args is a list of 2 or 3 lists, first is (list (list (var . binding) incr-expr init-value) ...), second is end-expr, third can be result expr
   *   so for (do ((i 0 (+ i 1))) ((= i 3) (+ i 1)) ...) args is ((((i . 0) (+ i 1) 0 #f)) (= i 3) (+ i 1))
   */
  return(fall_through);
}


/* -------------------------------------------------------------------------------- */
static inline bool closure_is_ok_1(s7_scheme *sc, s7_pointer code, uint16_t type, int32_t args)
{
  s7_pointer f;
  f = lookup_unexamined(sc, car(code));
  if ((f == opt1_lambda_unchecked(code)) ||
      ((f) &&
       (typesflag(f) == type) &&
       ((closure_arity(f) == args) || (closure_arity_to_int(sc, f) == args)) && /* 3 type bits to replace this but not hit enough to warrant them */
       (set_opt1_lambda(code, f))))
    return(true);
  sc->last_function = f;
  return(false);
}

static inline bool closure_is_ok_2(s7_scheme *sc, s7_pointer code, uint16_t type, int32_t args)
{
  s7_pointer f;
  f = lookup_unexamined(sc, car(code));
  if ((f == opt1_lambda_unchecked(code)) ||
      ((f) &&
       ((typesflag(f) & (TYPE_MASK | T_SAFE_CLOSURE)) == type) &&
       ((closure_arity(f) == args) || (closure_arity_to_int(sc, f) == args)) &&
       (set_opt1_lambda(code, f))))
    return(true);
  sc->last_function = f;
  return(false);
}

/* it is almost never the case that we already have the value and can see it in the current environment directly,
 *   but once found, the value usually matches the current (opt1_lambda(code)), but it might not:
 *   symbol_ctr is almost useless.  We only care if it is 1.  If we save symbol_ctr in opt2(code),
 *   they can be equal, local_slot can be ok, its value can equal opt1_lambda(code), typesflag(opt1_lambda(code))
 *   can match the target type, and yet opt_lambda is wrong! (recursion backs up, local_slot is actually
 *   out-of-date, symbol has not been redefined).  So, we can't be very smart here.
 *   symbol_ctr==1 does not guarantee that local_slot is a slot (the one definition was local, env has been
 *   exited, slot freed), but it's a cell (not NULL), so we can look at local_slot->object.slt.val no matter
 *   what its true type is.  Then if slot_value==opt_lambda incorrectly, we are incredibly unlucky.
 *   The problem may be that set! does not increment symbol_ctr, and also maybe not (define f1 f2),
 *     but those cases will change the local_slot value. So, the combination as it is now is safe but stupid?
 */

#define closure_is_ok(Sc, Code, Type, Args)			\
  (((symbol_ctr(car(Code)) == 1) &&				\
    (unchecked_slot_value(local_slot(car(Code))) == opt1_lambda_unchecked(Code))) || \
   (closure_is_ok_1(Sc, Code, Type, Args)))

#define closure_is_fine(Sc, Code, Type, Args)			\
  (((symbol_ctr(car(Code)) == 1) &&				\
    (unchecked_slot_value(local_slot(car(Code))) == opt1_lambda_unchecked(Code))) || \
   (closure_is_ok_2(Sc, Code, Type, Args)))

static bool star_arity_is_ok(s7_scheme *sc, s7_pointer val, int32_t args)
{
  int32_t arity;
  arity = closure_star_arity_to_int(sc, val);
  if (arity < 0) return(true);
  return((arity * 2) >= args);
}

static bool closure_star_is_ok_1(s7_scheme *sc, s7_pointer code, uint16_t type, int32_t args)
{
  s7_pointer val;
  val = lookup_unexamined(sc, car(code));
  if ((val == opt1_lambda_unchecked(code)) ||
      ((val) &&
       ((typesflag(val) & (T_SAFE_CLOSURE | TYPE_MASK)) == type) &&
       (star_arity_is_ok(sc, val, args)) &&
       (set_opt1_lambda(code, val))))
    return(true);
  sc->last_function = val;
  return(false);
}

#define closure_star_is_ok(Sc, Code, Type, Args)		\
  (((symbol_ctr(car(Code)) == 1) &&				\
    (unchecked_slot_value(local_slot(car(Code))) == opt1_lambda_unchecked(Code))) ||	\
   (closure_star_is_ok_1(Sc, Code, Type, Args)))

#define MATCH_UNSAFE_CLOSURE        (T_CLOSURE)
#define MATCH_SAFE_CLOSURE          (T_CLOSURE      | T_SAFE_CLOSURE)
#define MATCH_UNSAFE_CLOSURE_STAR   (T_CLOSURE_STAR)
#define MATCH_SAFE_CLOSURE_STAR     (T_CLOSURE_STAR | T_SAFE_CLOSURE)
#define MATCH_UNSAFE_CLOSURE_P      (T_CLOSURE                       | T_ONE_FORM)
#define MATCH_SAFE_CLOSURE_P        (T_CLOSURE      | T_SAFE_CLOSURE | T_ONE_FORM)
#define MATCH_UNSAFE_CLOSURE_M      (T_CLOSURE                       | T_MULTIFORM)
#define MATCH_SAFE_CLOSURE_M        (T_CLOSURE      | T_SAFE_CLOSURE | T_MULTIFORM)
#define MATCH_SAFE_CLOSURE_A        (T_CLOSURE      | T_SAFE_CLOSURE | T_ONE_FORM | T_MULTIFORM)
/* since T_HAS_METHODS is on if there might be methods, this can protect us from that case */

static int32_t fixup_unknown_op(s7_pointer code, s7_pointer func, opcode_t op)
{
  set_optimize_op(code, op);
  set_opt1_lambda(code, func); /* opt_lambda works here because it is the only checked case, but ideally we'd split out all the cases via switch (op) */
  return(goto_EVAL);
}

static int32_t unknown_unknown(s7_scheme *sc)
{
  if ((is_symbol(car(sc->code))) &&
      (!is_slot(symbol_to_slot(sc, car(sc->code)))))
    eval_error_no_return(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, car(sc->code));
  return(fall_through);
}

static int32_t unknown_ex(s7_scheme *sc, s7_pointer f)
{
  s7_pointer code;
  if (!f) /* can be NULL if unbound variable */
    return(unknown_unknown(sc));
  code = sc->code;

  increment_opt3_ctr(code);
  if (opt3_ctr(code) > 100)
    return(fixup_unknown_op(code, f, OP_S));

  switch (type(f))
    {
    case T_CLOSURE:
    case T_CLOSURE_STAR:
      if (!has_methods(f))
	{
	  if (is_null(closure_args(f)))
	    {
	      s7_pointer body;
	      bool safe_case;
	      body = closure_body(f);
	      safe_case = is_safe_closure(f);

	      if (is_null(cdr(body)))
		{
		  if (safe_case)
		    {
		      if (is_fx_safe(sc, car(body)))
			{
			  annotate_arg(sc, body, sc->envir);
			  set_optimize_op(code, OP_SAFE_THUNK_A);
			  set_closure_has_fx(f);
			}
		      else
			{
			  set_optimize_op(code, OP_SAFE_THUNK_P);
			  closure_clear_multiform(f); /* i.e. clear possible has_fx */
			}
		    }
		  else set_optimize_op(code, OP_THUNK_P);
		}
	      else
		{
		  if (safe_case)
		    set_optimize_op(code, OP_SAFE_THUNK);
		  else set_optimize_op(code, OP_THUNK);
		}
	      set_opt1_lambda(code, f);
	      return(goto_EVAL);
	    }
	  if ((is_closure_star(f)) && (is_safe_closure(f)))
	    {
	      set_optimize_op(code, OP_SAFE_CLOSURE_STAR_FX_0);
	      set_opt1_lambda(code, f);
	      return(goto_EVAL);
	    }
	}
      break;

    case T_GOTO:     return(fixup_unknown_op(code, f, OP_GOTO));
    case T_ITERATOR: return(fixup_unknown_op(code, f, OP_ITERATE));

    default:
      if ((is_symbol(car(code))) &&
	  (!is_slot(symbol_to_slot(sc, car(code)))))
	eval_error_no_return(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, car(code));
    }
  return(fixup_unknown_op(code, f, OP_S));
}

static int32_t unknown_g_ex(s7_scheme *sc, s7_pointer f)
{
  s7_pointer code;
  bool sym_case;

  if (!f) /* can be NULL if unbound variable */
    return(unknown_unknown(sc));
  code = sc->code;
#if S7_DEBUGGING
  if (is_pair(cadr(code)))
    fprintf(stderr, "%s[%d]: arg is a pair: %s\n", __func__, __LINE__, DISPLAY(code));
#endif
  sym_case = is_normal_symbol(cadr(code));
  if ((sym_case) &&
      (!is_slot(symbol_to_slot(sc, cadr(code)))))
    return(fall_through);

  increment_opt3_ctr(code);
  if (opt3_ctr(code) > 100)
    {
      /* fprintf(stderr, "unopt %s\n", DISPLAY_80(code)); */
      return(fixup_unknown_op(code, f, (sym_case) ? OP_S_S : OP_S_C));
    }

  switch (type(f))
    {
    case T_C_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      if ((c_function_required_args(f) > 1) ||
	  (c_function_all_args(f) == 0))
	break;

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
      if (sym_case)
	{
	  if (is_safe_procedure(f))
	    set_optimize_op(code, OP_SAFE_C_S);
	  else set_optimize_op(code, OP_C_S);
	  set_c_function(code, f);
	  return(goto_EVAL);
	}
      if (is_safe_procedure(f))
	{
	  set_optimize_op(code, OP_SAFE_C_D);
	  set_c_function(code, f);
	  return(goto_EVAL);
	}
      break;

    case T_CLOSURE:
      if ((!has_methods(f)) &&
	  (closure_arity_to_int(sc, f) == 1))
	{
	  s7_pointer body;
	  body = closure_body(f);
	  if (sym_case)
	    set_opt2_sym(code, cadr(code));
	  else set_opt2_con(code, cadr(code));
	  if (is_safe_closure(f))
	    {
	      if (is_null(cdr(body)))
		{
		  if (is_fx_safe(sc, car(body)))
		    {
		      annotate_arg(sc, body, sc->envir);
		      set_optimize_op(code, (sym_case) ? OP_SAFE_CLOSURE_S_A : OP_SAFE_CLOSURE_C_A);
		      set_closure_has_fx(f);
		      fx_tree(sc, body, car(closure_args(f)), NULL);
		    }
		  else
		    {
		      /* hop if is_constant(sc, car(code)) is not foolproof here -- see t967.scm */
		      set_optimize_op(code, (sym_case) ? OP_SAFE_CLOSURE_S_P : OP_SAFE_CLOSURE_C_P);
		      closure_clear_multiform(f);
		    }
		}
	      else set_optimize_op(code, (sym_case) ? OP_SAFE_CLOSURE_S : OP_SAFE_CLOSURE_C);
	    }
	  else
	    {
	      if (is_null(cdr(body)))
		set_optimize_op(code, (sym_case) ? OP_CLOSURE_S_P : OP_CLOSURE_C_P);
	      else set_optimize_op(code, (sym_case) ? OP_CLOSURE_S : OP_CLOSURE_C);
	    }
	  set_opt1_lambda(code, f);
	  return(goto_EVAL);
	}
      break;

    case T_CLOSURE_STAR:
      if ((!has_methods(f)) &&
	  (closure_star_arity_to_int(sc, f) != 0))
	{
	  annotate_arg(sc, cdr(code), sc->envir);
	  set_opt3_arglen(code, small_int(1));
	  if (lambda_has_simple_defaults(closure_body(f)))
	    {
	      if (arglist_has_rest(sc, closure_args(f)))
		return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_FX_1 : OP_CLOSURE_STAR_FX));
	      return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_A : OP_CLOSURE_STAR_A));
	    }
	  if (is_safe_closure(f))
	    return(fixup_unknown_op(code, f, OP_SAFE_CLOSURE_STAR_FX_1));
	}
      break;

    case T_GOTO:
      annotate_arg(sc, cdr(code), sc->envir);
      set_opt3_arglen(code, small_int(1));
      return(fixup_unknown_op(code, f, OP_GOTO_A));

    case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_VECTOR: case T_BYTE_VECTOR:
      if ((sym_case) ||
	  (is_t_integer(cadr(code))))      /* (v 4/3) */
	{
	  annotate_arg(sc, cdr(code), sc->envir);
	  return(fixup_unknown_op(code, f, OP_VECTOR_A));
	}
      break;

    case T_STRING:
      annotate_arg(sc, cdr(code), sc->envir);
      return(fixup_unknown_op(code, f, OP_STRING_A));

    case T_PAIR:
      annotate_arg(sc, cdr(code), sc->envir);
      return(fixup_unknown_op(code, f, OP_PAIR_A));

    case T_C_OBJECT:
      if (s7_is_aritable(sc, f, 1))
	{
	  annotate_arg(sc, cdr(code), sc->envir);
	  return(fixup_unknown_op(code, f, OP_C_OBJECT_A));
	}
      break;

    case T_LET:
      if (is_normal_symbol(cadr(code)))
	{
	  annotate_arg(sc, cdr(code), sc->envir);
	  return(fixup_unknown_op(code, f, OP_ENVIRONMENT_A));
	}
      set_opt3_any(code, cadr(code));
      return(fixup_unknown_op(code, f, OP_ENVIRONMENT_C));

    case T_HASH_TABLE:
      annotate_arg(sc, cdr(code), sc->envir);
      return(fixup_unknown_op(code, f, OP_HASH_TABLE_A));

    case T_CONTINUATION:
      annotate_arg(sc, cdr(code), sc->envir);
      return(fixup_unknown_op(code, f, OP_CONTINUATION_A));

    default:
      break;
    }
  if ((is_symbol(car(code))) &&
      (!is_slot(symbol_to_slot(sc, car(code)))))
    eval_error_no_return(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, car(code));

  return(fixup_unknown_op(code, f, (sym_case) ? OP_S_S : OP_S_C));
}

static int32_t unknown_a_ex(s7_scheme *sc, s7_pointer f)
{
  s7_pointer code;
  if (!f) /* can be NULL if unbound variable */
    return(unknown_unknown(sc));
  code = sc->code;
#if S7_DEBUGGING
  if (!has_fx(cdr(code)))
    fprintf(stderr, "unknown_a_ex missing _a support? %s\n", DISPLAY_80(code));
#endif

  increment_opt3_ctr(code);
  if (opt3_ctr(code) > 100)
    {
      /* fprintf(stderr, "unopt %s\n", DISPLAY_80(code)); */
      return(fixup_unknown_op(code, f, OP_S_A));
    }

  switch (type(f))
    {
    case T_C_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      if ((c_function_required_args(f) > 1) ||
	  (c_function_all_args(f) == 0))
	break;

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
      set_optimize_op(code, (is_safe_procedure(f)) ? OP_SAFE_C_A : OP_C_A);
      set_c_function(code, f);
      return(goto_EVAL);

    case T_CLOSURE:
      if ((!has_methods(f)) &&
	  (closure_arity_to_int(sc, f) == 1))
	{
	  s7_pointer body;
	  bool one_form, safe_case;

	  body = closure_body(f);
	  one_form = is_null(cdr(body));
	  safe_case = is_safe_closure(f);

	  if (one_form)
	    {
	      if (safe_case)
		{
		  if (is_fx_safe(sc, car(body)))
		    {
		      annotate_arg(sc, body, sc->envir);
		      set_optimize_op(code, OP_SAFE_CLOSURE_A_A);
		      set_closure_has_fx(f);
		      fx_tree(sc, body, car(closure_args(f)), NULL);
		    }
		  else
		    {
		      set_optimize_op(code, OP_SAFE_CLOSURE_A_P);
		      closure_clear_multiform(f);
		    }
		}
	      else
		{
		  if ((c_callee(cdr(code)) == fx_c_sub_si) || (c_callee(cdr(code)) == fx_c_sub_s1) || (c_callee(cdr(code)) == fx_c_sub_t1))
		    {
		      set_opt2_pair(code, cdadr(code));
		      set_optimize_op(code, OP_CLOSURE_SUB_P);
		    }
		  else set_optimize_op(code, OP_CLOSURE_A_P);
		}
	    }
	  else set_optimize_op(code, (safe_case) ? OP_SAFE_CLOSURE_A : OP_CLOSURE_A);

	  /* we might not be in "f" I think, tree_memq(sc, code, body)?? */
	  if ((safe_case) &&
	      (is_very_safe_closure(f)) &&
	      (!tree_has_definers_or_binders(sc, body)) &&
	      (s7_tree_memq(sc, code, body)))
	    fx_tree(sc, cdr(code), car(closure_args(f)), NULL);
	  set_opt1_lambda(code, f);
	  return(goto_EVAL);
	}
      break;

    case T_CLOSURE_STAR:
      if ((!has_methods(f)) &&
	  (closure_star_arity_to_int(sc, f) != 0))
	{
	  if (lambda_has_simple_defaults(closure_body(f)))
	    {
	      if (arglist_has_rest(sc, closure_args(f)))
		return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_FX_1 : OP_CLOSURE_STAR_FX));
	      return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_A : OP_CLOSURE_STAR_A));
	    }
	  if (is_safe_closure(f))
	    return(fixup_unknown_op(code, f, OP_SAFE_CLOSURE_STAR_FX_1));
	}
      break;

    case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_VECTOR: case T_BYTE_VECTOR:
      return(fixup_unknown_op(code, f, OP_VECTOR_A));

    case T_STRING:     return(fixup_unknown_op(code, f, OP_STRING_A));
    case T_PAIR:       return(fixup_unknown_op(code, f, OP_PAIR_A));
    case T_C_OBJECT:   return(fixup_unknown_op(code, f, OP_C_OBJECT_A));
    case T_HASH_TABLE: return(fixup_unknown_op(code, f, OP_HASH_TABLE_A));
    case T_GOTO:       return(fixup_unknown_op(code, f, OP_GOTO_A));

    case T_LET:
      {
	s7_pointer arg1;
	arg1 = cadr(code);
	if (is_pair(arg1))
	  {
	    if (car(arg1) == sc->quote_symbol)
	      {
		set_opt3_any(code, cadadr(code));
		return(fixup_unknown_op(code, f, OP_ENVIRONMENT_C));
	      }
	    return(fixup_unknown_op(code, f, OP_ENVIRONMENT_A)); /* arg is already annotated (unknown_a) */
	  }
	/* is this possible? */
	set_opt3_any(code, cadr(code));
	return(fixup_unknown_op(code, f, OP_ENVIRONMENT_C));
      }

    default:
      /* macro, continuation */
      break;
    }
  if ((is_symbol(car(code))) &&
      (!is_slot(symbol_to_slot(sc, car(code)))))
    eval_error_no_return(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, car(code));

  return(fixup_unknown_op(code, f, OP_S_A)); /* closure with methods etc */
}

static int32_t fixup_closure_star_aa(s7_scheme *sc, s7_pointer f, s7_pointer code)
{
  if (!has_methods(f))
    {
      set_opt3_arglen(code, small_int(2));
      if (lambda_has_simple_defaults(closure_body(f)))
	{
	  if (closure_star_arity_to_int(sc, f) == 2)
	    return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_AA : OP_CLOSURE_STAR_FX));
	  return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_FX_2 : OP_CLOSURE_STAR_FX));
	}
      if (is_safe_closure(f))
	return(fixup_unknown_op(code, f, OP_SAFE_CLOSURE_STAR_FX_2));
    }
  return(fixup_unknown_op(code, f, OP_S_AA));
}

static int32_t unknown_gg_ex(s7_scheme *sc, s7_pointer f)
{
  bool s1, s2;
  s7_pointer code;
  if (!f) /* can be NULL if unbound variable */
    return(unknown_unknown(sc));

  code = sc->code;
#if S7_DEBUGGING
  if ((is_pair(cadr(code))) || (is_pair(caddr(code))))
    fprintf(stderr, "%s[%d]: arg is a pair: %s\n", __func__, __LINE__, DISPLAY(code));
#endif
  s1 = is_normal_symbol(cadr(code));
  s2 = is_normal_symbol(caddr(code));

  if ((s1) &&
      (!is_slot(symbol_to_slot(sc, cadr(code)))))
    return(fall_through);
  if ((s2) &&
      (!is_slot(symbol_to_slot(sc, caddr(code)))))
    return(fall_through);

  switch (type(f))
    {
    case T_C_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      if ((c_function_required_args(f) > 2) ||
	  (c_function_all_args(f) < 2))
	break;

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
      if (is_safe_procedure(f))
	{
	  if (s1)
	    {
	      if (s2)
		{
		  set_optimize_op(code, OP_SAFE_C_SS);
		  set_opt2_sym(cdr(code), caddr(code));
		}
	      else
		{
		  set_opt2_con(cdr(code), caddr(code));
		  set_optimize_op(code, OP_SAFE_C_SC);
		}
	    }
	  else
	    {
	      if (s2)
		{
		  set_opt1_con(cdr(code), (is_pair(cadr(code))) ? cadadr(code) : cadr(code));
		  set_optimize_op(code, OP_SAFE_C_CS);
		}
	      else set_optimize_op(code, OP_SAFE_C_D);
	    }
	}
      else
	{
	  set_optimize_op(code, OP_C_FX);
	  annotate_args(sc, cdr(code), sc->envir);
	}
      set_opt3_arglen(code, small_int(2));
      set_c_function(code, f);
      return(goto_EVAL);

    case T_CLOSURE:
      if (has_methods(f)) break;
      if (((s1) || (s2)) &&
	  (closure_arity_to_int(sc, f) == 2))
	{
	  s7_pointer body;
	  bool one_form, safe_case;

	  body = closure_body(f);
	  one_form = is_null(cdr(body));
	  safe_case = is_safe_closure(f);

	  if ((s1) && (s2))
	    {
	      if (one_form)
		{
		  if (safe_case)
		    {
		      if (is_fx_safe(sc, car(body)))
			{
			  annotate_arg(sc, body, sc->envir);
			  set_optimize_op(code, OP_SAFE_CLOSURE_SS_A);
			  set_closure_has_fx(f);
			}
		      else
			{
			  set_optimize_op(code, OP_SAFE_CLOSURE_SS_P);
			  closure_clear_multiform(f);
			}
		    }
		  else set_optimize_op(code, OP_CLOSURE_SS_P);
		}
	      else set_optimize_op(code, (safe_case) ? OP_SAFE_CLOSURE_SS : OP_CLOSURE_SS);
	    }
	  else
	    {
	      if (one_form)
		{
		  if (safe_case)
		    set_optimize_op(code, (s1) ? OP_SAFE_CLOSURE_SC_P : OP_SAFE_CLOSURE_CS);
		  else set_optimize_op(code, (s1) ? OP_CLOSURE_SC_P : OP_CLOSURE_CS);
		}
	      else set_optimize_op(code, (safe_case) ? ((s1) ? OP_SAFE_CLOSURE_SC : OP_SAFE_CLOSURE_CS) : ((s1) ? OP_CLOSURE_SC : OP_CLOSURE_CS));
	    }
	  if (s2)
	    set_opt2_sym(code, caddr(code));
	  else set_opt2_con(code, caddr(code));
	  set_opt1_lambda(code, f);
	  return(goto_EVAL);
	}
      break;

    case T_CLOSURE_STAR:
      if ((closure_star_arity_to_int(sc, f) != 0) &&
	  (closure_star_arity_to_int(sc, f) != 1))
	{
	  annotate_args(sc, cdr(code), sc->envir);
	  return(fixup_closure_star_aa(sc, f, code));
	}
      break;

    case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_VECTOR: case T_BYTE_VECTOR:
      annotate_args(sc, cdr(code), sc->envir);
      return(fixup_unknown_op(code, f, OP_VECTOR_AA));

    default:
      break;
    }

  if ((is_symbol(car(code))) &&
      (!is_slot(symbol_to_slot(sc, car(code)))))
    eval_error_no_return(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, car(code));

  annotate_args(sc, cdr(code), sc->envir);
  return(fixup_unknown_op(code, f, OP_S_AA));
  /* return(unknown_unknown(sc)); */
}

static int32_t unknown_all_s_ex(s7_scheme *sc, s7_pointer f)
{
  s7_pointer code, arg;
  int32_t num_args;
  if (!f) /* can be NULL if unbound variable */
    return(unknown_unknown(sc));
  code = sc->code;
  num_args = integer(opt3_arglen(code));
  for (arg = cdr(code); is_pair(arg); arg = cdr(arg))
    if (/* (!is_symbol(car(arg))) ||  */            /* can't happen?? */
	(!is_slot(symbol_to_slot(sc, car(arg)))))
      return(fall_through);

  switch (type(f))
    {
    case T_C_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      if ((c_function_required_args(f) > num_args) ||
	  (c_function_all_args(f) < num_args))
	break;

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
      if (is_safe_procedure(f))
	{
	  if (num_args == 3)
	    {
	      set_optimize_op(code, OP_SAFE_C_SSS);
	      set_opt1_sym(cdr(code), caddr(code));
	      set_opt2_sym(cdr(code), cadddr(code));
	    }
	  else set_optimize_op(code, OP_SAFE_C_ALL_S);
	}
      else
	{
	  set_optimize_op(code, OP_C_FX);
	  annotate_args(sc, cdr(code), sc->envir);
	}
      set_c_function(code, f);
      return(goto_EVAL);

    case T_CLOSURE:
      if ((!has_methods(f)) &&
	  (closure_arity_to_int(sc, f) == num_args))
	{
	  annotate_args(sc, cdr(code), sc->envir);
	  return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_FX : OP_CLOSURE_ALL_S));
	}
      break;

    case T_CLOSURE_STAR:
      if ((!has_methods(f)) &&
	  (lambda_has_simple_defaults(closure_body(f))) &&
	  ((closure_star_arity_to_int(sc, f) < 0) || ((closure_star_arity_to_int(sc, f) * 2) >= num_args)))
	{
	  annotate_args(sc, cdr(code), sc->envir);
	  return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_FX : OP_CLOSURE_STAR_FX));
	}
      break;

    default:
      break;
    }
  return(unknown_unknown(sc));
}

static int32_t unknown_aa_ex(s7_scheme *sc, s7_pointer f)
{
  s7_pointer code;

  if (!f) /* can be NULL if unbound variable */
    return(unknown_unknown(sc));

  code = sc->code;
  set_opt3_arglen(code, small_int(2));
  annotate_args(sc, cdr(code), sc->envir);

  increment_opt3_ctr(code);
  if (opt3_ctr(code) > 100)
    return(fixup_unknown_op(code, f, OP_S_AA));

  switch (type(f))
    {
    case T_C_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      if ((c_function_required_args(f) > 2) ||
	  (c_function_all_args(f) < 2))
	break;

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
      set_optimize_op(code, (is_safe_procedure(f)) ? OP_SAFE_C_AA : OP_C_FX);
      set_c_function(code, f);
      return(goto_EVAL);

    case T_CLOSURE:
      if ((!has_methods(f)) &&
	  (closure_arity_to_int(sc, f) == 2))
	{
	  s7_pointer body;
	  bool one_form, safe_case;

	  body = closure_body(f);
	  one_form = is_null(cdr(body));
	  safe_case = is_safe_closure(f);

	  if (one_form)
	    {
	      if (safe_case)
		{
		  if (is_fx_safe(sc, car(body)))
		    {
		      annotate_arg(sc, body, sc->envir);
		      set_optimize_op(code, OP_SAFE_CLOSURE_AA_A);
		      set_closure_has_fx(f);
		    }
		  else
		    {
		      set_optimize_op(code, OP_SAFE_CLOSURE_AA_P);
		      closure_clear_multiform(f);
		    }
		}
	      else set_optimize_op(code, OP_CLOSURE_AA_P);
	    }
	  else set_optimize_op(code, (safe_case) ? OP_SAFE_CLOSURE_AA : OP_CLOSURE_AA);
	  set_opt1_lambda(code, f);
	  return(goto_EVAL);
	}
      break;

    case T_CLOSURE_STAR:
      return(fixup_closure_star_aa(sc, f, code));
      break;

    case T_INT_VECTOR: case T_FLOAT_VECTOR: case T_VECTOR: case T_BYTE_VECTOR:
      return(fixup_unknown_op(code, f, OP_VECTOR_AA));

    default:
      break;
    }

  if ((is_symbol(car(code))) &&
      (!is_slot(symbol_to_slot(sc, car(code)))))
    eval_error_no_return(sc, sc->unbound_variable_symbol, "~A: unbound variable", 20, car(code));

  return(fixup_unknown_op(code, f, OP_S_AA));
}

static int32_t unknown_fx_ex(s7_scheme *sc, s7_pointer f)
{
  s7_pointer code;
  int32_t num_args;
  if (!f) /* can be NULL if unbound variable */
    return(unknown_unknown(sc));
  code = sc->code;
  num_args = (is_pair(cdr(code))) ? integer(opt3_arglen(code)) : 0; /* opt3_arglen is on cdr(code) */

  switch (type(f))
    {
    case T_C_FUNCTION:
    case T_C_RST_ARGS_FUNCTION:
      if ((c_function_required_args(f) > num_args) ||
	  (c_function_all_args(f) < num_args))
	break;

    case T_C_OPT_ARGS_FUNCTION:
    case T_C_ANY_ARGS_FUNCTION:
      if (is_safe_procedure(f))
	set_optimize_op(code, (num_args == 3) ? OP_SAFE_C_AAA : OP_SAFE_C_FX);
      else set_optimize_op(code, OP_C_FX);
      annotate_args(sc, cdr(code), sc->envir);
      set_c_function(code, f);
      return(goto_EVAL);

    case T_CLOSURE:
      if ((!has_methods(f)) &&
	  (closure_arity_to_int(sc, f) == num_args))
	{
	  annotate_args(sc, cdr(code), sc->envir);
	  if (is_safe_closure(f))
	    {
	      if ((is_symbol(cadr(code))) &&
		  (num_args == 3))
		set_optimize_op(code, OP_SAFE_CLOSURE_SAA);
	      else set_optimize_op(code, OP_SAFE_CLOSURE_FX);
	      /* recur doesn't happen much here */
	    }
	  else set_optimize_op(code, OP_CLOSURE_FX);
	  set_opt1_lambda(code, f);
	  return(goto_EVAL);
	}
      break;

    case T_CLOSURE_STAR:
      if ((!has_methods(f)) &&
	  (lambda_has_simple_defaults(closure_body(f))) &&
	  ((closure_star_arity_to_int(sc, f) < 0) || ((closure_star_arity_to_int(sc, f) * 2) >= num_args)))
	{
	  if (num_args > 0)
	    {
	      set_opt3_arglen(code, small_int(num_args));
	      annotate_args(sc, cdr(code), sc->envir);
	    }
	  return(fixup_unknown_op(code, f, (is_safe_closure(f)) ? OP_SAFE_CLOSURE_STAR_FX : OP_CLOSURE_STAR_FX));
	}
      break;

    default:
      break;
    }
  return(unknown_unknown(sc));
}

static void unwind_output_ex(s7_scheme *sc)
{
  bool is_file;
  is_file = is_file_port(sc->code);

  if ((is_output_port(sc->code)) &&
      (!port_is_closed(sc->code)))
    s7_close_output_port(sc, sc->code); /* may call fflush */

  if (((is_output_port(sc->args)) &&
       (!port_is_closed(sc->args))) ||
      (sc->args == sc->F))
    sc->output_port = sc->args;

  if ((is_file) &&
      (is_multiple_value(sc->value)))
    sc->value = splice_in_values(sc, multiple_value(sc->value));
}

static void unwind_input_ex(s7_scheme *sc)
{
  /* sc->code is an input port */
  if (!port_is_closed(sc->code))
    s7_close_input_port(sc, sc->code);

  if ((is_input_port(sc->args)) &&
      (!port_is_closed(sc->args)))
    sc->input_port = sc->args;

  if (is_multiple_value(sc->value))
    sc->value = splice_in_values(sc, multiple_value(sc->value));
}

static int32_t dynamic_wind_ex(s7_scheme *sc)
{
  if (dynamic_wind_state(sc->code) == DWIND_INIT)
    {
      dynamic_wind_state(sc->code) = DWIND_BODY;
      push_stack(sc, OP_DYNAMIC_WIND, sc->nil, sc->code);
      sc->code = dynamic_wind_body(sc->code);
      sc->args = sc->nil;
      return(goto_APPLY);
    }
  if (dynamic_wind_state(sc->code) == DWIND_BODY)
    {
      dynamic_wind_state(sc->code) = DWIND_FINISH;
      if (dynamic_wind_out(sc->code) != sc->F)
	{
	  push_stack(sc, OP_DYNAMIC_WIND, sc->value, sc->code);
	  sc->code = dynamic_wind_out(sc->code);
	  sc->args = sc->nil;
	  return(goto_APPLY);
	}
      if (is_multiple_value(sc->value))
	sc->value = splice_in_values(sc, multiple_value(sc->value));
      return(goto_START);
    }
  if (is_multiple_value(sc->args))       /* (+ 1 (dynamic-wind (lambda () #f) (lambda () (values 2 3 4)) (lambda () #f)) 5) */
    sc->value = splice_in_values(sc, multiple_value(sc->args));
  else sc->value = sc->args;             /* value saved above */
  return(goto_START);
}

static int32_t read_s_ex(s7_scheme *sc)
{
  /* another lint opt */
  s7_pointer port, code;

  code = sc->code;
  port = lookup(sc, cadr(code));

  if (!is_input_port(port)) /* was also not stdin */
    {
      sc->value = g_read(sc, list_1(sc, port));
      return(goto_START);
    }
  /* I guess this port_is_closed check is needed because we're going down a level below */
  if (port_is_closed(port))
    simple_wrong_type_argument_with_type(sc, sc->read_symbol, port, an_open_port_string);

  if (is_function_port(port))
    sc->value = (*(port_input_function(port)))(sc, S7_READ, port);
  else
    {
      if ((is_string_port(port)) &&
	  (port_data_size(port) <= port_position(port)))
	sc->value = eof_object;
      else
	{
	  push_input_port(sc, port);
	  push_stack_op(sc, OP_READ_DONE); /* this stops the internal read process so we only get one form */
	  sc->tok = token(sc);
	  switch (sc->tok)
	    {
	    case TOKEN_EOF:	    return(goto_START);
	    case TOKEN_RIGHT_PAREN: read_error(sc, "unexpected close paren");
	    case TOKEN_COMMA:	    read_error(sc, "unexpected comma");
	    default:
	      sc->value = read_expression(sc);
	      sc->current_line = port_line_number(sc->input_port);  /* this info is used to track down missing close parens */
	      sc->current_file = port_filename(sc->input_port);
	    }
	}
    }
  /* equally read-done and read-list here */
  return(goto_START);
}

static int32_t string_a_ex(s7_scheme *sc)
{
  s7_int index;
  s7_pointer s, x, code;
  code = sc->code;

  s = lookup_checked(sc, car(code));
  x = fx_call(sc, cdr(code));
  if (!is_string(s))
    {
      sc->last_function = s;
      return(fall_through);
    }
  if (!s7_is_integer(x))
    {
      sc->value = string_ref_1(sc, s, set_plist_1(sc, x));
      return(goto_START);
    }
  index = s7_integer(x);
  if ((index < string_length(s)) &&
      (index >= 0))
    {
      sc->value = s7_make_character(sc, ((uint8_t *)string_value(s))[index]);
      return(goto_START);
    }
  sc->value = string_ref_1(sc, s, x);
  return(goto_START);
}

static int32_t vector_a_ex(s7_scheme *sc)
{
  s7_pointer v, x, code;

  code = sc->code;
  v = lookup_checked(sc, car(code));
  if (!is_any_vector(v))
    {
      sc->last_function = v;
      return(fall_through);
    }
  x = fx_call(sc, cdr(code));
  if ((s7_is_integer(x)) &&
      (vector_rank(v) == 1))
    {
      s7_int index;
      index = s7_integer(x);
      if ((index < vector_length(v)) &&
	  (index >= 0))
	{
	  if (is_float_vector(v))
	    sc->value = make_real(sc, float_vector(v, index));
	  else sc->value = vector_getter(v)(sc, v, index);
	  return(goto_START);
	}
    }
  sc->value = vector_ref_1(sc, v, set_plist_1(sc, x));
  return(goto_START);
}

static int32_t vector_aa_ex(s7_scheme *sc)
{
  s7_pointer v, x, y, code;

  code = sc->code;
  v = lookup_checked(sc, car(code));
  if (!is_any_vector(v))
    {
      sc->last_function = v;
      return(fall_through);
    }
  x = fx_call(sc, cdr(code));
  y = fx_call(sc, cddr(code));
  if ((s7_is_integer(x)) &&
      (s7_is_integer(y)) &&
      (vector_rank(v) == 2))
    {
      s7_int ix, iy;
      ix = s7_integer(x);
      iy = s7_integer(y);

      if ((ix >= 0) &&
	  (iy >= 0) &&
	  (ix < vector_dimension(v, 0)) &&
	  (iy < vector_dimension(v, 1)))
	{
	  s7_int index;
	  index = (ix * vector_offset(v, 0)) + iy;
	  sc->value = vector_getter(v)(sc, v, index);
	  return(goto_START);
	}
    }
  sc->value = vector_ref_1(sc, v, set_plist_2(sc, x, y));
  return(goto_START);
}

static void increment_1_ex(s7_scheme *sc)
{
  /* ([set!] ctr (+ ctr 1)) */
  s7_pointer val, y;

  y = symbol_to_slot(sc, cadr(sc->code));
  if (!is_slot(y))
    eval_error_no_return(sc, sc->wrong_type_arg_symbol, "set! ~A: unbound variable", 25, cadr(sc->code));

  val = slot_value(y);
  switch (type(val))
    {
    case T_INTEGER:
      sc->value = make_integer(sc, integer(val) + 1);  /* this can't be optimized to treat y's value as a mutable integer */
      break;

    case T_RATIO:
      new_cell(sc, sc->value, T_RATIO);
      numerator(sc->value) = numerator(val) + denominator(val);
      denominator(sc->value) = denominator(val);
      break;

    case T_REAL:
      sc->value = make_real(sc, real(val) + 1.0);
      break;

    case T_COMPLEX:
      new_cell(sc, sc->value, T_COMPLEX);
      set_real_part(sc->value, real_part(val) + 1.0);
      set_imag_part(sc->value, imag_part(val));
      break;

    default:
      sc->value = g_add(sc, set_plist_2(sc, val, small_int(1)));
      break;
    }
  slot_set_value(y, sc->value);
}

static void decrement_1_ex(s7_scheme *sc)
{
  /* ([set!] ctr (- ctr 1)) */
  s7_pointer val, y;
  y = symbol_to_slot(sc, cadr(sc->code));
  if (!is_slot(y))
    eval_error_no_return(sc, sc->wrong_type_arg_symbol, "set! ~A: unbound variable", 25, cadr(sc->code));
  val = slot_value(y);
  switch (type(val))
    {
    case T_INTEGER:
      sc->value = make_integer(sc, integer(val) - 1);
      break;

    case T_RATIO:
      new_cell(sc, sc->value, T_RATIO);
      numerator(sc->value) = numerator(val) - denominator(val);
      denominator(sc->value) = denominator(val);
      break;

    case T_REAL:
      sc->value = make_real(sc, real(val) - 1.0);
      break;

    case T_COMPLEX:
      new_cell(sc, sc->value, T_COMPLEX);
      set_real_part(sc->value, real_part(val) - 1.0);
      set_imag_part(sc->value, imag_part(val));
      break;

    default:
      sc->value = g_subtract(sc, set_plist_2(sc, val, small_int(1)));
      break;
    }
  slot_set_value(y, sc->value);
}

static void set_pws_ex(s7_scheme *sc)
{
  /* ([set!] (save-dir) "/home/bil/zap/snd") */
  s7_pointer obj;

  obj = caar(sc->code);
  if (is_symbol(obj))
    {
      obj = symbol_to_slot(sc, obj);
      if (is_slot(obj))
	obj = slot_value(obj);
      else eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, caar(sc->code));
    }

  if ((is_c_function(obj)) &&
      (is_procedure(c_function_setter(obj))))
    {
      s7_pointer value;
      value = cadr(sc->code);
      if (is_symbol(value))
	value = lookup_checked(sc, value);

      set_car(sc->t1_1, value);
      sc->value = c_function_call(c_function_setter(obj))(sc, sc->t1_1);
    }
  else eval_error_no_return(sc, sc->syntax_error_symbol, "no generalized set for ~A", 25, obj);
}


/* -------------------------------- apply functions -------------------------------- */

static void apply_c_function(s7_scheme *sc) 	                    /* -------- C-based function -------- */
{
  s7_int len;
  len = safe_list_length(sc->args);
  if (len < c_function_required_args(sc->code))
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, not_enough_arguments_string, sc->code, sc->args));
  if (c_function_all_args(sc->code) < len)
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, sc->code, sc->args));
  sc->value = c_function_call(sc->code)(sc, sc->args);
}

static void apply_c_opt_args_function(s7_scheme *sc)                /* -------- C-based function that has n optional arguments -------- */
{
  s7_int len;
  len = safe_list_length(sc->args);
  if (c_function_all_args(sc->code) < len)
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, sc->code, sc->args));
  sc->value = c_function_call(sc->code)(sc, sc->args);
}

static void apply_c_rst_args_function(s7_scheme *sc)                /* -------- C-based function that has n required args, then any others -------- */
{
  s7_int len;
  len = safe_list_length(sc->args);
  if (len < c_function_required_args(sc->code))
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, not_enough_arguments_string, sc->code, sc->args));
  sc->value = c_function_call(sc->code)(sc, sc->args);
  /* sc->code here need not match sc->code before the function call (map for example) */
}

static void apply_c_any_args_function(s7_scheme *sc)                /* -------- C-based function that can take any number of arguments -------- */
{
  sc->value = c_function_call(sc->code)(sc, sc->args);
}

static void apply_c_macro(s7_scheme *sc)  	                    /* -------- C-based macro -------- */
{
  s7_int len;
  len = safe_list_length(sc->args);

  if (len < c_macro_required_args(sc->code))
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, not_enough_arguments_string, sc->code, sc->args));

  if (c_macro_all_args(sc->code) < len)
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, sc->code, sc->args));

  sc->code = c_macro_call(sc->code)(sc, sc->args);
  if (is_multiple_value(sc->code)) /* can this happen? s7_values splices before returning, and `(values ...) is handled later */
    {
#if S7_DEBUGGING
      fprintf(stderr, "%d unexpected mv code: %s\n", __LINE__, DISPLAY(sc->code));
#endif
      push_stack(sc, OP_EVAL_MACRO_MV, sc->nil, cdr(sc->code));
      sc->code = car(sc->code);
    }
}

static void apply_syntax(s7_scheme *sc)                            /* -------- syntactic keyword as applicable object -------- */
{                                                                  /* current reader-cond macro uses this via (map quote ...) */
  s7_int len;                                                      /*    ((apply lambda '((x) (+ x 1))) 4) */
  if (is_pair(sc->args))                                           /* this is ((pars) . body) */
    {
      len = s7_list_length(sc, sc->args);
      if (len == 0)
	eval_error_no_return(sc, sc->syntax_error_symbol, "attempt to evaluate a circular list: ~S", 39, sc->args);
      
      if ((sc->safety > NO_SAFETY) &&
	  (tree_is_cyclic(sc, sc->args)))
	s7_error(sc, sc->syntax_error_symbol,
		 set_elist_3(sc, wrap_string(sc, "apply ~S: body is circular: ~S", 30), sc->code, sc->args));
    }
  else len = 0;

  if (len < syntax_min_args(sc->code))
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, not_enough_arguments_string, sc->code, sc->args));

  if ((syntax_max_args(sc->code) < len) &&
      (syntax_max_args(sc->code) != -1))
    s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, sc->code, sc->args));

  sc->cur_op = (opcode_t)syntax_opcode(sc->code);                  /* (apply begin '((define x 3) (+ x 2))) */
  /* I used to have elaborate checks here for embedded circular lists, but now i think that is the caller's problem */
  sc->code = cons(sc, sc->code, sc->args);

  pair_set_syntax_op(sc->code, sc->cur_op);
}

static void apply_vector(s7_scheme *sc)                            /* -------- vector as applicable object -------- */
{
  /* sc->code is the vector, sc->args is the list of indices */
  if (is_null(sc->args))                  /* (#2d((1 2) (3 4))) */
    s7_wrong_number_of_args_error(sc, "not enough args for vector-ref: ~A", sc->args);

  if ((is_null(cdr(sc->args))) &&
      (s7_is_integer(car(sc->args))) &&
      (vector_rank(sc->code) == 1))
    {
      s7_int index;
      index = s7_integer(car(sc->args));
      if ((index >= 0) &&
	  (index < vector_length(sc->code)))
	sc->value = vector_getter(sc->code)(sc, sc->code, index);
      else out_of_range(sc, sc->vector_ref_symbol, small_int(2), car(sc->args), (index < 0) ? its_negative_string : its_too_large_string);
    }
  else sc->value = vector_ref_1(sc, sc->code, sc->args);
}

static void apply_string(s7_scheme *sc)                            /* -------- string as applicable object -------- */
{
  if ((is_pair(sc->args)) &&
      (is_null(cdr(sc->args))))
    {
      if (s7_is_integer(car(sc->args)))
	{
	  s7_int index;                  /* not int: ("abs" most-negative-fixnum) */
	  index = s7_integer(car(sc->args));
	  if ((index >= 0) &&
	      (index < string_length(sc->code)))
	    {
	      sc->value = s7_make_character(sc, ((uint8_t *)string_value(sc->code))[index]);
	      return;
	    }
	}
      sc->value = string_ref_1(sc, sc->code, car(sc->args));
      return;
    }
  s7_error(sc, sc->wrong_number_of_args_symbol,
	   set_elist_3(sc, (is_null(sc->args)) ? not_enough_arguments_string : too_many_arguments_string, sc->code, sc->args));
}

static bool apply_pair(s7_scheme *sc)                               /* -------- list as applicable object -------- */
{
  if (is_multiple_value(sc->code))                                  /* ((values 1 2 3) 0) */
    {
      /* car of values can be anything, so conjure up a new expression, and apply again */
      sc->x = multiple_value(sc->code);                             /* ((values + 1 2) 3) */
      sc->code = car(sc->x);
      sc->args = s7_append(sc, cdr(sc->x), sc->args);
      sc->x = sc->nil;
      return(false);
    }
  if (is_null(sc->args))
    s7_wrong_number_of_args_error(sc, "not enough args for list-ref (via list as applicable object): ~A", sc->args);
  sc->value = list_ref_1(sc, sc->code, car(sc->args));            /* (L 1) */
  if (!is_null(cdr(sc->args)))
    sc->value = implicit_index(sc, sc->value, cdr(sc->args));     /* (L 1 2) */
  return(true);
}

static void apply_hash_table(s7_scheme *sc)                        /* -------- hash-table as applicable object -------- */
{
  if (is_null(sc->args))
    s7_wrong_number_of_args_error(sc, "not enough args for hash-table-ref (via hash table as applicable object): ~A", sc->args);
  sc->value = s7_hash_table_ref(sc, sc->code, car(sc->args));
  if (!is_null(cdr(sc->args)))
    sc->value = implicit_index(sc, sc->value, cdr(sc->args));
}

static void apply_let(s7_scheme *sc)                               /* -------- environment as applicable object -------- */
{
  if (is_null(sc->args))
    wrong_type_argument_with_type(sc, sc->let_ref_symbol, 2, sc->args, a_symbol_string);
  else
    {
      sc->value = s7_let_ref(sc, sc->code, car(sc->args));
      if (is_pair(cdr(sc->args)))
	sc->value = implicit_index(sc, sc->value, cdr(sc->args));
    }
  /*    (let ((v #(1 2 3))) (let ((e (curlet))) ((e 'v) 1))) -> 2
   * so (let ((v #(1 2 3))) (let ((e (curlet))) (e 'v 1))) -> 2
   */
}

static void apply_iterator(s7_scheme *sc)                          /* -------- iterator as applicable object -------- */
{
  if (!is_null(sc->args))
    s7_wrong_number_of_args_error(sc, "too many args for iterator: ~A", sc->args);
  sc->value = s7_iterate(sc, sc->code);
}

static void apply_lambda(s7_scheme *sc)                            /* -------- normal function (lambda), or macro -------- */
{             /* load up the current args into the ((args) (lambda)) layout [via the current environment] */
  s7_pointer x, z, e;
  uint64_t id;

  e = sc->envir;
  id = let_id(e);
  for (x = closure_args(sc->code), z = T_Lst(sc->args); is_pair(x); x = cdr(x), z = cdr(z)) /* closure_args can be a symbol, for example */
    {
      s7_pointer sym, slot;
      if (is_null(z))
	s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, not_enough_arguments_string, sc->code, sc->args));
      new_cell(sc, slot, T_SLOT);
#if S7_DEBUGGING
      slot->debugger_bits = 0;
#endif
      sym = car(x);
      slot_set_symbol(slot, sym);
      slot_set_value(slot, T_Pos(unchecked_car(z)));
      symbol_set_local(sym, id, slot);
      set_next_slot(slot, let_slots(e));
      let_set_slots(e, slot);
    }
  if (is_null(x))
    {
      if (is_not_null(z))
	s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, sc->code, sc->args));
    }
  else make_slot_1(sc, sc->envir, x, z);
  sc->code = closure_body(sc->code);
}


/* lambda* */
static s7_pointer star_set(s7_scheme *sc, s7_pointer slot, s7_pointer val, bool check_rest)
{
  if (is_checked_slot(slot))
    return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, parameter_set_twice_string, slot_symbol(slot), sc->args)));
  if ((check_rest) && (is_rest_slot(slot)))
    return(s7_error(sc, sc->wrong_type_arg_symbol,
		    set_elist_3(sc, wrap_string(sc, "can't set rest arg ~S to ~S via keyword", 39),
				slot_symbol(slot), val)));
  set_checked_slot(slot);
  slot_set_value(slot, val);
  return(val);
}

static s7_pointer lambda_star_argument_set_value(s7_scheme *sc, s7_pointer sym, s7_pointer val, s7_pointer slot, bool check_rest)
{
  s7_pointer x;
  if (val == sc->no_value) val = sc->unspecified;
  if (sym == slot_symbol(slot))
    return(star_set(sc, slot, val, check_rest));
  for (x = let_slots(sc->envir) /* presumably the arglist */; tis_slot(x); x = next_slot(x))
    if (slot_symbol(x) == sym)
      return(star_set(sc, x, val, check_rest));
  return(sc->no_value);
}

static s7_pointer lambda_star_set_args(s7_scheme *sc)
{
  bool allow_other_keys;
  s7_pointer lx, cx, zx, code, args, slot;

  code = sc->code;
  args = sc->args;
  cx = closure_args(code);
  slot = let_slots(sc->envir);
  allow_other_keys = ((is_pair(cx)) && (allows_other_keys(cx)));
  lx = sc->args;
  zx = sc->nil;
  while ((is_pair(cx)) &&
	 (is_pair(lx)))
    {
      if (car(cx) == sc->key_rest_symbol)           /* the rest arg, default arg not allowed here (see check_lambda_star_args) */
	{
	  /* next arg is bound to trailing args from this point as a list */
	  zx = sc->key_rest_symbol;
	  cx = cdr(cx);
	  if ((is_keyword(car(lx))) &&
	      (is_pair(cdr(lx))) &&
	      (keyword_symbol(car(lx)) == car(cx)))
	    return(s7_error(sc, sc->wrong_type_arg_symbol,
			    set_elist_3(sc, wrap_string(sc, "can't set rest arg ~S to ~S via keyword", 39), car(cx), cadr(lx))));
	  lambda_star_argument_set_value(sc, car(cx), lx, slot, false);
	  lx = cdr(lx);
	  cx = cdr(cx);
	  slot = next_slot(slot);
	}
      else
	{
	  s7_pointer car_lx;
	  car_lx = car(lx);
	  if (is_keyword(car_lx))
	    {
	      s7_pointer sym;
	      if (!is_pair(cdr(lx)))
		return(s7_error(sc, sc->wrong_type_arg_symbol,
				set_elist_4(sc, wrap_string(sc, "~A: keyword argument's value is missing: ~S in ~S", 49), closure_name(sc, code), lx, args)));
	      sym = keyword_symbol(car_lx);
	      if (lambda_star_argument_set_value(sc, sym, cadr(lx), slot, true) == sc->no_value)
		{
		  /* if default value is a key, go ahead and use this value.
		   *    (define* (f (a :b)) a) (f :c)
		   * this has become much trickier than I anticipated...
		   */
		  if (allow_other_keys)
		    {
		      /* in CL: (defun hi (&key (a 1) &allow-other-keys) a) (hi :b :a :a 3) -> 3
		       * in s7: (define* (hi (a 1) :allow-other-keys) a)    (hi :b :a :a 3) -> 3
		       */
		      lx = cddr(lx);
		      continue;
		    }
		  else return(s7_error(sc, sc->wrong_type_arg_symbol,
				       set_elist_4(sc, wrap_string(sc, "~A: unknown key: ~S in ~S", 25), closure_name(sc, code), lx, args)));
		}
	      lx = cddr(lx);
	      slot = next_slot(slot);
	    }
	  else                                  /* not a key/value pair */
	    {
	      if (is_checked_slot(slot))
		return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, parameter_set_twice_string, slot_symbol(slot), sc->args)));
	      set_checked_slot(slot);
	      slot_set_value(slot, car(lx));
	      slot = next_slot(slot);
	      lx = cdr(lx);
	    }
	  cx = cdr(cx);
	}
    }
  /* (let () (define* (hi (a 1) :allow-other-keys) a) (hi :a 2 32)) -> 'error */
  /* (let () (define* (f (a :b)) a) (list (f) (f 1) (f :c) (f :a :c) (f :a 1) (f))) -> 'error */

  /* check for trailing args with no :rest arg */
  if (is_not_null(lx))
    {
      if ((is_not_null(cx)) ||
	  (zx == sc->key_rest_symbol))
	{
	  if (is_symbol(cx))
	    {
	      if ((is_keyword(car(lx))) &&
		  (is_pair(cdr(lx))) &&
		  (keyword_symbol(car(lx)) == cx))
		return(s7_error(sc, sc->wrong_type_arg_symbol,
				set_elist_3(sc, wrap_string(sc, "can't set rest arg ~S to ~S via keyword", 39), cx, cadr(lx))));
	      slot_set_value(slot, lx);
	    }
	}
      else
	{
	  if (!allow_other_keys)                       /* ((lambda* (a) a) :a 1 2) */
	    return(s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, closure_name(sc, code), args)));
	  /* check trailing args for repeated keys or keys with no values or values with no keys */
	  while (is_pair(lx))
	    {
	      if ((!is_keyword(car(lx))) ||     /* ((lambda* (a :allow-other-keys) a) :a 1 :b 2 3) */
		  (!is_pair(cdr(lx))))          /* ((lambda* (a :allow-other-keys) a) :a 1 :b) */
		return(s7_error(sc, sc->wrong_type_arg_symbol,
				set_elist_3(sc, wrap_string(sc, "~A: not a key/value pair: ~S", 28), closure_name(sc, code), lx)));
	      slot = symbol_to_local_slot(sc, keyword_symbol(car(lx)), sc->envir);
	      if ((is_slot(slot)) &&
		  (is_checked_slot(slot)))
		return(s7_error(sc, sc->wrong_type_arg_symbol, set_elist_3(sc, parameter_set_twice_string, slot_symbol(slot), sc->args)));
	      lx = cddr(lx);
	    }
	}
    }
  return(sc->nil);
}

static inline int32_t lambda_star_default(s7_scheme *sc)
{
  while (true)
    {
      s7_pointer z;
      z = sc->args;
      if (tis_slot(z))
	{
	  if ((slot_value(z) == sc->undefined) &&    /* trouble: (lambda* ((e #<undefined>))...) */
	      (slot_has_expression(z)) &&            /* if default val is not a pair or a symbol, this is false */
	      (!is_checked_slot(z)))  
	    {
	      if (is_closure_star(sc->code))         /* as opposed to macro* and bacro* */
		{
		  s7_pointer val;
		  val = slot_expression(z);
		  if (is_symbol(val))
		    {
		      slot_set_value(z, lookup_checked(sc, val));
		      if (slot_value(z) == sc->undefined)
			{
			  /* the current environment here contains the function parameters which
			   *   defaulted to #<undefined> (or maybe #<unused>?) earlier in apply_lambda_star,
			   *   so (define (f f) (define* (f (f f)) f) (f)) (f 0) looks for the
			   *   default f, finds itself currently undefined, and raises an error!
			   *   So, before claiming it is unbound, we need to check outlet as well.
			   *   But in the case above, the inner define* shadows the caller's
			   *   parameter before checking the default arg values, so the default f
			   *   refers to the define* -- I'm not sure this is a bug.  It means
			   *   that (define* (f (a f)) a) returns f: (equal? f (f)) -> #t, so
			   *   any outer f needs an extra let and endless outlets:
			   *   (let ((f 3)) (let () (define* (f (a ((outlet (outlet (outlet (curlet)))) 'f))) a) (f))) -> 3
			   *   We want the shadowing once the define* is done, so the current mess is simplest.
			   */
			  slot_set_value(z, s7_symbol_local_value(sc, val, outlet(sc->envir)));
			  if (slot_value(z) == sc->undefined)
			    eval_error_no_return(sc, sc->syntax_error_symbol, "lambda* defaults: ~A is unbound", 31, slot_symbol(z));
			}
		    }
		  else
		    {
		      if (is_pair(val))
			{
			  if (car(val) == sc->quote_symbol)
			    {
			      if ((!is_pair(cdr(val))) ||      /* (lambda* ((a (quote))) a) or (lambda* ((a (quote 1 1))) a) etc */
				  (is_pair(cddr(val))))
				eval_error_no_return(sc, sc->syntax_error_symbol, "lambda* default: ~A is messed up", 32, val);
			      slot_set_value(z, cadr(val));
			    }
			  else
			    {
			      push_stack(sc, OP_LAMBDA_STAR_DEFAULT, sc->args, sc->code);
			      sc->code = val;
			      return(goto_EVAL);
			    }
			}
		      else slot_set_value(z, val);
		    }
		}
	      else slot_set_value(z, slot_expression(z));
	    }
	  sc->args = next_slot(z);
	}
      else break;
    }
  sc->args = sc->nil;
  return(fall_through);
}

static int32_t apply_lambda_star(s7_scheme *sc) 	                  /* -------- define* (lambda*) -------- */
{
  s7_pointer z, car_z, val, top;

  if (is_safe_closure(sc->code))
    {
      /* slots are in "reverse order" -- in the same order as the args, despite let printout (which reverses the order!) */
      sc->envir = closure_let(sc->code);
      z = let_slots(sc->envir);
      if (tis_slot(z))
	{
	  for (; tis_slot(z); z = next_slot(z))
	    {
	      clear_checked_slot(z);
	      slot_set_value(z, (slot_defaults(z)) ? sc->undefined : slot_expression(z));
	    }
	  top = slot_pending_value(let_slots(sc->envir));
	  goto SET_ARGS;
	}
      if (!is_null(sc->args))
	s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, closure_name(sc, sc->code), sc->args));
      /* what about (define* (f :allow-other-keys) 0) (f :a-key 21) */
      sc->code = closure_body(sc->code);
      return(goto_BEGIN);
    }

  top = sc->nil;
  for (z = closure_args(sc->code); is_pair(z); z = cdr(z))
    {
      car_z = car(z);
      if (is_pair(car_z))           /* arg has a default value */
	{
	  s7_pointer slot;
	  val = cadr(car_z);
	  if ((!is_pair(val)) &&
	      (!is_symbol(val)))
	    slot = make_slot_1(sc, sc->envir, car(car_z), val);
	  else
	    {
	      add_slot(sc->envir, car(car_z), sc->undefined);
	      slot = let_slots(sc->envir);
	      slot_set_expression(slot, val);
	    }
	  if (is_null(top))
	    top = slot;
	}
      else
	{
	  if (!is_keyword(car_z))
	    make_slot_1(sc, sc->envir, car_z, sc->F);
	  else
	    {
	      if (car_z == sc->key_rest_symbol) /* else it's :allow-other-keys? */
		{
		  set_is_rest_slot(make_slot_1(sc, sc->envir, cadr(z), sc->nil));
		  z = cdr(z);
		}
	    }
	}
    }
  if (is_symbol(z))
    set_is_rest_slot(make_slot_1(sc, sc->envir, z, sc->nil));     /* set up rest arg */
  let_set_slots(sc->envir, reverse_slots(sc, let_slots(sc->envir)));

 SET_ARGS:
  lambda_star_set_args(sc);                     /* load up current arg vals */
  sc->args = top;
  if (is_slot(sc->args))
    {
      /* get default values, which may involve evaluation -- see also OP_LAMBDA_STAR_DEFAULT  */
      push_stack(sc, OP_GC_PROTECT, sc->args, sc->code);
      if (lambda_star_default(sc) == goto_EVAL) return(goto_EVAL);
      pop_stack_no_op(sc);              /* get original args and code back */
    }

  sc->code = closure_body(sc->code);
  return(goto_BEGIN);
}

static void safe_closure_star_a(s7_scheme *sc, s7_pointer code)
{
  s7_pointer p, val, func;
  func = opt1_lambda(code);
  val = fx_call(sc, cdr(code));
  if (is_keyword(val))
    s7_error(sc, sc->wrong_type_arg_symbol,
	     set_elist_4(sc, wrap_string(sc, "~A: keyword argument's value is missing: ~S in ~S", 49),
			 closure_name(sc, func), val, sc->args));
  sc->envir = old_frame_with_slot(sc, closure_let(func), val);
  /* that sets the first arg to the passed symbol value; now set default values, if any */

  p = cdr(closure_args(func));
  if (is_pair(p))
    {
      s7_pointer x;
      for (x = next_slot(let_slots(closure_let(func))); is_pair(p); p = cdr(p), x = next_slot(x))
	{
	  if (is_pair(car(p)))
	    {
	      s7_pointer defval;
	      defval = cadar(p);
	      if (is_pair(defval))
		slot_set_value(x, cadr(defval));
	      else slot_set_value(x, defval);
	    }
	  else slot_set_value(x, sc->F);
	  symbol_set_local(slot_symbol(x), let_id(sc->envir), x);
	}
    }
  sc->code = T_Pair(closure_body(func));
}

static void safe_closure_star_aa(s7_scheme *sc, s7_pointer code)
{
  /* here closure_arity == 2 and we have 2 args */
  s7_pointer arg1, arg2, clet, cargs, p;
  clet = closure_let(opt1_lambda(code));
  cargs = closure_args(opt1_lambda(code));
  p = cdr(code);
  arg1 = fx_call(sc, p);
  arg2 = fx_call(sc, cdr(p));

  if (is_keyword(arg1))
    {
      if (keyword_symbol(arg1) == slot_symbol(let_slots(clet)))
	{
	  arg1 = arg2;
	  arg2 = cadr(cargs);
	  if (is_pair(arg2)) arg2 = cadr(arg2); else arg2 = sc->F;
	}
      else
	{
	  if (keyword_symbol(arg1) == slot_symbol(next_slot(let_slots(clet))))
	    {
	      arg1 = car(cargs);
	      if (is_pair(arg1)) arg1 = cadr(arg1); else arg1 = sc->F;
	    }
	  else
	    s7_error(sc, sc->wrong_type_arg_symbol,
		     set_elist_4(sc, wrap_string(sc, "~A: unknown keyword argument: ~S in ~S", 38),
				 closure_name(sc, opt1_lambda(code)), arg1, code));
	}
    }
  else
    {
      if (is_keyword(arg2))
	s7_error(sc, sc->wrong_type_arg_symbol,
		 set_elist_4(sc, wrap_string(sc, "~A: keyword argument's value is missing: ~S in ~S", 49),
			     closure_name(sc, opt1_lambda(code)), arg2, code));
    }
  sc->envir = old_frame_with_two_slots(sc, clet, arg1, arg2);
  sc->code = T_Pair(closure_body(opt1_lambda(code)));
}

static int32_t safe_closure_star_fx_0(s7_scheme *sc, s7_pointer code)
{
  sc->args = sc->nil;
  sc->code = opt1_lambda(code);
  return(apply_lambda_star(sc));
}

#define call_lambda_star(sc) do {sc->code = opt1_lambda(code); target = apply_lambda_star(sc); clear_list_in_use(arglist); sc->current_safe_list = 0;} while (0)

static int32_t safe_closure_star_fx_1(s7_scheme *sc, s7_pointer code)
{
  int32_t target;
  s7_pointer arglist;
  sc->args = safe_list_1(sc);
  arglist = sc->args;
  set_car(sc->args, fx_call(sc, cdr(code)));
  call_lambda_star(sc);
  return(target);
}

static int32_t safe_closure_star_fx_2(s7_scheme *sc, s7_pointer code)
{
  int32_t target;
  s7_pointer arglist, p;
  sc->args = safe_list_2(sc);
  arglist = sc->args;
  set_car(sc->args, fx_call(sc, cdr(code)));
  p = cddr(code);
  set_car(cdr(sc->args), fx_call(sc, p));
  call_lambda_star(sc);
  return(target);
}

static int32_t safe_closure_star_fx(s7_scheme *sc, s7_pointer code)
{
  s7_pointer old_args, p, arglist;
  int32_t target;
#if S7_DEBUGGING
  if (!is_pair(cdr(code))) fprintf(stderr, "%s[%d]: no args!\n", __func__, __LINE__);
#endif
  sc->args = safe_list_if_possible(sc, integer(opt3_arglen(code)));
  arglist = sc->args;
  for (p = sc->args, old_args = cdr(code); is_pair(p); p = cdr(p), old_args = cdr(old_args))
    set_car(p, fx_call(sc, old_args));
  call_lambda_star(sc);
  return(target);
}

static void closure_star_a(s7_scheme *sc, s7_pointer code)
{
  s7_pointer val, p, func;

  val = fx_call(sc, cdr(code));
  if (is_keyword(val))
    s7_error(sc, sc->wrong_type_arg_symbol,
	     set_elist_4(sc, wrap_string(sc, "~A: keyword argument's value is missing: ~S in ~S", 49),
			 closure_name(sc, opt1_lambda(code)), val, code));

  func = opt1_lambda(code);
  if (closure_star_arity_to_int(sc, func) == 1)
    {
      p = car(closure_args(func));
      new_frame_with_slot(sc, closure_let(func), sc->envir, (is_pair(p)) ? car(p) : p, val);
    }
  else
    {
      s7_pointer x, z, e;
      uint64_t id;

      sc->args = list_1(sc, val);
      p = cdr(closure_args(func));
      for (; is_pair(p); p = cdr(p))
	{
	  if (is_pair(car(p)))
	    {
	      s7_pointer defval;
	      defval = cadar(p);
	      if (is_pair(defval))
		sc->args = cons(sc, cadr(defval), sc->args);
	      else sc->args = cons(sc, defval, sc->args);
	    }
	  else sc->args = cons(sc, sc->F, sc->args);
	}
      sc->args = safe_reverse_in_place(sc, sc->args);
      new_frame(sc, closure_let(func), sc->envir);
      e = sc->envir;
      id = let_id(e);

      for (x = closure_args(func), z = sc->args; is_pair(x); x = cdr(x))
	{
	  s7_pointer sym, args;
	  if (is_pair(car(x)))
	    sym = caar(x);
	  else sym = car(x);
	  args = cdr(z);
	  reuse_as_slot(z, sym, unchecked_car(z));
	  symbol_set_local(sym, id, z);
	  set_next_slot(z, let_slots(e));
	  let_set_slots(e, z);
	  z = args;
	}
    }
  sc->code = T_Pair(closure_body(func));
}

static inline void closure_star_fx(s7_scheme *sc, s7_pointer code)
{
  s7_pointer p, old_args;
  if (is_pair(cdr(code)))
    {
      sc->w = cdr(code);               /* args aren't evaluated yet */
      sc->args = make_list(sc, integer(opt3_arglen(code)), sc->F);
      for (p = sc->args, old_args = sc->w; is_pair(p); p = cdr(p), old_args = cdr(old_args))
	set_car(p, fx_call(sc, old_args));
      sc->w = sc->nil;
    }
  else sc->args = sc->nil;
  sc->code = opt1_lambda(code);
  new_frame(sc, closure_let(sc->code), sc->envir);
}

static int32_t define1_ex(s7_scheme *sc)
{
  /* sc->code is the symbol being defined, sc->value is its value
   *   if sc->value is a closure, car is of the form ((args...) body...)
   * it's not possible to expand and replace macros at this point without evaluating
   *   the body.  Just as examples, say we have a macro "mac",
   *   (define (hi) (call/cc (lambda (mac) (mac 1))))
   *   (define (hi) (quote (mac 1))) or macroexpand etc
   *   (define (hi mac) (mac 1)) assuming mac here is a function passed as an arg, etc...
   * the immutable constant check needs to wait until we have the actual new value because
   *   we want to ignore the rebinding (not raise an error) if it is the existing value.
   *   This happens when we reload a file that calls define-constant.
   */
  if (is_multiple_value(sc->value))                 /* (define x (values 1 2)) */
    eval_error_no_return(sc, sc->syntax_error_symbol, "define: more than one value: ~S", 31, sc->value);
  if (is_constant_symbol(sc, sc->code))             /* (define pi 3) or (define (pi a) a) */
    {
      s7_pointer x;

      if (is_slot(global_slot(sc->code)))
	x = global_slot(sc->code);
      else x = symbol_to_slot(sc, sc->code);  /* local_slot can be free even if sc->code is immutable (local constant now defunct) */

      if (!((is_slot(x)) &&
	    (type(sc->value) == unchecked_type(slot_value(x))) &&
	    (s7_is_equivalent(sc, sc->value, slot_value(x)))))    /* if value is unchanged, just ignore this (re)definition */
	eval_error_no_return(sc, sc->syntax_error_symbol, "define: ~S is immutable", 23, sc->code);   /*   can't use s7_is_equal because value might be NaN, etc */
    }
  if (symbol_has_setter(sc->code))
    {
      s7_pointer x;
      x = symbol_to_slot(sc, sc->code);
      if ((is_slot(x)) &&
	  (slot_has_setter(x)))
	{
	  sc->value = bind_symbol_with_setter(sc, OP_DEFINE_WITH_SETTER, sc->code, sc->value);
	  if (sc->value == sc->no_value)
	    return(goto_APPLY);
	  /* if all goes well, OP_DEFINE_WITH_SETTER will jump to DEFINE2 */
	}
    }
  return(fall_through);
}

static void define2_ex(s7_scheme *sc)
{
  if ((is_immutable(sc->envir)) &&
      (is_let(sc->envir))) /* not () */
    eval_error_no_return(sc, sc->syntax_error_symbol, "define ~S: let is immutable", 27, sc->code);

  if ((is_any_closure(sc->value)) &&
      ((!(is_let(closure_let(sc->value)))) ||
       (!(is_funclet(closure_let(sc->value))))))  /* otherwise it's (define f2 f1) or something similar */
    {
      s7_pointer new_func, new_env;
      new_func = sc->value;
      new_env = make_funclet(sc, new_func, sc->code, closure_let(new_func));
      /* this should happen only if the closure* default values do not refer in any way to
       *   the enclosing environment (else we can accidentally shadow something that happens
       *   to share an argument name that is being used as a default value -- kinda dumb!).
       *   I think I'll check this before setting the safe_closure bit.
       */

      if ((port_filename(sc->input_port)) &&
	  (port_file(sc->input_port) != stdin))
	{
	  /* unbound_variable will be called if __func__ is encountered, and will return this info as if __func__ had some meaning */
	  let_set_file(new_env, port_file_number(sc->input_port));
	  let_set_line(new_env, port_line_number(sc->input_port));
	  set_has_let_file(new_env);
	}
      else
	{
	  let_set_file(new_env, 0);
	  let_set_line(new_env, 0);
	  clear_has_let_file(new_env);
	}

      /* add the newly defined thing to the current environment */
      if (is_let(sc->envir))
	{
	  if (let_id(sc->envir) < symbol_id(sc->code)) /* we're adding a later-bound symbol to an old let (?) */
	    {
	      s7_pointer slot;
	      sc->let_number++; /* dummy let, force symbol lookup */

	      for (slot = let_slots(sc->envir); tis_slot(slot); slot = next_slot(slot))
		if (slot_symbol(slot) == sc->code)
		  {
		    if (is_immutable(slot))
		      eval_error_no_return(sc, sc->syntax_error_symbol, "define ~S: but it is immutable", 30, sc->code);
		    slot_set_value(slot, new_func);
		    symbol_set_local(sc->code, sc->let_number, slot);
		    set_local(sc->code);
		    sc->value = new_func; /* probably not needed? */
		    return;
		  }
	      new_cell_no_check(sc, slot, T_SLOT);
	      slot_set_symbol(slot, sc->code);
	      slot_set_value(slot, new_func);
	      symbol_set_local(sc->code, sc->let_number, slot);
	      set_next_slot(slot, let_slots(sc->envir));
	      let_set_slots(sc->envir, slot);
	    }
	  else add_slot(sc->envir, sc->code, new_func);
	  set_local(sc->code);
	}
      else
	{
	  if ((is_slot(global_slot(sc->code))) &&
	      (is_immutable(global_slot(sc->code))))
	    {
	      s7_pointer old_value, old_symbol;
	      old_symbol = sc->code;
	      old_value = slot_value(global_slot(sc->code));
	      if ((type(old_value) != type(new_func)) ||
		  (!s7_is_equivalent(sc, old_value, new_func)))    /* if value is unchanged, just ignore this (re)definition */
		eval_error_no_return(sc, sc->syntax_error_symbol, "define ~S: but it is immutable", 30, old_symbol);
	    }
	  s7_make_slot(sc, sc->envir, sc->code, new_func);
	}
      sc->value = new_func; /* 25-Jul-14 so define returns the value not the name */
    }
  else
    {
      s7_pointer lx;
      /* add the newly defined thing to the current environment */
      lx = symbol_to_local_slot(sc, sc->code, sc->envir);
      if (is_slot(lx))
	{
	  if (is_immutable(lx))
	    {
	      s7_pointer old_value, old_symbol;
	      old_symbol = sc->code;
	      old_value = slot_value(lx);
	      if ((type(old_value) != type(sc->value)) ||
		  (!s7_is_equivalent(sc, old_value, sc->value)))    /* if value is unchanged, just ignore this (re)definition */
		eval_error_no_return(sc, sc->syntax_error_symbol, "define ~S: but it is immutable", 30, old_symbol);
	    }
	  slot_set_value_with_hook(lx, sc->value);
	}
      else s7_make_slot(sc, sc->envir, sc->code, sc->value);
    }
}


/* ---------------------------------------- */

#define c_function_is_ok_cadr(Sc, P) ((c_function_is_ok(Sc, P)) && (c_function_is_ok(Sc, cadr(P))))
#define c_function_is_ok_caddr(Sc, P) ((c_function_is_ok(Sc, P)) && (c_function_is_ok(Sc, caddr(P))))
#define c_function_is_ok_cadr_caddr(Sc, P) ((c_function_is_ok(Sc, P)) && (c_function_is_ok(Sc, cadr(P))) && (c_function_is_ok(Sc, caddr(P))))

#if WITH_GCC
  #define indirect_c_function_is_ok(Sc, X) ({s7_pointer _X_; _X_ = X; (((optimize_op(_X_) & 0x1) != 0) || (c_function_is_ok(Sc, _X_)));})
#else
  #define indirect_c_function_is_ok(Sc, X) (((optimize_op(X) & 0x1) != 0) || (c_function_is_ok(Sc, X)))
#endif


/* -------------------------------- profile -------------------------------- */
#if WITH_PROFILE
#define profile_location(p)        p->file_and_line
#define profile_set_location(p, N) p->file_and_line = N

#define remember_location(Line, File) (((File) << 20) | (Line))
#define remembered_line_number(Line)  ((Line) & 0xfffff)
#define remembered_file_name(Line)    ((((Line) >> 20) <= sc->file_names_top) ? sc->file_names[Line >> 20] : sc->F)

static void profile(s7_scheme *sc, s7_pointer expr)
{
  /* I tried using SIGPROF and a tick counter below (in addition to the line counter), but the added info did not seem very useful. */
  check_heap_size(sc, 32);

  if (is_null(sc->profile_info))
    {
      sc->profile_info = s7_make_hash_table(sc, 65536);
      s7_gc_protect_1(sc, sc->profile_info);
    }
  if ((is_pair(expr)) &&
      (profile_location(expr) > 0))
    {
      s7_pointer val, key;
      key = s7_make_integer(sc, profile_location(expr)); /* file + line */
      val = s7_hash_table_ref(sc, sc->profile_info, key);
      if (val == sc->F)
	{
	  bool old_short_print;
	  s7_pointer env;
	  int32_t tx1, tx2;

	  old_short_print = sc->short_print;
	  sc->short_print = true;

	  env = find_closure_let(sc, sc->envir);

	  tx1 = next_tx(sc);
	  tx2 = next_tx(sc);
	  sc->t_temps[tx1] = g_object_to_string(sc, set_plist_3(sc, expr, sc->T, small_int(120)));
	  sc->t_temps[tx2] = (is_let(env)) ? g_object_to_string(sc, set_plist_1(sc, funclet_function(env))) : sc->nil;

	  s7_hash_table_set(sc, sc->profile_info, key,
			    cons(sc, make_mutable_integer(sc, 1),
				 cons(sc, sc->t_temps[tx1], sc->t_temps[tx2])));
	  sc->t_temps[tx1] = sc->nil;
	  sc->t_temps[tx2] = sc->nil;
	  sc->short_print = old_short_print;
	}
      /* can't save the actual expr here -- it can be stepped on */
      else integer(car(val))++;
    }
}

static s7_pointer g_profile_line_number(s7_scheme *sc, s7_pointer args)
{
  #define H_profile_line_number "(profile-line-number obj) returns the line number at which the profiler read obj"
  #define Q_profile_line_number s7_make_signature(sc, 2, sc->is_integer_symbol, sc->T)
  return(make_integer(sc, remembered_line_number(integer(car(args)))));
}

static s7_pointer g_profile_filename(s7_scheme *sc, s7_pointer args)
{
  #define H_profile_filename "(profile-filename obj) returns the name of the file containing obj"
  #define Q_profile_filename s7_make_signature(sc, 2, sc->is_string_symbol, sc->T)
  return(remembered_file_name(integer(car(args))));
}
#endif


/* -------------------------------- eval -------------------------------- */

#if WITH_GMP
#define global_add big_add
#else
#define global_add g_add
#endif

static s7_pointer check_for_cyclic_code(s7_scheme *sc, s7_pointer code)
{
  if (tree_is_cyclic(sc, code))
    eval_error(sc, "attempt to evaluate a circular list: ~A", 39, code);
  resize_stack(sc); /* we've already checked that resize_stack is needed */
  return(sc->F);
}

#if WITH_PROFILE
  static s7_pointer profile_at_start = NULL;
#endif

#define closure_push_and_goto_eval(sc) \
	 do {								\
	   sc->code = T_Pair(closure_body(sc->code));			\
	   push_stack_no_args(sc, sc->begin_op, cdr(sc->code));		\
	   sc->code = car(sc->code); 					\
	   goto EVAL;							\
	 } while (0)
#define closure_goto_eval(sc) do {sc->code = car(closure_body(sc->code)); goto EVAL;} while (0)

#define closure_push(sc) \
	 do {								\
	   sc->code = T_Pair(closure_body(sc->code));			\
	   push_stack_no_args(sc, sc->begin_op, cdr(sc->code));		\
	   sc->code = car(sc->code);					\
	 } while (0)
/* #define closure_goto(sc) sc->code = car(closure_body(sc->code)) */


static inline void op_closure_a(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->value = fx_call(sc, cdr(sc->code));
  check_stack_size(sc);
  sc->code = opt1_lambda(code);
  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value);
}

static void op_closure_sub(s7_scheme *sc)
{
  s7_pointer arg;
  check_stack_size(sc);
  arg = opt2_pair(sc->code); /* cdadr(sc->code); */
  sc->value = lookup(sc, car(arg));
  if (is_t_integer(sc->value))
    sc->value = make_integer(sc, integer(sc->value) - integer(cadr(arg)));
  else sc->value = subtract_p_pp(sc, sc->value, cadr(arg));
  sc->code = opt1_lambda(sc->code);
  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value);
}

static void op_safe_closure_saa(s7_scheme *sc)
{
  s7_pointer args, z, f;
  int32_t tx;
  f = opt1_lambda(sc->code);
  tx = next_tx(sc);
  args = cddr(sc->code);
  sc->t_temps[tx] = fx_call(sc, args);
  args = cdr(args);
  z = fx_call(sc, args);
  sc->envir = old_frame_with_three_slots(sc, closure_let(f), lookup(sc, cadr(sc->code)), sc->t_temps[tx], z);
  sc->code = T_Pair(closure_body(f));
  sc->t_temps[tx] = sc->F;
}

static void op_safe_closure_a(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->value = fx_call(sc, cdr(sc->code));
  sc->code = opt1_lambda(code);
  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
  closure_push(sc);
}

static void op_safe_closure_a_p(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->value = fx_call(sc, cdr(sc->code));
  sc->code = opt1_lambda(code);
  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
  sc->code = car(closure_body(sc->code));
}

static void op_safe_closure_a_a(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->value = fx_call(sc, cdr(sc->code));
  sc->code = opt1_lambda(code);
  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
  sc->value = fx_call(sc, closure_body(sc->code));
}

static void op_closure_ap(s7_scheme *sc)
{
  s7_pointer val, code;
  code = sc->code;
  val = fx_call(sc, cdr(code));
  /* (hook-push (undo-hook ind 0) (lambda (hook) (set! u0 #t))) -> #<unused>
   *    g_undo_hook calls s7_eval_c_string so it obviously should be declared unsafe!
   */
  push_stack(sc, OP_CLOSURE_AP_1, val, code);
  sc->code = caddr(code);
}

static void op_closure_ap_1(s7_scheme *sc)
{
  /* sc->value is presumably the "P" argument value, "A" is sc->args */
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->args, cadr(closure_args(sc->code)), sc->value);
  sc->code = T_Pair(closure_body(sc->code));
}

static void op_closure_ap_mv(s7_scheme *sc)
{
  sc->code = opt1_lambda(sc->code);
  sc->args = cons(sc, sc->args, copy_list(sc, sc->value));
}

static void op_closure_pa(s7_scheme *sc)
{
  s7_pointer val, code;
  code = sc->code;
  val = fx_call(sc, cddr(code));
  push_stack(sc, OP_CLOSURE_PA_1, val, code);
  sc->code = cadr(code);
}

static void op_closure_pa_1(s7_scheme *sc)
{
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->args);
  sc->code = T_Pair(closure_body(sc->code));
}

static void op_closure_pa_mv(s7_scheme *sc)
{
  sc->code = opt1_lambda(sc->code);
  sc->args = s7_append(sc, copy_list(sc, sc->value), cons(sc, sc->args, sc->nil));
}

static void op_safe_closure_ap(s7_scheme *sc)
{
  s7_pointer val;
  val = fx_call(sc, cdr(sc->code));
  push_stack(sc, OP_SAFE_CLOSURE_AP_1, val, sc->code);
  sc->code = caddr(sc->code);
}

static void op_safe_closure_ap_1(s7_scheme *sc)
{
  sc->envir = old_frame_with_two_slots(sc, closure_let(opt1_lambda(sc->code)), sc->args, sc->value);
  sc->code = T_Pair(closure_body(opt1_lambda(sc->code)));
}

static void op_safe_closure_pa(s7_scheme *sc)
{
  s7_pointer val;
  val = fx_call(sc, cddr(sc->code));
  push_stack(sc, OP_SAFE_CLOSURE_PA_1, val, sc->code);
  sc->code = cadr(sc->code);
}

static void op_safe_closure_pa_1(s7_scheme *sc)
{
  sc->envir = old_frame_with_two_slots(sc, closure_let(opt1_lambda(sc->code)), sc->value, sc->args);
  sc->code = T_Pair(closure_body(opt1_lambda(sc->code)));
}

static void op_safe_closure_sa(s7_scheme *sc)
{
  s7_pointer f, args;
  f = opt1_lambda(sc->code);
  args = cddr(sc->code);
  args = fx_call(sc, args);
  sc->envir = old_frame_with_two_slots(sc, closure_let(f), lookup(sc, cadr(sc->code)), args);
  sc->code = T_Pair(closure_body(f));
}

static void op_safe_closure_ss(s7_scheme *sc)
{
  sc->temp5 = lookup(sc, opt2_sym(sc->code));
  sc->value = lookup(sc, cadr(sc->code));
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  closure_push(sc);
}

static void op_safe_closure_ss_p(s7_scheme *sc)
{
  sc->temp5 = lookup(sc, opt2_sym(sc->code));
  sc->value = lookup(sc, cadr(sc->code));
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  sc->code = car(closure_body(sc->code));
}

static void op_safe_closure_ss_a(s7_scheme *sc)
{
  sc->temp5 = lookup(sc, opt2_sym(sc->code));
  sc->value = lookup(sc, cadr(sc->code));
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  sc->value = fx_call(sc, closure_body(sc->code));
}

static void op_closure_ss(s7_scheme *sc)
{
  sc->temp5 = lookup(sc, opt2_sym(sc->code));
  sc->value = lookup(sc, cadr(sc->code));
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->temp5);
  closure_push(sc);
}

static void op_closure_ss_p(s7_scheme *sc)
{
  sc->temp5 = lookup(sc, opt2_sym(sc->code));
  sc->value = lookup(sc, cadr(sc->code));
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->temp5);
  sc->code = car(closure_body(sc->code));
}

static void op_safe_closure_sc(s7_scheme *sc)
{
  sc->temp5 = opt2_con(sc->code);
  sc->value = lookup(sc, cadr(sc->code));
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  closure_push(sc);
}

static void op_safe_closure_sc_p(s7_scheme *sc)
{
  sc->temp5 = opt2_con(sc->code);
  sc->value = lookup(sc, cadr(sc->code));
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  sc->code = car(closure_body(sc->code));
}

static void op_closure_sc(s7_scheme *sc)
{
  sc->temp5 = opt2_con(sc->code);
  sc->value = lookup(sc, cadr(sc->code));
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->temp5);
  closure_push(sc);
}

static void op_closure_sc_p(s7_scheme *sc)
{
  sc->temp5 = opt2_con(sc->code);
  sc->value = lookup(sc, cadr(sc->code));
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->temp5);
  sc->code = car(closure_body(sc->code));
}

static void op_safe_closure_cs(s7_scheme *sc)
{
  sc->temp5 = lookup(sc, opt2_sym(sc->code));
  sc->value = cadr(sc->code);
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  sc->code = T_Pair(closure_body(sc->code));
}

static void op_closure_cs(s7_scheme *sc)
{
  sc->temp5 = lookup(sc, opt2_sym(sc->code));
  sc->value = cadr(sc->code);
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->temp5);
  sc->code = T_Pair(closure_body(sc->code));
}

static void op_safe_closure_aa(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->temp5 = fx_call(sc, cdr(p));
  sc->value = fx_call(sc, p);
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  closure_push(sc);
}

static void op_safe_closure_aa_p(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->temp5 = fx_call(sc, cdr(p));
  sc->value = fx_call(sc, p);
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  sc->code = car(closure_body(sc->code));
}

static void op_safe_closure_aa_a(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->temp5 = fx_call(sc, cdr(p));
  sc->value = fx_call(sc, p);
  sc->code = opt1_lambda(sc->code);
  sc->envir = old_frame_with_two_slots(sc, closure_let(sc->code), sc->value, sc->temp5);
  sc->value = fx_call(sc, closure_body(sc->code));
}

static void op_closure_aa(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->temp5 = fx_call(sc, cdr(p));
  sc->value = fx_call(sc, p);
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->temp5);
  closure_push(sc);
}

static void op_closure_aa_p(s7_scheme *sc)
{
  s7_pointer p;
  p = cdr(sc->code);
  sc->temp5 = fx_call(sc, cdr(p));
  sc->value = fx_call(sc, p);
  check_stack_size(sc);
  sc->code = opt1_lambda(sc->code);
  new_frame_with_two_slots(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value, cadr(closure_args(sc->code)), sc->temp5);
  sc->code = car(closure_body(sc->code));
}

static void op_closure_fa(s7_scheme *sc)
{
  s7_pointer farg, larg, aarg, func, func_args, code;
  code = sc->code;
  farg = opt3_pair(code); /* cdadr(code); */
  aarg = fx_call(sc, cddr(code));
  make_closure_with_let(sc, larg, car(farg), cdr(farg), sc->envir, CLOSURE_ARITY_NOT_SET);
  check_stack_size(sc);
  func = opt1_lambda(code);         /* outer func */
  func_args = closure_args(func);
  new_frame_with_two_slots(sc, closure_let(func), sc->envir, car(func_args), larg, cadr(func_args), aarg);
  sc->code = car(closure_body(func));
}

static void op_safe_closure_fx(s7_scheme *sc)
{
  s7_pointer args, p, env, x, z;
  uint64_t id;

  sc->args = safe_list_if_possible(sc, integer(opt3_arglen(sc->code)));
  for (args = cdr(sc->code), p = sc->args; is_pair(args); args = cdr(args), p = cdr(p))
    set_car(p, fx_call(sc, args));
  clear_list_in_use(sc->args);
  sc->current_safe_list = 0;
  sc->code = opt1_lambda(sc->code);

  id = ++sc->let_number;
  env = closure_let(sc->code);
  let_id(env) = id;

  for (x = let_slots(env), z = sc->args; tis_slot(x); x = next_slot(x), z = cdr(z))
    {
      slot_set_value(x, car(z));
      symbol_set_local(slot_symbol(x), id, x);
    }
  sc->envir = env;
  sc->code = closure_body(sc->code);
  if (is_pair(cdr(sc->code)))
    push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
  sc->code = car(sc->code);
}

static void op_closure_all_s(s7_scheme *sc)
{
  s7_pointer args, p, e;
  /* in this case, we have just lambda (not lambda*), and no dotted arglist,
   *   and no accessed symbols in the arglist, and we know the arglist matches the parameter list.
   */
  check_stack_size(sc);
  args = cdr(sc->code);
  sc->code = opt1_lambda(sc->code);
  new_frame(sc, closure_let(sc->code), e);
  sc->z = e;
  for (p = closure_args(sc->code); is_pair(p); p = cdr(p), args = cdr(args))
    add_slot(e, car(p), lookup(sc, car(args))); /* main such call in lt (fx_s is 1/2, this is 1/5 of all calls) */
  sc->envir = e;
  sc->z = sc->nil;
  sc->code = T_Pair(closure_body(sc->code));
  if (is_pair(cdr(sc->code)))
    push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
  sc->code = car(sc->code);
}

static void op_closure_fx(s7_scheme *sc)
{
  s7_pointer args, p, e;
  check_stack_size(sc);
  args = cdr(sc->code);
  sc->code = opt1_lambda(sc->code);
  new_frame(sc, closure_let(sc->code), e);
  sc->z = e;
  for (p = closure_args(sc->code); is_pair(p); p = cdr(p), args = cdr(args))
    add_slot(e, car(p), fx_call(sc, args));
  /* ssfx is a common pattern; hits 5m/23m in lg: about 25? */
  sc->envir = e;
  sc->z = sc->nil;
  sc->code = T_Pair(closure_body(sc->code));
  if (is_pair(cdr(sc->code)))
    push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
  sc->code = car(sc->code);
}

static void op_closure_any_fx(s7_scheme *sc)
{
  s7_pointer p, old_args;
  check_stack_size(sc);
  sc->w = cdr(sc->code);               /* args aren't evaluated yet */
  sc->args = make_list(sc, integer(opt3_arglen(sc->code)), sc->F);
  for (p = sc->args, old_args = sc->w; is_pair(p); p = cdr(p), old_args = cdr(old_args))
    set_car(p, fx_call(sc, old_args));
  sc->w = sc->nil;
  sc->code = opt1_lambda(sc->code);
  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, closure_args(sc->code), sc->args);
  sc->code = T_Pair(closure_body(sc->code));
}

static void op_safe_c_cs(s7_scheme *sc)
{
  s7_pointer args;
  args = cdr(sc->code);
  set_car(sc->t2_2, lookup(sc, cadr(args)));
  set_car(sc->t2_1, opt1_con(args)); /* car(args) or cadar */
  sc->value = c_call(sc->code)(sc, sc->t2_1);
}

static s7_pointer op_c_s_opsq(s7_scheme *sc)
{
  s7_pointer args, val;
  args = cdr(sc->code);
  val = lookup(sc, car(args));
  set_car(sc->t1_1, lookup(sc, opt1_sym(args)));
  sc->args = list_2(sc, val, c_call(cadr(args))(sc, sc->t1_1));
  return(c_call(sc->code)(sc, sc->args));
}

static s7_pointer op_c_s_opdq(s7_scheme *sc)
{
  s7_pointer args, val;
  int32_t tx;
  tx = next_tx(sc);
  args = cdr(sc->code);
  sc->t_temps[tx] = lookup(sc, car(args));
  val = c_call(cadr(args))(sc, opt1_pair(args));
  sc->args = list_2(sc, sc->t_temps[tx], val);
  sc->t_temps[tx] = sc->F;
  return(c_call(sc->code)(sc, sc->args));
}

static s7_pointer op_c_scs(s7_scheme *sc)
{
  s7_pointer a1, a2;
  a1 = cdr(sc->code);
  a2 = cdr(a1);
  sc->args = list_3(sc, lookup(sc, car(a1)), car(a2), lookup(sc, cadr(a2)));
  return(c_call(sc->code)(sc, sc->args));
}

static s7_pointer op_s_c(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->code = lookup_checked(sc, car(code));
  if (!is_applicable(sc->code))
    apply_error(sc, sc->code, cdr(code));
  if (dont_eval_args(sc->code))
    sc->args = copy_list(sc, cdr(code));
  else sc->args = list_1(sc, cadr(code));
  return(NULL);
}

static bool op_s_s(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->code = lookup_checked(sc, car(code));
  if ((is_c_function(sc->code)) &&
      (c_function_required_args(sc->code) == 1) &&
      (!needs_copied_args(sc->code)))
    {
      set_car(sc->t1_1, lookup(sc, cadr(code)));
      sc->value = c_function_call(sc->code)(sc, sc->t1_1);
      return(true); /* goto START; */
    }
  if (!is_applicable(sc->code))
    apply_error(sc, sc->code, cdr(code));
  if (dont_eval_args(sc->code))
    sc->args = copy_list(sc, cdr(code));
  else sc->args = list_1(sc, lookup(sc, cadr(code)));
  return(false); /* goto APPLY; */
}

static s7_pointer op_s_a(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->code = lookup_checked(sc, car(code));
  if (!is_applicable(sc->code))
    apply_error(sc, sc->code, cdr(code));
  if (dont_eval_args(sc->code))
    sc->args = copy_list(sc, cdr(code));
  else sc->args = list_1(sc, fx_call(sc, cdr(code)));
  return(NULL);
}

static s7_pointer op_s_aa(s7_scheme *sc)
{
  s7_pointer code;
  code = sc->code;
  sc->code = lookup_checked(sc, car(code));
  if (!is_applicable(sc->code))
    apply_error(sc, sc->code, cdr(code));
  if (dont_eval_args(sc->code))
    sc->args = copy_list(sc, cdr(code));
  else
    {
      s7_pointer val1, val2;
      val1 = fx_call(sc, cdr(code));
      val2 = fx_call(sc, cddr(code));
      sc->args = list_2(sc, val1, val2);
    }
  return(NULL);
}

static void safe_c_star_fx(s7_scheme *sc)
{
  s7_pointer args, p;
  sc->args = safe_list_if_possible(sc, integer(opt3_arglen(sc->code)));
  for (args = cdr(sc->code), p = sc->args; is_pair(args); args = cdr(args), p = cdr(p))
    set_car(p, fx_call(sc, args));
  clear_list_in_use(sc->args);
  sc->current_safe_list = 0;
  sc->code = opt1_cfunc(sc->code);
  apply_c_function_star(sc);
}

static void safe_c_star_aa(s7_scheme *sc)
{
  set_car(sc->a2_1, fx_call(sc, cdr(sc->code)));
  set_car(sc->a2_2, fx_call(sc, cddr(sc->code)));
  sc->args = sc->a2_1;
  sc->code = opt1_cfunc(sc->code);
  apply_c_function_star(sc);
}

static s7_pointer safe_c_opaaq(s7_scheme *sc, s7_pointer code)
{
  s7_pointer arg, val;
  arg = cadr(code);
  val = fx_call(sc, cdr(arg));
  set_car(sc->a2_2, fx_call(sc, cddr(arg)));
  set_car(sc->a2_1, val);
  set_car(sc->t1_1, c_call(arg)(sc, sc->a2_1));
  return(c_call(code)(sc, sc->t1_1));
}

static void op_safe_c_css(s7_scheme *sc)
{
  s7_pointer val1, args;
  args = cdr(sc->code);
  val1 = lookup(sc, opt2_sym(args));
  set_car(sc->t3_2, lookup(sc, opt1_sym(args)));
  set_car(sc->t3_3, val1);
  set_car(sc->t3_1, car(args));
  sc->value = c_call(sc->code)(sc, sc->t3_1);
}

static void op_safe_c_sc(s7_scheme *sc)
{
  set_car(sc->t2_1, lookup(sc, cadr(sc->code)));
  set_car(sc->t2_2, opt2_con(cdr(sc->code)));
  sc->value = c_call(sc->code)(sc, sc->t2_1);
}

static void op_safe_c_opsq(s7_scheme *sc)
{
  s7_pointer args;
  args = cadr(sc->code);
  set_car(sc->t1_1, lookup(sc, cadr(args)));
  set_car(sc->t1_1, c_call(args)(sc, sc->t1_1));
  sc->value = c_call(sc->code)(sc, sc->t1_1);
}

static void op_safe_c_aa(s7_scheme *sc)
{
  s7_pointer val, code;
  code = sc->code;
  val = fx_call(sc, cdr(code));
  sc->temp4 = val;
  set_car(sc->a2_2, fx_call(sc, cddr(code)));
  set_car(sc->a2_1, val);
  sc->value = c_call(code)(sc, sc->a2_1);
  sc->temp4 = sc->nil;
}

static void op_safe_c_ap(s7_scheme *sc)
{
  s7_pointer val, code;
  code = sc->code;
  check_stack_size(sc);
  val = fx_call(sc, cdr(sc->code));
  push_stack(sc, (opcode_t)opt1_any(cdr(sc->code)), val, code);
  sc->code = caddr(code);
}

static void op_safe_c_aaa(s7_scheme *sc)
{
  s7_pointer arg, val1, val2, code;
  code = sc->code;
  arg = cdr(code);
  val1 = fx_call(sc, arg);
  sc->temp4 = val1;
  arg = cdr(arg);
  val2 = fx_call(sc, arg);
  sc->temp10 = val2;
  arg = cdr(arg);
  set_car(sc->t3_3, fx_call(sc, arg));
  set_car(sc->t3_1, val1);
  set_car(sc->t3_2, val2);
  sc->value = c_call(code)(sc, sc->t3_1);
  sc->temp4 = sc->nil;
  sc->temp10 = sc->nil;
}

static void op_safe_c_ssa(s7_scheme *sc)
{
  s7_pointer arg, val1, val2, code;
  code = sc->code;
  arg = cdr(code);
  val1 = lookup(sc, car(arg));
  arg = cdr(arg);
  val2 = lookup(sc, car(arg));
  arg = cdr(arg);
  set_car(sc->a3_3, fx_call(sc, arg));
  set_car(sc->a3_1, val1);
  set_car(sc->a3_2, val2);
  sc->value = c_call(code)(sc, sc->a3_1);
}

static void op_safe_c_opaaaq(s7_scheme *sc)
{
  s7_pointer arg, val1, val2, code;
  code = sc->code; /* not redundant */
  arg = cadr(code);
  val1 = fx_call(sc, cdr(arg));
  sc->temp4 = val1;
  val2 = fx_call(sc, cddr(arg));
  sc->temp10 = val2;
  set_car(sc->a3_3, fx_call(sc, cdddr(arg)));
  set_car(sc->a3_1, val1);
  set_car(sc->a3_2, val2);
  set_car(sc->t1_1, c_call(arg)(sc, sc->a3_1));
  sc->value = c_call(code)(sc, sc->t1_1);
  sc->temp4 = sc->nil;
  sc->temp10 = sc->nil;
}

static void op_safe_c_s_opaaq(s7_scheme *sc)
{
  s7_pointer arg, val1, code;
  code = sc->code;
  arg = caddr(code);
  val1 = fx_call(sc, cdr(arg));
  sc->temp4 = val1;
  set_car(sc->a2_2, fx_call(sc, cddr(arg)));
  set_car(sc->a2_1, val1);
  set_car(sc->t2_2, c_call(arg)(sc, sc->a2_1));
  set_car(sc->t2_1, lookup(sc, cadr(code)));
  sc->value = c_call(code)(sc, sc->t2_1);
  sc->temp4 = sc->nil;
}

static void op_safe_c_s_opaaaq(s7_scheme *sc)
{
  s7_pointer arg, p, val1, val2, code;
  code = sc->code;
  p = caddr(code);
  arg = cdr(p);
  val1 = fx_call(sc, arg);
  sc->temp4 = val1;
  arg = cdr(arg);
  val2 = fx_call(sc, arg);
  sc->temp10 = val2;
  arg = cdr(arg);
  set_car(sc->a3_3, fx_call(sc, arg));
  set_car(sc->a3_1, val1);
  set_car(sc->a3_2, val2);
  set_car(sc->t2_2, c_call(p)(sc, sc->a3_1));
  set_car(sc->t2_1, lookup(sc, cadr(code)));
  sc->value = c_call(code)(sc, sc->t2_1);
  sc->temp4 = sc->nil;
  sc->temp10 = sc->nil;
}

static void op_safe_c_aaaa(s7_scheme *sc)
{
  s7_pointer arg, val1, val2, val3, code;
  int32_t tx;
  code = sc->code;
  tx = next_tx(sc);
  arg = cdr(code);
  val1 = fx_call(sc, arg);
  sc->temp4 = val1;
  arg = cdr(arg);
  val2 = fx_call(sc, arg);
  sc->temp10 = val2;
  arg = cdr(arg);
  val3 = fx_call(sc, arg);
  sc->t_temps[tx] = val3;
  arg = cdr(arg);
  set_car(sc->a4_4, fx_call(sc, arg));
  set_car(sc->a4_1, val1);
  set_car(sc->a4_2, val2);
  set_car(sc->a4_3, val3);
  sc->value = c_call(code)(sc, sc->a4_1);
  sc->temp4 = sc->nil;
  sc->t_temps[tx] = sc->nil;
  sc->temp10 = sc->nil;
}

static void op_safe_c_fx(s7_scheme *sc)
{
  s7_pointer args, p, code;
  code = sc->code;
  sc->args = safe_list_if_possible(sc, integer(opt3_arglen(code)));
  for (args = cdr(code), p = sc->args; is_pair(args); args = cdr(args), p = cdr(p))
    set_car(p, fx_call(sc, args));
  clear_list_in_use(sc->args);
  sc->current_safe_list = 0;
  sc->value = c_call(code)(sc, sc->args);
  /* we can't release a temp here:
   *   (define (hi) (vector 14800 14020 (oscil os) (* 1/3 14800) 14800 (* 1/2 14800))) (hi) where os returns non-zero:
   *   #(14800 14020 <output-string-port> 14800/3 14800 7400)
   */
}

static inline bool op_safe_c_fp(s7_scheme *sc, opcode_t op, s7_pointer args)
{
  s7_pointer p;
  sc->args = args;
  p = sc->code;
  while ((is_pair(p)) && (has_fx(p)))
    {
      sc->args = cons(sc, fx_call(sc, p), sc->args); /* reversed before apply in OP_SAFE_C_FP_1 */
      p = cdr(p);
    }
  if (is_pair(p))
    {
      push_stack(sc, op, sc->args, cdr(p));
      sc->code = T_Pair(car(p));
      return(true);
    }
  return(false);
}

static void op_safe_c_all_ca(s7_scheme *sc)
{
  s7_pointer args, p, code;
  code = sc->code;
  sc->args = safe_list_if_possible(sc, integer(opt3_arglen(code)));
  for (args = cdr(code), p = sc->args; is_pair(args); args = cdr(args), p = cddr(p))
    {
      set_car(p, opt2_any(args));
      args = cdr(args);
      set_car(cdr(p), fx_call(sc, args));
    }
  clear_list_in_use(sc->args);
  sc->current_safe_list = 0;
  sc->value = c_call(code)(sc, sc->args);
}

static void op_safe_c_pa_mv(s7_scheme *sc)
{
  s7_pointer val, code;
  code = sc->code;
  val = sc->value; /* this is necessary since the c_call below can clobber sc->value */
  sc->args = s7_append(sc, val, set_plist_1(sc, fx_call(sc, cddr(code))));
  sc->code = c_function_base(opt1_cfunc(code));
}

static void op_safe_c_opsq_p(s7_scheme *sc)
{
  s7_pointer args, val;
  args = cadr(sc->code);
  check_stack_size(sc);
  set_car(sc->t1_1, lookup(sc, cadr(args)));
  val = c_call(args)(sc, sc->t1_1);
  push_stack(sc, (opcode_t)opt1_any(cdr(sc->code)), val, sc->code);
  sc->code = caddr(sc->code);
}

static void op_c_fx(s7_scheme *sc)
{ /* (set-cdr! lst ()) */
  s7_pointer args, p, new_args;
  new_args = make_list(sc, integer(opt3_arglen(sc->code)), sc->nil);
  /* this make_list is usually unneeded -- most "unsafe" functions do not mess with their arguments, but
   *   catching that and using safe_list_if_possible instead costs more than it saves in most cases.
   */
  sc->args = new_args;
  /* GC protect? fx stuff below can clobber sc->args:
   *    (catch #f (vector-ref #(1 2) 0 1.0+1.0i) (vector-ref #(1 2) 0 1.0+1.0i))
   */
  for (args = cdr(sc->code), p = new_args; is_pair(args); args = cdr(args), p = cdr(p))
    set_car(p, fx_call(sc, args));
  sc->value = c_call(sc->code)(sc, new_args);
}

static inline void op_eval_args1(s7_scheme *sc) /* inline is needed here */
{
  s7_pointer x;
  new_cell(sc, x, T_PAIR);
  set_car(x, sc->value);
  set_cdr(x, sc->args);
  sc->args = x;
}

static void op_eval_args2(s7_scheme *sc)
{
  s7_pointer x;
  sc->code = pop_op_stack(sc);
  new_cell(sc, x, T_PAIR);
  set_car(x, sc->value);
  set_cdr(x, sc->args);
  if (!is_null(sc->args))
    sc->args = safe_reverse_in_place(sc, x);
  else sc->args = x;
}

static void op_eval_args3(s7_scheme *sc)
{
  s7_pointer x, y, val;
  val = sc->code;
  if (is_symbol(val))
    val = lookup_checked(sc, val);
  new_cell(sc, x, T_PAIR);
  new_cell_no_check(sc, y, T_PAIR);
  set_car(x, sc->value);
  set_cdr(x, sc->args);
  set_car(y, val);
  set_cdr(y, x);
  sc->args = safe_reverse_in_place(sc, y);
  sc->code = pop_op_stack(sc);
}

static void op_eval_args4(s7_scheme *sc)
{
  s7_pointer x;
  new_cell(sc, x, T_PAIR);
  set_car(x, sc->value);
  set_cdr(x, sc->args);
  sc->args = x;          /* all the others reverse -- why not this case? -- reverse is at end? (below) */
}

static void op_eval_args5(s7_scheme *sc)      /* sc->value is the last arg, sc->code is the previous */
{
  s7_pointer x, y;
  new_cell(sc, x, T_PAIR);
  new_cell_no_check(sc, y, T_PAIR);
  set_car(x, sc->code);
  set_cdr(x, sc->args);
  set_car(y, sc->value);
  set_cdr(y, x);
  sc->args = safe_reverse_in_place(sc, y);
  sc->code = pop_op_stack(sc);
}

static bool op_read_vector(s7_scheme *sc)
{
  if (is_dotted_pair(sc->value))            /* #(1 . 2) */
    read_error(sc, "vector constant data is not a proper list");
  sc->v = sc->value;
  if (sc->args == small_int(1))             /* sc->args was sc->w earlier from read_sharp */
    sc->value = g_vector(sc, sc->value);
  else sc->value = g_multivector(sc, integer(sc->args), sc->value);
  /* here and below all of the sc->value list can be freed, but my tests showed no speed up even in large cases */
  free_vlist(sc, sc->v);
  if (sc->safety > IMMUTABLE_VECTOR_SAFETY) set_immutable(sc->value);
  return(main_stack_op(sc) != OP_READ_LIST);
}

static bool op_read_int_vector(s7_scheme *sc)
{
  if (is_dotted_pair(sc->value))
    read_error(sc, "int-vector constant data is not a proper list");
  sc->v = sc->value;
  if (sc->args == small_int(1))             /* sc->args was sc->w earlier from read_sharp */
    sc->value = g_int_vector(sc, sc->value);
  else sc->value = g_int_multivector(sc, integer(sc->args), sc->value);
  free_vlist(sc, sc->v);
  if (sc->safety > IMMUTABLE_VECTOR_SAFETY) set_immutable(sc->value);
  return(main_stack_op(sc) != OP_READ_LIST);
}

static bool op_read_float_vector(s7_scheme *sc)
{
  if (is_dotted_pair(sc->value))
    read_error(sc, "float-vector constant data is not a proper list");
  sc->v = sc->value;
  if (sc->args == small_int(1))             /* sc->args was sc->w earlier from read_sharp */
    sc->value = g_float_vector(sc, sc->value);
  else sc->value = g_float_multivector(sc, integer(sc->args), sc->value);
  free_vlist(sc, sc->v);
  if (sc->safety > IMMUTABLE_VECTOR_SAFETY) set_immutable(sc->value);
  return(main_stack_op(sc) != OP_READ_LIST);
}

static bool op_read_byte_vector(s7_scheme *sc)
{
  if (is_dotted_pair(sc->value))
    read_error(sc, "byte-vector constant data is not a proper list");
  sc->v = sc->value;
  if (sc->args == small_int(1))             /* sc->args was sc->w earlier from read_sharp */
    sc->value = g_byte_vector(sc, sc->value);
  else sc->value = g_byte_multivector(sc, integer(sc->args), sc->value);
  free_vlist(sc, sc->v);
  if (sc->safety > IMMUTABLE_VECTOR_SAFETY) set_immutable(sc->value);
  return(main_stack_op(sc) != OP_READ_LIST);
}

static void op_eval_macro(s7_scheme *sc)
{
  /* (define-macro (hi a) `(+ ,a 1))
   * (hi 2)
   * here with value: (+ 2 1)
   */
  if (is_multiple_value(sc->value))
    {
      /* a normal macro's result is evaluated (below) and its value replaces the macro invocation,
       *   so if a macro returns multiple values, evaluate each one, then replace the macro
       *   invocation with (apply values evaluated-results-in-a-list).  We need to save the
       *   new list of results, and where we are in the macro's output list, so code=macro output,
       *   args=new list.  If it returns (values), should we use #<unspecified>?  I think that
       *   happens now without generating a multiple_value object:
       *       (define-macro (hi) (values)) (hi) -> #<unspecified>
       *   (define-macro (ho) (values '(+ 1 2) '(* 3 4))) (+ 1 (ho) 3) -> 19
       *   (define-macro (ha) (values '(define a 1) '(define b 2))) (let () (ha) (+ a b)) -> 3
       */
      push_stack(sc, OP_EVAL_MACRO_MV, sc->nil, cdr(sc->value));
      sc->code = car(sc->value);
    }
  else sc->code = sc->value;
}

static bool op_eval_macro_mv(s7_scheme *sc)
{
  if (is_null(sc->code)) /* end of values list */
    {
      sc->value = splice_in_values(sc, multiple_value(safe_reverse_in_place(sc, cons(sc, sc->value, sc->args))));
      return(true);
    }
  push_stack(sc, OP_EVAL_MACRO_MV, cons(sc, sc->value, sc->args), cdr(sc->code));
  sc->code = car(sc->code);
  return(false);
}

static s7_pointer eval(s7_scheme *sc, opcode_t first_op)
{
#if SHOW_EVAL_OPS
  safe_print(fprintf(stderr, "eval[%d]:, %s %s %s\n", __LINE__, op_names[first_op], DISPLAY_80(sc->code), DISPLAY_80(sc->args)));
#endif
  sc->cur_op = first_op;
  goto TOP_NO_POP;

  while (true)
    {
    START:
      pop_stack(sc);
      goto TOP_NO_POP;

    BEGIN:
      if (is_pair(cdr(T_Pair(sc->code))))
	push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
      sc->code = car(sc->code);
      set_current_code(sc, sc->code);

    EVAL:
      sc->cur_op = optimize_op(sc->code);

    TOP_NO_POP:
#if SHOW_EVAL_OPS
      safe_print(fprintf(stderr, "%s (%d), code: %s, args: %s\n", op_names[sc->cur_op], (int)(sc->cur_op), DISPLAY_80(sc->code), DISPLAY_80(sc->args)));
#endif
#if WITH_PROFILE
      profile_at_start = sc->code;
      profile(sc, sc->code);
#endif

      /* it is only slightly faster to use labels as values (computed gotos) here. In my timing tests (June-2018), the best case speedup was in titer.scm
       *    callgrind numbers 4808 to 4669; another good case was tread.scm: 2410 to 2386.  Most timings were a draw.  computed-gotos-s7.c has the code,
       *    macroized so it will work if such gotos aren't available.  I think I'll stick with a switch statement.
       */
      switch (sc->cur_op)
	{
	case OP_SAFE_C_D:
	  if (!c_function_is_ok(sc, sc->code))
	    {
	      if ((is_pair(cdr(sc->code))) && /* code here can be (values) for example, if values is a method in lt and we're in (with-let lt ...) */
		  (is_null(cddr(sc->code))))
		{
		  set_optimize_op(sc->code, OP_S_C);
		  goto EVAL;
		}
	      break;
	    }
	  /* break = fall into the "trailers" section where optimizations are cleared */
	case HOP_SAFE_C_D:
	  sc->value = d_call(sc, sc->code);
	  goto START;

	case OP_SAFE_C_AND2:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_AND2:
	  sc->code = cdr(sc->code);
	  if (is_false(sc, fx_call(sc, sc->code)))
	    {
	      sc->value = sc->F;
	      goto START;
	    }
	  sc->value = fx_call(sc, cdr(sc->code));
	  goto START;

	case OP_SAFE_C_OR2:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_OR2:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  if (is_true(sc, sc->value))
	    goto START;
	  sc->value = fx_call(sc, cdr(sc->code));
	  goto START;

	case OP_SAFE_C_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_SAFE_C_S:
	  set_car(sc->t1_1, lookup(sc, cadr(sc->code)));
	  sc->value = c_call(sc->code)(sc, sc->t1_1);
	  goto START;

	case OP_SAFE_CAR_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_SAFE_CAR_S:
	  sc->value = lookup(sc, cadr(sc->code));
	  sc->value = (is_pair(sc->value)) ? car(sc->value) : g_car(sc, set_plist_1(sc, sc->value));
	  goto START;

	case OP_SAFE_CDR_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_SAFE_CDR_S:
	  sc->value = lookup(sc, cadr(sc->code));
	  sc->value = (is_pair(sc->value)) ? cdr(sc->value) : g_cdr(sc, set_plist_1(sc, sc->value));
	  goto START;

	case OP_SAFE_CADR_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_SAFE_CADR_S:
	  sc->value = fx_cadr_s(sc, sc->code);
	  goto START;

	case OP_SAFE_IS_PAIR_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_SAFE_IS_PAIR_S:
	  sc->value = lookup(sc, cadr(sc->code));
	  sc->value = (is_pair(sc->value)) ? sc->T : sc->F;
	  goto START;

	case OP_SAFE_IS_NULL_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_SAFE_IS_NULL_S:
	  sc->value = lookup(sc, cadr(sc->code));
	  sc->value = (is_null(sc->value)) ? sc->T : sc->F;
	  goto START;

	case OP_SAFE_IS_SYMBOL_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_SAFE_IS_SYMBOL_S:
	  sc->value = lookup(sc, cadr(sc->code));
	  sc->value = (is_symbol(sc->value)) ? sc->T : sc->F;
	  goto START;

	case OP_SAFE_C_SS:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SS:
	  set_car(sc->t2_1, lookup(sc, cadr(sc->code)));
	  set_car(sc->t2_2, lookup(sc, opt2_sym(cdr(sc->code))));
	  sc->value = c_call(sc->code)(sc, sc->t2_1);
	  goto START;

	case OP_SAFE_C_ALL_S: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_ALL_S: sc->value = fx_c_all_s(sc, sc->code); goto START;

	case OP_SAFE_C_SC: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SC: op_safe_c_sc(sc); goto START;

	case OP_SAFE_C_CS: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CS: op_safe_c_cs(sc); goto START;

	case OP_SAFE_C_CQ: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CQ: sc->value = fx_c_cq(sc, sc->code); goto START;

	case OP_SAFE_C_P:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_P:
	  check_stack_size(sc);
	  push_stack_no_args(sc, OP_SAFE_C_P_1, sc->code);
	  sc->code = T_Pair(cadr(sc->code));
	  goto EVAL;

	case OP_SAFE_C_P_1:
	  set_car(sc->t1_1, sc->value);
	  sc->value = c_call(sc->code)(sc, sc->t1_1);
	  goto START;

	case OP_NOT_P:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_NOT_P:
	  push_stack_no_args(sc, OP_NOT_P_1, sc->code);
	  sc->code = T_Pair(cadr(sc->code));
	  goto EVAL;

	case OP_NOT_P_1:
	  sc->value = ((sc->value == sc->F) ? sc->T : sc->F);
	  goto START;


	case OP_SAFE_C_FP:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_FP:
	  check_stack_size(sc);
	  push_stack_no_args(sc, OP_SAFE_C_FP_1, sc->code);
	  sc->code = cdr(sc->code);
	  op_safe_c_fp(sc, OP_SAFE_C_FP_1, sc->nil);
	  goto EVAL;

	case OP_SAFE_C_FP_1:
	  /* in-coming sc->value has the current arg value, sc->args is all previous args, sc->code is the next arg if any */
	  if (op_safe_c_fp(sc, OP_SAFE_C_FP_1, cons(sc, sc->value, sc->args)))
	    goto EVAL;
	  do {sc->stack_end -= 4;} while (((opcode_t)sc->stack_end[3]) == OP_GC_PROTECT); /* perhaps use a cons to carry this info instead */
	  /* normally an outside function that calls gc_protect_via_stack should be declared unsafe (since it messes with the stack),
	   *   but block_copy is a method with no way to say that it is unsafe!  so (c-fnc ... (copy (block)...) ...) will insert
	   *   the OP_GC_PROTECT frame in the midst of our args, but we're expecting to get the original sc->code pointer from
	   *   the previous stack frame.
	   */
	  sc->code = sc->stack_end[0];
	  sc->value = c_call(sc->code)(sc, safe_reverse_in_place(sc, sc->args));
	  goto START;

	case OP_SAFE_C_FP_MV_1:
	  if (op_safe_c_fp(sc, OP_SAFE_C_FP_MV_1, (is_multiple_value(sc->value)) ? s7_append(sc, s7_reverse(sc, sc->value), sc->args) : cons(sc, sc->value, sc->args)))
	    goto EVAL;
	  do {sc->stack_end -= 4;} while (((opcode_t)sc->stack_end[3]) == OP_GC_PROTECT);
	  sc->code = sc->stack_end[0];
	  sc->code = c_function_base(opt1_cfunc(sc->code));
	  sc->args = safe_reverse_in_place(sc, sc->args);
	  goto APPLY;


	case OP_SAFE_C_SSP:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SSP:
	  check_stack_size(sc);
	  push_stack_no_args(sc, OP_SAFE_C_SSP_1, sc->code);
	  sc->code = opt3_pair(sc->code);
	  goto EVAL;

	case OP_SAFE_C_SSP_1:
	  set_car(sc->t3_3, sc->value);
	  set_car(sc->t3_1, lookup(sc, cadr(sc->code)));
	  set_car(sc->t3_2, lookup(sc, caddr(sc->code)));
	  sc->value = c_call(sc->code)(sc, sc->t3_1);
	  goto START;

	case OP_SAFE_C_SSP_MV_1:
	  sc->args = cons(sc, lookup(sc, cadr(sc->code)), cons(sc, lookup(sc, caddr(sc->code)), sc->value));
	  sc->code = c_function_base(opt1_cfunc(sc->code));
	  goto APPLY;


	case OP_SAFE_C_A:
	  if (!c_function_is_ok(sc, sc->code))
	    {
	      if (unknown_a_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) /* for lt?? */
		{
		  if (op_no_hop(sc->code) == OP_SAFE_C_A)
		    {
		      set_car(sc->a1_1, c_call(cdr(sc->code))(sc, cadr(sc->code)));
		      sc->value = c_call(sc->code)(sc, sc->a1_1);
		      goto START;
		    }
		}
	      else set_optimize_op(sc->code, OP_S_A);
	      goto EVAL;
	    }
	case HOP_SAFE_C_A: sc->value = fx_c_a(sc, sc->code); goto START;

	case OP_SAFE_C_opAq: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_opAq: sc->value = fx_c_opaq(sc, sc->code); goto START;

	case OP_SAFE_C_opAAq: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_opAAq: sc->value = safe_c_opaaq(sc, sc->code); goto START;

	case OP_SAFE_C_opAAAq: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_opAAAq: op_safe_c_opaaaq(sc); goto START;

	case OP_SAFE_C_S_opAq: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_S_opAq: sc->value = fx_c_s_opaq(sc, sc->code); goto START;

	case OP_SAFE_C_opAq_S: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_opAq_S: sc->value = fx_c_opaq_s(sc, sc->code); goto START;

	case OP_SAFE_C_S_opAAq: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_S_opAAq: op_safe_c_s_opaaq(sc); goto START;

	case OP_SAFE_C_S_opAAAq: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_S_opAAAq: op_safe_c_s_opaaaq(sc); goto START;

	case OP_SAFE_C_AA: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_AA: op_safe_c_aa(sc); goto START;

	case OP_SAFE_C_AAA: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_AAA: op_safe_c_aaa(sc); goto START;

	case OP_SAFE_C_SSA: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SSA: op_safe_c_ssa(sc); goto START;

	case OP_SAFE_C_SAS: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SAS: sc->value = fx_c_sas(sc, sc->code); goto START;

	case OP_SAFE_C_CAC: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CAC: sc->value = fx_c_cac(sc, sc->code); goto START;

	case OP_SAFE_C_CSA: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CSA: sc->value = fx_c_csa(sc, sc->code); goto START;

	case OP_SAFE_C_SCA: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SCA: sc->value = fx_c_sca(sc, sc->code); goto START;

	case OP_SAFE_C_SSSC: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SSSC: sc->value = fx_c_sssc(sc, sc->code); goto START;

	case OP_SAFE_C_AAAA: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_AAAA: op_safe_c_aaaa(sc); goto START;

	case OP_SAFE_C_FX: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_FX: op_safe_c_fx(sc); goto START;

	case OP_SAFE_C_ALL_CA: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_ALL_CA: op_safe_c_all_ca(sc); goto START;

	case OP_SAFE_C_SCS: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SCS: sc->value = fx_c_scs(sc, sc->code); goto START;

	case OP_SAFE_C_SSC: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SSC: sc->value = fx_c_ssc(sc, sc->code); goto START;

	case OP_SAFE_C_SCC: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SCC: sc->value = fx_c_scc(sc, sc->code); goto START;

	case OP_SAFE_C_CSC: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CSC: sc->value = fx_c_csc(sc, sc->code); goto START;

	case OP_SAFE_C_CCS: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CCS: sc->value = fx_c_ccs(sc, sc->code); goto START;

	case OP_SAFE_C_CSS: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CSS: op_safe_c_css(sc); goto START;

	case OP_SAFE_C_SSS: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SSS: sc->value = fx_c_sss(sc, sc->code); goto START;

	case OP_SAFE_C_opDq: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opDq: sc->value = fx_c_opdq(sc, sc->code); goto START;

	case OP_SAFE_C_opSq: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq: op_safe_c_opsq(sc); goto START;

	case OP_SAFE_C_op_opSq_q: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, cadadr(sc->code)))) break;
	case HOP_SAFE_C_op_opSq_q: sc->value = fx_c_op_opsq_q(sc, sc->code); goto START;

	case OP_SAFE_C_op_S_opSq_q: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, caddr(cadr(sc->code))))) break;
	case HOP_SAFE_C_op_S_opSq_q: sc->value = fx_c_op_s_opsq_q(sc, sc->code); goto START;

	case OP_SAFE_C_op_opSq_S_q: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, cadadr(sc->code)))) break;
	case HOP_SAFE_C_op_opSq_S_q: sc->value = fx_c_op_opsq_s_q(sc, sc->code); goto START;

	case OP_SAFE_C_PS:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_PS:
	  push_stack_no_args(sc, OP_SAFE_C_PS_1, sc->code); /* gotta wait in this case */
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_PS_1:
	  set_car(sc->t2_2, lookup(sc, caddr(sc->code)));
	  /* we have to wait because we say the evaluation order is left to right (in lambda*)
	   *   and the first arg's evaluation might change the value of the second arg.
	   */
	  set_car(sc->t2_1, sc->value);
	  sc->value = c_call(sc->code)(sc, sc->t2_1);
	  goto START;

	case OP_SAFE_C_PS_MV:      /* (define (hi a) (+ (values 1 2) a)) */
	  sc->args = s7_append(sc, sc->value, set_plist_1(sc, lookup(sc, caddr(sc->code))));
	  sc->code = c_function_base(opt1_cfunc(sc->code));
	  goto APPLY;


	case OP_SAFE_C_PC:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_PC:
	  /* if (optimize_op(cadr(sc->code)) == HOP_SAFE_CLOSURE_S_A) fprintf(stderr, "%s\n", DISPLAY_80(sc->code)); */
	  check_stack_size(sc);
	  push_stack(sc, OP_SAFE_C_PC_1, opt2_con(cdr(sc->code)), sc->code);
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_PC_1:
	  set_car(sc->t2_1, sc->value);
	  set_car(sc->t2_2, sc->args);
	  sc->value = c_call(sc->code)(sc, sc->t2_1);
	  goto START;

	case OP_SAFE_C_PC_MV:
	  sc->args = s7_append(sc, sc->value, set_plist_1(sc, sc->args));
	  sc->code = c_function_base(opt1_cfunc(sc->code));
	  goto APPLY;


	case OP_SAFE_C_SP:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_SP:
	  check_stack_size(sc);
	  push_stack(sc, (opcode_t)opt1_any(cdr(sc->code)), lookup(sc, cadr(sc->code)), sc->code);
	  sc->code = caddr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_SP_1: /* we get here from many places (op_safe_c_sp for example), but all are safe */
	  set_car(sc->t2_1, sc->args);
	  set_car(sc->t2_2, sc->value);
	  sc->value = c_call(sc->code)(sc, sc->t2_1);
	  goto START;

	case OP_SAFE_CONS_SP_1:
	  sc->value = cons(sc, sc->args, sc->value);
	  goto START;

#if (!WITH_GMP)
	case OP_SAFE_ADD_SP_1:
	  if ((is_t_integer(sc->args)) && (is_t_integer(sc->value)))
#if HAVE_OVERFLOW_CHECKS
	    {
	      s7_int val;
	      if (add_overflow(integer(sc->args), integer(sc->value), &val))
		sc->value = make_real(sc, (double)integer(sc->args) + (double)integer(sc->value));
	      else sc->value = make_integer(sc, val);
	    }
#else
	    sc->value = make_integer(sc, integer(sc->args) + integer(sc->value));
#endif
	  else sc->value = add_p_pp(sc, sc->args, sc->value);
	  goto START;

	case OP_SAFE_SUBTRACT_SP_1:
	  sc->value = subtract_p_pp(sc, sc->args, sc->value);
	  goto START;

	case OP_SAFE_MULTIPLY_SP_1:
	  if ((is_t_real(sc->args)) && (is_t_real(sc->value)))
	    sc->value = make_real(sc, real(sc->args) * real(sc->value));
	  else sc->value = multiply_p_pp(sc, sc->args, sc->value);
	  goto START;
#endif

	case OP_SAFE_MEMQ_SP_1:
	  if (is_pair(sc->value))
	    sc->value = s7_memq(sc, sc->args, sc->value);
	  else
	    {
	      if (is_null(sc->value))
		sc->value = sc->F;
	      else sc->value = method_or_bust_with_type(sc, sc->value, sc->memq_symbol, list_2(sc, sc->args, sc->value), a_list_string, 2);
	    }
	  goto START;

	case OP_SAFE_C_SP_MV:
	  sc->args = cons(sc, sc->args, sc->value); /* don't use u2_1 or some permanent list here: immutable=copied later */
	  sc->code = c_function_base(opt1_cfunc(sc->code));
	  goto APPLY;


	case OP_SAFE_C_AP:
	  if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code)))) break;
	case HOP_SAFE_C_AP:
	  op_safe_c_ap(sc);
	  goto EVAL;

	case OP_SAFE_C_PA:
	  if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, caddr(sc->code)))) break;
	case HOP_SAFE_C_PA:
	  check_stack_size(sc);
	  push_stack(sc, OP_SAFE_C_PA_1, sc->nil, sc->code);
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_PA_1:
	  {
	    s7_pointer val, code;
	    code = sc->code;
	    val = sc->value;
	    set_car(sc->t2_2, fx_call(sc, cddr(code)));
	    set_car(sc->t2_1, val);
	    sc->value = c_call(code)(sc, sc->t2_1);
	    goto START;
	  }

	case OP_SAFE_C_PA_MV:
	  op_safe_c_pa_mv(sc);
	  goto APPLY;

	case OP_SAFE_C_CP:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_CP:
	  /* it's possible in a case like this to overflow the stack -- s7test has a deeply
	   *   nested expression involving (+ c (+ c (+ ... ))) all opt'd as safe_c_cz -- if we're close
	   *   to the stack end at the start, it runs off the end.  Normally the stack increase in
	   *   the reader protects us, but a call/cc can replace the original stack with a much smaller one.
	   * How to minimize the cost of this check?
	   */
	  check_stack_size(sc);
	  push_stack(sc, (opcode_t)opt1_any(cdr(sc->code)), opt3_any(cdr(sc->code)), sc->code);
	  sc->code = caddr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_PP:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_PP:
	  check_stack_size(sc);
	  push_stack_no_args(sc, OP_SAFE_C_PP_1, sc->code);
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_PP_1:
	  /* unless multiple values from last call (first arg) we get here only from OP_SAFE_C_PP.
	   *   splice_in_values changes the operator so if we get here, sc->value is the result of the first arg
	   * safe_c_pp -> 1, but if mv, -> 3
	   *   1: -> 2, if mv -> 4
	   *   2: done (both normal)
	   *   3: -> 5, but if mv, -> 6
	   *   4: done (1 normal, 2 mv)
	   *   5: done (1 mv, 2 normal)
	   *   6: done (both mv)
	   * I think safe_c_ppp would require 18 branches (or maybe just collect the args and concatenate at the end?)
	   */
	  push_stack(sc, (opcode_t)opt1_any(cdr(sc->code)), sc->value, sc->code); /* mv -> 3, opt1 is OP_SAFE_CONS_SP_1 et al which assume no mv */
	  sc->code = caddr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_PP_3_MV:  /* we get here if the first arg returned multiple values */
	  push_stack(sc, OP_SAFE_C_PP_5, copy_list(sc, sc->value), sc->code); /* copy is needed here */
	  sc->code = caddr(sc->code);
	  goto EVAL;

	case OP_SAFE_C_PP_5:
	  /* 1 mv, 2, normal */
	  sc->args = s7_append(sc, sc->args, list_1(sc, sc->value));
	  sc->code = c_function_base(opt1_cfunc(sc->code));
	  goto APPLY;

	case OP_SAFE_C_PP_6_MV:	  /* both mv */
	  sc->args = s7_append(sc, sc->args, sc->value);
	  /*
	   * c_callee(sc->code) here is g_add_2, but we have any number of args from a values call
	   *   the original (unoptimized) function is (hopefully) c_function_base(opt1_cfunc(sc->code))?
	   *   (let () (define (ho a) (+ a 2)) (define (hi) (+ (ho 1) (ho 2))) (hi)) -> 7
	   *   (let () (define (ho a) (+ a 2)) (define (hi) (+ (ho 1) (values 3 4))) (hi)) -> 10
	   *   (let () (define (ho a) (+ a 2)) (define (hi) (+ (values 3 4) (ho 1))) (hi)) -> 10
	   *   (let () (define (hi) (+ (values 1 2) (values 3 4))) (hi)) -> 10
	   */
	  sc->code = c_function_base(opt1_cfunc(sc->code));
	  goto APPLY;

	case OP_SAFE_C_opSSq: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSSq: sc->value = fx_c_opssq(sc, sc->code); goto START;

	case OP_SAFE_C_opSCq: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSCq: sc->value = fx_c_opscq(sc, sc->code); goto START;

	case OP_SAFE_C_opCSq: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opCSq: sc->value = fx_c_opcsq(sc, sc->code); goto START;

	case OP_SAFE_C_S_opSq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_S_opSq: sc->value = fx_c_s_opsq(sc, sc->code); goto START;

	case OP_SAFE_C_S_opDq: if (!c_function_is_ok_caddr(sc, sc->code))break;
	case HOP_SAFE_C_S_opDq: sc->value = fx_c_s_opdq(sc, sc->code); goto START;

	case OP_SAFE_C_C_opSq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_C_opSq: sc->value = fx_c_c_opsq(sc, sc->code); goto START;

	case OP_SAFE_C_C_opDq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_C_opDq: sc->value = fx_c_c_opdq(sc, sc->code); goto START;

	case OP_SAFE_C_C_opCSq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_C_opCSq: sc->value = fx_c_c_opcsq(sc, sc->code); goto START;

	case OP_SAFE_C_C_opSSq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_C_opSSq: sc->value = fx_c_c_opssq(sc, sc->code); goto START;

	case OP_SAFE_C_opCSq_C: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opCSq_C: sc->value = fx_c_opcsq_c(sc, sc->code); goto START;

	case OP_SAFE_C_opSSq_C: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSSq_C: sc->value = fx_c_opssq_c(sc, sc->code); goto START;

	case OP_SAFE_C_opSSq_S: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSSq_S: sc->value = fx_c_opssq_s(sc, sc->code); goto START;

	case OP_SAFE_C_op_opSSq_q_C: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, cadadr(sc->code)))) break;
	case HOP_SAFE_C_op_opSSq_q_C: sc->value = fx_c_op_opssq_q_c(sc, sc->code); goto START;

	case OP_SAFE_C_op_opSSq_q_S: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, cadadr(sc->code)))) break;
	case HOP_SAFE_C_op_opSSq_q_S: sc->value = fx_c_op_opssq_q_s(sc, sc->code); goto START;

	case OP_SAFE_C_op_opSSq_Sq_S: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, cadadr(sc->code)))) break;
	case HOP_SAFE_C_op_opSSq_Sq_S: sc->value = fx_c_op_opssq_sq_s(sc, sc->code); goto START;

	case OP_SAFE_C_op_opSq_q_C: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, cadadr(sc->code)))) break;
	case HOP_SAFE_C_op_opSq_q_C: sc->value = fx_c_op_opsq_q_c(sc, sc->code); goto START;

	case OP_SAFE_C_op_opSq_q_S: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, cadr(sc->code))) || (!c_function_is_ok(sc, cadadr(sc->code)))) break;
	case HOP_SAFE_C_op_opSq_q_S: sc->value = fx_c_op_opsq_q_s(sc, sc->code); goto START;

	case OP_SAFE_C_S_op_opSq_Cq: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, caddr(sc->code))) || (!c_function_is_ok(sc, cadr(caddr(sc->code))))) break;
	case HOP_SAFE_C_S_op_opSq_Cq: sc->value = fx_c_s_op_opsq_cq(sc, sc->code); goto START;

	case OP_SAFE_C_S_op_S_opSqq: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, caddr(sc->code))) || (!c_function_is_ok(sc, caddr(caddr(sc->code))))) break;
	case HOP_SAFE_C_S_op_S_opSqq: sc->value = fx_c_s_op_s_opsqq(sc, sc->code); goto START;

	case OP_SAFE_C_S_op_S_opSSqq: if ((!c_function_is_ok(sc, sc->code)) || (!c_function_is_ok(sc, caddr(sc->code))) || (!c_function_is_ok(sc, caddr(caddr(sc->code))))) break;
	case HOP_SAFE_C_S_op_S_opSSqq: sc->value = fx_c_s_op_s_opssqq(sc, sc->code); goto START;

	case OP_SAFE_C_S_op_opSSq_opSSqq: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_S_op_opSSq_opSSqq: sc->value = fx_c_s_op_opssq_opssqq(sc, sc->code); goto START;

	case OP_SAFE_C_opSCq_S: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSCq_S: sc->value = fx_c_opscq_s(sc, sc->code); goto START;

	case OP_SAFE_C_opSCq_C: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSCq_C: sc->value = fx_c_opscq_c(sc, sc->code); goto START;

	case OP_SAFE_C_opCSq_S: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opCSq_S: sc->value = fx_c_opcsq_s(sc, sc->code); goto START;

	case OP_SAFE_C_S_opSCq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_S_opSCq: sc->value = fx_c_s_opscq(sc, sc->code); goto START;

	case OP_SAFE_C_C_opSCq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_C_opSCq: sc->value = fx_c_c_opscq(sc, sc->code); goto START;

	case OP_SAFE_C_S_opSSq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_S_opSSq: sc->value = fx_c_s_opssq(sc, sc->code); goto START;

	case OP_SAFE_C_S_opCSq: if (!c_function_is_ok_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_S_opCSq: sc->value = fx_c_s_opcsq(sc, sc->code); goto START;

	case OP_SAFE_C_opSq_S: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq_S: sc->value = fx_c_opsq_s(sc, sc->code); goto START;

	case OP_SAFE_C_CAR_S_S: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_CAR_S_S: sc->value = fx_c_car_s_s(sc, sc->code); goto START;

	case OP_SAFE_C_opSq_P: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq_P: op_safe_c_opsq_p(sc); goto EVAL;

	case OP_SAFE_C_opSq_CS: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq_CS: sc->value = fx_c_opsq_cs(sc, sc->code); goto START;

	case OP_SAFE_C_opDq_S: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opDq_S: sc->value = fx_c_opdq_s(sc, sc->code); goto START;

	case OP_SAFE_C_opDq_C: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opDq_C: sc->value = fx_c_opdq_c(sc, sc->code); goto START;

	case OP_SAFE_C_opSq_C: if (!c_function_is_ok_cadr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq_C: sc->value = fx_c_opsq_c(sc, sc->code); goto START;

	case OP_SAFE_C_opSq_opSq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq_opSq: sc->value = fx_c_opsq_opsq(sc, sc->code); goto START;

	case OP_SAFE_C_opDq_opDq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opDq_opDq: sc->value = fx_c_opdq_opdq(sc, sc->code); goto START;

	case OP_SAFE_C_opSq_opDq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq_opDq: sc->value = fx_c_opsq_opdq(sc, sc->code); goto START;

	case OP_SAFE_C_opDq_opSq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opDq_opSq: sc->value = fx_c_opdq_opsq(sc, sc->code); goto START;

	case OP_SAFE_C_opDq_opSSq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opDq_opSSq: sc->value = fx_c_opdq_opssq(sc, sc->code); goto START;

	case OP_SAFE_C_opSCq_opSCq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opSCq_opSCq: sc->value = fx_c_opscq_opscq(sc, sc->code); goto START;

	case OP_SAFE_C_opSSq_opSSq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opSSq_opSSq: sc->value = fx_c_opssq_opssq(sc, sc->code); goto START;

	case OP_SAFE_C_opSSq_opSq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opSSq_opSq: sc->value = fx_c_opssq_opsq(sc, sc->code); goto START;

	case OP_SAFE_C_opSq_opSSq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opSq_opSSq: sc->value = fx_c_opsq_opssq(sc, sc->code); goto START;

	case OP_SAFE_C_opSSq_opDq: if (!c_function_is_ok_cadr_caddr(sc, sc->code)) break;
	case HOP_SAFE_C_opSSq_opDq: sc->value = fx_c_opssq_opdq(sc, sc->code); goto START;

	case OP_SAFE_IFA_SS_A: /* ((if fx s s) fx) I think */
	case HOP_SAFE_IFA_SS_A:
	  {
	    s7_function f;
	    f = c_function_call((is_true(sc, fx_call(sc, cdar(sc->code)))) ? opt1_con(sc->code) : opt2_con(sc->code));
	    sc->value = f(sc, set_plist_1(sc, fx_call(sc, cdr(sc->code))));
	    goto START;
	  }

	  /* -------------------------------------------------------------------------------- */
	case OP_C_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_C_S:
	  sc->args = list_1(sc, lookup(sc, cadr(sc->code)));
	  sc->value = c_call(sc->code)(sc, sc->args);
	  goto START;

	case OP_READ_S:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_S); goto EVAL;}
	case HOP_READ_S:
	  read_s_ex(sc);
	  goto START;

	case OP_C_A:
	  if (!c_function_is_ok(sc, sc->code)) {set_optimize_op(sc->code, OP_S_A); goto EVAL;}
	case HOP_C_A:
	  sc->args = list_1(sc, fx_call(sc, cdr(sc->code)));
	  sc->value = c_call(sc->code)(sc, sc->args);
	  goto START;

	case OP_C_P:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_P:
	  push_stack_no_args(sc, OP_C_P_1, sc->code);
	  sc->code = T_Pair(cadr(sc->code));
	  goto EVAL;

	case OP_C_P_1:
	  sc->value = c_call(sc->code)(sc, list_1(sc, sc->value));
	  goto START;

	case OP_C_P_MV:
	  /* op_c_p_1 -> mv case: (define (hi) (format (values #f "~A ~D" 1 2))) */
	  sc->code = c_function_base(opt1_cfunc(sc->code)); /* see comment above */
	  sc->args = copy_list(sc, sc->value);
	  goto APPLY;

	case OP_C_SS:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_SS:
	  sc->args = list_2(sc, lookup(sc, cadr(sc->code)), lookup(sc, caddr(sc->code)));
	  sc->value = c_call(sc->code)(sc, sc->args);
	  goto START;

	case OP_C_AP:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_AP:
	  {
	    s7_pointer val;
	    val = fx_call(sc, cdr(sc->code));
	    push_stack(sc, OP_C_AP_1, val, sc->code); /* op_c_ap_1 sends us to apply which calls check_stack_size I think */
	    sc->code = caddr(sc->code);
	    goto EVAL;
	  }

	case OP_C_AP_1: /* goes to c_sp_mv if multiple values */
	  sc->value = c_call(sc->code)(sc, sc->args = list_2(sc, sc->args, sc->value));
	  goto START;

	case OP_C_FA: /* op_c_fs was not faster if fx_s below */
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_FA:
	  {
	    s7_pointer f, code;
	    code = sc->code;
	    sc->code = cdadr(code);
	    make_closure_with_let(sc, f, car(sc->code), cdr(sc->code), sc->envir, CLOSURE_ARITY_NOT_SET);
	    sc->w = f;  /* f=new closure cell, car=args, cdr=body, can't use sc->value here because c_call below may clobber it */
	    sc->args = list_2(sc, f, fx_call(sc, cddr(code)));
	    sc->value = c_call(code)(sc, sc->args);
	    goto START;
	  }

	case OP_C_FA_1:  /* here only if for-each or map */
	  {
	    s7_pointer f, code;
	    code = sc->code;
	    f = cddr(code);
	    sc->value = fx_call(sc, f);
	    if (is_null(sc->value))
	      {
		if (c_callee(code))
		  sc->value = sc->unspecified;
		goto START;
	      }
	    sc->code = opt3_pair(code); /* cdadr(code); */
	    make_closure_with_let(sc, f, car(sc->code), cdr(sc->code), sc->envir, 1);
	    if (c_callee(code))
	      sc->value = g_for_each_closure(sc, f, sc->value);
	    else sc->value = g_map_closure(sc, f, sc->value);
	    goto START;
	  }

	case OP_C_AA:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_AA:
	  {
	    s7_pointer code;
	    code = sc->code;
	    sc->code = fx_call(sc, cdr(code));
	    sc->value = fx_call(sc, cddr(code));
	    sc->args = list_2(sc, sc->code, sc->value);
	    sc->value = c_call(code)(sc, sc->args);
	    goto START;
	  }

	case OP_APPLY_SS:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_APPLY_SS:
	  sc->args = lookup(sc, opt2_sym(sc->code));  /* is this right if code=macro? */
	  sc->code = lookup(sc, cadr(sc->code));      /* global search here was slower */
	  if (!s7_is_proper_list(sc, sc->args))       /* (apply + #f) etc */
	    apply_list_error(sc, sc->args);
	  if (needs_copied_args(sc->code))
	    sc->args = copy_list(sc, sc->args);
	  goto APPLY;

	case OP_APPLY_SA:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_APPLY_SA:
	  {
	    s7_pointer p;
	    p = cdr(sc->code);
	    sc->args = fx_call(sc, cdr(p));
	    sc->code = lookup(sc, car(p));
	    if (!s7_is_proper_list(sc, sc->args))     /* (apply + #f) etc */
	      apply_list_error(sc, sc->args);
	    if (needs_copied_args(sc->code))
	      sc->args = copy_list(sc, sc->args);
	    goto APPLY;
	  }

	case OP_APPLY_SL:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_APPLY_SL:
	  {
	    s7_pointer p;
	    p = cdr(sc->code);
	    sc->args = fx_call(sc, cdr(p));
	    sc->code = lookup(sc, car(p));
	    goto APPLY;
	  }

	case OP_C_S_opSq: if ((!c_function_is_ok(sc, sc->code)) || (!indirect_c_function_is_ok(sc, caddr(sc->code)))) break;
	case HOP_C_S_opSq: sc->value = op_c_s_opsq(sc); goto START;

	case OP_C_S_opDq: if ((!c_function_is_ok(sc, sc->code)) || (!indirect_c_function_is_ok(sc, caddr(sc->code)))) break;
	case HOP_C_S_opDq: sc->value = op_c_s_opdq(sc); goto START;

	case OP_C_SCS: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_SCS: sc->value = op_c_scs(sc); goto START;

	case OP_C_FX: if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_FX: op_c_fx(sc); goto START;

	case OP_CALL_WITH_EXIT:
	  if (!c_function_is_ok(sc, sc->code)) break;
	  check_lambda_args(sc, cadadr(sc->code), NULL);
	case HOP_CALL_WITH_EXIT:
	  op_call_with_exit(sc);
	  goto BEGIN;

	case OP_CALL_WITH_EXIT_P:
	  if (!c_function_is_ok(sc, sc->code)) break;
	  check_lambda_args(sc, cadadr(sc->code), NULL);
	case HOP_CALL_WITH_EXIT_P:
	  op_call_with_exit_p(sc);
	  goto EVAL;

	case OP_C_CATCH:
	  if (!c_function_is_ok(sc, sc->code)) break;
	  check_lambda_args(sc, cadr(cadddr(sc->code)), NULL);
	case HOP_C_CATCH:
	  op_c_catch(sc);
	  goto BEGIN;

	case OP_C_CATCH_ALL:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_CATCH_ALL:                                /* (catch #t (lambda () ...) (lambda args #f) */
	  set_current_code(sc, sc->code);
	  new_frame(sc, sc->envir, sc->envir);
	  catch_all_set_goto_loc(sc->envir, s7_stack_top(sc));
	  catch_all_set_op_loc(sc->envir, sc->op_stack_now - sc->op_stack);
	  push_stack(sc, OP_CATCH_ALL, opt2_con(sc->code), sc->code);
	  sc->code = T_Pair(opt1_pair(cdr(sc->code)));       /* the body of the first lambda */
	  goto BEGIN;

	case OP_C_CATCH_ALL_P:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_CATCH_ALL_P:
	  new_frame(sc, sc->envir, sc->envir);               /* frame is needed even if no definers because we're setting the dox1/2 slots */
	  catch_all_set_goto_loc(sc->envir, s7_stack_top(sc));
	  catch_all_set_op_loc(sc->envir, sc->op_stack_now - sc->op_stack);
	  push_stack(sc, OP_CATCH_ALL, opt2_con(sc->code), sc->code);
	  sc->code = opt1_pair(cdr(sc->code));
	  goto EVAL;

	case OP_C_CATCH_ALL_FX:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_C_CATCH_ALL_FX:
	  new_frame(sc, sc->envir, sc->envir);
	  catch_all_set_goto_loc(sc->envir, s7_stack_top(sc));
	  catch_all_set_op_loc(sc->envir, sc->op_stack_now - sc->op_stack);
	  push_stack(sc, OP_CATCH_ALL, opt2_con(sc->code), sc->code);
	  sc->value = fx_call(sc, opt1_pair(cdr(sc->code)));
	  goto START;

	  /* -------------------------------------------------------------------------------- */
	  /* unknown* fallback on these */
	case OP_S:
	  sc->code = lookup(sc, car(sc->code));
	  if (!is_applicable(sc->code))
	    apply_error(sc, sc->code, sc->nil);
	  sc->args = sc->nil;
	  goto APPLY;

	case OP_S_C:
	  op_s_c(sc);
	  goto APPLY;

	case OP_S_S:
	  if (op_s_s(sc)) goto START;
	  goto APPLY;

	case OP_S_A:
	  op_s_a(sc);
	  goto APPLY;

	case OP_S_AA:
	  op_s_aa(sc);
	  goto APPLY;

	case OP_SAFE_C_STAR:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_STAR:
	  sc->code = opt1_cfunc(sc->code);
	  apply_c_function_star_fill_defaults(sc, 0);
	  goto START;

	case OP_SAFE_C_STAR_A:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_STAR_A:
	  set_car(sc->a1_1, fx_call(sc, cdr(sc->code)));
	  sc->args = sc->a1_1;
	  sc->code = opt1_cfunc(sc->code);
	  /* one arg, so it's not a keyword; all we need to do is fill in defaults */
	  apply_c_function_star_fill_defaults(sc, 1);
	  goto START;

	case OP_SAFE_C_STAR_AA:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_STAR_AA:
	  safe_c_star_aa(sc);
	  goto START;

	case OP_SAFE_C_STAR_FX:
	  if (!c_function_is_ok(sc, sc->code)) break;
	case HOP_SAFE_C_STAR_FX:
	  safe_c_star_fx(sc);
	  goto START;

	  /* -------------------------------------------------------------------------------- */
	case OP_THUNK:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_M, 0)) {if (unknown_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_THUNK:
	  check_stack_size(sc);
	  /* this recursion check is consistent with the other unsafe closure calls, but we're probably in big trouble:
	   *   (letrec ((a (lambda () (cons 1 (b)))) (b (lambda () (a)))) (b))
	   */
	  sc->code = opt1_lambda(sc->code);
	  new_frame(sc, closure_let(sc->code), sc->envir);
	  closure_push_and_goto_eval(sc);

	case OP_THUNK_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 0)) {if (unknown_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_THUNK_P:
	  sc->code = opt1_lambda(sc->code);
	  new_frame(sc, closure_let(sc->code), sc->envir);
	  closure_goto_eval(sc);

	case OP_SAFE_THUNK:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_M, 0)) {if (unknown_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_THUNK: /* no frame needed */
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = closure_let(sc->code);
	  closure_push_and_goto_eval(sc);

	case OP_SAFE_THUNK_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_P, 0)) {if (unknown_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_THUNK_P:
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = closure_let(sc->code);
	  closure_goto_eval(sc);

	case OP_SAFE_THUNK_A:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_A, 0)) {if (unknown_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_THUNK_A:
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = closure_let(sc->code);
          sc->value = fx_call(sc, closure_body(sc->code));
          goto START;


	case OP_CLOSURE_S:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_M, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_S:
	  sc->value = lookup(sc, opt2_sym(sc->code));
	  check_stack_size(sc);
	  sc->code = opt1_lambda(sc->code);
	  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value);
	  closure_push_and_goto_eval(sc);

	case OP_CLOSURE_S_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_S_P:
	  sc->value = lookup(sc, opt2_sym(sc->code));
	  check_stack_size(sc);
	  sc->code = opt1_lambda(sc->code);
	  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value);
	  closure_goto_eval(sc);

	case OP_SAFE_CLOSURE_S:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_M, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_S:
	  sc->value = lookup(sc, opt2_sym(sc->code));
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
	  closure_push_and_goto_eval(sc);

	case OP_SAFE_CLOSURE_S_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_P, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_S_P:
	  sc->value = lookup(sc, opt2_sym(sc->code));
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
	  closure_goto_eval(sc);

	case OP_SAFE_CLOSURE_S_A:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_A, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_S_A:
	  sc->value = lookup(sc, opt2_sym(sc->code));
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
	  sc->value = fx_call(sc, closure_body(sc->code));
          goto START;


	case OP_CLOSURE_C:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_M, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_C:
	  check_stack_size(sc);
	  sc->value = cadr(sc->code);
	  sc->code = opt1_lambda(sc->code);
	  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value);
	  closure_push_and_goto_eval(sc);

	case OP_CLOSURE_C_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_C_P:
	  sc->value = cadr(sc->code);
	  check_stack_size(sc);
	  sc->code = opt1_lambda(sc->code);
	  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value);
	  closure_goto_eval(sc);

	case OP_SAFE_CLOSURE_C:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_M, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_C:
	  sc->value = cadr(sc->code);
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
	  closure_push_and_goto_eval(sc);

	case OP_SAFE_CLOSURE_C_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_P, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_C_P:
	  sc->value = cadr(sc->code);
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
	  closure_goto_eval(sc);

	case OP_SAFE_CLOSURE_C_A:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_A, 1)) {if (unknown_g_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_C_A:
	  sc->value = cadr(sc->code);
	  sc->code = opt1_lambda(sc->code);
	  sc->envir = old_frame_with_slot(sc, closure_let(sc->code), sc->value);
          sc->value = fx_call(sc, closure_body(sc->code));
          goto START;


	case OP_CLOSURE_P:
	  if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, 1)) break;
	case HOP_CLOSURE_P:
	  push_stack(sc, OP_CLOSURE_P_1, sc->args, sc->code);
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_CLOSURE_P_1:
	  check_stack_size(sc);
	  sc->code = opt1_lambda(sc->code);
	  new_frame_with_slot(sc, closure_let(sc->code), sc->envir, car(closure_args(sc->code)), sc->value);
	  sc->code = T_Pair(closure_body(sc->code));
	  goto BEGIN;

	case OP_CLOSURE_P_MV:
	  sc->code = opt1_lambda(sc->code);
	  sc->args = copy_list(sc, sc->value);
	  goto APPLY;

	case OP_SAFE_CLOSURE_P:
	  if (!closure_is_fine(sc, sc->code, MATCH_SAFE_CLOSURE, 1)) break;
	case HOP_SAFE_CLOSURE_P:
	  push_stack(sc, OP_SAFE_CLOSURE_P_1, sc->args, sc->code);
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_SAFE_CLOSURE_P_1:
	  sc->envir = old_frame_with_slot(sc, closure_let(opt1_lambda(sc->code)), sc->value);
	  sc->code = T_Pair(closure_body(opt1_lambda(sc->code)));
	  goto BEGIN;


	case OP_CLOSURE_A:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_M, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_A:
	  op_closure_a(sc);
	  closure_push_and_goto_eval(sc);

	case OP_CLOSURE_A_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_A_P:
	  op_closure_a(sc);
	  closure_goto_eval(sc);

	case OP_CLOSURE_SUB_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_SUB_P:
	  op_closure_sub(sc);
	  closure_goto_eval(sc);

	case OP_SAFE_CLOSURE_A:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_M, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_A:
	  op_safe_closure_a(sc);
	  goto EVAL;

	case OP_SAFE_CLOSURE_A_P:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_P, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_A_P:
	  op_safe_closure_a_p(sc);
	  goto EVAL;

	case OP_SAFE_CLOSURE_A_A:
	  if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_A, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_A_A:
	  op_safe_closure_a_a(sc);
	  goto START;


	case OP_CLOSURE_AP: if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, 2)) break;
	case HOP_CLOSURE_AP: op_closure_ap(sc); goto EVAL;
	case OP_CLOSURE_AP_1: op_closure_ap_1(sc); goto BEGIN;
	case OP_CLOSURE_AP_MV: op_closure_ap_mv(sc); goto APPLY;

	case OP_CLOSURE_PA: if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, 2)) break;
	case HOP_CLOSURE_PA: op_closure_pa(sc); goto EVAL;
	case OP_CLOSURE_PA_1: op_closure_pa_1(sc); goto BEGIN;
	case OP_CLOSURE_PA_MV: op_closure_pa_mv(sc); goto APPLY;

	case OP_SAFE_CLOSURE_AP: if (!closure_is_fine(sc, sc->code, MATCH_SAFE_CLOSURE, 2)) break;
	case HOP_SAFE_CLOSURE_AP: op_safe_closure_ap(sc); goto EVAL;
	case OP_SAFE_CLOSURE_AP_1: op_safe_closure_ap_1(sc); goto BEGIN;

	case OP_SAFE_CLOSURE_PA: if (!closure_is_fine(sc, sc->code, MATCH_SAFE_CLOSURE, 2)) break;
	case HOP_SAFE_CLOSURE_PA: op_safe_closure_pa(sc); goto EVAL;
	case OP_SAFE_CLOSURE_PA_1: op_safe_closure_pa_1(sc); goto BEGIN;

	case OP_CLOSURE_FA: if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, 2)) break;
	case HOP_CLOSURE_FA: op_closure_fa(sc); goto EVAL;

	case OP_CLOSURE_SS: if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_M, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_SS: op_closure_ss(sc); goto EVAL;

	case OP_CLOSURE_SS_P: if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_SS_P: op_closure_ss_p(sc); goto EVAL;

	case OP_SAFE_CLOSURE_SS: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_M, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_SS: op_safe_closure_ss(sc); goto EVAL;

	case OP_SAFE_CLOSURE_SS_P: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_P, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_SS_P: op_safe_closure_ss_p(sc); goto EVAL;

	case OP_SAFE_CLOSURE_SS_A: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_A, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_SS_A: op_safe_closure_ss_a(sc); goto START;


	case OP_CLOSURE_SC: if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_M, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_SC: op_closure_sc(sc); goto EVAL;

	case OP_CLOSURE_SC_P: if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_SC_P: op_closure_sc_p(sc); goto EVAL;

	case OP_SAFE_CLOSURE_SC: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_M, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_SC: op_safe_closure_sc(sc); goto EVAL;

	case OP_SAFE_CLOSURE_SC_P: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_P, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_SC_P: op_safe_closure_sc_p(sc); goto EVAL;


	case OP_CLOSURE_CS: if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_CS: op_closure_cs(sc); goto BEGIN;

	case OP_SAFE_CLOSURE_CS: if (!closure_is_fine(sc, sc->code, MATCH_SAFE_CLOSURE, 2)) {if (unknown_gg_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_CS: op_safe_closure_cs(sc); goto BEGIN;


	case OP_SAFE_CLOSURE_SA: if (!closure_is_fine(sc, sc->code, MATCH_SAFE_CLOSURE, 2)) {if (unknown_aa_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_SA: op_safe_closure_sa(sc); goto BEGIN;

	case OP_CLOSURE_AA: if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_M, 2)) {if (unknown_aa_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_AA: op_closure_aa(sc); goto EVAL;

	case OP_CLOSURE_AA_P: if (!closure_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_P, 2)) {if (unknown_aa_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_AA_P: op_closure_aa_p(sc); goto EVAL;

	case OP_SAFE_CLOSURE_AA: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_M, 2)) {if (unknown_aa_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_AA: op_safe_closure_aa(sc); goto EVAL;

	case OP_SAFE_CLOSURE_AA_P: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_P, 2)) {if (unknown_aa_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_AA_P: op_safe_closure_aa_p(sc); goto EVAL;

	case OP_SAFE_CLOSURE_AA_A: if (!closure_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_A, 2)) {if (unknown_aa_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_AA_A: op_safe_closure_aa_a(sc); goto START;

	  /* safe_closure_sss was not a win: fx_s overhead -5, three_slot overhead +2 */
	case OP_SAFE_CLOSURE_SAA: if (!closure_is_fine(sc, sc->code, MATCH_SAFE_CLOSURE, 3)) break;
	case HOP_SAFE_CLOSURE_SAA: op_safe_closure_saa(sc); goto BEGIN;

	case OP_SAFE_CLOSURE_FX: if (!closure_is_fine(sc, sc->code, MATCH_SAFE_CLOSURE, integer(opt3_arglen(sc->code)))) break;
	case HOP_SAFE_CLOSURE_FX: op_safe_closure_fx(sc); goto EVAL;

	case OP_CLOSURE_ALL_S:
	  if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, integer(opt3_arglen(sc->code))))
	    {
	      if (unknown_all_s_ex(sc, sc->last_function) == goto_EVAL)
		goto EVAL;
	      break;
	    }
	case HOP_CLOSURE_ALL_S:
	  op_closure_all_s(sc);
	  goto EVAL;

	case OP_CLOSURE_FX:
	  if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, integer(opt3_arglen(sc->code))))
	    {
	      if (unknown_fx_ex(sc, sc->last_function) == goto_EVAL)
		goto EVAL;
	      break;
	    }
	case HOP_CLOSURE_FX:
	  op_closure_fx(sc);
	  goto EVAL;

	case OP_CLOSURE_ANY_FX: if (!closure_is_fine(sc, sc->code, MATCH_UNSAFE_CLOSURE, -1)) break;
	case HOP_CLOSURE_ANY_FX: op_closure_any_fx(sc); goto BEGIN;

	  /* -------------------------------------------------------------------------------- */
	case OP_SAFE_CLOSURE_STAR_A:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_STAR, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_STAR_A:
	  safe_closure_star_a(sc, sc->code);
	  goto BEGIN;

	case OP_SAFE_CLOSURE_STAR_AA:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_STAR, 2)) break;
	case HOP_SAFE_CLOSURE_STAR_AA:
	  safe_closure_star_aa(sc, sc->code);
	  goto BEGIN;

	case OP_SAFE_CLOSURE_STAR_FX:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_STAR, (is_pair(cdr(sc->code))) ? integer(opt3_arglen(sc->code)) : 0))
	    {
	      if (unknown_fx_ex(sc, sc->last_function) == goto_EVAL)
		goto EVAL;
	      break;
	    }
	case HOP_SAFE_CLOSURE_STAR_FX:
	  if (safe_closure_star_fx(sc, sc->code) == goto_EVAL) goto EVAL;
	  goto BEGIN;

	case OP_SAFE_CLOSURE_STAR_FX_0:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_STAR, 0)) {if (unknown_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_STAR_FX_0:
	  if (safe_closure_star_fx_0(sc, sc->code) == goto_EVAL) goto EVAL;
	  goto BEGIN;

	case OP_SAFE_CLOSURE_STAR_FX_1:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_STAR, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_STAR_FX_1:
	  if (safe_closure_star_fx_1(sc, sc->code) == goto_EVAL) goto EVAL;
	  goto BEGIN;

	case OP_SAFE_CLOSURE_STAR_FX_2:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_SAFE_CLOSURE_STAR, 2)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_SAFE_CLOSURE_STAR_FX_2:
	  if (safe_closure_star_fx_2(sc, sc->code) == goto_EVAL) goto EVAL;
	  goto BEGIN;

	  /* -------------------------------------------------------------------------------- */
	case OP_CLOSURE_STAR_A:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_STAR, 1)) {if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL; break;}
	case HOP_CLOSURE_STAR_A:
	  closure_star_a(sc, sc->code);
	  goto BEGIN;

	case OP_CLOSURE_STAR_FX:
	  if (!closure_star_is_ok(sc, sc->code, MATCH_UNSAFE_CLOSURE_STAR, (is_pair(cdr(sc->code))) ? integer(opt3_arglen(sc->code)) : 0))
	    {
	      if (unknown_fx_ex(sc, sc->last_function) == goto_EVAL)
		goto EVAL;
	      break;
	    }
	case HOP_CLOSURE_STAR_FX:
	  check_stack_size(sc);
	  closure_star_fx(sc, sc->code);
	  if (apply_lambda_star(sc) == goto_EVAL) goto EVAL;
	  goto BEGIN;

	  /* -------------------------------------------------------------------------------- */
	case OP_UNKNOWN:       if (unknown_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) goto EVAL;       break;
	case OP_UNKNOWN_G:     if (unknown_g_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) goto EVAL;     break;
	case OP_UNKNOWN_GG:    if (unknown_gg_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) goto EVAL;    break;
	case OP_UNKNOWN_ALL_S: if (unknown_all_s_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) goto EVAL; break;
	case OP_UNKNOWN_A:     if (unknown_a_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) goto EVAL;     break;
	case OP_UNKNOWN_AA:    if (unknown_aa_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) goto EVAL;    break;
	case OP_UNKNOWN_FX:    if (unknown_fx_ex(sc, lookup_checked(sc, car(sc->code))) == goto_EVAL) goto EVAL;    break;

	  /* -------------------------------------------------------------------------------- */
	case OP_VECTOR_A:
	  if (vector_a_ex(sc) == goto_START) goto START;
	  if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_VECTOR_AA:
	  if (vector_aa_ex(sc) == goto_START) goto START;
	  if (unknown_aa_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_STRING_A:
	  if (string_a_ex(sc) == goto_START) goto START;
	  if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_HASH_TABLE_A:
	  if (op_hash_table_a(sc)) goto START;
	  if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_CONTINUATION_A:
	  if (op_continuation_a(sc)) goto START;
	  if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_ITERATE:
	  if (op_iterate(sc)) goto START;
	  if (unknown_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_S7_LET:
	  sc->value = g_s7_let_ref_fallback(sc, set_plist_2(sc, sc->s7_let, (is_keyword(cadr(sc->code))) ? keyword_symbol(cadr(sc->code)) : cadadr(sc->code)));
	  goto START;

	case OP_ENVIRONMENT_C:
	  if (op_environment_c(sc)) goto START;
	  if ((has_fx(cdr(sc->code))) && (unknown_a_ex(sc, sc->last_function) == goto_EVAL)) goto EVAL;
	  break;

	case OP_ENVIRONMENT_A:
	  if (op_environment_a(sc)) goto START;
	  if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_PAIR_A:
	  if (op_pair_a(sc)) goto START;
	  if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_C_OBJECT_A:
	  if (op_c_object_a(sc)) goto START;
	  if (unknown_a_ex(sc, sc->last_function) == goto_EVAL) goto EVAL;
	  break;

	case OP_GOTO:
	  if (op_goto(sc)) goto START;
	  if (unknown_ex(sc, opt1_goto(sc->code)) == goto_EVAL) goto EVAL;
	  break;

	case OP_GOTO_A:
	  if (op_goto_a(sc)) goto START;
	  if (unknown_a_ex(sc, opt1_goto(sc->code)) == goto_EVAL) goto EVAL;
	  break;

	case OP_UNOPT:
	case HOP_UNOPT:
	  goto UNOPT;

	case OP_SYM:
	case HOP_SYM:
	  sc->value = lookup_checked(sc, sc->code);
	  goto START;

	case OP_CON:
	case HOP_CON:
	  sc->value = sc->code;
	  goto START;

	case OP_PAIR_PAIR:
	case HOP_PAIR_PAIR:
	  if (sc->stack_end >= sc->stack_resize_trigger)
	    check_for_cyclic_code(sc, sc->code);
	  push_stack(sc, OP_EVAL_ARGS, sc->nil, sc->code);
	  push_stack(sc, OP_EVAL_ARGS, sc->nil, car(sc->code));
	  sc->code = caar(sc->code);
	  goto EVAL;

	case OP_PAIR_SYM:
	case HOP_PAIR_SYM:
	  /* car is a non-syntax symbol, sc->code a list */
	  sc->value = find_global_symbol_checked(sc, car(sc->code));
	  goto EVAL_ARGS_TOP;

	case OP_PAIR_ANY:
	case HOP_PAIR_ANY:
	  sc->value = car(sc->code);
	  goto EVAL_ARGS_TOP;

	  /* sc->value is car=something applicable, sc->code = rest of expression
	   * sc->args is nil (set by the drop-through cases above -- perhaps clearer to bring that down?)
	   */
	EVAL_ARGS_TOP:
	case OP_EVAL_ARGS:
	  if (dont_eval_args(sc->value))
	    {
	      if (is_any_macro(sc->value))
		{
		  /* macro expansion */
		  sc->args = copy_list_with_arglist_error(sc, cdr(sc->code));
		  sc->code = sc->value;
		  goto APPLY;                      /* not UNSAFE_CLOSURE because it might be a bacro */
		}
	      /* (define progn begin) (progn (display "hi") (+ 1 23)) */
	      if (is_syntactic_pair(sc->code))
		sc->cur_op = optimize_op(sc->code);
	      else
		{
		  sc->cur_op = syntax_opcode(sc->value);
		  pair_set_syntax_op(sc->code, sc->cur_op);
		}
	      goto TOP_NO_POP;
	    }
	  sc->code = cdr(sc->code);

	  /* sc->value is the func
	   *   we don't have to delay lookup of the func because arg evaluation order is not specified, so
	   *     (let ((func +)) (func (let () (set! func -) 3) 2))
	   *   can return 5.
	   */
	  /* if (is_null(sc->code)) {sc->code = sc->value; goto APPLY;}
	   *   this is hit very rarely so it costs more than it saves
	   */

	  push_op_stack(sc, sc->value);
	  if (sc->op_stack_now >= sc->op_stack_end)
	    resize_op_stack(sc);

	  sc->args = sc->nil;
	  goto EVAL_ARGS;
	  /* moving eval_args up here (to avoid this goto) was slightly slower, probably by chance. */

	case OP_EVAL_ARGS5:
	  op_eval_args5(sc);
	  goto APPLY;

	case OP_EVAL_ARGS2:          /* sc->value is the last arg, [so if is_null(cdr(sc->code) and current is pair, push args2] */
	  op_eval_args2(sc);
	  goto APPLY;

	case OP_EVAL_ARGS3:          /* sc->value is the next-to-last arg, and we know the last arg is not a list (so values can't mess us up!) */
	  op_eval_args3(sc);
	  goto APPLY;

	case OP_EVAL_ARGS4: 	     /* sc->code is a pair, and either cdr(sc->code) is not null or car(sc->code) is a pair */
	  op_eval_args4(sc);
	  goto EVAL_ARGS_PAIR;

	case OP_EVAL_ARGS1:
	  op_eval_args1(sc);

	EVAL_ARGS:	          /* first time, value = op, args = nil, code is args */
	  if (is_pair(sc->code))  /* evaluate current arg -- must check for pair here, not sc->nil (improper list as args) */
	    {
	      s7_pointer car_code;
	      if ((sc->safety > NO_SAFETY) &&
		  (tree_is_cyclic(sc, sc->code)))
		eval_error(sc, "attempt to evaluate a circular list: ~A", 39, sc->code);

	    EVAL_ARGS_PAIR: /* pulling this out as a function slowed us down noticeably */
	      car_code = car(sc->code);
	      /* switch statement here is much slower */
	      if (is_pair(car_code))
		{
		  if (sc->stack_end >= sc->stack_resize_trigger)
		    check_for_cyclic_code(sc, sc->code);

		  /* all 3 of these push_stacks can result in stack overflow, see above 64065 */
		  if (is_null(cdr(sc->code)))
		    push_stack_no_code(sc, OP_EVAL_ARGS2, sc->args);
		  else
		    {
		      if (!is_pair(cdr(sc->code)))            /* (= 0 '(1 . 2) . 3) */
			improper_arglist_error(sc);

		      if ((is_null(cddr(sc->code))) &&
			  (!is_pair(cadr(sc->code))))
			push_stack(sc, OP_EVAL_ARGS3, sc->args, cadr(sc->code));
		      else push_stack(sc, OP_EVAL_ARGS4, sc->args, cdr(sc->code));
		    }
		  sc->code = car_code;
		  goto EVAL;
		}

	      /* car(sc->code) is not a pair */
	      /* fprintf(stderr, "%s[%d]: code: %s, car_code: %s\n", __func__, __LINE__, DISPLAY(sc->code), DISPLAY(car_code)); */
	      if (is_pair(cdr(sc->code)))
		{
		  sc->code = cdr(sc->code);
		  if (is_symbol(car_code))
		    sc->value = lookup_checked(sc, car_code);
		  else sc->value = T_Pos(car_code);
		  /* sc->value is the current arg's value, sc->code is pointing to the next */

		  /* cdr(sc->code) may not be a pair or nil here! (eq? #f . 1) -> sc->code is 1 */
		  if (is_null(cdr(sc->code)))
		    {
		      s7_pointer x, y, val;
		      /* we're at the last arg, sc->value is the previous one, not yet saved in the args list */
		      car_code = car(sc->code);
		      if (is_pair(car_code))
			{
			  if (sc->stack_end >= sc->stack_resize_trigger)
			    check_for_cyclic_code(sc, sc->code);
			  push_stack(sc, OP_EVAL_ARGS5, sc->args, sc->value);
			  sc->code = car_code;
			  goto EVAL;
			}

		      /* get the last arg */
		      if (is_symbol(car_code))
			val = lookup_checked(sc, car_code);
		      else val = car_code;
		      sc->temp4 = val;

		      /* get the current arg, which is not a list */
		      sc->code = pop_op_stack(sc);
		      new_cell(sc, x, T_PAIR);
		      new_cell_no_check(sc, y, T_PAIR);
		      set_car(x, sc->value);
		      set_cdr(x, sc->args);
		      set_car(y, val);
		      set_cdr(y, x);
		      sc->args = safe_reverse_in_place(sc, y);
		      /* drop into APPLY */
		    }
		  else
		    {
		      /* here we know sc->code is a pair, cdr(sc->code) is not null, sc->value is the previous arg's value */
		      s7_pointer x;
		      new_cell(sc, x, T_PAIR);
		      set_car(x, sc->value);
		      set_cdr(x, sc->args);
		      sc->args = x;
		      goto EVAL_ARGS_PAIR;
		    }
		}
	      else
		{
		  /* here we've reached the last arg (sc->code == nil), it is not a pair */
		  s7_pointer x, val;

		  if (!is_null(cdr(sc->code)))
		    improper_arglist_error(sc);

		  sc->code = pop_op_stack(sc);
		  if (is_symbol(car_code))
		    val = lookup_checked(sc, car_code); /* this has to precede the set_type below */
		  else val = car_code;
		  sc->temp4 = val;
		  new_cell(sc, x, T_PAIR);
		  set_car(x, val);
		  set_cdr(x, sc->args);

		  if (!is_null(sc->args))
		    sc->args = safe_reverse_in_place(sc, x);
		  else sc->args = x;
		  /* drop into APPLY */
		}
	    }
	  else                       /* got all args -- go to apply */
	    {
	      if (is_not_null(sc->code))
		improper_arglist_error(sc);
	      else
		{
		  sc->code = pop_op_stack(sc);
		  sc->args = safe_reverse_in_place(sc, sc->args);
		  /* we could omit the arg reversal in many cases, but lots of code assumes the args are in order;
		   *   adding a bit for this in the type field saves some time in s7test (many + and * tests), but costs
		   *   about the same time in other cases, so it's not a clear win.
		   */
		}
	    }

	  /* turning this into a call on an array of functions was not a complete disaster, but tauto.scm was ~1.5% slower.
	   *   the array-index overhead is the same as the current switch statement's, but there was also the boolean+jump overhead,
	   *   and the function-local overhead currently otherwise 0 (I assume because the compiler can simply plug it in here).
	   */
	APPLY:
	case OP_APPLY:
	  set_current_code(sc, history_cons(sc, sc->code, sc->args));
#if SHOW_EVAL_OPS
	  safe_print(fprintf(stderr, "  apply %s to %s\n", DISPLAY_80(sc->code), DISPLAY_80(sc->args)));
#endif
	  switch (type(sc->code))
	    {
	    case T_C_FUNCTION:          apply_c_function(sc);           goto START;
	    case T_C_ANY_ARGS_FUNCTION: apply_c_any_args_function(sc);  goto START;
	    case T_C_FUNCTION_STAR:     apply_c_function_star(sc);      goto START;
	    case T_C_OPT_ARGS_FUNCTION: apply_c_opt_args_function(sc);  goto START;
	    case T_C_RST_ARGS_FUNCTION: apply_c_rst_args_function(sc);  goto START;
	    case T_C_MACRO:  	        apply_c_macro(sc);	        goto EVAL;
	    case T_CONTINUATION:        apply_continuation(sc);         goto START;
	    case T_GOTO:	        call_with_exit(sc);	        goto START;
	    case T_C_OBJECT:	        apply_c_object(sc);	        goto START;
	    case T_INT_VECTOR:
	    case T_BYTE_VECTOR:
	    case T_FLOAT_VECTOR:
	    case T_VECTOR: 	        apply_vector(sc);	        goto START;
	    case T_STRING:	        apply_string(sc);	        goto START;
	    case T_HASH_TABLE:	        apply_hash_table(sc);           goto START;
	    case T_ITERATOR:	        apply_iterator(sc);	        goto START;
	    case T_LET:	                apply_let(sc);	                goto START;
	    case T_SYNTAX:	        apply_syntax(sc); 	        goto TOP_NO_POP;
	    case T_PAIR:	        if (apply_pair(sc)) goto START; goto APPLY;

	    case T_MACRO:
	      /* this is not from the reader, so treat expansions here as normal macros */
	      push_stack_op_let(sc, OP_EVAL_MACRO);
	      new_frame(sc, closure_let(sc->code), sc->envir);
	      goto APPLY_LAMBDA;

	    case T_BACRO:
	      push_stack_op_let(sc, OP_EVAL_MACRO);
	      new_frame(sc, sc->envir, sc->envir);       /* like let* -- we'll be adding macro args, so might as well sequester things here */
	      goto APPLY_LAMBDA;

	    case T_CLOSURE:
	      /* we can get safe_closures here, but can't easily determine whether we have the expected saved funclet -- see ~/old/safe-closure-s7.c */
	      check_stack_size(sc);
	      new_frame(sc, closure_let(sc->code), sc->envir);
	      goto APPLY_LAMBDA;

	    case T_MACRO_STAR:
	      push_stack_op_let(sc, OP_EVAL_MACRO);
	      new_frame(sc, closure_let(sc->code), sc->envir);
	      if (apply_lambda_star(sc) == goto_EVAL) goto EVAL;
	      goto BEGIN;

	    case T_BACRO_STAR:
	      push_stack_op_let(sc, OP_EVAL_MACRO);
	      new_frame(sc, sc->envir, sc->envir);
	      if (apply_lambda_star(sc) == goto_EVAL) goto EVAL;
	      goto BEGIN;

	    case T_CLOSURE_STAR:
	      check_stack_size(sc);
	      sc->envir = new_frame_in_env(sc, closure_let(sc->code));
	      if (apply_lambda_star(sc) == goto_EVAL) goto EVAL;
	      goto BEGIN;

	    default:
	      apply_error(sc, sc->code, sc->args);
	    }

	APPLY_LAMBDA:
	case OP_APPLY_LAMBDA:
	  apply_lambda(sc);
	  goto BEGIN;

	case OP_LAMBDA_STAR_DEFAULT:
	  /* sc->args is the current let slots position, sc->value is the default expression's value */
	  if (is_multiple_value(sc->value))
	    eval_error(sc, "lambda*: argument default value can't be ~S", 43, cons(sc, sc->values_symbol, sc->value));
	  slot_set_value(sc->args, sc->value);
	  sc->args = next_slot(sc->args);
	  if (lambda_star_default(sc) == goto_EVAL) goto EVAL;
	  pop_stack_no_op(sc);
	  sc->code = T_Pair(closure_body(sc->code));
	  goto BEGIN;

	case OP_MACROEXPAND_1:
	  sc->args = copy_list(sc, cdar(sc->code));
	  sc->code = sc->value;
	  goto MACROEXPAND;

	case OP_MACROEXPAND:
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	  /* mimic APPLY above, but don't push OP_EVAL_MACRO or OP_EXPANSION
	   *   (define-macro (mac a) `(+ ,a 1)) (macroexpand (mac 3)), sc->code: ((mac 3))
	   */
	  if ((!is_pair(sc->code)) ||
	      (!is_pair(car(sc->code))))
	    eval_error(sc, "macroexpand argument is not a macro call: ~A", 44, sc->code);
	  if (!is_null(cdr(sc->code)))
	    eval_error(sc, "macroexpand: too many arguments: ~A", 35, sc->code);

	  if ((is_pair(cdar(sc->code))) &&
	      (is_pair(cadar(sc->code))) &&
	      (!s7_is_proper_list(sc, cadar(sc->code))))
	    eval_error(sc, "macroexpand: improper arg list: ~A", 34, sc->code);

	  if (is_pair(caar(sc->code)))                            /* (macroexpand ((symbol->value 'mac) (+ 1 2))) */
	    {
	      push_stack_no_args(sc, OP_MACROEXPAND_1, sc->code);
	      sc->code = caar(sc->code);
	      goto EVAL;
	    }

	  sc->args = copy_list(sc, cdar(sc->code));               /* apply_lambda reuses args as slots, and these have not been copied yet */
	  if (!is_symbol(caar(sc->code)))
	    eval_error(sc, "macroexpand argument is not a macro call: ~A", 44, sc->code);
	  sc->code = lookup_checked(sc, caar(sc->code));

	MACROEXPAND:
	  switch (type(sc->code))
	    {
	    case T_MACRO:
	      new_frame(sc, closure_let(sc->code), sc->envir);
	      goto APPLY_LAMBDA;

	    case T_BACRO:
	      new_frame(sc, sc->envir, sc->envir);
	      goto APPLY_LAMBDA;

	    case T_MACRO_STAR:
	      new_frame(sc, closure_let(sc->code), sc->envir);
	      if (apply_lambda_star(sc) == goto_EVAL) goto EVAL;
	      goto BEGIN;

	    case T_BACRO_STAR:
	      new_frame(sc, sc->envir, sc->envir);
	      if (apply_lambda_star(sc) == goto_EVAL) goto EVAL;
	      goto BEGIN;

	    case T_C_MACRO: /* moving this out of eval makes callgrind behave foolishly */
	      {
		s7_int len;
		len = safe_list_length(sc->args);
		if (len < c_macro_required_args(sc->code))
		  s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, not_enough_arguments_string, sc->code, sc->args));
		if (c_macro_all_args(sc->code) < len)
		  s7_error(sc, sc->wrong_number_of_args_symbol, set_elist_3(sc, too_many_arguments_string, sc->code, sc->args));
		sc->value = c_macro_call(sc->code)(sc, sc->args);
		goto START;
	      }
	    }
	  eval_error(sc, "macroexpand argument is not a macro call: ~A", 44, sc->args);

	case OP_GC_PROTECT:
	  goto START;

	  /* -------------------- sort! (heapsort, done directly so that call/cc in the sort function will work correctly) -------------------- */
	HEAPSORT:
	  if (op_heapsort(sc)) goto START;
	  if (sc->value != sc->F) goto APPLY;

	case OP_SORT1:
	  op_sort1(sc);
	  goto APPLY;

	case OP_SORT2:
	  if (op_sort2(sc)) goto START;
	  goto HEAPSORT;

	case OP_SORT:
	  if (!op_sort(sc)) goto HEAPSORT;

	case OP_SORT3:
	  if (op_sort3(sc)) goto START;
	  goto HEAPSORT;

	case OP_SORT_PAIR_END:       /* sc->value is the sort vector which needs to be copied into the original list */
	  sc->value = vector_into_list(sc->value, car(sc->args));
	  free_cell(sc, sc->args);
	  goto START;

	case OP_SORT_VECTOR_END:     /* sc->value is the sort (s7_pointer) vector which needs to be copied into the original (double/int) vector */
	  sc->value = vector_into_fi_vector(sc->value, car(sc->args));
	  free_cell(sc, sc->args);
	  goto START;

	case OP_SORT_STRING_END:
	  sc->value = vector_into_string(sc->value, car(sc->args));
	  free_cell(sc, sc->args);
	  goto START;


	case OP_MAP_GATHER_1:
	  if (sc->value != sc->no_value)
	    {
	      if (is_multiple_value(sc->value))
		counter_set_result(sc->args, revappend(sc, multiple_value(sc->value), counter_result(sc->args)));
	      else counter_set_result(sc->args, cons(sc, sc->value, counter_result(sc->args)));
	    }

	case OP_MAP_1:
	  if (op_map_1(sc)) goto START;
	  goto BEGIN;

	case OP_MAP_GATHER:
	  if (sc->value != sc->no_value)                   /* (map (lambda (x) (values)) (list 1)) */
	    {
	      if (is_multiple_value(sc->value))            /* (map (lambda (x) (if (odd? x) (values x (* x 20)) (values))) (list 1 2 3 4)) */
		counter_set_result(sc->args, revappend(sc, multiple_value(sc->value), counter_result(sc->args)));
	      /* not append_in_place here because sc->value has the multiple-values bit set */
	      else counter_set_result(sc->args, cons(sc, sc->value, counter_result(sc->args)));
	    }

	case OP_MAP:
	  if (op_map(sc)) goto START;
	  goto APPLY;

	case OP_MAP_GATHER_2:
	case OP_MAP_GATHER_3:
	  if (sc->value != sc->no_value)
	    {
	      if (is_multiple_value(sc->value))
		counter_set_result(sc->args, revappend(sc, multiple_value(sc->value), counter_result(sc->args)));
	      else counter_set_result(sc->args, cons(sc, sc->value, counter_result(sc->args)));
	    }
	case OP_MAP_2:
	  if (op_map_2(sc)) goto START;
	  goto EVAL;


	case OP_FOR_EACH:
	  if (op_for_each(sc)) goto START;
	  goto APPLY;

	case OP_FOR_EACH_1:
	  if (op_for_each_1(sc)) goto START;
	  goto BEGIN;

	case OP_FOR_EACH_3:
	case OP_FOR_EACH_2:
	  if (op_for_each_2(sc)) goto START;
	  goto EVAL;


	case OP_MEMBER_IF:
	case OP_MEMBER_IF1:
	  if (member_if(sc)) goto START;
	  goto APPLY;

	case OP_ASSOC_IF:
	case OP_ASSOC_IF1:
	  if (assoc_if(sc)) goto START;
	  goto APPLY;


	  /* -------------------------------- do -------------------------------- */
	case OP_DO_NO_VARS:
	DO_NO_VARS: /* check_do */
	  if (op_do_no_vars(sc))
	    goto DO_END_CLAUSES;
	  goto BEGIN;

	case OP_DO_NO_VARS_NO_OPT:
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	  new_frame(sc, sc->envir, sc->envir);

	case OP_DO_NO_VARS_NO_OPT_1:
	  sc->value = fx_call(sc, cadr(sc->code));
	  if (is_true(sc, sc->value)) 
	    {
	      sc->code = cdadr(sc->code);
	      goto DO_END_CLAUSES;
	    }
	  push_stack_no_args(sc, OP_DO_NO_VARS_NO_OPT_1, sc->code);
	  sc->code = T_Pair(cddr(sc->code));
	  goto BEGIN;

	case OP_SAFE_DOTIMES:
	SAFE_DOTIMES: /* check_do */
	  {
	    s7_pointer form;
	    int32_t choice;

	    form = sc->code;
	    set_current_code(sc, form);
	    sc->code = cdr(sc->code);
	    choice = safe_dotimes_ex(sc);

	    if (choice == goto_SAFE_DO_END_CLAUSES) goto SAFE_DO_END_CLAUSES;
	    if (choice == goto_BEGIN) goto BEGIN;
	    if (choice == goto_EVAL) goto EVAL;
	    if (choice == goto_TOP_NO_POP) goto TOP_NO_POP;
 	    pair_set_syntax_op(form, OP_SIMPLE_DO);
	    sc->code = form;
	    goto SIMPLE_DO;
	  }

#define do_stepper_end(sc)					    \
  do {s7_pointer arg; arg = slot_value(sc->args); numerator(arg)++; \
      if (numerator(arg) == denominator(arg)) {sc->value = sc->T; sc->code = cdadr(sc->code); goto DO_END_CLAUSES;}} while (0)

	case OP_SAFE_DOTIMES_STEP_P:
	  do_stepper_end(sc);
	  push_stack(sc, OP_SAFE_DOTIMES_STEP_P, sc->args, sc->code);
	  sc->code = opt2_pair(sc->code);
	  goto EVAL;

	case OP_SAFE_DOTIMES_STEP_O:
	  do_stepper_end(sc);
	  push_stack(sc, OP_SAFE_DOTIMES_STEP_O, sc->args, sc->code);
	  sc->code = T_Pair(opt2_pair(sc->code));
	  goto EVAL;

	case OP_SAFE_DOTIMES_STEP:
	  do_stepper_end(sc);
	  push_stack(sc, OP_SAFE_DOTIMES_STEP, sc->args, sc->code);
	  sc->code = opt2_pair(sc->code); /* here we know the body has more than one form */
	  push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_SAFE_DO:
	SAFE_DO: /* check_do */
	  {
	    int32_t choice;
	    set_current_code(sc, sc->code);
	    choice = safe_do_ex(sc);
	    if (choice == goto_SAFE_DO_END_CLAUSES) goto SAFE_DO_END_CLAUSES;
	    if (choice == goto_EVAL) goto EVAL;
	    if (choice == goto_DO_UNCHECKED) goto DO_UNCHECKED;
	    goto BEGIN;
	  }

	case OP_SAFE_DO_STEP:
	  if (op_safe_do_step(sc))
	    goto BEGIN;
	  goto DO_END_CLAUSES;

	case OP_SIMPLE_DO:
	SIMPLE_DO: /* check_do safe_dotimes */
	  {
	    /* body might not be safe in this case, but the step and end exprs are easy
	     * simple_do: set up local env, check end (c_c?), goto simple_do_ex
	     *   if latter gets s7_optimize, run locally, else goto simple_do_step.
	     */
	    s7_pointer init, end, code, body;
	    set_current_code(sc, sc->code);
	    code = cdr(sc->code);
	    sc->envir = new_frame_in_env(sc, sc->envir);
	    init = cadaar(code);
	    if (is_symbol(init))
	      sc->value = lookup_checked(sc, init);
	    else
	      {
		if (is_pair(init))
		  sc->value = d_call(sc, init);
		else sc->value = init;
	      }
	    dox_set_slot1(sc->envir, make_slot_1(sc, sc->envir, caaar(code), sc->value));
	    end = caddr(caadr(code));
	    if (is_symbol(end))
	      dox_set_slot2(sc->envir, symbol_to_slot(sc, end));
	    else dox_set_slot2(sc->envir, make_slot_1(sc, sc->envir, sc->dox_slot_symbol, end));

	    set_car(sc->t2_1, slot_value(dox_slot1(sc->envir)));
	    set_car(sc->t2_2, slot_value(dox_slot2(sc->envir)));
	    sc->value = c_call(caadr(code))(sc, sc->t2_1);
	    if (is_true(sc, sc->value)) 
	      {
		sc->code = cdadr(code); 
		goto DO_END_CLAUSES;
	      }
	    body = cddr(code);
	    if ((is_null(cdr(body))) &&      /* one expr in body */
		(is_pair(car(body))) &&      /*   and it is a pair */
		(is_symbol(cadr(caddr(caar(code))))) && /* caar=(i 0 (+ i 1)), caddr=(+ i 1), so this is apparently checking that the stepf is reasonable? */
		(is_t_integer(caddr(caddr(caar(code))))))
	      {
		int32_t choice;
		choice = simple_do_ex(sc, sc->code);
		if (choice == goto_START) goto START;
		if (choice == goto_BEGIN) goto BEGIN;
		if (choice == goto_DO_END_CLAUSES) goto DO_END_CLAUSES;
	      }
	    push_stack(sc, OP_SIMPLE_DO_STEP, sc->args, code);
	    sc->code = body;
	    goto BEGIN;
	  }

	case OP_SIMPLE_DO_STEP:
	  if (op_simple_do_step(sc))
	    goto BEGIN;
	  goto DO_END_CLAUSES;

	case OP_DOTIMES_P:
	DOTIMES_P: /* check_do */
	  {
	    int32_t choice;
	    set_current_code(sc, sc->code);
	    choice = dotimes_p_ex(sc);
	    if (choice == goto_DO_END_CLAUSES) goto DO_END_CLAUSES;
	    if (choice == goto_DO_UNCHECKED) goto DO_UNCHECKED;
	    goto EVAL;
	  }

	case OP_DOTIMES_STEP_P:
	  if (op_dotimes_step_p(sc))
	    goto EVAL;
	  goto DO_END_CLAUSES;

	case OP_DOX:
	DOX: /* check_do */
	  {
	    int32_t choice;
	    s7_pointer form;
	    form = sc->code;
	    set_current_code(sc, sc->code);
	    sc->code = cdr(sc->code);

	    choice = dox_ex(sc);
	    if (choice == goto_DO_END_CLAUSES) goto DO_END_CLAUSES;
	    if (choice == goto_SAFE_DO_END_CLAUSES) goto SAFE_DO_END_CLAUSES;
	    if (choice == goto_START) goto START;
	    if (choice == goto_BEGIN) goto BEGIN;
	    if (choice == goto_TOP_NO_POP) goto TOP_NO_POP;
	    if (choice == fall_through)
	      pair_set_syntax_op(form, OP_DOX_INIT);

	    push_stack_no_args(sc, OP_DOX_STEP, sc->code);
	    sc->code = T_Pair(cddr(sc->code));
	    goto BEGIN;
	  }

	case OP_DOX_INIT:
	  {
	    s7_pointer frame, vars, test;
	    set_current_code(sc, sc->code);
	    sc->code = cdr(sc->code);
	    new_frame(sc, sc->envir, frame);
	    sc->temp10 = frame;
	    for (vars = car(sc->code); is_pair(vars); vars = cdr(vars))
	      {
		add_slot(frame, caar(vars), fx_call(sc, cdar(vars)));
		if (is_pair(cddar(vars)))
		  slot_set_expression(let_slots(frame), cddar(vars));
		else slot_just_set_expression(let_slots(frame), sc->nil);
	      }
	    sc->envir = frame;
	    sc->temp10 = sc->nil;
	    test = cadr(sc->code);
	    if (is_true(sc, sc->value = fx_call(sc, test)))
	      {
		sc->code = cdr(test);
		goto DO_END_CLAUSES;
	      }
	    push_stack_no_args(sc, OP_DOX_STEP, sc->code);
	    sc->code = T_Pair(cddr(sc->code));
	    goto BEGIN;
	  }

	case OP_DOX_STEP:
	  {
	    s7_pointer slot;
	    for (slot = let_slots(sc->envir); tis_slot(slot); slot = next_slot(slot))
	      if (slot_has_expression(slot))
		slot_set_value(slot, fx_call(sc, slot_expression(slot)));
	    sc->value = fx_call(sc, cadr(sc->code));
	    if (is_true(sc, sc->value)) 
	      {
		sc->code = cdadr(sc->code);
		goto DO_END_CLAUSES;
	      }
	    push_stack_no_args(sc, OP_DOX_STEP, sc->code);
	    sc->code = T_Pair(cddr(sc->code));
	    goto BEGIN;
	  }

	case OP_DOX_STEP_P:
	  {
	    s7_pointer slot;
	    for (slot = let_slots(sc->envir); tis_slot(slot); slot = next_slot(slot))
	      if (slot_has_expression(slot))
		slot_set_value(slot, fx_call(sc, slot_expression(slot)));
	    sc->value = fx_call(sc, cadr(sc->code));
	    if (is_true(sc, sc->value)) 
	      {
		sc->code = cdadr(sc->code);
		goto DO_END_CLAUSES;
	      }
	    push_stack_no_args(sc, OP_DOX_STEP_P, sc->code);
	    sc->code = caddr(sc->code);
	    goto EVAL;
	  }

	case OP_DOX_NO_BODY:
	DOX_NO_BODY:
	  op_dox_no_body(sc);
	  goto START;

	  /* we could use slot_pending_value, slot_expression, not this extra list, but the list seems simpler. */
        #define do_var_slot(P) opt1_slot(P)
        #define do_var_new_value(P) cdr(P)
        #define do_var_set_new_value(P, Val) set_cdar(P, Val)
        #define do_var_step_expr(P) car(P)

	DO_STEP:
	case OP_DO_STEP:
	  /* increment all vars, return to endtest
	   *   these are also updated in parallel at the end, so we gather all the incremented values first
	   *
	   * here we know car(sc->args) is not null, args is the list of steppable vars,
	   *   any unstepped vars in the do var section are not in this list, so
	   *   (do ((i 0 (+ i 1)) (j 2)) ...) arrives here with sc->args: '(((+ i 1) . 0))
	   */
	  push_stack(sc, OP_DO_END, sc->args, sc->code);
	  sc->args = car(sc->args);                /* the var data lists */
	  sc->code = sc->args;                     /* save the top of the list */

	DO_STEP1:
	  /* on each iteration, each arg incr expr is evaluated and the value placed in caddr while we cdr down args */
	  if (is_null(sc->args))
	    {
	      s7_pointer x;
	      for (x = sc->code; is_not_null(x); x = cdr(x))
		slot_set_value(do_var_slot(car(x)), do_var_new_value(car(x)));
	      pop_stack_no_op(sc);
	      goto DO_END;
	    }
	  push_stack(sc, OP_DO_STEP2, sc->args, sc->code);

	  /* here sc->args is a list like (((i . 0) (+ i 1) 0) ...) so sc->code becomes (+ i 1) in this case */
	  sc->code = do_var_step_expr(car(sc->args));
	  goto EVAL;

	case OP_DO_STEP2:
	  if (is_multiple_value(sc->value))
	    eval_error(sc, "do: variable step value can't be ~S", 35, cons(sc, sc->values_symbol, sc->value));
	  do_var_set_new_value(sc->args, sc->value);  /* save current value */
	  sc->args = cdr(sc->args);                   /* go to next step var */
	  goto DO_STEP1;

	case OP_DO:
	  set_current_code(sc, sc->code);
	  if (is_null(check_do(sc)))
	    {
	      opcode_t op;
	      op = optimize_op(sc->code);
 	      if (op == OP_DOX)	         goto DOX;
 	      if (op == OP_SAFE_DOTIMES) goto SAFE_DOTIMES;
 	      if (op == OP_DOTIMES_P)    goto DOTIMES_P;
 	      if (op == OP_SAFE_DO)	 goto SAFE_DO;
 	      if (op == OP_DO_NO_VARS)   goto DO_NO_VARS;
	      if (op == OP_DOX_NO_BODY)  goto DOX_NO_BODY;
	      goto SIMPLE_DO;
	    }

	case OP_DO_UNCHECKED:
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	DO_UNCHECKED: /* fall through above, safe_do_ex, dotimes_p_ex */
	  if (is_null(car(sc->code)))                           /* (do () ...) -- (let ((i 0)) (do () ((= i 1)) (set! i 1))) */
	    {
	      sc->envir = new_frame_in_env(sc, sc->envir);
	      sc->args = cons_unchecked(sc, sc->nil, cadr(sc->code));
	      sc->code = cddr(sc->code);
	      goto DO_END;
	    }
	  /* eval each init value, then set up the new frame (like let, not let*) */
	  sc->args = sc->nil;                             /* the evaluated var-data */
	  sc->value = sc->code;                           /* protect it */
	  sc->code = car(sc->code);                       /* the vars */

	case OP_DO_INIT:
	  if (do_init_ex(sc) == goto_EVAL) goto EVAL;

	DO_END:
	case OP_DO_END:
	  /* here vars have been init'd or incr'd, args = (list var-data end-expr return-expr-if-any)
	   *   (do ((i 0 (+ i 1))) ((= i 3) 10)) args: (vars (= i 3) 10)
	   */
	  if (is_not_null(cdr(sc->args)))
	    {
	      push_stack(sc, OP_DO_END1, sc->args, sc->code);
	      sc->code = cadr(sc->args);               /* evaluate the end expr */
	      goto EVAL;
	    }
	DO_END2:
	  if (is_pair(sc->code))
	    {
	      if (is_null(car(sc->args)))
		push_stack(sc, OP_DO_END, sc->args, sc->code);
	      else push_stack(sc, OP_DO_STEP, sc->args, sc->code);
	      goto BEGIN;
	    }
	  if (is_null(car(sc->args))) /* no steppers */
	    goto DO_END;
	  goto DO_STEP;

	case OP_DO_END1:
	  if (is_true(sc, sc->value))             /* sc->value is the result of end-test evaluation */
	    {
	      /* we're done -- deal with result exprs, if there isn't an end test, there also isn't a result (they're in the same list)
	       * multiple-value end-test result is ok
	       */
	      sc->code = T_Lst(cddr(sc->args));   /* result expr (a list -- implicit begin) */
	      free_cell(sc, sc->args);
	      sc->args = sc->nil;
	      if (is_null(sc->code))
		{
		  if (is_multiple_value(sc->value))  /* (define (f) (+ 1 (do ((i 2 (+ i 1))) ((values i (+ i 1)))))) -> 6 */
		    sc->value = splice_in_values(sc, multiple_value(sc->value));
		  /* similarly, if the result is a multiple value:
		   * (define (f) (+ 1 (do ((i 2 (+ i 1))) ((= i 3) (values i (+ i 1)))))) -> 8
		   */
		  goto START;
		}
	      /* might be => here as in cond and case */
	      if (is_null(cdr(sc->code)))
		{
		  sc->code = car(sc->code);
		  goto EVAL;
		}
	      if ((car(sc->code) == sc->feed_to_symbol) &&
		  (s7_symbol_value(sc, sc->feed_to_symbol) == sc->undefined))
		goto FEED_TO;
	      push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
	      sc->code = car(sc->code);
	      goto EVAL;
	    }
	  goto DO_END2;

	SAFE_DO_END_CLAUSES:
	  if (is_null(sc->code)) /* I don't think multiple values (as test result) can happen here -- all safe do loops involve counters by 1 to some integer end */
	    goto START;
	  goto DO_END_CODE;

	DO_END_CLAUSES:
	  if (is_null(sc->code))
	    {
	      if (is_multiple_value(sc->value))
		sc->value = splice_in_values(sc, multiple_value(sc->value));
	      goto START;
	    }

	DO_END_CODE:
	  if (is_pair(cdr(sc->code)))
	    {
	      if ((car(sc->code) == sc->feed_to_symbol) &&
		  (s7_symbol_value(sc, sc->feed_to_symbol) == sc->undefined))
		goto FEED_TO;
	      push_stack_no_args(sc, sc->begin_op, cdr(sc->code));
	      sc->code = car(sc->code);
	      goto EVAL;
	    }
	  sc->code = car(sc->code);
	  if (is_pair(sc->code))
	    goto EVAL;
	  if (is_symbol(sc->code))
	    sc->value = lookup_checked(sc, sc->code);
	  else sc->value = sc->code;
	  goto START;

	  /* -------------------------------- begin -------------------------------- */

	case OP_BEGIN_UNCHECKED:
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	  goto BEGIN;

	case OP_BEGIN:
	  {
	    s7_pointer form;
	    form = sc->code;
	    set_current_code(sc, sc->code);
	    sc->code = cdr(sc->code);
	    if (!s7_is_proper_list(sc, sc->code))    /* proper list includes () */
	      eval_error(sc, "unexpected dot? ~A", 18, form);
	    if (is_null(sc->code))                   /* (begin) -> () */
	      {
		sc->value = sc->nil;
		goto START;
	      }
	    pair_set_syntax_op(form, OP_BEGIN_UNCHECKED);
	  }

	case OP_BEGIN0:
	  if ((sc->begin_hook) && (call_begin_hook(sc))) return(sc->F);
	case OP_BEGIN1:
	  goto BEGIN;

	case OP_EVAL:
	  goto EVAL;

	case OP_QUOTE:
	  /* I think a quoted list in another list can be applied to a function, come here and
	   *   be changed to unchecked, set-cdr! or something clobbers the argument so we get
	   *   here on the next time around with the equivalent of (quote . 0) if unchecked
	   * so set-cdr! of constant -- if marked immutable, we could catch this case and clear.
	   */
	  check_quote(sc, sc->code);
	  sc->value = cadr(sc->code);
	  goto START;

	case OP_DEFINE_FUNCHECKED:
	  define_funchecked(sc);
	  goto START;

	case OP_DEFINE_CONSTANT1:
	  if (is_pair(sc->code)) sc->code = car(sc->code); /* (define-constant (ex3 a)...) */
	  if (is_symbol(sc->code))
	    {
	      s7_pointer slot;
	      slot = symbol_to_slot(sc, sc->code);
	      set_possibly_constant(sc->code);
	      set_immutable(slot);
	      if (is_any_closure(slot_value(slot)))
		set_immutable(slot_value(slot)); /* for the optimizer mainly */
	    }
	  goto START;

	case OP_DEFINE_CONSTANT:
	  if (op_define_constant(sc)) goto START;

	case OP_DEFINE_STAR:
	case OP_DEFINE:
	  check_define(sc);

	case OP_DEFINE_CONSTANT_UNCHECKED:
	case OP_DEFINE_STAR_UNCHECKED:
	case OP_DEFINE_UNCHECKED:
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	  if (define_unchecked_ex(sc)) goto TOP_NO_POP;

	case OP_DEFINE1:
	  if (define1_ex(sc) == goto_APPLY) goto APPLY;

	case OP_DEFINE_WITH_SETTER:
	  define2_ex(sc);
	  goto START;

	case OP_EVAL_STRING:
	  op_eval_string(sc);
	  goto EVAL;


	  /* -------------------------------- set! -------------------------------- */
	case OP_SET_PAIR_P:
	  op_set_pair_p(sc);
	  goto EVAL;

	case OP_SET_PAIR_A:
	  op_set_pair_a(sc);
	  goto START;

	case OP_SET_LET_S:        /* (set! (*s7* 'print-length) i) */
	  sc->code = cdr(sc->code);
	  if (set_pair_p_3(sc, symbol_to_slot(sc, caar(sc->code)), cadr(cadar(sc->code)), lookup(sc, cadr(sc->code))))
	    goto APPLY;
	  goto START;

	case OP_SET_LET_FX:   /* (set! (hook 'result) 123) or (set! (H 'c) 32) */
	  sc->code = cdr(sc->code);
	  if (set_pair_p_3(sc, symbol_to_slot(sc, caar(sc->code)), cadr(cadar(sc->code)), fx_call(sc, cdr(sc->code))))
	    goto APPLY;
	  goto START;

	case OP_SET_PAIR_ZA:     /* unknown setter pair, but value is easy */
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, cdr(sc->code));
	  /* fall through */

	case OP_SET_PAIR_P_1:
	  if (op_set_pair_p_1(sc)) goto APPLY;
	  goto START;

	case OP_SET_DILAMBDA_P:
	  op_set_dilambda_p(sc);
	  goto EVAL;

	case OP_SET_DILAMBDA:  /* ([set!] (dilambda-setter g) s) */
	  op_set_dilambda(sc);
	  /* fall through */

	case OP_SET_DILAMBDA_P_1:
	  {
	    s7_pointer obj, func, arg;
	    arg = cadar(sc->code);
	    if (is_symbol(arg))
	      arg = lookup_checked(sc, arg);
	    else
	      {
		if (is_pair(arg))
		  arg = cadr(arg); /* can only be (quote ...) in this case */
	      }
	    obj = symbol_to_slot(sc, caar(sc->code));
	    func = slot_value(obj);
	    if ((is_closure(func)) &&
		(is_safe_closure(closure_setter(func))))
	      {
		s7_pointer setter;
		setter = closure_setter(func);
		if (is_pair(closure_args(setter)))
		  {
		    sc->envir = old_frame_with_two_slots(sc, closure_let(setter), arg, sc->value);
		    sc->code = T_Pair(closure_body(setter));
		    goto BEGIN;
		  }
	      }
	    if (set_pair_p_3(sc, obj, arg, sc->value))
	      goto APPLY;
	  }
	  goto START;

	case OP_SET_PAIR:
	  if (op_set_pair(sc)) goto APPLY;
	  goto START;

	  /* this is (set! (getter) val) where getter is a global c_function (a built-in pws) and val is not a pair */
	case OP_SET_PWS:        /* (set! (mus-clipping) #f) */
	  sc->code = cdr(sc->code);
	  set_pws_ex(sc);
	  goto START;

	case OP_INCREMENT_1:
	  increment_1_ex(sc);
	  goto START;

	case OP_DECREMENT_1:
	  decrement_1_ex(sc);
	  goto START;

        #define SET_CASE(Op, Code)					\
	  case Op:							\
	    {								\
	      s7_pointer lx;						\
	      sc->code = cdr(sc->code);					\
	      lx = symbol_to_slot(sc, car(sc->code));			\
	      Code;							\
	      sc->value = slot_value(lx);				\
	      goto START;						\
	    }

	    SET_CASE(OP_SET_SYMBOL_C, slot_set_value(lx, opt2_con(sc->code)))

	    SET_CASE(OP_SET_SYMBOL_A, slot_set_value(lx, fx_call(sc, cdr(sc->code))))

	    SET_CASE(OP_SET_SYMBOL_S, slot_set_value(lx, lookup(sc, cadr(sc->code))))

	    SET_CASE(OP_SET_CONS, slot_set_value(lx, cons(sc, lookup(sc, opt2_sym(sc->code)), slot_value(lx))))  /* ([set!] bindings (cons v bindings)) */

	    SET_CASE(OP_SET_SYMBOL_opDq, slot_set_value(lx, c_call(cadr(sc->code))(sc, opt2_pair(sc->code))))

	    /* here we know the symbols do not have setters, at least at optimization time */
	    SET_CASE(OP_SET_SYMBOL_opSq,
		     do {						\
		       set_car(sc->t1_1, lookup(sc, opt2_sym(sc->code))); \
		       slot_set_value(lx, c_call(cadr(sc->code))(sc, sc->t1_1)); \
		     } while (0))

	    SET_CASE(OP_SET_SYMBOL_opSSq,
		     do {						\
		       set_car(sc->t2_1, lookup(sc, car(opt2_pair(sc->code)))); \
		       set_car(sc->t2_2, lookup(sc, cadr(opt2_pair(sc->code)))); \
		       slot_set_value(lx, c_call(cadr(sc->code))(sc, sc->t2_1)); \
		     } while (0))

	    SET_CASE(OP_INCREMENT_SS,                                       /* ([set!] x (+ x i)) */
		     do {						\
		       set_car(sc->t2_1, slot_value(lx));		\
		       set_car(sc->t2_2, lookup(sc, cadr(opt2_pair(sc->code)))); \
		       slot_set_value(lx, c_call(cadr(sc->code))(sc, sc->t2_1)); \
		     } while (0))

	    SET_CASE(OP_INCREMENT_SSS,                                      /* ([set!] x (+ x y z)) -- nearly always involves reals */
		     do {						\
		       s7_pointer x1; s7_pointer x2; s7_pointer x3;	\
		       x1 = slot_value(lx);				\
		       x2 = lookup(sc, opt1_sym(opt2_pair(sc->code))); \
		       x3 = lookup(sc, opt2_sym(opt2_pair(sc->code))); \
		       if ((is_t_real(x1)) && (is_t_real(x2)) && (is_t_real(x3))) \
			 slot_set_value(lx, make_real(sc, real(x1) + real(x2) + real(x3))); \
		       else {						\
		         set_car(sc->t3_1, x1); set_car(sc->t3_2, x2); set_car(sc->t3_3, x3); \
			 slot_set_value(lx, global_add(sc, sc->t3_1));	\
		       }						\
		     } while (0))

	    SET_CASE(OP_INCREMENT_SA,
		     do {						\
		       s7_pointer arg;					\
		       arg = opt2_pair(sc->code);			\
		       set_car(sc->t2_2, fx_call(sc, arg));		\
		       set_car(sc->t2_1, slot_value(lx));		\
		       slot_set_value(lx, c_call(cadr(sc->code))(sc, sc->t2_1)); \
		     } while (0))

	    SET_CASE(OP_INCREMENT_SAA,                                      /* (set! sum (+ sum (expt k i) (expt (- k) i))) -- oops */
		     do {					\
		       s7_pointer arg;					\
		       arg = opt2_pair(sc->code); /* cddr(value) */		\
		       set_car(sc->a3_3, fx_call(sc, cdr(arg)));	\
		       set_car(sc->a3_2, fx_call(sc, arg));		\
		       set_car(sc->a3_1, slot_value(lx));		\
		       slot_set_value(lx, c_call(cadr(sc->code))(sc, sc->a3_1)); \
		     } while (0))

	case OP_SET_SAFE:
	  op_set_safe(sc);
	  goto START;

	case OP_SET_SYMBOL_P:       /* ([set!] f (lambda () 1)) */
	  op_set_symbol_p(sc);
	  goto EVAL;

	case OP_INCREMENT_SP:
	  op_increment_sp(sc);
	  goto EVAL;

	case OP_INCREMENT_SP_1:
	  op_increment_sp_1(sc);
	  goto START;

	case OP_INCREMENT_SP_MV:
	  op_increment_sp_mv(sc);
	  goto START;

	case OP_SET2:
	  if (op_set2(sc)) goto EVAL;

	case OP_SET:                                                              /* entry for set! */
	  check_set(sc);

	case OP_SET_UNCHECKED:
	  set_current_code(sc, sc->code);
	  if (is_pair(cadr(sc->code)))                                            /* has setter */
	    {
	      int32_t choice;
	      sc->code = cdr(sc->code);
	      choice = set_pair_ex(sc);
	      if (choice == goto_TOP_NO_POP) goto TOP_NO_POP;
	      if (choice == goto_START) goto START;
	      if (choice == goto_APPLY) goto APPLY;
	      goto EVAL_ARGS;
	    }

	case OP_SET_NORMAL:
	  if (op_set_normal(sc)) goto EVAL;

	case OP_SET1:
	  if (op_set1(sc)) goto START;
	  goto APPLY;

	case OP_SET_WITH_SETTER:
	  if (is_immutable(sc->code))
	    immutable_object_error(sc, set_elist_3(sc, immutable_error_string, sc->set_symbol, sc->code));
	  slot_set_value(sc->code, sc->value);
	  goto START;

	case OP_SET_WITH_LET_1:
	  if (op_set_with_let_1(sc)) goto TOP_NO_POP;
	  goto SET_WITH_LET;

	case OP_SET_WITH_LET_2:
	  if (op_set_with_let_2(sc)) goto START;

	SET_WITH_LET:
	  activate_let(sc, sc->value);  /* this activates sc->value, so the set! will happen in that environment */
	  if (is_pair(car(sc->code)))
	    {
	      int32_t choice;
	      choice = set_pair_ex(sc);
	      if (choice == goto_TOP_NO_POP) goto TOP_NO_POP;
	      if (choice == goto_START) goto START;
	      if (choice == goto_APPLY) goto APPLY;
	      goto EVAL_ARGS;
	    }
	  s7_error(sc, sc->error_symbol, set_elist_2(sc, wrap_string(sc, "can't set ~S", 12), sc->args));


	  /* -------------------------------- if -------------------------------- */
	case OP_IF:
	  set_current_code(sc, sc->code);
	  check_if(sc);
	  push_stack_no_args(sc, OP_IF1, cdr(sc->code));
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_IF_UNCHECKED:
	  set_current_code(sc, sc->code);
	  push_stack_no_args(sc, OP_IF1, cddr(sc->code));
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_IF1:
	  if (is_true(sc, sc->value))
	    sc->code = car(sc->code);
	  else sc->code = unchecked_car(cdr(sc->code));   /* even pre-optimization, (if #f #f) ==> #<unspecified> because unique_car(sc->nil) = sc->unspecified */
	  if (is_pair(sc->code))
	    goto EVAL;
	  if (is_symbol(sc->code))
	    sc->value = lookup_checked(sc, sc->code);
	  else sc->value = sc->code;
	  goto START;

        #define IF_CASE(Op, Code, Not_Code)						\
	  case Op ## _P:   sc->code = cdr(sc->code); Code {sc->code = cadr(sc->code); goto EVAL;} else {sc->value = sc->unspecified; goto START;} \
	  case Op ## _R:   sc->code = cdr(sc->code); Code {sc->value = sc->unspecified; goto START;} else {sc->code = cadr(sc->code); goto EVAL;} \
  	  case Op ## _P_P: sc->code = cdr(sc->code); Code {sc->code = cadr(sc->code); goto EVAL;} else {sc->code = caddr(sc->code); goto EVAL;} \
	  case Op ## _N:   sc->code = cdr(sc->code); Not_Code {sc->code = cadr(sc->code); goto EVAL;} else {sc->value = sc->unspecified; goto START;} \
  	  case Op ## _N_N: sc->code = cdr(sc->code); Not_Code {sc->code = cadr(sc->code); goto EVAL;} else {sc->code = caddr(sc->code); goto EVAL;}

	  IF_CASE(OP_IF_S,
	    if (is_true(sc, lookup(sc, car(sc->code)))),
	    if (is_false(sc, lookup(sc, cadar(sc->code)))))

	  IF_CASE(OP_IF_A,
		  if (is_true(sc, fx_call(sc, sc->code))),
		  if (is_false(sc, fx_call(sc, cdar(sc->code)))))

	  IF_CASE(OP_IF_D,
		  if (is_true(sc, c_call(car(sc->code))(sc, opt2_pair(sc->code)))),
		  if (is_false(sc, c_call(cadar(sc->code))(sc, opt2_pair(sc->code)))))

	  IF_CASE(OP_IF_IS_TYPE_S,
		  if (gen_type_match(sc, lookup(sc, opt2_sym(sc->code)), opt3_con(sc->code))),
		  if (!gen_type_match(sc, lookup(sc, opt2_sym(sc->code)), opt3_con(sc->code))))

	  IF_CASE(OP_IF_IS_TYPE_opSq,
		  set_car(sc->t1_1, lookup(sc, opt2_sym(sc->code))); \
		  if (gen_type_match(sc, c_call(cadar(sc->code))(sc, sc->t1_1), opt3_con(sc->code))),
		  set_car(sc->t1_1, lookup(sc, opt2_sym(sc->code))); \
		  if (!gen_type_match(sc, c_call(cadr(cadar(sc->code)))(sc, sc->t1_1), opt3_con(sc->code))))

	  IF_CASE(OP_IF_CS,
		  set_car(sc->t1_1, lookup(sc, opt2_sym(sc->code))); if (is_true(sc, c_call(car(sc->code))(sc, sc->t1_1))),
		  set_car(sc->t1_1, lookup(sc, opt2_sym(sc->code))); if (is_false(sc, c_call(cadar(sc->code))(sc, sc->t1_1))))

	  IF_CASE(OP_IF_CSS,
		  set_car(sc->t2_1, lookup(sc, opt3_sym(sc->code))); \
		  set_car(sc->t2_2, lookup(sc, opt2_sym(sc->code)));
		  if (is_true(sc, c_call(car(sc->code))(sc, sc->t2_1))),
		  set_car(sc->t2_1, lookup(sc, opt3_sym(sc->code))); \
		  set_car(sc->t2_2, lookup(sc, opt2_sym(sc->code)));
		  if (is_false(sc, c_call(cadar(sc->code))(sc, sc->t2_1))))

	  IF_CASE(OP_IF_CSC,
		  set_car(sc->t2_1, lookup(sc, opt3_sym(sc->code))); \
		  set_car(sc->t2_2, opt2_con(sc->code));		\
		  if (is_true(sc, c_call(car(sc->code))(sc, sc->t2_1))),
		  set_car(sc->t2_1, lookup(sc, opt3_sym(sc->code))); \
		  set_car(sc->t2_2, opt2_con(sc->code));		\
		  if (is_false(sc, c_call(cadar(sc->code))(sc, sc->t2_1))))

	  IF_CASE(OP_IF_S_opDq,
		  set_car(sc->t2_2, d_call(sc, opt2_pair(sc->code))); \
		  set_car(sc->t2_1, lookup(sc, opt3_sym(sc->code))); \
		  if (is_true(sc, c_call(car(sc->code))(sc, sc->t2_1))),
		  set_car(sc->t2_2, d_call(sc, opt2_pair(sc->code))); \
		  set_car(sc->t2_1, lookup(sc, opt3_sym(sc->code))); \
		  if (is_false(sc, c_call(cadar(sc->code))(sc, sc->t2_1))))

	  IF_CASE(OP_IF_opSq,
		  set_car(sc->t1_1, lookup(sc, opt3_sym(sc->code))); \
		  set_car(sc->t1_1, c_call(opt2_pair(sc->code))(sc, sc->t1_1));     \
		  if (is_true(sc, c_call(car(sc->code))(sc, sc->t1_1))),
		  set_car(sc->t1_1, lookup(sc, opt3_sym(sc->code))); \
		  set_car(sc->t1_1, c_call(opt2_pair(sc->code))(sc, sc->t1_1));     \
		  if (is_false(sc, c_call(cadar(sc->code))(sc, sc->t1_1))))

	  IF_CASE(OP_IF_AND2,
		  if ((is_true(sc, fx_call(sc, opt2_pair(sc->code)))) && \
		      (is_true(sc, fx_call(sc, opt3_pair(sc->code))))),
		  if ((is_false(sc, fx_call(sc, opt2_pair(sc->code)))) || \
		      (is_false(sc, fx_call(sc, opt3_pair(sc->code))))))

	  IF_CASE(OP_IF_AND3,
		  if ((is_true(sc, fx_call(sc, opt2_pair(sc->code)))) && \
		      (is_true(sc, fx_call(sc, opt3_pair(sc->code)))) && \
		      (is_true(sc, fx_call(sc, cdr(opt3_pair(sc->code)))))),
		  if ((is_false(sc, fx_call(sc, opt2_pair(sc->code)))) || \
		      (is_false(sc, fx_call(sc, opt3_pair(sc->code)))) || \
		      (is_false(sc, fx_call(sc, cdr(opt3_pair(sc->code)))))))

	  IF_CASE(OP_IF_OR2,
		  if ((is_true(sc, fx_call(sc, opt2_pair(sc->code)))) || \
		      (is_true(sc, fx_call(sc, opt3_pair(sc->code))))),
		  if ((is_false(sc, fx_call(sc, opt2_pair(sc->code)))) && \
		      (is_false(sc, fx_call(sc, opt3_pair(sc->code))))))

	case OP_IF_P_P: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PP, cadr(sc->code)); sc->code = car(sc->code); goto EVAL;
	case OP_IF_P_N: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PR, cadr(sc->code)); sc->code = cadar(sc->code); goto EVAL;
	case OP_IF_P_R: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PR, cadr(sc->code)); sc->code = car(sc->code); goto EVAL;
	case OP_IF_P_P_P: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PPP, cdr(sc->code)); sc->code = car(sc->code); goto EVAL;
	case OP_IF_P_N_N: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PRR, cdr(sc->code)); sc->code = cadar(sc->code); goto EVAL;

	case OP_IF_ANDP_P: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PP, cadr(sc->code)); sc->code = cdar(sc->code); goto AND_P;
	case OP_IF_ANDP_N: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PR, cadr(sc->code)); sc->code = cdadar(sc->code); goto AND_P;
	case OP_IF_ANDP_R: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PR, cadr(sc->code)); sc->code = cdar(sc->code); goto AND_P;
	case OP_IF_ANDP_P_P: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PPP, cdr(sc->code)); sc->code = cdar(sc->code); goto AND_P;
	case OP_IF_ANDP_N_N: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PRR, cdr(sc->code)); sc->code = cdadar(sc->code); goto AND_P;

	case OP_IF_ORP_P: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PP, cadr(sc->code)); sc->code = cdar(sc->code); goto OR_P;
	case OP_IF_ORP_N: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PR, cadr(sc->code)); sc->code = cdadar(sc->code); goto OR_P;
	case OP_IF_ORP_R: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PR, cadr(sc->code)); sc->code = cdar(sc->code); goto OR_P;
	case OP_IF_ORP_P_P: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PPP, cdr(sc->code)); sc->code = cdar(sc->code); goto OR_P;
	case OP_IF_ORP_N_N: sc->code = cdr(sc->code); push_stack_no_args(sc, OP_IF_PRR, cdr(sc->code)); sc->code = cdadar(sc->code); goto OR_P;

	case OP_IF_PP:
	  if (is_true(sc, sc->value))
	    goto EVAL;
	  sc->value = sc->unspecified;
	  goto START;

	case OP_IF_PPP:
	  if (is_true(sc, sc->value))
	    sc->code = car(sc->code);
	  else sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_IF_PR:
	  if (is_false(sc, sc->value))
	    goto EVAL;
	  sc->value = sc->unspecified;
	  goto START;

	case OP_IF_PRR:
	  if (is_false(sc, sc->value))
	    sc->code = car(sc->code);
	  else sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_COND_FEED:
	  /* (cond (expr => p)) where p is (lambda (s) ...) -- see check_cond */
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_COND_FEED_1, sc->code);
	  sc->code = caar(sc->code);
	  goto EVAL;

	case OP_COND_FEED_1:
	  if (is_true(sc, sc->value))
	    {
	      if (is_multiple_value(sc->value))
		sc->code = cons(sc, opt2_lambda(sc->code), multiple_value(sc->value));
	      else
		{
		  new_frame_with_slot(sc, sc->envir, sc->envir, caadr(opt2_lambda(sc->code)), sc->value);
		  sc->code = caddr(opt2_lambda(sc->code));
		}
	      goto EVAL;
	    }
	  sc->value = sc->unspecified; /* it's cond -- perhaps push as sc->args above; this was nil until 21-Feb-17! */
	  goto START;

	  /* -------------------------------- when, unless -------------------------------- */
	case OP_WHEN:    check_when(sc);                 goto EVAL;
	case OP_WHEN_S:  if (op_when_s(sc)) goto START;  goto EVAL;
	case OP_WHEN_A:  if (op_when_a(sc)) goto START;  goto EVAL;
        case OP_WHEN_P:  op_when_p(sc);                  goto EVAL;
	case OP_WHEN_AND_AP:  if (op_when_and_ap(sc)) goto START;  goto EVAL;
	case OP_WHEN_PP: if (op_when_pp(sc)) goto START; goto EVAL;

	case OP_UNLESS:    check_unless(sc);                 goto EVAL;
	case OP_UNLESS_S:  if (op_unless_s(sc)) goto START;  goto EVAL;
	case OP_UNLESS_A:  if (op_unless_a(sc)) goto START;  goto EVAL;
        case OP_UNLESS_P:  op_unless_p(sc);                  goto EVAL;
	case OP_UNLESS_PP: if (op_unless_pp(sc)) goto START; goto EVAL;

	  /* -------------------------------- let -------------------------------- */
	case OP_LET_NO_VARS: 	   op_let_no_vars(sc);	       goto BEGIN;
	case OP_NAMED_LET_NO_VARS: op_named_let_no_vars(sc);   goto BEGIN;
	case OP_NAMED_LET:	   op_named_let(sc);	       goto LET1;
	case OP_LET: 	           if (op_let(sc)) goto BEGIN; goto LET1;
	case OP_LET_A_A:           op_let_a_a(sc);             goto START;
	case OP_LET_FX: 	   op_let_fx(sc);	       goto BEGIN;
	case OP_LET_FX_2: 	   op_let_fx_2(sc);	       goto EVAL;
	case OP_LET_FX_3: 	   op_let_fx_3(sc);	       goto EVAL;
	case OP_LET_ONE:	   op_let_one(sc);	       goto EVAL;
	case OP_LET_ONE_P: 	   op_let_one_p(sc);	       goto EVAL;

	case OP_LET_A:             op_let_a(sc); sc->code = cdr(sc->code);  goto BEGIN;
	case OP_LET_A_P:           op_let_a(sc); sc->code = cadr(sc->code); goto EVAL;

	case OP_LET_ONE_1:	   
	  new_frame_with_slot(sc, sc->envir, sc->envir, sc->args, sc->value); 
	  goto BEGIN;

	case OP_LET_ONE_P_1:	   
	  new_frame_with_slot(sc, sc->envir, sc->envir, sc->args, sc->value); 
	  goto EVAL;

	case OP_LET_ONE_2:
	  {
	    s7_pointer frame;
	    frame = old_frame_with_slot(sc, opt3_any(sc->code), sc->value); 
	    set_outlet(frame, sc->envir);
	    sc->envir = frame;
	    sc->code = cdr(sc->code);
	    goto BEGIN;
	  }

	case OP_LET_ONE_P_2:
	  {
	    s7_pointer frame;
	    frame = old_frame_with_slot(sc, opt3_any(sc->code), sc->value); 
	    set_outlet(frame, sc->envir);
	    sc->envir = frame;
	    sc->code = cadr(sc->code);
	    goto EVAL;
	  }

	case OP_LET_opSSq:       /* one var, init is safe_c_ss */
	  op_let_opssq(sc);
	  new_frame_with_slot(sc, sc->envir, sc->envir, caaar(sc->code), sc->value);
	  sc->code = T_Pair(cdr(sc->code));
	  goto BEGIN;

	case OP_LET_opSSq_E:
	  op_let_opssq(sc);
	  new_frame_with_slot(sc, sc->envir, sc->envir, caaar(sc->code), sc->value);
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_LET_opaSSq:
	  op_let_opassq(sc);
	  new_frame_with_slot(sc, sc->envir, sc->envir, caaar(sc->code), sc->value);
	  sc->code = T_Pair(cdr(sc->code));
	  goto BEGIN;

	case OP_LET_opaSSq_E:
	  op_let_opassq(sc);
	  new_frame_with_slot(sc, sc->envir, sc->envir, caaar(sc->code), sc->value);
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_LET_UNCHECKED:   /* not named, but has vars */
	  if (op_let_unchecked(sc)) goto EVAL;

	LET1:
	case OP_LET1:
	  if (op_let1(sc)) goto BEGIN;
	  goto EVAL;

	case OP_LET_STAR_FX:           op_let_star_fx(sc);    goto BEGIN;
	case OP_LET_STAR_FX_A:         op_let_star_fx_a(sc);  goto START;
	case OP_NAMED_LET_STAR:        op_named_let_star(sc); goto EVAL;
	case OP_LET_STAR2:             op_let_star2(sc);      goto EVAL;
	case OP_LET_STAR:              if (check_let_star(sc)) goto EVAL; goto BEGIN;
	case OP_LET_STAR1:             if (op_let_star1(sc)) goto EVAL; goto BEGIN;

	case OP_LETREC:                check_letrec(sc, true);
	case OP_LETREC_UNCHECKED:      if (op_letrec_unchecked(sc)) goto EVAL; goto BEGIN;
	case OP_LETREC1:               if (op_letrec1(sc)) goto BEGIN; goto EVAL;

	case OP_LETREC_STAR:           check_letrec(sc, false);
	case OP_LETREC_STAR_UNCHECKED: if (op_letrec_star_unchecked(sc)) goto EVAL; goto BEGIN;
	case OP_LETREC_STAR1:          if (op_letrec_star1(sc)) goto EVAL; goto BEGIN;

	  /* -------------------------------- let-temporarily -------------------------------- */
	case OP_LET_TEMPORARILY:
	  check_let_temporarily(sc);

	case OP_LET_TEMP_UNCHECKED:
	  op_let_temp_unchecked(sc);
	  goto LET_TEMP_INIT1;

	case OP_LET_TEMP_INIT1:
	  caddr(sc->args) = cons(sc, sc->value, caddr(sc->args));
	LET_TEMP_INIT1:
	  if (op_let_temp_init1(sc)) goto EVAL;

	case OP_LET_TEMP_INIT2:
	  {
	    s7_pointer val;
	    val = op_let_temp_init2(sc);
	    if (!val) goto EVAL;
	    if (val == sc->unused) goto BEGIN;
	  }

	case OP_LET_TEMP_DONE:
	  push_stack(sc, OP_GC_PROTECT, sc->args, sc->value);

	case OP_LET_TEMP_DONE1:
	  if (op_let_temp_done1(sc)) goto START;
	  goto EVAL;

	  /* -------------------------------- => -------------------------------- */
	FEED_TO:
	  if (is_multiple_value(sc->value))                            /* (cond ((values 1 2) => +)) */
	    {
	      sc->args = multiple_value(sc->value);
	      clear_multiple_value(sc->args);
	    }
	  else
	    {
	      if (is_symbol(cadr(sc->code)))
		{
		  s7_pointer func;
		  func = lookup_checked(sc, cadr(sc->code));  /* car is => */
		  if ((is_c_function(func)) &&
		      (is_safe_procedure(func)))
		    {
		      if ((c_function_required_args(func) <= 1) &&
			  (c_function_all_args(func) >= 1))
			{
			  sc->value = c_function_call(func)(sc, set_plist_1(sc, sc->value));
			  goto START;
			}
		    }
		  sc->code = func;
		  sc->args = (needs_copied_args(func)) ? list_1(sc, sc->value) : set_plist_1(sc, sc->value);
		  goto APPLY;
		}
	      sc->args = list_1(sc, sc->value);                       /* not plist here */
	    }
	  push_stack(sc, OP_FEED_TO_1, sc->args, sc->code);
	  sc->code = cadr(sc->code);                                  /* need to evaluate the target function */
	  goto EVAL;

	case OP_FEED_TO_1:
	  sc->code = sc->value;
	  goto APPLY;

	  /* -------------------------------- cond -------------------------------- */
	case OP_COND:
	  check_cond(sc);

	case OP_COND_UNCHECKED:
	  op_cond_unchecked(sc);
	  goto EVAL;

	case OP_COND1:
	  if (op_cond1(sc)) goto TOP_NO_POP;
	  goto FEED_TO;

	case OP_COND_SIMPLE: /* no => */
	  if (op_cond_simple(sc)) goto EVAL;

	case OP_COND1_SIMPLE:
	  if (op_cond1_simple(sc)) goto TOP_NO_POP;
	  goto BEGIN;

	case OP_COND_SIMPLE_P: /* no =>, no null or multiform consequent */
	  if (op_cond_simple_p(sc)) goto EVAL;

	case OP_COND1_SIMPLE_P:
	  if (op_cond1_simple_p(sc)) goto START;
	  goto EVAL;

	case OP_COND_FX:
	  if (op_cond_fx(sc)) goto START;
	  goto BEGIN;

	case OP_COND_FX_2:
	  if (op_cond_fx_2(sc)) goto START;
	  goto BEGIN;

	case OP_COND_FX_P:
	  if (op_cond_fx_p(sc)) goto START;
	  goto EVAL;

	case OP_COND_FX_1P_ELSE:
	  if (op_cond_fx_1p_else(sc)) goto START;
	  goto EVAL;

	case OP_COND_FX_2P_ELSE:
	  if (op_cond_fx_2p_else(sc)) goto START;
	  goto EVAL;

	  /* -------------------------------- and -------------------------------- */
	case OP_AND:
	  set_current_code(sc, sc->code);
	  if (check_and(sc)) goto START;

	case OP_AND_P:
	  sc->code = cdr(sc->code);
	AND_P:
	  if (has_fx(sc->code)) /* all c_callee's are set via fx_choose which can return nil, but it is not cleared when type is */
	    {                      /*   so, if (c_callee(sc->code)) here and in OR_P is not safe */
	      sc->value = fx_call(sc, sc->code);
	      if (is_false(sc, sc->value))
		goto START;
	      sc->code = cdr(sc->code);
	      if (is_null(sc->code))
		goto START;
	      goto AND_P;
	    }
	  if (is_not_null(cdr(sc->code)))
	    push_stack_no_args(sc, OP_AND_P1, cdr(sc->code));
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_AND_P1:
	  if ((is_false(sc, sc->value)) ||
	      (is_null(sc->code)))
	    goto START;
	  goto AND_P;

	case OP_AND_SAFE_P1:   /* sc->code: (and (func...) (fx...)...) */
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_AND_SAFE_P_REST, cdr(sc->code));
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_AND_SAFE_P2:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  if (is_false(sc, sc->value)) goto START;
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_AND_SAFE_P_REST, cdr(sc->code));
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_AND_SAFE_P3:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  if (is_false(sc, sc->value)) goto START;
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  if (is_false(sc, sc->value)) goto START;
	  sc->code = cadr(sc->code);
	  goto EVAL;

	case OP_AND_SAFE_P_REST:  /* cdr(sc->code) is known to be a pair (and was pushed => sc->code) */
	  if (is_false(sc, sc->value))
	    goto START;
	  op_and_safe_p(sc);
	  goto START;

	case OP_AND_SAFE_P:
	  sc->code = cdr(sc->code);
	  op_and_safe_p(sc);
	  goto START;

	case OP_AND_AP:
	  if (op_and_ap(sc)) goto START;
	  goto EVAL;

	case OP_AND_PAIR_P:
	  if (op_and_pair_p(sc)) goto START;
	  goto EVAL;

	case OP_AND_SAFE_AA:
	  op_and_safe_aa(sc);
	  goto START;

	  /* -------------------------------- or -------------------------------- */
	case OP_OR:
	  set_current_code(sc, sc->code);
	  if (check_or(sc)) goto START;

	case OP_OR_P:
	  sc->code = cdr(sc->code);
	OR_P:
	  if (has_fx(sc->code))
	    {
	      sc->value = fx_call(sc, sc->code);
	      if (is_true(sc, sc->value))
		goto START;
	      sc->code = cdr(sc->code);
	      if (is_null(sc->code))
		goto START;
	      goto OR_P;
	    }
	  if (is_not_null(cdr(sc->code)))
	    push_stack_no_args(sc, OP_OR_P1, cdr(sc->code));
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_OR_P1:
	  if ((is_true(sc, sc->value)) ||
	      (is_null(sc->code)))
	    goto START;
	  goto OR_P;

	case OP_OR_SAFE_P:   /* op_or_safe_p* did not make much difference (unlike op_and_safe_p*) */
	  op_or_safe_p(sc);
	  goto START;

	case OP_OR_AP:
	  if (op_or_ap(sc)) goto START;
	  goto EVAL;

	case OP_OR_SAFE_AA:
	  op_or_safe_aa(sc);
	  goto START;


	  /* -------------------------------- macro evaluation -------------------------------- */
	case OP_EVAL_MACRO:    /* after (scheme-side) macroexpansion, evaluate the resulting expression */
	  op_eval_macro(sc);
	  goto EVAL;

	case OP_EVAL_MACRO_MV:
	  if (op_eval_macro_mv(sc)) goto START;
	  goto EVAL;

	case OP_EXPANSION:
	  /* after the expander has finished, if a list was returned, we need to add some annotations.
	   *   if the expander returned (values), the list-in-progress vanishes! (This mimics map and *#readers*).
	   */
	  if (sc->value == sc->no_value)
	    sc->stack_end[-1] = (s7_pointer)OP_READ_NEXT;
	  else
	    {
	      if (is_pair(sc->value))
		sc->value = copy_body(sc, sc->value);
	    }
	  goto START;

	case OP_DEFINE_MACRO_WITH_SETTER:
	  op_define_macro_with_setter(sc);
	  goto START;

	case OP_DEFINE_BACRO:
	case OP_DEFINE_BACRO_STAR:
	case OP_DEFINE_EXPANSION:
	case OP_DEFINE_MACRO:
	case OP_DEFINE_MACRO_STAR:
	  if (op_define_macro(sc)) goto START;
	  goto APPLY;

	case OP_LAMBDA:
	  set_current_code(sc, sc->code);
	  check_lambda(sc);
	  make_closure_with_let(sc, sc->value, car(sc->code), cdr(sc->code), sc->envir, CLOSURE_ARITY_NOT_SET);  /* sc->value=new closure cell, car=args, cdr=body */
	  goto START;

	case OP_LAMBDA_UNCHECKED:      /* pre-calculating type/arity in check_lambda was slower?? */
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	  make_closure_with_let(sc, sc->value, car(sc->code), cdr(sc->code), sc->envir, CLOSURE_ARITY_NOT_SET);  /* sc->value=new closure cell, car=args, cdr=body */
	  goto START;

	case OP_LAMBDA_STAR:
	  set_current_code(sc, sc->code);
	  check_lambda_star(sc);
	  sc->value = make_closure(sc, car(sc->code), cdr(sc->code), (!is_pair(car(sc->code))) ? T_CLOSURE : T_CLOSURE_STAR, CLOSURE_ARITY_NOT_SET);
	  goto START;

	case OP_LAMBDA_STAR_UNCHECKED:
	  set_current_code(sc, sc->code);
	  sc->code = cdr(sc->code);
	  sc->value = make_closure(sc, car(sc->code), cdr(sc->code), (!is_pair(car(sc->code))) ? T_CLOSURE : T_CLOSURE_STAR, CLOSURE_ARITY_NOT_SET);
	  goto START;

	  /* -------------------------------- case -------------------------------- */
	case OP_CASE:       /* case, car(sc->code) is the selector */
	  if (check_case(sc)) goto EVAL;
	  /* else drop into CASE_G_G -- selector is a symbol or constant */

	CASE_G_G:
	case OP_CASE_G_G:
	  if (op_case_g_g(sc)) goto TOP_NO_POP;
	  goto FEED_TO;

	  /* selector A, key type: E=eq (symbol/char), I=integer, G=any, S=single keys and single bodies */
	case OP_CASE_A_E_S:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  goto CASE_E_S;

	case OP_CASE_A_S_S:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  goto CASE_S_S;

	case OP_CASE_A_I_S:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  goto CASE_I_S;

	case OP_CASE_A_E_G:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  goto CASE_E_G;

	case OP_CASE_A_S_G:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  goto CASE_S_G;

	case OP_CASE_A_G_G:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  goto CASE_G_G;

	case OP_CASE_S_G_S:
	  sc->code = cdr(sc->code);
	  sc->value = lookup_checked(sc, car(sc->code));
	  goto CASE_G_S;

	case OP_CASE_S_G_G:
	  sc->code = cdr(sc->code);
	  sc->value = lookup_checked(sc, car(sc->code));
	  goto CASE_G_G;

	  /* selector = any */
	case OP_CASE_P_E_S:
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_CASE_E_S, sc->code);
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_CASE_P_S_S:
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_CASE_S_S, sc->code);
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_CASE_P_I_S:
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_CASE_I_S, sc->code);
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_CASE_P_G_S:
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_CASE_G_S, sc->code);
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_CASE_P_E_G:
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_CASE_E_G, sc->code);
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_CASE_P_S_G:
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_CASE_S_G, sc->code);
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_CASE_P_G_G:
	  sc->code = cdr(sc->code);
	  push_stack_no_args(sc, OP_CASE_G_G, sc->code);
	  sc->code = car(sc->code);
	  goto EVAL;

	case OP_CASE_S_E_S:
	  sc->code = cdr(sc->code);
	  sc->value = lookup_checked(sc, car(sc->code));
	  /* goto CASE_E_S; */

	CASE_E_S:
	case OP_CASE_E_S:
	  op_case_e_s(sc);
	  goto EVAL;

	case OP_CASE_S_S_S:
	  sc->code = cdr(sc->code);
	  sc->value = lookup_checked(sc, car(sc->code));
	  /* goto CASE_S_S; */

	CASE_S_S:
	case OP_CASE_S_S:
	  op_case_s_s(sc);
	  goto EVAL;

	case OP_CASE_S_I_S:
	  sc->code = cdr(sc->code);
	  sc->value = lookup_checked(sc, car(sc->code));
	  /* goto CASE_I_S; */

	CASE_I_S:
	case OP_CASE_I_S:
	  if (op_case_i_s(sc)) goto START;
	  goto EVAL;

	case OP_CASE_A_G_S:
	  sc->code = cdr(sc->code);
	  sc->value = fx_call(sc, sc->code);
	  /* goto CASE_G_S; */

	CASE_G_S:
	case OP_CASE_G_S:
	  op_case_g_s(sc);
	  goto EVAL;

	case OP_CASE_S_E_G:
	  sc->code = cdr(sc->code);
	  sc->value = lookup_checked(sc, car(sc->code));
	  /* goto CASE_E_G; */

	CASE_E_G:
	case OP_CASE_E_G:
	  if (op_case_e_g_1(sc, sc->value, is_simple(sc->value)))
	    goto TOP_NO_POP;
	  goto FEED_TO;

	case OP_CASE_S_S_G:
	  sc->code = cdr(sc->code);
	  sc->value = lookup_checked(sc, car(sc->code));
	  /* goto CASE_S_G; */

	CASE_S_G:
	case OP_CASE_S_G:
	  if (op_case_e_g_1(sc, sc->value, is_case_key(sc->value)))
	    goto TOP_NO_POP;
	  goto FEED_TO;


	case OP_ERROR_QUIT:
	  if (sc->stack_end <= sc->stack_start)
	    stack_reset(sc); /* sets stack_end to stack_start, then pushes op_barrier and op_eval_done */
	  return(sc->F);

	case OP_ERROR_HOOK_QUIT:
	  sc->error_hook = sc->code;  /* restore old value */

	  /* now mimic the end of the normal error handler.  Since this error hook evaluation can happen
	   *   in an arbitrary s7_call nesting, we can't just return from the current evaluation --
	   *   we have to jump to the original (top-level) call.  Otherwise '#<unspecified> or whatever
	   *   is simply treated as the (non-error) return value, and the higher level evaluations
	   *   get confused.
	   */
	  stack_reset(sc);                                 /* is this necessary? is it a good idea?? */
	  push_stack_op(sc, OP_ERROR_QUIT);                /* added 3-Dec-16: try to make sure we actually exit! */
	  sc->cur_op = OP_ERROR_QUIT;
	  if (sc->longjmp_ok) longjmp(sc->goto_start, ERROR_QUIT_JUMP);
#if S7_DEBUGGING
	  fprintf(stderr, "%d: op_error_hook_quit did not jump, returns %s\n", __LINE__, DISPLAY(sc->value));
#endif
	  return(sc->value); /* not executed I hope */

	case OP_EVAL_DONE:   /* this is the "time to quit" operator */
	  return(sc->F);

	case OP_BARRIER:
	case OP_CATCH_ALL:
	case OP_CATCH:
	case OP_CATCH_1:
	case OP_CATCH_2:
	  goto START;

	case OP_DEACTIVATE_GOTO:
	  call_exit_active(sc->args) = false;      /* as we leave the call-with-exit body, deactivate the exiter */
	  goto START;

	case OP_GET_OUTPUT_STRING:                 /* from call-with-output-string and with-output-to-string -- return the port string directly */
	  op_get_output_string(sc);
	  /* fall through */

	case OP_UNWIND_OUTPUT:
	  unwind_output_ex(sc);
	  goto START;

	case OP_UNWIND_INPUT:
	  unwind_input_ex(sc);
	  goto START;

	case OP_DYNAMIC_WIND:
	  if (dynamic_wind_ex(sc) == goto_APPLY) goto APPLY;
	  goto START;

	  /* -------------------------------- with-let --------------------------------
	   *
	   * the extra set! to pull in args, or fixup the outlet is annoying, but
	   *   but with-let is hard to do right -- what if env is chained as in class/objects?
	   */
	case OP_WITH_LET_S:
	  op_with_let_s(sc);
	  goto BEGIN;

	case OP_WITH_LET:
	  check_with_let(sc);

	case OP_WITH_LET_UNCHECKED:
	  if (op_with_let_unchecked(sc)) goto EVAL;

	case OP_WITH_LET1:
	  activate_let(sc, sc->value);
	  goto BEGIN;

	  /* -------------------------------- with-baffle -------------------------------- */
	case OP_WITH_BAFFLE:
	  check_with_baffle(sc);

	case OP_WITH_BAFFLE_UNCHECKED:
	  if (op_with_baffle_unchecked(sc)) goto START;
	  goto BEGIN;

	  /* -------------------------------- the reader -------------------------------- */
	case OP_READ_INTERNAL:
	  /* if we're loading a file, and in the file we evaluate something like:
	   *    (let ()
	   *      (set-current-input-port (open-input-file "tmp2.r5rs"))
	   *      (close-input-port (current-input-port)))
	   *    ... (with no reset of input port to its original value)
	   * the load process tries to read the loaded string, but the sc->input_port is now closed,
	   * and the original is inaccessible!  So we get a segfault in token.  We don't want to put
	   * a port_is_closed check there because token only rarely is in this danger.  I think this
	   * is the only place where we can be about to call token, and someone has screwed up our port.
	   *
	   * We can't call read_error here because it assumes the input string is ok!
	   */

	  if (port_is_closed(sc->input_port))
	    s7_error(sc, sc->read_error_symbol,
		     set_elist_1(sc, wrap_string(sc, "our input port got clobbered!", 29)));

	  sc->tok = token(sc);
	  switch (sc->tok)
	    {
	    case TOKEN_EOF:
	      goto START;

	    case TOKEN_RIGHT_PAREN:
	      read_error(sc, "unexpected close paren");

	    case TOKEN_COMMA:
	      read_error(sc, "unexpected comma");

	    default:
	      sc->value = read_expression(sc);
	      sc->current_line = port_line_number(sc->input_port);  /* this info is used to track down missing close parens */
	      sc->current_file = port_filename(sc->input_port);
	      break;
	    }
	  goto START;

	case OP_READ_DONE:
	  pop_input_port(sc);

	  if (sc->tok == TOKEN_EOF)
	    sc->value = eof_object;
	  sc->current_file = NULL; /* this is for error handling */
	  goto START;


	  /* load("file"); from C (g_load) -- assume caller will clean up
	   *   read and evaluate exprs until EOF that matches (stack reflects nesting)
	   */
	case OP_LOAD_RETURN_IF_EOF:  /* loop here until eof (via push stack below) */
	  if (sc->tok != TOKEN_EOF)
	    {
	      push_stack_op_let(sc, OP_LOAD_RETURN_IF_EOF);
	      push_stack_op_let(sc, OP_READ_INTERNAL);
	      sc->code = sc->value;
	      goto EVAL;             /* we read an expression, now evaluate it, and return to read the next */
	    }
	  sc->current_file = NULL;
	  return(sc->F);


	  /* (load "file") in scheme
	   *    read and evaluate all exprs, then upon EOF, close current and pop input port stack
	   */
	case OP_LOAD_CLOSE_AND_POP_IF_EOF:
	  if (sc->tok != TOKEN_EOF)
	    {
	      push_stack_op_let(sc, OP_LOAD_CLOSE_AND_POP_IF_EOF); /* was push args, code */
	      if ((!is_string_port(sc->input_port)) ||
		  (port_position(sc->input_port) < port_data_size(sc->input_port)))
		push_stack_op_let(sc, OP_READ_INTERNAL);
	      else sc->tok = TOKEN_EOF;
	      sc->code = sc->value;
	      goto EVAL;             /* we read an expression, now evaluate it, and return to read the next */
	    }
#if S7_DEBUGGING
	  if (!is_loader_port(sc->input_port))
	    fprintf(stderr, "%s not loading?\n", DISPLAY(sc->input_port));
	  /* if *#readers* func hits error, clear_loader_port might not be undone? */
#endif
	  s7_close_input_port(sc, sc->input_port);
	  pop_input_port(sc);
	  sc->current_file = NULL;

	  if (is_multiple_value(sc->value))                    /* (load "file") where "file" is (values 1 2 3) */
	    sc->value = splice_in_values(sc, multiple_value(sc->value));
	  goto START;


	POP_READ_LIST:
	  /* push-stack OP_READ_LIST is always no_code and op is always OP_READ_LIST (and not used), sc->envir is apparently not needed here */
	  sc->stack_end -= 4;
	  sc->args = sc->stack_end[2];

	READ_LIST:
	case OP_READ_LIST:        /* sc->args is sc->nil at first */
	  {
	    s7_pointer x;
	    new_cell(sc, x, T_PAIR);
	    set_car(x, sc->value);
	    set_cdr(x, sc->args);
	    sc->args = x;
#if WITH_PROFILE
	    profile_set_location(x, remember_location(port_line_number(sc->input_port), port_file_number(sc->input_port)));
#endif
	  }

	case OP_READ_NEXT:       /* this is 75% of the token calls, so expanding it saves lots of time */
	  {
	    int32_t c;
	    s7_pointer pt;

	    pt = sc->input_port;
	    c = port_read_white_space(pt)(sc, pt);

	  READ_C:
	    switch (c)
	      {
	      case '(':
		c = port_read_white_space(pt)(sc, pt);  /* sc->tok = token(sc) */
		switch (c)
		  {
		  case '(':  sc->tok = TOKEN_LEFT_PAREN;                break;
		  case ')':  sc->value = sc->nil; goto READ_LIST;       /* was tok = TOKEN_RIGHT_PAREN */
		  case '.':  sc->tok = read_dot(sc, pt);                break;
		  case '\'': sc->tok = TOKEN_QUOTE;                     break;
		  case ';':  sc->tok = port_read_semicolon(pt)(sc, pt); break;
		  case '"':  sc->tok = TOKEN_DOUBLE_QUOTE;              break;
		  case '`':  sc->tok = TOKEN_BACK_QUOTE;                break;
		  case ',':  sc->tok = read_comma(sc, pt);              break;
		  case '#':  sc->tok = read_sharp(sc, pt);              break;
		  case '\0': case EOF: sc->tok = TOKEN_EOF;             break;

		  default:
		    {
		      s7_pointer x;
		      sc->strbuf[0] = (unsigned char)c;
		      push_stack_no_let_no_code(sc, OP_READ_LIST, sc->args);
		      check_stack_size(sc);
		      sc->value = port_read_name(pt)(sc, pt);
		      new_cell(sc, x, T_PAIR);
		      set_car(x, sc->value);
		      set_cdr(x, sc->nil);
		      sc->args = x;
#if WITH_PROFILE
		      profile_set_location(x, remember_location(port_line_number(sc->input_port), port_file_number(sc->input_port)));
#endif
		      c = port_read_white_space(pt)(sc, pt);
		      goto READ_C;
		    }
		  }

		if (sc->tok == TOKEN_ATOM)
		  {
		    s7_pointer x;
		    push_stack_no_let_no_code(sc, OP_READ_LIST, sc->args);
		    check_stack_size(sc);
		    sc->value = port_read_name(pt)(sc, pt);
		    new_cell(sc, x, T_PAIR);
		    set_car(x, sc->value);
		    set_cdr(x, sc->nil);
		    sc->args = x;
#if WITH_PROFILE
		    profile_set_location(x, remember_location(port_line_number(sc->input_port), port_file_number(sc->input_port)));
#endif
		    c = port_read_white_space(pt)(sc, pt);
		    goto READ_C;
		  }

		if (sc->tok == TOKEN_RIGHT_PAREN)
		  {
		    sc->value = sc->nil;
		    goto READ_LIST;
		  }

		if (sc->tok == TOKEN_DOT)
		  {
		    do {c = inchar(pt);} while ((c != ')') && (c != EOF));
		    read_error(sc, "stray dot after '('?");      /* (car '( . )) */
		  }

		if (sc->tok == TOKEN_EOF)
		  return(missing_close_paren_error(sc));

		push_stack_no_let_no_code(sc, OP_READ_LIST, sc->args);
		push_stack_no_let_no_code(sc, OP_READ_LIST, sc->nil);
		check_stack_size(sc);
		sc->value = read_expression(sc);
		if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
		goto START;

	      case ')':
		sc->tok = TOKEN_RIGHT_PAREN;
		break;

	      case '.':
		sc->tok = read_dot(sc, pt); /* dot or atom */
		break;

	      case '\'':
		sc->tok = TOKEN_QUOTE;
		push_stack_no_let_no_code(sc, OP_READ_LIST, sc->args);
		sc->value = read_expression(sc);
		goto START;

	      case ';':
		sc->tok = port_read_semicolon(pt)(sc, pt);
		break;

	      case '"':
		sc->tok = TOKEN_DOUBLE_QUOTE;
		sc->value = read_string_constant(sc, pt);
		if (sc->value == sc->F)                                /* can happen if input code ends in the middle of a string */
		  return(string_read_error(sc, "end of input encountered while in a string"));
		if (sc->value == sc->T)
		  read_error(sc, "unknown backslash usage -- perhaps you meant two backslashes?");
		if (sc->safety > IMMUTABLE_VECTOR_SAFETY) set_immutable(sc->value);
		goto READ_LIST;

	      case '`':
		sc->tok = TOKEN_BACK_QUOTE;
		push_stack_no_let_no_code(sc, OP_READ_LIST, sc->args);
		sc->value = read_expression(sc);
		if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
		goto START;

	      case ',':
		sc->tok = read_comma(sc, pt); /* at_mark or comma */
		push_stack_no_let_no_code(sc, OP_READ_LIST, sc->args);
		sc->value = read_expression(sc);
		goto START;

	      case '#':
		sc->tok = read_sharp(sc, pt);
		break;

	      case '\0':
	      case EOF:
		return(missing_close_paren_error(sc));

	      default:
		sc->strbuf[0] = (unsigned char)c;
		sc->value = port_read_name(pt)(sc, pt);
		goto READ_LIST;
	      }
	  }

	READ_TOK:
	  switch (sc->tok)
	    {
	    case TOKEN_RIGHT_PAREN:
	      /* sc->args can't be null here */
	      sc->value = safe_reverse_in_place(sc, sc->args);
	      if (is_symbol(car(sc->value)))
		{
		  if (sc->input_port != sc->standard_input) /* (port_file_number(sc->input_port) > 1) -- maybe 0 is legit? */
		    {
		      pair_set_line(sc->value, port_line_number(sc->input_port));
		      pair_set_file(sc->value, port_file_number(sc->input_port));
		      set_has_line_number(sc->value);	      /* sc->input_port above can't be nil(?) -- it falls back on stdin now */
		    }
		  if ((is_expansion(car(sc->value))) &&
		      (expansion_ex(sc) == goto_APPLY))
		    {
		      push_stack_no_code(sc, OP_EXPANSION, sc->nil);
		      new_frame(sc, closure_let(sc->code), sc->envir);
		      goto APPLY_LAMBDA;
		    }
		}
	      break;

	    case TOKEN_EOF:      /* can't happen, I believe */
	      return(missing_close_paren_error(sc));

	    case TOKEN_ATOM:
	      sc->value = port_read_name(sc->input_port)(sc, sc->input_port);
	      goto READ_LIST;

	    case TOKEN_SHARP_CONST:
	      sc->value = port_read_sharp(sc->input_port)(sc, sc->input_port);
	      if (sc->value == sc->no_value)
		{
		  /* (set! *#readers* (cons (cons #\; (lambda (s) (read) (values))) *#readers*))
		   * (+ 1 #;(* 2 3) 4)
		   * so we need to get the next token, act on it without any assumptions about read list
		   */
		  sc->tok = token(sc);
		  goto READ_TOK;
		}
	      goto READ_LIST;

	    case TOKEN_DOUBLE_QUOTE:
	      sc->value = read_string_constant(sc, sc->input_port);
	      if (sc->value == sc->F)                                /* can happen if input code ends in the middle of a string */
		return(string_read_error(sc, "end of input encountered while in a string"));
	      if (sc->value == sc->T)
		read_error(sc, "unknown backslash usage -- perhaps you meant two backslashes?");
	      if (sc->safety > IMMUTABLE_VECTOR_SAFETY) set_immutable(sc->value);
	      goto READ_LIST;

	    case TOKEN_DOT:
	      push_stack_no_let_no_code(sc, OP_READ_DOT, sc->args);
	      sc->tok = token(sc);
	      sc->value = read_expression(sc);
	      break;

	    default:
	      /* by far the main case here is TOKEN_LEFT_PAREN, but it doesn't save anything to move it to this level */
	      push_stack_no_let_no_code(sc, OP_READ_LIST, sc->args);
	      sc->value = read_expression(sc);
	      /* check for op_read_list here and explicit pop_stack are slower */
	      break;
	    }
	  if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
	  goto START;

	case OP_READ_DOT:
	  {
	    token_t c;
	    c = token(sc);
	    if (c != TOKEN_RIGHT_PAREN) /* '(1 . (2) 3) -> '(1 2 3), Guile says "missing close paren" */
	      {
		if (is_pair(sc->value))
		  {
		    s7_pointer p;
		    for (p = sc->value; is_pair(p); p = cdr(p))
		      sc->args = cons(sc, car(p), sc->args);
		    sc->tok = c;
		    goto READ_TOK;
		  }
		back_up_stack(sc);
		read_error(sc, "stray dot?");            /* (+ 1 . 2 3) or (list . ) */
	      }
	    /* args = previously read stuff, value = thing just after the dot and before the ')':
	     *   (list 1 2 . 3) -> value: 3, args: (2 1 list)
	     *   '(1 . 2) ->       value: 2, args: (1)
	     * but we also get here in a lambda arg list:
	     *   (lambda (a b . c) #f) -> value: c, args: (b a)
	     * so we have to leave any error checks until later, I guess
	     *   -- in eval_args1, if we end with non-pair-not-nil then something is fishy
	     */
	    sc->value = reverse_in_place(sc, sc->value, sc->args);
	    pair_set_dotted(sc->value);
	    if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
	  }
	  goto START;

	case OP_READ_QUOTE:
	  /* can't check for sc->value = sc->nil here because we want ''() to be different from '() */
	  if ((sc->safety > IMMUTABLE_VECTOR_SAFETY) &&
	      ((is_pair(sc->value)) || (is_any_vector(sc->value)) || (is_string(sc->value))))
	    set_immutable(sc->value);
	  sc->value = list_2(sc, sc->quote_symbol, sc->value);
	  if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
	  goto START;

	case OP_READ_QUASIQUOTE:
	  /* this was pushed when the backquote was seen, then eventually we popped back to it */
	  sc->value = g_quasiquote_1(sc, sc->value, false);
	  /* doing quasiquote at read time means there are minor inconsistencies in
	   *    various combinations or quote/' and quasiquote/`.  A quoted ` will expand
	   *    but quoted quasiquote will not (` can't be redefined, but quasiquote can).
	   *    see s7test.scm for examples.
	   */
	  if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
	  goto START;

	case OP_READ_UNQUOTE:
	  /* here if sc->value is a constant, the unquote is pointless (should we complain?) */
	  if ((is_pair(sc->value)) ||
	      (is_symbol(sc->value)))
	    sc->value = list_2(sc, sc->unquote_symbol, sc->value);
	  if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
	  goto START;

	case OP_READ_APPLY_VALUES:
	  sc->value = list_2(sc, sc->unquote_symbol, list_2(sc, sc->apply_values_symbol, sc->value));
	  if (main_stack_op(sc) == OP_READ_LIST) goto POP_READ_LIST;
	  goto START;

	case OP_READ_VECTOR:       if (op_read_vector(sc)) goto START;       goto POP_READ_LIST;
	case OP_READ_INT_VECTOR:   if (op_read_int_vector(sc)) goto START;   goto POP_READ_LIST;
	case OP_READ_FLOAT_VECTOR: if (op_read_float_vector(sc)) goto START; goto POP_READ_LIST;
	case OP_READ_BYTE_VECTOR:  if (op_read_byte_vector(sc)) goto START;  goto POP_READ_LIST;

	default:
	  fprintf(stderr, "unknown operator: %" print_pointer " in %s\n", sc->cur_op, DISPLAY(current_code(sc)));
	  fprintf(stderr, "estr: %s\n", s7_object_to_c_string(sc, s7_name_to_value(sc, "estr")));
	  return(sc->F);
	}
#if S7_DEBUGGING
      if ((sc->cur_op >= OPT_MAX_DEFINED) && (sc->cur_op != OP_EVAL_DONE))
	fprintf(stderr, "trailers: %s, code: %s\n", op_names[sc->cur_op], DISPLAY(sc->code));
#endif
      /* else cancel all the optimization info -- someone stepped on our symbol */
      /* there is a problem with this -- if the caller still insists on goto EVAL, for example,
       *   we get here over and over.  (let ((x (list (car y))))...) where list is redefined away.
       */
      clear_all_optimizations(sc, sc->code);

    UNOPT:
      {
	s7_pointer code;
	code = sc->code;
	if (is_pair(code))
	  {
	    s7_pointer carc;
	    carc = car(code);
	    if (is_syntactic_symbol(carc))  /* carc can also be syntactic */
	      {
		sc->cur_op = (opcode_t)symbol_syntax_op_checked(code);
		pair_set_syntax_op(code, sc->cur_op);
		goto TOP_NO_POP;
	      }

	    /* -------------------------------------------------------------------------------- */
	    /* trailers */

	    if (is_symbol(carc))
	      {
		/* car is a symbol, sc->code a list */
		if (is_syntactic_symbol(carc))
		  {
		    sc->cur_op = (opcode_t)symbol_syntax_op_checked(code);
		    pair_set_syntax_op(sc->code, sc->cur_op);
		    goto TOP_NO_POP;
		  }
		sc->value = find_global_symbol_checked(sc, carc);
		set_optimize_op(code, OP_PAIR_SYM);
		goto EVAL_ARGS_TOP;
	      }
	    /* very uncommon case: car is either itself a pair or some non-symbol */
	    if (is_pair(carc))
	      {
		/* evaluate the inner list but that list can be circular: carc: #1=(#1# #1#)!
		 *   and the cycle can be well-hidden -- #1=((#1 2) . 2) and other such stuff
		 */
		if (sc->stack_end >= sc->stack_resize_trigger)
		  check_for_cyclic_code(sc, code);
		push_stack(sc, OP_EVAL_ARGS, sc->nil, code);

		if (is_syntactic_symbol(car(carc)))
		  /* was checking for is_syntactic here but that can be confused by successive optimizer passes:
		   *  (define (hi) (((lambda () list)) 1 2 3)) etc
		   */
		  {
		    if ((car(carc) == sc->quote_symbol) &&        /* ('and #f) */
			((!is_pair(cdr(carc))) ||                 /* ((quote . #\h) (2 . #\i)) ! */
			 (is_syntactic(cadr(carc)))))
		      apply_error(sc, (is_pair(cdr(carc))) ? cadr(carc) : carc, cdr(code));

		    sc->code = carc;
		    sc->cur_op = (opcode_t)symbol_syntax_op_checked(sc->code);
		    pair_set_syntax_op(sc->code, sc->cur_op);
		    goto TOP_NO_POP;
		  }
		set_optimize_op(code, OP_PAIR_PAIR);
		push_stack(sc, OP_EVAL_ARGS, sc->nil, carc);
		sc->code = car(carc);
		goto EVAL;
	      }
	    /* here we can get syntax objects like quote */
	    if (is_syntax(carc))
	      {
		sc->cur_op = (opcode_t)syntax_opcode(carc);
		pair_set_syntax_op(sc->code, sc->cur_op);
		goto TOP_NO_POP;
	      }
	    /* car must be the function to be applied, or (for example) a syntax variable like quote that has been used locally */
	    set_optimize_op(code, OP_PAIR_ANY);
	    sc->value = T_Pos(carc);
	    goto EVAL_ARGS_TOP;
	  }
	if (is_symbol(code))
	  {
	    sc->value = lookup_checked(sc, code);
	    set_optimize_op(code, (is_keyword(code)) ? OP_CON : OP_SYM);
	  }
	else
	  {
	    sc->value = T_Pos(code);
	    set_optimize_op(code, OP_CON);
	  }
	goto START;
      }
    }
  return(sc->F);
}


/* -------------------------------- multiprecision arithmetic -------------------------------- */

#if WITH_GMP
static mp_prec_t mpc_precision = DEFAULT_BIGNUM_PRECISION; /* global for libs */
static mp_prec_t mpc_set_default_precision(mp_prec_t prec) {mpc_precision = prec; return(prec);}

#define mpc_init(Z) mpc_init2(Z, mpc_precision)

static void mpc_init_set(mpc_ptr z, mpc_ptr y, mpc_rnd_t rnd)
{
  mpc_init(z);
  mpc_set(z, y, rnd);
}

mpfr_t *s7_big_real(s7_pointer x)    {return(&big_real(x));}
mpz_t  *s7_big_integer(s7_pointer x) {return(&big_integer(x));}
mpq_t  *s7_big_ratio(s7_pointer x)   {return(&big_ratio(x));}
mpc_t  *s7_big_complex(s7_pointer x) {return(&big_complex(x));}

static char *mpfr_to_string(mpfr_t val, int32_t radix)
{
  char *str, *tmp, *str1;
  mp_exp_t expptr;
  int32_t ep;
  s7_int i, len;

  if (mpfr_zero_p(val))
    return(copy_string("0.0"));

  if (mpfr_nan_p(val))
    return(copy_string("+nan.0"));
  if (mpfr_inf_p(val))
    {
      if (mpfr_signbit(val) == 0)
	return(copy_string("+inf.0"));
      return(copy_string("-inf.0"));
    }

  str1 = mpfr_get_str(NULL, &expptr, radix, 0, val, GMP_RNDN);

  /* 0 -> full precision, but it's too hard to make this look like C formatted output.
   *  (format #f "~,3F" pi)-> "3.141592653589793238462643383279502884195E0"
   *  (format #f "~,3F" 1.1234567890123) -> "1.123" ; not a bignum
   *  (format #f "~,3F" 1.12345678901234) -> "1.123456789012339999999999999999999999999E0" ; a bignum
   * but we don't know the exponent or the string length until after we call mpfr_get_str.
   */
  str = str1;
  ep = (int32_t)expptr;
  len = safe_strlen(str);

  /* remove trailing 0's */
  for (i = len - 1; i > 3; i--)
    if (str[i] != '0')
      break;
  if (i < len - 1)
    str[i + 1] = '\0';

  len += 64;
  tmp = (char *)malloc(len * sizeof(char));

  if (str[0] == '-')
    snprintf(tmp, len, "-%c.%s%c%d", str[1], (char *)(str + 2), (radix <= 10) ? 'E' : '@', ep - 1);
  else snprintf(tmp, len, "%c.%s%c%d", str[0], (char *)(str + 1), (radix <= 10) ? 'E' : '@', ep - 1);

  mpfr_free_str(str1);
  return(tmp);
}

static char *mpc_to_string(mpc_t val, int32_t radix, use_write_t use_write)
{
  char *rl, *im, *tmp;
  s7_int len;
  mpfr_t a, b;

  mpfr_init(a);
  mpc_real(a, val, GMP_RNDN);
  rl = mpfr_to_string(a, radix);
  mpfr_init(b);
  mpc_imag(b, val, GMP_RNDN);
  im = mpfr_to_string(b, radix);

  len = safe_strlen(rl) + safe_strlen(im) + 128;
  tmp = (char *)malloc(len * sizeof(char));

  if (use_write == P_READABLE)
    snprintf(tmp, len, "(complex %s %s)", rl, im);
  else snprintf(tmp, len, "%s%s%si", rl, ((im[0] == '-') || (im[0] == '+')) ? "" : "+", im);

  free(rl);
  free(im);
  return(tmp);
}

static char *big_number_to_string_with_radix(s7_pointer p, int32_t radix, s7_int width, s7_int *nlen, use_write_t use_write)
{
  char *str = NULL;

  switch (type(p))
    {
    case T_BIG_INTEGER: str = mpz_get_str(NULL, radix, big_integer(p));        break;
    case T_BIG_RATIO:   str = mpq_get_str(NULL, radix, big_ratio(p));          break;
    case T_BIG_REAL:    str = mpfr_to_string(big_real(p), radix);              break;
    default:            str = mpc_to_string(big_complex(p), radix, use_write); break;
    }

  if (width > 0)
    {
      s7_int len;
      len = safe_strlen(str);
      if (width > len)
	{
	  int32_t spaces;
	  str = (char *)realloc(str, (width + 1) * sizeof(char));
	  spaces = width - len;
	  str[width] = '\0';
	  memmove((void *)(str + spaces), (void *)str, len);
	  memset((void *)str, (int)' ', spaces);
	  (*nlen) = width;
	}
      else (*nlen) = len;
    }
  else (*nlen) = safe_strlen(str);
  return(str);
}

static bool s7_is_one_or_big_one(s7_pointer p)
{
  bool result = false;

  if (!is_big_number(p))
    return(s7_is_one(p));

  if (is_t_big_integer(p))
    {
      mpz_t n;
      mpz_init_set_si(n, 1);
      result = (mpz_cmp(n, big_integer(p)) == 0);
      mpz_clear(n);
    }
  else
    {
      if (is_t_big_real(p))
	{
	  mpfr_t n;
	  mpfr_init_set_d(n, 1.0, GMP_RNDN);
	  result = (mpfr_cmp(n, big_real(p)) == 0);
	  mpfr_clear(n);
	}
    }
  return(result);
}

static s7_pointer string_to_big_integer(s7_scheme *sc, const char *str, int32_t radix)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_INTEGER);
  mpz_init_set_str(big_integer(x), (str[0] == '+') ? (const char *)(str + 1) : str, radix);
  add_big_integer(sc, x);
  return(x);
}

static s7_pointer mpz_to_big_integer(s7_scheme *sc, mpz_t val)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_INTEGER);
  mpz_init_set(big_integer(x), val);
  add_big_integer(sc, x);
  return(x);
}

s7_pointer s7_make_big_integer(s7_scheme *sc, mpz_t *val) {return(mpz_to_big_integer(sc, *val));}

static s7_pointer string_to_big_ratio(s7_scheme *sc, const char *str, int32_t radix)
{
  s7_pointer x;
  mpq_t n;

  mpq_init(n);
  mpq_set_str(n, str, radix);
  mpq_canonicalize(n);

  if (mpz_cmp_ui(mpq_denref(n), 1) == 0)
    x = mpz_to_big_integer(sc, mpq_numref(n));
  else
    {
      new_cell(sc, x, T_BIG_RATIO);
      add_big_ratio(sc, x);
      mpq_init(big_ratio(x));
      mpq_set_num(big_ratio(x), mpq_numref(n));
      mpq_set_den(big_ratio(x), mpq_denref(n));
    }
  mpq_clear(n);
  return(x);
}

static s7_pointer mpq_to_big_ratio(s7_scheme *sc, mpq_t val)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_RATIO);
  add_big_ratio(sc, x);
  mpq_init(big_ratio(x));
  mpq_set_num(big_ratio(x), mpq_numref(val));
  mpq_set_den(big_ratio(x), mpq_denref(val));
  return(x);
}

s7_pointer s7_make_big_ratio(s7_scheme *sc, mpq_t *val) {return(mpq_to_big_ratio(sc, *val));}

static s7_pointer mpz_to_big_ratio(s7_scheme *sc, mpz_t val)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_RATIO);
  add_big_ratio(sc, x);
  mpq_init(big_ratio(x));
  mpq_set_num(big_ratio(x), val);
  return(x);
}

static s7_pointer make_big_integer_or_ratio(s7_scheme *sc, s7_pointer z)
{
  if (mpz_cmp_ui(mpq_denref(big_ratio(z)), 1) == 0)
    return(mpz_to_big_integer(sc, mpq_numref(big_ratio(z))));
  return(z);
}

static s7_pointer string_to_big_real(s7_scheme *sc, const char *str, int32_t radix)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_REAL);
  add_big_real(sc, x);
  mpfr_init_set_str(big_real(x), str, radix, GMP_RNDN);
  return(x);
}

static void mpz_init_set_s7_int(mpz_t n, s7_int uval);

static s7_pointer s7_number_to_big_real(s7_scheme *sc, s7_pointer p)
{
  s7_pointer x;

  new_cell(sc, x, T_BIG_REAL);
  add_big_real(sc, x);

  switch (type(p))
    {
    case T_INTEGER:
      if (sizeof(s7_int) == sizeof(long int))
	mpfr_init_set_si(big_real(x), integer(p), GMP_RNDN);
      else mpfr_init_set_ld(big_real(x), (long_double)integer(p), GMP_RNDN);
      break;

    case T_RATIO:
      /* here we can't use fraction(number(p)) even though that uses long double division because
       *   there are lots of int64_t ratios that will still look the same.
       *   We have to do the actual bignum divide by hand.
       */
      {
	mpq_t rat;
	mpz_t n1, d1;

	mpz_init_set_s7_int(n1, numerator(p));
	mpz_init_set_s7_int(d1, denominator(p));
	mpq_init(rat);

	mpq_set_num(rat, n1);
	mpq_set_den(rat, d1);
	mpq_canonicalize(rat);
	mpfr_init_set_q(big_real(x), rat, GMP_RNDN);

	mpz_clear(n1);
	mpz_clear(d1);
	mpq_clear(rat);
      }
      break;

    default:
      mpfr_init_set_d(big_real(x), s7_real(p), GMP_RNDN);
      break;
    }
  return(x);
}

static s7_pointer mpz_to_big_real(s7_scheme *sc, mpz_t val)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_REAL);
  add_big_real(sc, x);
  mpfr_init_set_z(big_real(x), val, GMP_RNDN);
  return(x);
}

static s7_pointer mpq_to_big_real(s7_scheme *sc, mpq_t val)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_REAL);
  add_big_real(sc, x);
  mpfr_init_set_q(big_real(x), val, GMP_RNDN);
  return(x);
}

static s7_pointer mpfr_to_big_real(s7_scheme *sc, mpfr_t val)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_REAL);
  add_big_real(sc, x);
  mpfr_init_set(big_real(x), val, GMP_RNDN);
  return(x);
}

s7_pointer s7_make_big_real(s7_scheme *sc, mpfr_t *val)
{
  return(mpfr_to_big_real(sc, *val));
}

static s7_pointer big_pi(s7_scheme *sc)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_REAL);
  add_big_real(sc, x);
  mpfr_init(big_real(x));
  mpfr_const_pi(big_real(x), GMP_RNDN);
  return(x);
}

static s7_pointer s7_number_to_big_complex(s7_scheme *sc, s7_pointer p)
{
  s7_pointer x;
  new_cell(sc, x, T_BIG_COMPLEX);
  add_big_complex(sc, x);
  mpc_init(big_complex(x));

  switch (type(p))
    {
    case T_INTEGER:
      if (sizeof(s7_int) == sizeof(long int))
	mpc_set_si(big_complex(x), integer(p), MPC_RNDNN);
      else mpc_set_d(big_complex(x), (double)integer(p), MPC_RNDNN);
      break;

    case T_RATIO:
      /* can't use fraction here */
      {
	mpfr_t temp;
	mpq_t rat;
	mpz_t n1, d1;

	mpz_init_set_s7_int(n1, numerator(p));
	mpz_init_set_s7_int(d1, denominator(p));
	mpq_init(rat);

	mpq_set_num(rat, n1);
	mpq_set_den(rat, d1);
	mpq_canonicalize(rat);
	mpfr_init_set_q(temp, rat, GMP_RNDN);
	mpc_set_fr(big_complex(x), temp, MPC_RNDNN);

	mpz_clear(n1);
	mpz_clear(d1);
	mpq_clear(rat);
	mpfr_clear(temp);
      }
      break;

    case T_REAL:
      mpc_set_d(big_complex(x), s7_real(p), MPC_RNDNN);
      break;

    default:
      mpc_set_d_d(big_complex(x), real_part(p), imag_part(p), MPC_RNDNN);
      break;
    }
  return(x);
}

static s7_pointer make_big_real_or_complex(s7_scheme *sc, s7_pointer z)
{
  double ipart;

  ipart = mpfr_get_d(mpc_imagref(big_complex(z)), GMP_RNDN);
  /* not mpfr_cmp_ui to 0 here because that misleads us when imag_part is NaN or inf */
  if (ipart == 0.0)
    return(mpfr_to_big_real(sc, mpc_realref(big_complex(z))));
  return(z);
}

static s7_pointer mpz_to_big_complex(s7_scheme *sc, mpz_t val)
{
  mpfr_t temp;
  s7_pointer x;

  new_cell(sc, x, T_BIG_COMPLEX);
  add_big_complex(sc, x);
  mpc_init(big_complex(x));
  mpfr_init_set_z(temp, val, GMP_RNDN);
  mpc_set_fr(big_complex(x), temp, MPC_RNDNN);

  mpfr_clear(temp);
  return(x);
}

static s7_pointer mpq_to_big_complex(s7_scheme *sc, mpq_t val)
{
  mpfr_t temp;
  s7_pointer x;

  new_cell(sc, x, T_BIG_COMPLEX);
  add_big_complex(sc, x);
  mpc_init(big_complex(x));
  mpfr_init_set_q(temp, val, GMP_RNDN);
  mpc_set_fr(big_complex(x), temp, MPC_RNDNN);

  mpfr_clear(temp);
  return(x);
}

static s7_pointer mpfr_to_big_complex(s7_scheme *sc, mpfr_t val)
{
  s7_pointer x;

  new_cell(sc, x, T_BIG_COMPLEX);
  add_big_complex(sc, x);
  mpc_init(big_complex(x));
  mpc_set_fr(big_complex(x), val, MPC_RNDNN);
  return(x);
}

static s7_pointer mpc_to_big_complex(s7_scheme *sc, mpc_t val)
{
  s7_pointer x;

  new_cell(sc, x, T_BIG_COMPLEX);
  add_big_complex(sc, x);
  mpc_init(big_complex(x));
  mpc_set(big_complex(x), val, MPC_RNDNN);
  return(x);
}

s7_pointer s7_make_big_complex(s7_scheme *sc, mpc_t *val)
{
  return(mpc_to_big_complex(sc, *val));
}

static s7_pointer make_big_complex(s7_scheme *sc, mpfr_t rl, mpfr_t im)
{
  /* there is no mpc_get_str equivalent, so we need to split up str,
   *   use make_big_real to get the 2 halves, then mpc_init, then
   *   mpc_set_fr_fr.
   */
  s7_pointer x;

  new_cell(sc, x, T_BIG_COMPLEX);
  add_big_complex(sc, x);
  mpc_init(big_complex(x));
  mpc_set_fr_fr(big_complex(x), rl ,im, MPC_RNDNN);
  return(x);
}

/* gmp.h mpz_init_set_si the "si" part is "signed long int", so in 64-bit machines, s7_int already fits (if it's int64_t).
 *   I guess we can catch the 4-byte long int32_t (since no configure script) by noticing that sizeof(s7_int) == sizeof(long int)?
 */

static void mpz_init_set_s7_int(mpz_t n, s7_int uval)
{
  if (sizeof(s7_int) == sizeof(long int))
    mpz_init_set_si(n, uval);
  else
    {
      /* int64_t to gmp mpz_t */
      bool need_sign;
      int64_t val;
      val = (int64_t)uval;
      if (val == s7_int_min) /* handle one special case (sigh) */
	mpz_init_set_str(n, "-9223372036854775808", 10);
      else
	{
	  need_sign = (val < 0);
	  if (need_sign) val = -val;
	  mpz_init_set_si(n, val >> 32);
	  mpz_mul_2exp(n, n, 32);
	  mpz_add_ui(n, n, (uint32_t)(val & 0xffffffff));
	  if (need_sign) mpz_neg(n, n);
	}
    }
}

static s7_pointer s7_int_to_big_integer(s7_scheme *sc, s7_int val)
{
  s7_pointer x;

  new_cell(sc, x, T_BIG_INTEGER);
  mpz_init_set_s7_int(big_integer(x), val);
  add_big_integer(sc, x);
  return(x);
}

static s7_int big_integer_to_s7_int(mpz_t n)
{
  int64_t high, low;
  mpz_t x;
  bool need_sign = false;

  if (mpz_fits_slong_p(n))
    return(mpz_get_si(n));

  mpz_init_set(x, n);
  if (mpz_cmp_ui(x, 0) < 0)
    {
      need_sign = true;
      mpz_neg(x, x);
    }
  low = mpz_get_ui(x);
  if (low == s7_int_min)
    return(s7_int_min);

  mpz_fdiv_q_2exp(x, x, 32);
  high = mpz_get_ui(x);

  if (high > (1LL << 31)) /* most callers of this function do not take sc as an argument and are in s7.h (s7_integer for example) */
    s7_error(cur_sc, cur_sc->out_of_range_symbol,
	     set_elist_2(cur_sc, wrap_string(cur_sc, "big int does not fit in s7_int: ~S", 34),
			 mpz_to_big_integer(cur_sc, n)));
  mpz_clear(x);
  if (need_sign)
    return(-(low + (high << 32)));
  return(low + (high << 32));
}

static mpq_t *s7_ints_to_mpq(s7_int num, s7_int den)
{
  /* den here always comes from denominator(x) so it is not negative */
  mpq_t *n;
  n = (mpq_t *)malloc(sizeof(mpq_t));
  mpq_init(*n);
  if (sizeof(s7_int) == sizeof(long int))
    mpq_set_si(*n, num, den);
  else
    {
      mpz_t n1, d1;
      mpz_init_set_s7_int(n1, num);
      mpz_init_set_s7_int(d1, den);
      mpq_set_num(*n, n1);
      mpq_set_den(*n, d1);
      mpq_canonicalize(*n);
      mpz_clear(n1);
      mpz_clear(d1);
    }
  return(n);
}

static mpfr_t *s7_double_to_mpfr(s7_double val)
{
  mpfr_t *n;
  n = (mpfr_t *)malloc(sizeof(mpfr_t));
  mpfr_init_set_d(*n, val, GMP_RNDN);
  return(n);
}

static mpc_t *s7_doubles_to_mpc(s7_double rl, s7_double im)
{
  mpc_t *n;
  n = (mpc_t *)malloc(sizeof(mpc_t));
  mpc_init(*n);
  mpc_set_d_d(*n, rl, im, MPC_RNDNN);
  return(n);
}

static s7_pointer s7_ratio_to_big_ratio(s7_scheme *sc, s7_int num, s7_int den)
{
  /* den here always comes from denominator(x) or some positive constant so it is not negative */
  s7_pointer x;
  new_cell(sc, x, T_BIG_RATIO);
  add_big_ratio(sc, x);
  mpq_init(big_ratio(x));
  if (sizeof(s7_int) == sizeof(long int))
    mpq_set_si(big_ratio(x), num, den);
  else
    {
      mpz_t n1, d1;
      mpz_init_set_s7_int(n1, num);
      mpz_init_set_s7_int(d1, den);
      mpq_set_num(big_ratio(x), n1);
      mpq_set_den(big_ratio(x), d1);
      mpq_canonicalize(big_ratio(x));
      mpz_clear(n1);
      mpz_clear(d1);
    }
  return(x);
}

static bool big_numbers_are_eqv(s7_pointer a, s7_pointer b)
{
  bool result;
  /* either or both can be big here, but not neither */

  if (s7_is_integer(a))
    {
      mpz_t a1, b1;
      if (!(s7_is_integer(b))) return(false);

      if ((is_big_number(a)) && (is_big_number(b)))
	return(mpz_cmp(big_integer(a), big_integer(b)) == 0);

      if (is_big_number(a))
	mpz_init_set(a1, big_integer(a));
      else mpz_init_set_s7_int(a1, s7_integer(a));

      if (is_big_number(b))
	mpz_init_set(b1, big_integer(b));
      else mpz_init_set_s7_int(b1, s7_integer(b));
      result = (mpz_cmp(a1, b1) == 0);

      mpz_clear(a1);
      mpz_clear(b1);
      return(result);
    }

  if (s7_is_ratio(a))
    {
      mpq_t *a1, *b1;
      if (!s7_is_ratio(b)) return(false);

      if ((is_big_number(a)) && (is_big_number(b)))
	return(mpq_cmp(big_ratio(a), big_ratio(b)) == 0);

      if (is_big_number(a))
	a1 = &big_ratio(a);
      else a1 = s7_ints_to_mpq(numerator(a), denominator(a));
      if (is_big_number(b))
	b1 = &big_ratio(b);
      else b1 = s7_ints_to_mpq(numerator(b), denominator(b));

      result = (mpq_cmp(*a1, *b1) == 0);

      if (!is_big_number(a))
	{
	  mpq_clear(*a1);
	  free(a1);
	}
      if (!is_big_number(b))
	{
	  mpq_clear(*b1);
	  free(b1);
	}
      return(result);
    }

  if (s7_is_real(a))
    {
      mpfr_t *a1, *b1;

      /* s7_is_real is not finicky enough here -- (eqv? 1.0 1) should return #f */
      if (is_big_number(b))
	{
	  if (type(b) != T_BIG_REAL)
	    return(false);
	}
      else
	{
	  if (type(b) != T_REAL)
	    return(false);
	}

      if ((is_big_number(a)) && (is_big_number(b)))
	return(mpfr_equal_p(big_real(a), big_real(b)));

      if (is_big_number(a))
	a1 = &big_real(a);
      else a1 = s7_double_to_mpfr(s7_real(a));

      if (is_big_number(b))
	b1 = &big_real(b);
      else b1 = s7_double_to_mpfr(s7_real(b));

      result = (mpfr_cmp(*a1, *b1) == 0);

      if (!is_big_number(a))
	{
	  mpfr_clear(*a1);
	  free(a1);
	}
      if (!is_big_number(b))
	{
	  mpfr_clear(*b1);
	  free(b1);
	}
      return(result);
    }

  if (s7_is_complex(a))
    {
      mpc_t *a1, *b1;
      /* s7_is_complex is not finicky enough here */

      if ((type(b) != T_BIG_COMPLEX) &&
	  (type(b) != T_COMPLEX))
	return(false);

      /* (eqv? (bignum "1+i") 1+1i) */
      if ((is_big_number(a)) && (is_big_number(b)))
	return(mpc_cmp(big_complex(a), big_complex(b)) == 0);

      if (is_big_number(a))
	a1 = &big_complex(a);
      else a1 = s7_doubles_to_mpc(real_part(a), imag_part(a));

      if (is_big_number(b))
	b1 = &big_complex(b);
      else b1 = s7_doubles_to_mpc(real_part(b), imag_part(b));

      result = (mpc_cmp(*a1, *b1) == 0);

      if (!is_big_number(a))
	{
	  mpc_clear(*a1);
	  free(a1);
	}
      if (!is_big_number(b))
	{
	  mpc_clear(*b1);
	  free(b1);
	}
      return(result);
    }
  return(false);
}

static s7_pointer string_to_either_integer(s7_scheme *sc, const char *str, int32_t radix)
{
  s7_int val;
  bool overflow = false;

  val = string_to_integer(str, radix, &overflow);
  if (!overflow)
    return(make_integer(sc, val));

  return(string_to_big_integer(sc, str, radix));
}

static s7_pointer string_to_either_ratio(s7_scheme *sc, const char *nstr, const char *dstr, int32_t radix)
{
  s7_int n, d;
  bool overflow = false;

  /* gmp segfaults if passed a bignum/0 so this needs to check first that
   *   the denominator is not 0 before letting gmp screw up.  Also, if the
   *   first character is '+', gmp returns 0!
   */
  d = string_to_integer(dstr, radix, &overflow);
  if (!overflow)
    {
      if (d == 0)
	return(real_NaN);

      n = string_to_integer(nstr, radix, &overflow);
      if (!overflow)
	return(s7_make_ratio(sc, n, d));
    }
  if (nstr[0] == '+')
    return(string_to_big_ratio(sc, (const char *)(nstr + 1), radix));
  return(string_to_big_ratio(sc, nstr, radix));
}

static s7_pointer string_to_either_real(s7_scheme *sc, const char *str, int32_t radix)
{
  bool overflow = false;
  s7_double val;

  val = string_to_double_with_radix((char *)str, radix, &overflow);
  if (!overflow)
    return(make_real(sc, val));

  return(string_to_big_real(sc, str, radix));
}

static s7_pointer string_to_either_complex_1(s7_scheme *sc, char *q, char *slash1, char *ex1, bool has_dec_point1, int32_t radix, s7_double *d_rl)
{
  bool overflow = false;
  /* there's a real problem here -- we don't want to promote s7_double .1 to a bignum because
   *    its low order digits are garbage, causing (rationalize .1 0) to return 3602879701896397/36028797018963968
   *    no matter what the bignum-precision.  But we can't just fallback on gmp's reader because (for example)
   *    it reads 1/2+i or 1+0/0i as 1.0.  Also format gets screwed up.  And string->number signals an error
   *    where it should return #f.  I wonder what to do.
   */
  if ((has_dec_point1) ||
      (ex1))
    {
      (*d_rl) = string_to_double_with_radix(q, radix, &overflow);
      if (overflow)
	return(string_to_big_real(sc, q, radix));
    }
  else
    {
      if (slash1)
	{
	  s7_int n, d;

	  /* q can include the slash and denominator */
	  n = string_to_integer(q, radix, &overflow);
	  if (overflow)
	    return(string_to_big_ratio(sc, q, radix));
	  d = string_to_integer(slash1, radix, &overflow);
	  if (!overflow)
	    (*d_rl) = (s7_double)n / (s7_double)d;
	  else return(string_to_big_ratio(sc, q, radix));
	}
      else
	{
	  s7_int val;

	  val = string_to_integer(q, radix, &overflow);
	  if (overflow)
	    return(string_to_big_integer(sc, q, radix));
	  (*d_rl) = (s7_double)val;
	}
    }
  if ((*d_rl) == -0.0) (*d_rl) = 0.0;
  return(NULL);
}

static s7_pointer string_to_either_complex(s7_scheme *sc, char *q, char *slash1, char *ex1, bool has_dec_point1,
					   char *plus, char *slash2, char *ex2, bool has_dec_point2,
					   int32_t radix, int32_t has_plus_or_minus)
{
  /* this can be just about anything involving 2 real/ratio/int portions, +/- in between and 'i' at the end */
  double d_rl = 0.0, d_im = 0.0;
  s7_pointer p_rl = NULL, p_im = NULL, result;
  mpfr_t m_rl, m_im;

  p_rl = string_to_either_complex_1(sc, q, slash1, ex1, has_dec_point1, radix, &d_rl);
  p_im = string_to_either_complex_1(sc, plus, slash2, ex2, has_dec_point2, radix, &d_im);

  if (d_im == 0.0)
    {
      /* 1.0+0.0000000000000000000000000000i */
      if ((!p_im) ||
	  (s7_is_zero(p_im)))
	{
	  if (!p_rl)
	    return(make_real(sc, d_rl));
	  return(p_rl);
	}
    }

  if ((!p_rl) && (!p_im))
    return(s7_make_complex(sc, d_rl, (has_plus_or_minus == -1) ? (-d_im) : d_im));

  if (p_rl)
    mpfr_init_set(m_rl, big_real(promote_number(sc, T_BIG_REAL, p_rl)), GMP_RNDN);
  else mpfr_init_set_d(m_rl, d_rl, GMP_RNDN);

  if (p_im)
    mpfr_init_set(m_im, big_real(promote_number(sc, T_BIG_REAL, p_im)), GMP_RNDN);
  else mpfr_init_set_d(m_im, d_im, GMP_RNDN);

  if (has_plus_or_minus == -1)
    mpfr_neg(m_im, m_im, GMP_RNDN);

  result = make_big_complex(sc, m_rl, m_im);

  mpfr_clear(m_rl);
  mpfr_clear(m_im);
  return(result);
}

static int32_t big_type_to_result_type(int32_t cur_type, int32_t next_type)
{
  if ((cur_type == T_BIG_COMPLEX) ||
      (cur_type == T_COMPLEX) ||
      (next_type == T_BIG_COMPLEX))
    return(T_BIG_COMPLEX);

  if ((cur_type == T_BIG_REAL) ||
      (cur_type == T_REAL) ||
      (next_type == T_BIG_REAL))
    return(T_BIG_REAL);

  if ((cur_type == T_BIG_RATIO) ||
      (cur_type == T_RATIO) ||
      (next_type == T_BIG_RATIO))
    return(T_BIG_RATIO);

  return(T_BIG_INTEGER);
}

static int32_t normal_type_to_result_type(int32_t cur_type, int32_t next_type)
{
  if (cur_type > T_COMPLEX)
    next_type += 4;
  if (cur_type > next_type)
    return(cur_type);
  return(next_type);
}

static s7_pointer promote_number_1(s7_scheme *sc, int32_t type, s7_pointer x, bool copy)
{
  /* x can be any number -- need to convert it to the current result type */
  switch (type)
    {
    case T_BIG_INTEGER:
      if (is_big_number(x))
	{
	  if (copy)
	    return(mpz_to_big_integer(sc, big_integer(x)));
	  return(x);                       /* can only be T_BIG_INTEGER here */
	}
      return(s7_int_to_big_integer(sc, s7_integer(x))); /* can only be integer here */

    case T_BIG_RATIO:
      if (is_big_number(x))
	{
	  if (is_t_big_ratio(x))
	    {
	      if (copy)
		return(mpq_to_big_ratio(sc, big_ratio(x)));
	      return(x);
	    }
	  return(mpz_to_big_ratio(sc, big_integer(x)));
	}
      if (is_t_integer(x))
	return(s7_ratio_to_big_ratio(sc, integer(x), 1));
      return(s7_ratio_to_big_ratio(sc, numerator(x), denominator(x)));

    case T_BIG_REAL:
      if (is_big_number(x))
	{
	  if (is_t_big_real(x))
	    {
	      if (copy)
		return(mpfr_to_big_real(sc, big_real(x)));
	      return(x);
	    }
	  if (is_t_big_ratio(x))
	    return(mpq_to_big_real(sc, big_ratio(x)));
	  return(mpz_to_big_real(sc, big_integer(x)));
	}
      return(s7_number_to_big_real(sc, x));

    default:
      if (is_big_number(x))
	{
	  if (is_t_big_complex(x))
	    {
	      if (copy)
		return(mpc_to_big_complex(sc, big_complex(x)));
	      return(x);
	    }
	  if (is_t_big_real(x))
	    return(mpfr_to_big_complex(sc, big_real(x)));
	  if (is_t_big_ratio(x))
	    return(mpq_to_big_complex(sc, big_ratio(x)));
	  return(mpz_to_big_complex(sc, big_integer(x)));
	}
      return(s7_number_to_big_complex(sc, x));
    }
  return(sc->nil);
}

static s7_pointer promote_number(s7_scheme *sc, int32_t type, s7_pointer x)
{
  return(promote_number_1(sc, type, x, false));
}

static s7_pointer to_big(s7_scheme *sc, s7_pointer x)
{
  if (is_big_number(x))
    return(x);
  switch (type(x))
    {
    case T_INTEGER: return(s7_int_to_big_integer(sc, integer(x)));
    case T_RATIO:   return(s7_ratio_to_big_ratio(sc, numerator(x), denominator(x)));
    case T_REAL:    return(s7_number_to_big_real(sc, x));
    default:        return(s7_number_to_big_complex(sc, x));
    }
}

static s7_pointer copy_and_promote_number(s7_scheme *sc, int32_t type, s7_pointer x)
{
  return(promote_number_1(sc, type, x, true));
}

void s7_vector_fill(s7_scheme *sc, s7_pointer vec, s7_pointer obj)
{
  /* if the same bignum object is assigned to each element, different vector elements
   *    are actually the same -- we need to make a copy of obj for each one
   */
  if ((is_normal_vector(vec)) &&
      (!is_typed_vector(vec)) &&
      (is_big_number(obj)))
    {
      s7_int gc_loc;
      s7_int i, len;
      s7_pointer *tp;

      len = vector_length(vec);
      tp = (s7_pointer *)(vector_elements(vec));

      /* we'll be calling new_cell below, hence the GC, so make sure the elements are markable,
       *   and the vector itself is GC protected (we can be called within make-vector).
       */
      gc_loc = s7_gc_protect_1(sc, vec);
      vector_fill(sc, vec, sc->nil);

      switch (type(obj))
	{
	case T_BIG_INTEGER: for (i = 0; i < len; i++) tp[i] = mpz_to_big_integer(sc, big_integer(obj)); break;
	case T_BIG_RATIO:   for (i = 0; i < len; i++) tp[i] = mpq_to_big_ratio(sc, big_ratio(obj));     break;
	case T_BIG_REAL:    for (i = 0; i < len; i++) tp[i] = mpfr_to_big_real(sc, big_real(obj));      break;
	default:  	    for (i = 0; i < len; i++) tp[i] = mpc_to_big_complex(sc, big_complex(obj)); break;
	}
      s7_gc_unprotect_at(sc, gc_loc);
    }
  else vector_fill(sc, vec, obj);
}

static s7_pointer big_bignum(s7_scheme *sc, s7_pointer args)
{
  #define H_bignum "(bignum val (radix 10)) returns a multiprecision version of the string 'val'"
  #define Q_bignum s7_make_signature(sc, 3, sc->is_bignum_symbol, sc->is_number_symbol, sc->is_integer_symbol)
  s7_pointer p;

  p = g_string_to_number_1(sc, args, sc->bignum_symbol);
  if (is_false(sc, p))                                       /* (bignum "1/3.0") */
    s7_error(sc, make_symbol(sc, "bignum-error"),
	     set_elist_2(sc, wrap_string(sc, "bignum argument does not represent a number: ~S", 47), car(args)));

  switch (type(p))
    {
    case T_INTEGER:
      return(promote_number(sc, T_BIG_INTEGER, p));

    case T_RATIO:
      return(promote_number(sc, T_BIG_RATIO, p));

      /* we can't use promote_number here because it propagates C-double inaccuracies
       *    (rationalize (bignum "0.1") 0) should return 1/10 not 3602879701896397/36028797018963968
       */
    case T_REAL:
      if (is_NaN(real(p))) return(p);
      return(string_to_big_real(sc, string_value(car(args)), (is_pair(cdr(args))) ? s7_integer(cadr(args)) : 10));

    case T_COMPLEX:
      return(promote_number(sc, T_BIG_COMPLEX, p));

    default:
      return(p);
    }
}

bool s7_is_bignum(s7_pointer obj) {return(is_big_number(obj));}

static s7_pointer big_is_bignum(s7_scheme *sc, s7_pointer args)
{
  #define H_is_bignum "(bignum? obj) returns #t if obj is a multiprecision number."
  #define Q_is_bignum sc->pl_bt
  return(s7_make_boolean(sc, is_big_number(car(args))));
}

#define get_result_type(Sc, Type, P) \
  ((is_number(P)) ? normal_type_to_result_type(Type, type(P)) : ((is_big_number(P)) ? big_type_to_result_type(Type, type(P)) : result_type_via_method(Sc, Type, P)))

static int32_t result_type_via_method(s7_scheme *sc, int32_t result_type, s7_pointer p)
{
  s7_pointer f;
  if (!has_active_methods(sc, p)) return(-1);

  f = find_method(sc, find_let(sc, p), sc->is_integer_symbol);
  if ((f != sc->undefined) &&
      (is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil)))))
    return(big_type_to_result_type(result_type, T_BIG_INTEGER));

  f = find_method(sc, find_let(sc, p), sc->is_rational_symbol);
  if ((f != sc->undefined) &&
      (is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil)))))
    return(big_type_to_result_type(result_type, T_BIG_RATIO));

  f = find_method(sc, find_let(sc, p), sc->is_real_symbol);
  if ((f != sc->undefined) &&
      (is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil)))))
    return(big_type_to_result_type(result_type, T_BIG_REAL));

  /* might be a number, but not complex (quaternion) */
  f = find_method(sc, find_let(sc, p), sc->is_complex_symbol);
  if ((f != sc->undefined) &&
      (is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil)))))
    return(big_type_to_result_type(result_type, T_BIG_COMPLEX));

  return(-1);
}

static s7_pointer copy_args_if_needed(s7_scheme *sc, s7_pointer args)
{
  s7_pointer x;
  for (x = args; is_pair(x); x = cdr(x))
    if ((!is_number(car(x))) &&
	(!is_big_number(car(x))))
      break;
  if (is_pair(x))
    {
      args = copy_list(sc, args);
      sc->w = args;
    }
  return(args);
}

static s7_pointer big_add(s7_scheme *sc, s7_pointer args)
{
  int32_t result_type = T_INTEGER;
  s7_pointer x, result;

  if (is_null(args))
    return(small_int(0));
  if (is_null(cdr(args)))
    {
      if (s7_is_number(car(args)))
	return(car(args));
      return(method_or_bust_with_type_one_arg(sc, car(args), sc->add_symbol, args, a_number_string));
    }

  args = copy_args_if_needed(sc, args);
  for (x = args; is_not_null(x); x = cdr(x))
    {
      s7_pointer p;
      p = car(x);
      result_type = get_result_type(sc, result_type, p);
      if (result_type < 0) /* it still might be a number (quaternion) */
	s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "+: non-numeric arg, ~A", 22), args));
    }

  if (result_type < T_BIG_INTEGER)
    return(g_add(sc, args));
  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->add_symbol, args);
  result = copy_and_promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      s7_pointer arg;
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->add_symbol, cons(sc, result, x));

      arg = promote_number(sc, result_type, car(x));

      switch (result_type)
	{
	case T_BIG_INTEGER: mpz_add(big_integer(result), big_integer(result), big_integer(arg));             break;
	case T_BIG_RATIO:   mpq_add(big_ratio(result), big_ratio(result), big_ratio(arg));                   break;
	case T_BIG_REAL:    mpfr_add(big_real(result), big_real(result), big_real(arg), GMP_RNDN);           break;
	case T_BIG_COMPLEX: mpc_add(big_complex(result), big_complex(result), big_complex(arg), MPC_RNDNN);  break;
	}
    }

  switch (result_type)
      {
      case T_BIG_RATIO:	  return(make_big_integer_or_ratio(sc, result));
      case T_BIG_COMPLEX: return(make_big_real_or_complex(sc, result));
      }
  return(result);
}

static s7_pointer big_negate(s7_scheme *sc, s7_pointer args)
{
  /* assume cdr(args) is nil and we're called from subtract, so check for big num else call g_subtract */
  s7_pointer p, x;

  p = car(args);
  switch (type(p))
    {
    case T_BIG_INTEGER:
      x = mpz_to_big_integer(sc, big_integer(p));
      mpz_neg(big_integer(x), big_integer(x));
      return(x);

    case T_BIG_RATIO:
      x = mpq_to_big_ratio(sc, big_ratio(p));
      mpq_neg(big_ratio(x), big_ratio(x));
      return(x);

    case T_BIG_REAL:
      x = mpfr_to_big_real(sc, big_real(p));
      mpfr_neg(big_real(x), big_real(x), GMP_RNDN);
      return(x);

    case T_BIG_COMPLEX:
      x = mpc_to_big_complex(sc, big_complex(p));
      mpc_neg(big_complex(x), big_complex(x), MPC_RNDNN);
      return(x);

    case T_INTEGER:
      if (integer(p) == s7_int_min)
	{
	  x = s7_int_to_big_integer(sc, integer(p));
	  mpz_neg(big_integer(x), big_integer(x));
	  return(x);
	}
      return(make_integer(sc, -integer(p)));

    case T_RATIO:
      return(make_simple_ratio(sc, -numerator(p), denominator(p)));

    case T_REAL:
      return(make_real(sc, -real(p)));

    default:
      return(s7_make_complex(sc, -real_part(p), -imag_part(p)));
    }
}

static s7_pointer big_subtract(s7_scheme *sc, s7_pointer args)
{
  int32_t result_type = T_INTEGER;
  s7_pointer x, result;

  if (!s7_is_number(car(args)))
    return(method_or_bust_with_type(sc, car(args), sc->subtract_symbol, args, a_number_string, 1));
  if (is_null(cdr(args)))
    return(big_negate(sc, args));

  args = copy_args_if_needed(sc, args);
  for (x = args; is_not_null(x); x = cdr(x))
    {
      s7_pointer p;
      p = car(x);
      result_type = get_result_type(sc, result_type, p);
      if (result_type < 0)
	s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "-: non-numeric arg, ~A", 22), args));
    }
  if (result_type < T_BIG_INTEGER)
    return(g_subtract(sc, args));

  result = copy_and_promote_number(sc, result_type, car(args));
  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      s7_pointer arg;
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->subtract_symbol, cons(sc, result, x));
      arg = promote_number(sc, result_type, car(x));

      switch (result_type)
	{
	case T_BIG_INTEGER:  mpz_sub(big_integer(result), big_integer(result), big_integer(arg));	     break;
	case T_BIG_RATIO:    mpq_sub(big_ratio(result),   big_ratio(result),   big_ratio(arg));	             break;
	case T_BIG_REAL:     mpfr_sub(big_real(result),   big_real(result),    big_real(arg), GMP_RNDN);     break;
	case T_BIG_COMPLEX:  mpc_sub(big_complex(result), big_complex(result), big_complex(arg), MPC_RNDNN); break;
	}
    }

  switch (result_type)
    {
      case T_BIG_RATIO:	  return(make_big_integer_or_ratio(sc, result));
      case T_BIG_COMPLEX: return(make_big_real_or_complex(sc, result));
    }
  return(result);
}

static s7_pointer big_multiply(s7_scheme *sc, s7_pointer args)
{
  int32_t result_type = T_INTEGER;
  s7_pointer x, result;

  if (is_null(args))
    return(small_int(1));
  if ((is_null(cdr(args))) && (s7_is_number(car(args))))
    return(car(args));
  args = copy_args_if_needed(sc, args);
  for (x = args; is_not_null(x); x = cdr(x))
    {
      s7_pointer p;
      p = car(x);
      result_type = get_result_type(sc, result_type, p);
      if (result_type < 0)
	s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "*: non-numeric arg, ~A", 22), args));
    }

  if (result_type < T_BIG_INTEGER)
    return(g_multiply(sc, args));

  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->multiply_symbol, args);
  result = copy_and_promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      s7_pointer arg;
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->multiply_symbol, cons(sc, result, x));

      arg = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: mpz_mul(big_integer(result), big_integer(result), big_integer(arg));	    break;
	case T_BIG_RATIO:   mpq_mul(big_ratio(result),   big_ratio(result),   big_ratio(arg));	            break;
	case T_BIG_REAL:    mpfr_mul(big_real(result),   big_real(result),    big_real(arg), GMP_RNDN);     break;
	case T_BIG_COMPLEX: mpc_mul(big_complex(result), big_complex(result), big_complex(arg), MPC_RNDNN); break;
	}
    }

  switch (result_type)
    {
    case T_BIG_RATIO:   return(make_big_integer_or_ratio(sc, result));
    case T_BIG_COMPLEX: return(make_big_real_or_complex(sc, result));
    }
  return(result);
}

static s7_pointer big_invert(s7_scheme *sc, s7_pointer args)
{
  /* assume cdr(args) is nil and we're called from divide, so check for big num else call g_divide */
  s7_pointer p, x;

  p = car(args);
  if (s7_is_zero(p))
    return(division_by_zero_error(sc, sc->divide_symbol, p));

  switch (type(p))
    {
    case T_INTEGER:
      if (integer(p) == s7_int_min)
	{
	  mpz_t n1, d1;

	  new_cell(sc, x, T_BIG_RATIO);
	  add_big_ratio(sc, x);

	  mpz_init_set_s7_int(n1, 1);
	  mpz_init_set_s7_int(d1, s7_int_min);
	  mpq_set_num(big_ratio(x), n1);
	  mpq_set_den(big_ratio(x), d1);
	  mpq_canonicalize(big_ratio(x));
	  mpz_clear(n1);
	  mpz_clear(d1);

	  return(x);
	}
      return(make_simple_ratio(sc, 1, integer(p)));      /* a already checked, not 0 */

    case T_RATIO:   return(make_simple_ratio(sc, denominator(p), numerator(p)));
    case T_REAL:    return(make_real(sc, 1.0 / real(p)));
    case T_COMPLEX: return(complex_invert(sc, p));

    case T_BIG_INTEGER:
      /* p might be 1 or -1 */
      {
	mpz_t n;

	mpz_init_set_si(n, 1);
	if (mpz_cmp(n, big_integer(p)) == 0)
	  {
	    mpz_clear(n);
	    return(small_int(1));
	  }
	mpz_set_si(n, -1);
	if (mpz_cmp(n, big_integer(p)) == 0)
	  {
	    mpz_clear(n);
	    return(minus_one);
	  }

	new_cell(sc, x, T_BIG_RATIO);
	add_big_ratio(sc, x);
	mpq_init(big_ratio(x));

	mpz_set_ui(n, 1);
	mpq_set_num(big_ratio(x), n);
	mpz_clear(n);

	mpq_set_den(big_ratio(x), big_integer(p));
	mpq_canonicalize(big_ratio(x));
	return(x);
      }

    case T_BIG_RATIO:
      {
	mpz_t n;

	mpz_init_set_si(n, 1);
	if (mpz_cmp(n, mpq_numref(big_ratio(p))) == 0)
	  {
	    mpz_clear(n);
	    return(mpz_to_big_integer(sc, mpq_denref(big_ratio(p))));
	  }
	mpz_set_si(n, -1);
	if (mpz_cmp(n, mpq_numref(big_ratio(p))) == 0)
	  {
	    mpz_clear(n);
	    x = mpz_to_big_integer(sc, mpq_denref(big_ratio(p)));
	    mpz_neg(big_integer(x), big_integer(x));
	    return(x);
	  }
	mpz_clear(n);

	new_cell(sc, x, T_BIG_RATIO);
	add_big_ratio(sc, x);

	mpq_init(big_ratio(x));
	mpq_set_num(big_ratio(x), mpq_denref(big_ratio(p)));
	mpq_set_den(big_ratio(x), mpq_numref(big_ratio(p)));
	mpq_canonicalize(big_ratio(x));
	return(x);
      }

    case T_BIG_REAL:
      x = mpfr_to_big_real(sc, big_real(p));
      mpfr_ui_div(big_real(x), 1, big_real(x), GMP_RNDN);
      return(x);

    default:
      x = mpc_to_big_complex(sc, big_complex(p));
      mpc_ui_div(big_complex(x), 1, big_complex(x), MPC_RNDNN);
      return(x);
    }
}

static s7_pointer big_divide(s7_scheme *sc, s7_pointer args)
{
  int32_t result_type = T_INTEGER;
  s7_pointer x, divisor, result;

  if (!s7_is_number(car(args)))
    return(method_or_bust_with_type(sc, car(args), sc->divide_symbol, args, a_number_string, 1));
  if (is_null(cdr(args)))
    return(big_invert(sc, args));
  args = copy_args_if_needed(sc, args);
  for (x = args; is_not_null(x); x = cdr(x))
    {
      s7_pointer p;
      p = car(x);
      /* if divisor is 0, gmp throws an exception and halts s7!
       *   I don't think we can trap gmp errors, and the abort is built into the library code.
       */
      result_type = get_result_type(sc, result_type, p);
      if (result_type < 0)
	s7_error(sc, sc->wrong_type_arg_symbol, set_elist_2(sc, wrap_string(sc, "/: non-numeric arg, ~A", 22), args));
    }
  if (result_type < T_BIG_INTEGER)
    return(g_divide(sc, args));

  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->divide_symbol, args);
  if (!s7_is_number(cadr(args)))
    check_method(sc, cadr(args), sc->divide_symbol, args);

  divisor = copy_and_promote_number(sc, result_type, cadr(args));
  if (s7_is_zero(divisor))
    return(division_by_zero_error(sc, sc->divide_symbol, divisor));

  for (x = cddr(args); is_not_null(x); x = cdr(x))
    {
      s7_pointer arg;
      if (!s7_is_number(car(x)))
	{
	  s7_pointer func;
	  if ((has_active_methods(sc, car(x))) &&
	      ((func = find_method(sc, find_let(sc, car(x)), sc->multiply_symbol)) != sc->undefined))
	    {
	      divisor = s7_apply_function(sc, func, cons(sc, divisor, x));
	      break;
	    }
	}

      arg = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: mpz_mul(big_integer(divisor), big_integer(divisor), big_integer(arg));	      break;
	case T_BIG_RATIO:   mpq_mul(big_ratio(divisor),   big_ratio(divisor),   big_ratio(arg));	      break;
	case T_BIG_REAL:    mpfr_mul(big_real(divisor),   big_real(divisor),    big_real(arg), GMP_RNDN);     break;
	case T_BIG_COMPLEX: mpc_mul(big_complex(divisor), big_complex(divisor), big_complex(arg), MPC_RNDNN); break;
	}
    }

  if (s7_is_zero(divisor))
    return(division_by_zero_error(sc, sc->divide_symbol, args));

  /* it's possible for the divisor to be the wrong type here (if complex multiply -> real for example */
  divisor = promote_number_1(sc, result_type, divisor, false);
  result = copy_and_promote_number(sc, result_type, car(args));

  switch (result_type)
    {
    case T_BIG_INTEGER:
      {
	new_cell(sc, x, T_BIG_RATIO);
	add_big_ratio(sc, x);

	mpq_init(big_ratio(x));
	mpq_set_num(big_ratio(x), big_integer(result));
	mpq_set_den(big_ratio(x), big_integer(divisor));
	mpq_canonicalize(big_ratio(x));

	if (mpz_cmp_ui(mpq_denref(big_ratio(x)), 1) == 0)
	  return(mpz_to_big_integer(sc, mpq_numref(big_ratio(x))));
	return(x);
      }

    case T_BIG_RATIO:
      mpq_div(big_ratio(result), big_ratio(result), big_ratio(divisor));
      return(make_big_integer_or_ratio(sc, result));

    case T_BIG_REAL:
      mpfr_div(big_real(result), big_real(result), big_real(divisor), GMP_RNDN);
      break;

    case T_BIG_COMPLEX:
      mpc_div(big_complex(result), big_complex(result), big_complex(divisor), MPC_RNDNN);
      return(make_big_real_or_complex(sc, result));
    }
  return(result);
}

static s7_pointer big_abs(s7_scheme *sc, s7_pointer args)
{
  #define H_abs "(abs x) returns the absolute value of the real number x"
  #define Q_abs s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_real_symbol)
  s7_pointer p, x;

  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:
      if (integer(p) < 0)
	{
	  if (integer(p) == s7_int_min)
	    {
	      x = s7_int_to_big_integer(sc, integer(p));
	      mpz_neg(big_integer(x), big_integer(x));
	      return(x);
	    }
	  return(make_integer(sc, -integer(p)));
	}
      return(p);

    case T_RATIO:
      if (numerator(p) < 0)
	return(make_simple_ratio(sc, -numerator(p), denominator(p)));
      return(p);

    case T_REAL:
      if (real(p) < 0.0)
	return(make_real(sc, -real(p)));
      return(p);

    case T_BIG_INTEGER:
      x = mpz_to_big_integer(sc, big_integer(p));
      mpz_abs(big_integer(x), big_integer(x));
      return(x);

    case T_BIG_RATIO:
      x = mpq_to_big_ratio(sc, big_ratio(p));
      mpq_abs(big_ratio(x), big_ratio(x));
      return(x);

    case T_BIG_REAL:
      x = mpfr_to_big_real(sc, big_real(p));
      mpfr_abs(big_real(x), big_real(x), GMP_RNDN);
      return(x);

    default:
      return(method_or_bust_one_arg(sc, p, sc->abs_symbol, args, T_REAL));
    }
}

static s7_pointer big_magnitude(s7_scheme *sc, s7_pointer args)
{
  #define H_magnitude "(magnitude z) returns the magnitude of z"
  #define Q_magnitude s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_number_symbol)
  s7_pointer p;

  p = car(args);
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->magnitude_symbol, args, a_number_string));

  if (is_t_big_complex(p))
    {
      mpfr_t n;
      mpfr_init(n);
      mpc_abs(n, big_complex(p), GMP_RNDN);
      p = mpfr_to_big_real(sc, n);
      mpfr_clear(n);
      return(p);
    }

  if (is_t_complex(p))
    return(make_real(sc, hypot(imag_part(p), real_part(p))));

  return(big_abs(sc, args));
}

static s7_pointer big_angle(s7_scheme *sc, s7_pointer args)
{
  #define H_angle "(angle z) returns the angle of z"
  #define Q_angle s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_number_symbol)
  s7_pointer p;

  p = car(args);
  switch (type(p))
    {
    case T_INTEGER:
      if (integer(p) < 0)
	return(real_pi);
      return(small_int(0));

    case T_RATIO:
      if (numerator(p) < 0)
	return(real_pi);
      return(small_int(0));

    case T_REAL:
      if (is_NaN(real(p))) return(p);
      if (real(p) < 0.0)
	return(real_pi);
      return(real_zero);

    case T_COMPLEX:
      return(make_real(sc, atan2(imag_part(p), real_part(p))));

    case T_BIG_INTEGER:
      if (mpz_cmp_ui(big_integer(p), 0) >= 0)
	return(small_int(0));
      return(big_pi(sc));

    case T_BIG_RATIO:
      if (mpq_cmp_ui(big_ratio(p), 0, 1) >= 0)
	return(small_int(0));
      return(big_pi(sc));

    case T_BIG_REAL:
      {
	double x;
	x = mpfr_get_d(big_real(p), GMP_RNDN);
	/* mpfr_get_d returns inf or -inf if the arg is too large for a double */
	if (is_NaN(x)) return(p);
	if (x >= 0.0)
	  return(real_zero);
	return(big_pi(sc));
      }

    case T_BIG_COMPLEX:
      {
	s7_pointer x;
	new_cell(sc, x, T_BIG_REAL);
	add_big_real(sc, x);
	mpfr_init(big_real(x));
	mpc_arg(big_real(x), big_complex(p), GMP_RNDN);
	return(x);
      }

    default:
      return(method_or_bust_with_type_one_arg(sc, p, sc->angle_symbol, args, a_number_string));
    }
}

static s7_pointer c_big_complex(s7_scheme *sc, s7_pointer args)
{
  #define H_complex "(complex x1 x2) returns a complex number with real-part x1 and imaginary-part x2"
  #define Q_complex s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_real_symbol, sc->is_real_symbol)

  s7_pointer p0, p1, p;
  mpfr_t rl, im;
  double x;

  p0 = car(args);
  if (!s7_is_real(p0))
    return(method_or_bust(sc, p0, sc->complex_symbol, args, T_REAL, 1));

  p1 = cadr(args);
  if (!s7_is_real(p1))
    return(method_or_bust(sc, p1, sc->complex_symbol, args, T_REAL, 2));

  if ((!is_big_number(p1)) && (s7_real(p1) == 0.0)) /* imag-part is not bignum and is 0.0 */
    return(p0);

  mpfr_init_set(im, big_real(promote_number(sc, T_BIG_REAL, p1)), GMP_RNDN);
  x = mpfr_get_d(im, GMP_RNDN);
  if (x == 0.0)                                   /* imag-part is bignum 0.0 */
    {
      mpfr_clear(im);
      return(p0);
    }

  mpfr_init_set(rl, big_real(promote_number(sc, T_BIG_REAL, p0)), GMP_RNDN);

  new_cell(sc, p, T_BIG_COMPLEX);
  add_big_complex(sc, p);
  mpc_init(big_complex(p));
  mpc_set_fr_fr(big_complex(p), rl, im, MPC_RNDNN);

  mpfr_clear(rl);
  mpfr_clear(im);
  return(p);
}

/* (make-polar 0 (real-part (log 0))) = 0? or nan? */

#if (!WITH_PURE_S7)
static s7_pointer big_make_polar(s7_scheme *sc, s7_pointer args)
{
  #define H_make_polar "(make-polar mag ang) returns a complex number with magnitude mag and angle ang"
  #define Q_make_polar s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_real_symbol, sc->is_real_symbol)

  s7_pointer p0, p1, p;
  mpfr_t ang, mag, rl, im;
  double x, y;

  p0 = car(args);
  if (!s7_is_real(p0))
    return(method_or_bust(sc, p0, sc->make_polar_symbol, args, T_REAL, 1));

  p1 = cadr(args);
  if (!s7_is_real(p1))
    return(method_or_bust(sc, p1, sc->make_polar_symbol, args, T_REAL, 2));

  mpfr_init_set(ang, big_real(promote_number(sc, T_BIG_REAL, p1)), GMP_RNDN);
  y = mpfr_get_d(ang, GMP_RNDN);

  if (is_NaN(y))
    {
      mpfr_clear(ang);
      return(real_NaN);
    }

  mpfr_init_set(mag, big_real(promote_number(sc, T_BIG_REAL, p0)), GMP_RNDN);
  x = mpfr_get_d(mag, GMP_RNDN);

  if (is_NaN(x))
    {
      mpfr_clear(ang);
      mpfr_clear(mag);
      return(real_NaN);
    }
  if ((x == 0.0) || (y == 0.0))
    {
      mpfr_clear(ang);
      mpfr_clear(mag);
      return(p0);
    }

  mpfr_init_set(im, ang, GMP_RNDN);
  mpfr_sin(im, im, GMP_RNDN);
  mpfr_mul(im, im, mag, GMP_RNDN);

  x = mpfr_get_d(im, GMP_RNDN);
  if (x == 0.0)
    {
      mpfr_clear(im);
      mpfr_clear(ang);
      mpfr_clear(mag);
      return(p0);
    }

  mpfr_init_set(rl, ang, GMP_RNDN);
  mpfr_cos(rl, rl, GMP_RNDN);
  mpfr_mul(rl, rl, mag, GMP_RNDN);

  new_cell(sc, p, T_BIG_COMPLEX);
  add_big_complex(sc, p);
  mpc_init(big_complex(p));
  mpc_set_fr_fr(big_complex(p), rl, im, MPC_RNDNN);

  mpfr_clear(rl);
  mpfr_clear(im);
  mpfr_clear(ang);
  mpfr_clear(mag);
  return(p);
}
#endif

static s7_pointer big_log(s7_scheme *sc, s7_pointer args)
{
  #define H_log "(log z1 (z2 e)) returns log(z1) / log(z2) where z2 (the base) defaults to e: (log 8 2) = 3"
  #define Q_log sc->pcl_n

  /* either arg can be big, second is optional */
  s7_pointer p0, p1 = NULL, p;

  p0 = car(args);
  if (!s7_is_number(p0))
    return(method_or_bust_with_type(sc, p0, sc->log_symbol, args, a_number_string, 1));

  if (is_not_null(cdr(args)))
    {
      p1 = cadr(args);
      if (!s7_is_number(p1))
	return(method_or_bust_with_type(sc, p1, sc->log_symbol, args, a_number_string, 2));
    }

  if ((s7_is_real(p0)) &&
      ((!p1) || (s7_is_real(p1))))
    {
      double x, y = 0.0;

      p0 = promote_number(sc, T_BIG_REAL, p0);
      x = mpfr_get_d(big_real(p0), GMP_RNDN);
      if (is_NaN(x))
	return(real_NaN);

      if (p1)
	{
	  p1 = promote_number(sc, T_BIG_REAL, p1);
	  y = mpfr_get_d(big_real(p1), GMP_RNDN);

	  /* we can't check y here for 1.0 (check for 0.0 apparently is ok):
	   *   (log 100.0 (+ 1.0 (bignum "1e-16"))) -> ;log base, argument 2, 1.000000000000000100000000000000000000002E0, is out of range (can't be 0.0 or 1.0)
	   *   (= 1.0 (+ 1.0 (bignum "1e-16"))) -> #f
	   */
	  if (is_NaN(y))
	    return(real_NaN);
	  if (y == 0.0)
	    return(out_of_range(sc, sc->log_symbol, small_int(2), p1, wrap_string(sc, "argument can't be 0.0", 21)));
	}
      if (x == 0.0)
	return(s7_make_complex(sc, -INFINITY, M_PI));

      if ((x > 0.0) && (y >= 0.0))
	{
	  mpfr_t n, base;

	  mpfr_init_set(n, big_real(p0), GMP_RNDN);
	  mpfr_log(n, n, GMP_RNDN);

	  if (!p1)
	    {
	      /* presumably log is safe with regard to real-part overflow giving a bogus int? */
	      if ((s7_is_rational(car(args))) &&
		  (mpfr_integer_p(n) != 0))
		{
		  new_cell(sc, p, T_BIG_INTEGER);
		  mpz_init(big_integer(p));
		  mpfr_get_z(big_integer(p), n, GMP_RNDN);
		  add_big_integer(sc, p);
		}
	      else p = mpfr_to_big_real(sc, n);
	      mpfr_clear(n);
	      return(p);
	    }

	  mpfr_init_set(base, big_real(p1), GMP_RNDN);
	  mpfr_log(base, base, GMP_RNDN);
	  mpfr_div(n, n, base, GMP_RNDN);
	  mpfr_clear(base);

	  if ((s7_is_rational(car(args))) &&
	      (s7_is_rational(cadr(args))) &&
	      (mpfr_integer_p(n) != 0))
	    {
	      new_cell(sc, p, T_BIG_INTEGER);
	      mpz_init(big_integer(p));
	      mpfr_get_z(big_integer(p), n, GMP_RNDN);
	      add_big_integer(sc, p);
	    }
	  else p = mpfr_to_big_real(sc, n);
	  mpfr_clear(n);
	  return(p);
	}
    }

  p0 = promote_number(sc, T_BIG_COMPLEX, p0);
  if (p1) p1 = promote_number(sc, T_BIG_COMPLEX, p1);
  {
    mpc_t n, base;
    double x;

    mpc_init(n);
    mpc_set(n, big_complex(p0), MPC_RNDNN);
    mpc_log(n, n, MPC_RNDNN);
    if (!p1)
      {
	p = mpc_to_big_complex(sc, n);
	mpc_clear(n);
	return(p);
      }

    mpc_init(base);
    mpc_set(base, big_complex(p1), MPC_RNDNN);
    mpc_log(base, base, MPC_RNDNN);
    mpc_div(n, n, base, MPC_RNDNN);
    mpc_clear(base);

    x = mpfr_get_d(mpc_imagref(n), GMP_RNDN);
    if (x == 0.0)
      p = mpfr_to_big_real(sc, mpc_realref(n));
    else p = mpc_to_big_complex(sc, n);

    mpc_clear(n);
    return(p);
  }
}

static s7_pointer big_sqrt(s7_scheme *sc, s7_pointer args)
{
  /* real >= 0 -> real, else complex */
  #define H_sqrt "(sqrt z) returns the square root of z"
  #define Q_sqrt sc->pcl_n

  s7_pointer p;

  p = car(args);
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->sqrt_symbol, args, a_number_string));
  p = to_big(sc, p);

  /* if big integer, try to return int32_t if perfect square */
  if (is_t_big_integer(p))
    {
      if (mpz_cmp_ui(big_integer(p), 0) < 0)
	p = promote_number(sc, T_BIG_COMPLEX, p);
      else
	{
	  mpz_t n, rem;

	  mpz_init(rem);
	  mpz_init_set(n, big_integer(p));
	  mpz_sqrtrem(n, rem, n);

	  if (mpz_cmp_ui(rem, 0) == 0)
	    {
	      p = mpz_to_big_integer(sc, n);
	      mpz_clear(n);
	      mpz_clear(rem);
	      return(p);
	    }
	  mpz_clear(n);
	  mpz_clear(rem);
	  p = promote_number(sc, T_BIG_REAL, p);
	}
    }

  /* if big ratio, check both num and den for squares */
  if (is_t_big_ratio(p))
    {
      if (mpq_cmp_ui(big_ratio(p), 0, 1) < 0)
	p = promote_number(sc, T_BIG_COMPLEX, p);
      else
	{
	  mpz_t n1, rem;
	  mpz_init(rem);
	  mpz_init_set(n1, mpq_numref(big_ratio(p)));
	  mpz_sqrtrem(n1, rem, n1);

	  if (mpz_cmp_ui(rem, 0) == 0)
	    {
	      mpz_t d1;
	      mpz_init_set(d1, mpq_denref(big_ratio(p)));
	      mpz_sqrtrem(d1, rem, d1);

	      if (mpz_cmp_ui(rem, 0) == 0)
		{
		  mpq_t n;
		  mpq_init(n);
		  mpq_set_num(n, n1);
		  mpq_set_den(n, d1);
		  mpq_canonicalize(n);
		  p = mpq_to_big_ratio(sc, n);
		  mpz_clear(n1);
		  mpz_clear(d1);
		  mpz_clear(rem);
		  mpq_clear(n);
		  return(p);
		}
	      mpz_clear(d1);
	    }

	  mpz_clear(n1);
	  mpz_clear(rem);
	  p = promote_number(sc, T_BIG_REAL, p);
	}
    }

  /* if real and not negative, use mpfr_sqrt */
  if (is_t_big_real(p))
    {
      if (mpfr_cmp_ui(big_real(p), 0) < 0)
	p = promote_number(sc, T_BIG_COMPLEX, p);
      else
	{
	  mpfr_t n;
	  mpfr_init_set(n, big_real(p), GMP_RNDN);
	  mpfr_sqrt(n, n, GMP_RNDN);
	  p = mpfr_to_big_real(sc, n);
	  mpfr_clear(n);
	  return(p);
	}
    }

  /* p is a big number, so it must be complex at this point */
  {
    mpc_t n;
    mpc_init(n);
    mpc_set(n, big_complex(p), MPC_RNDNN);
    mpc_sqrt(n, n, MPC_RNDNN);
    p = mpc_to_big_complex(sc, n);
    mpc_clear(n);
    return(p);
  }
}

enum {TRIG_NO_CHECK, TRIG_TAN_CHECK, TRIG_TANH_CHECK};

static s7_pointer big_trig(s7_scheme *sc, s7_pointer args,
			   int32_t (*mpfr_trig)(mpfr_ptr, mpfr_srcptr, mpfr_rnd_t),
			   int32_t (*mpc_trig)(mpc_ptr, mpc_srcptr, mpc_rnd_t),
			   int32_t tan_case, s7_pointer sym)
/* these declarations mimic the mpfr.h and mpc.h declarations.  It seems to me that they ought to be:
 *    int32_t (*mpfr_trig)(mpfr_t rop, mpfr_t op, mp_rnd_t rnd), void (*mpc_trig)(mpc_t rop, mpc_t op, mpc_rnd_t rnd))
 */
{
  s7_pointer p;
  mpc_t n;
  double ix;
  p = car(args);

  /* I think here we should always promote to bignum (otherwise, for example, (exp 800) -> inf) */
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sym, args, a_number_string));
  if (s7_is_real(p))
    {
      mpfr_t n;
      mpfr_init_set(n, big_real(promote_number(sc, T_BIG_REAL, p)), GMP_RNDN);
      mpfr_trig(n, n, GMP_RNDN);
      /* it's confusing to check for ints here via mpfr_integer_p because it
       *   is dependent on the precision!  (exp 617/5) returns an integer if
       *   precision is 128, but a float if 512.
       */
      p = mpfr_to_big_real(sc, n);
      mpfr_clear(n);
      return(p);
    }

  if (!is_big_number(p))
    p = promote_number(sc, T_BIG_COMPLEX, p);

  if (tan_case == TRIG_TAN_CHECK)
    {
      if ((MPC_INEX_IM(mpc_cmp_si_si(big_complex(p), 1, 350))) > 0)
	return(s7_make_complex(sc, 0.0, 1.0));
      if ((MPC_INEX_IM(mpc_cmp_si_si(big_complex(p), 1, -350))) < 0)
	return(s7_make_complex(sc, 0.0, -1.0));
    }

  if (tan_case == TRIG_TANH_CHECK)
    {
      if ((MPC_INEX_RE(mpc_cmp_si_si(big_complex(p), 350, 1))) > 0)
	return(real_one);
      if ((MPC_INEX_RE(mpc_cmp_si_si(big_complex(p), -350, 1))) < 0)
	return(make_real(sc, -1.0));
    }

  mpc_init(n);
  mpc_trig(n, big_complex(p), MPC_RNDNN);
  /* (sin (bignum "1e15+1e15i")) causes mpc to hang (e9 is ok, but e10 hangs)
   *   (sin (bignum "0+1e10i")) -> 0+inf (sin (bignum "1+1e10i")) hangs
   * before comparing imag-part to 0, we need to look for NaN and inf, else:
   *    (sinh 0+0/0i) -> 0.0 and (sinh (log 0.0)) -> inf.0
   */

  ix = mpfr_get_d(mpc_imagref(n), GMP_RNDN);
  if (ix == 0.0)
    {
      mpfr_t z;
      mpfr_init_set(z, mpc_realref(n), GMP_RNDN);
      p = mpfr_to_big_real(sc, z);
      mpfr_clear(z);
    }
  else p = mpc_to_big_complex(sc, n);
  mpc_clear(n);
  return(p);
}

static s7_pointer big_sin(s7_scheme *sc, s7_pointer args)
{
  #define H_sin "(sin z) returns sin(z)"
  #define Q_sin sc->pcl_n
  return(big_trig(sc, args, mpfr_sin, mpc_sin, TRIG_NO_CHECK, sc->sin_symbol));
}

static s7_pointer big_cos(s7_scheme *sc, s7_pointer args)
{
  #define H_cos "(cos z) returns cos(z)"
  #define Q_cos sc->pcl_n
  return(big_trig(sc, args, mpfr_cos, mpc_cos, TRIG_NO_CHECK, sc->cos_symbol));
}

s7_pointer s7_cos(s7_scheme *sc, s7_pointer x)
{
  return(big_cos(sc, cons(sc, x, sc->nil)));
}

static s7_pointer big_tan(s7_scheme *sc, s7_pointer args)
{
  #define H_tan "(tan z) returns tan(z)"
  #define Q_tan sc->pcl_n
  return(big_trig(sc, args, mpfr_tan, mpc_tan, TRIG_TAN_CHECK, sc->tan_symbol));
}

static s7_pointer big_sinh(s7_scheme *sc, s7_pointer args)
{
  #define H_sinh "(sinh z) returns sinh(z)"
  #define Q_sinh sc->pcl_n
  /* currently (sinh 0+0/0i) -> 0.0? */
  return(big_trig(sc, args, mpfr_sinh, mpc_sinh, TRIG_NO_CHECK, sc->sinh_symbol));
}

static s7_pointer big_cosh(s7_scheme *sc, s7_pointer args)
{
  #define H_cosh "(cosh z) returns cosh(z)"
  #define Q_cosh sc->pcl_n
  return(big_trig(sc, args, mpfr_cosh, mpc_cosh, TRIG_NO_CHECK, sc->cosh_symbol));
}

static s7_pointer big_tanh(s7_scheme *sc, s7_pointer args)
{
  #define H_tanh "(tanh z) returns tanh(z)"
  #define Q_tanh sc->pcl_n
  return(big_trig(sc, args, mpfr_tanh, mpc_tanh, TRIG_TANH_CHECK, sc->tanh_symbol));
}

static s7_pointer big_exp(s7_scheme *sc, s7_pointer args)
{
  #define H_exp "(exp z) returns e^z, (exp 1) is 2.718281828459"
  #define Q_exp sc->pcl_n
  return(big_trig(sc, args, mpfr_exp, mpc_exp, TRIG_NO_CHECK, sc->exp_symbol));
}

static s7_pointer big_expt(s7_scheme *sc, s7_pointer args)
{
  #define H_expt "(expt z1 z2) returns z1^z2"
  #define Q_expt sc->pcl_n

  s7_pointer x, y, p;

  x = car(args);
  if (!s7_is_number(x))
    return(method_or_bust_with_type(sc, x, sc->expt_symbol, args, a_number_string, 1));

  y = cadr(args);
  if (!s7_is_number(y))
    return(method_or_bust_with_type(sc, y, sc->expt_symbol, args, a_number_string, 2));

  if (s7_is_zero(x))
    {
      if ((s7_is_integer(x)) &&
	  (s7_is_integer(y)) &&
	  (s7_is_zero(y)))
	return(small_int(1));

      if (s7_is_real(y))
	{
	  if (s7_is_negative(y))
	    return(division_by_zero_error(sc, sc->expt_symbol, args));
	}
      else
	{
	  if (s7_is_negative(g_real_part(sc, cdr(args))))
	    return(division_by_zero_error(sc, sc->expt_symbol, args));
	}

      if ((s7_is_rational(x)) &&
	  (s7_is_rational(y)))
	return(small_int(0));
      return(real_zero);
    }

  if (s7_is_integer(y))
    {
      s7_int yval;
      yval = s7_integer(y);
      if (yval == 0)
	{
	  if (s7_is_rational(x))
	    return(small_int(1));
	  return(real_one);
	}

      if (yval == 1)
	return(x);

      if (!is_big_number(x))
	{
	  if ((s7_is_one(x)) || (s7_is_zero(x)))
	    return(x);
	}

      if ((yval < s7_int32_max) &&
	  (yval > s7_int32_min))
	{
	  /* (protect against gmp exception if for example (expt 1/9223372036854775807 -9223372036854775807) */
	  if (s7_is_integer(x))
	    {
	      mpz_t n;
	      mpq_t r;

	      x = promote_number(sc, T_BIG_INTEGER, x);
	      mpz_init_set(n, big_integer(x));
	      if (yval >= 0)
		{
		  mpz_pow_ui(n, n, (uint32_t)yval);
		  p = mpz_to_big_integer(sc, n);
		  mpz_clear(n);
		  return(p);
		}

	      mpz_pow_ui(n, n, (uint32_t)(-yval));
	      mpq_init(r);
	      mpq_set_z(r, n);
	      mpq_inv(r, r);
	      if (mpz_cmp_ui(mpq_denref(r), 1) == 0)
		{
		  mpz_t z;
		  mpz_init_set(z, mpq_numref(r));
		  mpq_clear(r);
		  mpz_clear(n);
		  p = mpz_to_big_integer(sc, z);
		  mpz_clear(z);
		  return(p);
		}
	      mpz_clear(n);
	      p = mpq_to_big_ratio(sc, r);
	      mpq_clear(r);
	      return(p);
	    }

	  if (s7_is_ratio(x)) /* here y is an integer */
	    {
	      mpz_t n, d;
	      mpq_t r;

	      x = promote_number(sc, T_BIG_RATIO, x);
	      mpz_init_set(n, mpq_numref(big_ratio(x)));
	      mpz_init_set(d, mpq_denref(big_ratio(x)));
	      mpq_init(r);
	      if (yval >= 0)
		{
		  mpz_pow_ui(n, n, (uint32_t)yval);
		  mpz_pow_ui(d, d, (uint32_t)yval);
		  mpq_set_num(r, n);
		  mpq_set_den(r, d);
		}
	      else
		{
		  yval = -yval;
		  mpz_pow_ui(n, n, (uint32_t)yval);
		  mpz_pow_ui(d, d, (uint32_t)yval);
		  mpq_set_num(r, d);
		  mpq_set_den(r, n);
		  mpq_canonicalize(r);
		}
	      mpz_clear(n);
	      mpz_clear(d);
	      if (mpz_cmp_ui(mpq_denref(r), 1) == 0)
		{
		  mpz_t z;
		  mpz_init_set(z, mpq_numref(r));
		  mpq_clear(r);
		  p = mpz_to_big_integer(sc, z);
		  mpz_clear(z);
		  return(p);
		}
	      p = mpq_to_big_ratio(sc, r);
	      mpq_clear(r);
	      return(p);
	    }

	  if (s7_is_real(x))
	    {
	      mpfr_t z;
	      x = promote_number(sc, T_BIG_REAL, x);
	      mpfr_init_set(z, big_real(x), GMP_RNDN);
	      mpfr_pow_si(z, z, yval, GMP_RNDN);
	      p = mpfr_to_big_real(sc, z);
	      mpfr_clear(z);
	      return(p);
	    }
	}
    }

  if ((is_t_ratio(y)) &&              /* not s7_is_ratio which accepts bignums */
      (numerator(y) == 1))
    {
      if (denominator(y) == 2)
	return(big_sqrt(sc, args));

      if ((s7_is_real(x)) &&
	  (denominator(y) == 3))
	{
	  mpfr_t z;
	  mpfr_init_set(z, big_real(promote_number(sc, T_BIG_REAL, x)), GMP_RNDN);
	  mpfr_cbrt(z, z, GMP_RNDN);
	  p = mpfr_to_big_real(sc, z);
	  mpfr_clear(z);
	  return(p);
	}
    }

  if ((s7_is_real(x)) &&
      (s7_is_real(y)) &&
      (s7_is_positive(x)))
    {
      mpfr_t z;
      mpfr_init_set(z, big_real(promote_number(sc, T_BIG_REAL, x)), GMP_RNDN);
      mpfr_pow(z, z, big_real(promote_number(sc, T_BIG_REAL, y)), GMP_RNDN);
      p = mpfr_to_big_real(sc, z);
      mpfr_clear(z);
      return(p);
    }

  {
    mpc_t cy;
    mpc_t z;

    x = promote_number(sc, T_BIG_COMPLEX, x);
    y = promote_number(sc, T_BIG_COMPLEX, y);

    mpc_init(z);
    mpc_set(z, big_complex(x), MPC_RNDNN);

    if (mpc_cmp_si_si(z, 0, 0) == 0)
      {
	mpc_clear(z);
	return(small_int(0));
      }
    if (mpc_cmp_si_si(z, 1, 0) == 0)
      {
	mpc_clear(z);
	return(small_int(1));
      }

    mpc_init(cy);
    mpc_set(cy, big_complex(y), MPC_RNDNN);
    mpc_pow(z, z, cy, MPC_RNDNN);
    mpc_clear(cy);

    if (mpfr_cmp_ui(mpc_imagref(z), 0) == 0)
      {
	mpfr_t n;
	if ((s7_is_rational(car(args))) &&
	    (s7_is_rational(cadr(args))) &&
	    (mpfr_integer_p(mpc_realref(z)) != 0))
	  {
	    /* mpfr_integer_p can be confused: (expt 2718/1000 (bignum "617/5")) returns an int32_t if precision=128, float if 512 */
	    /*   so first make sure we're within (say) 31 bits */
	    mpfr_t zi;
	    mpfr_init_set_ui(zi, s7_int32_max, GMP_RNDN);
	    if (mpfr_cmpabs(mpc_realref(z), zi) < 0)
	      {
		mpz_t k;
		mpz_init(k);
		mpfr_get_z(k, mpc_realref(z), GMP_RNDN);
		mpc_clear(z);
		mpfr_clear(zi);
		p = mpz_to_big_integer(sc, k);
		mpz_clear(k);
		return(p);
	      }
	    mpfr_clear(zi);
	  }

	mpfr_init_set(n, mpc_realref(z), GMP_RNDN);
	mpc_clear(z);
	p = mpfr_to_big_real(sc, n);
	mpfr_clear(n);
	return(p);
      }

    p = mpc_to_big_complex(sc, z);
    mpc_clear(z);
    return(p);
  }
}

static s7_pointer big_asinh(s7_scheme *sc, s7_pointer args)
{
  #define H_asinh "(asinh z) returns asinh(z)"
  #define Q_asinh sc->pcl_n
  s7_pointer p;
  mpc_t n;

  p = car(args);
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->asinh_symbol, args, a_number_string));

  if (s7_is_real(p))
    {
      mpfr_t n;
      p = promote_number(sc, T_BIG_REAL, p);
      mpfr_init_set(n, big_real(p), GMP_RNDN);
      mpfr_asinh(n, n, GMP_RNDN);
      p = mpfr_to_big_real(sc, n);
      mpfr_clear(n);
      return(p);
    }
  p = promote_number(sc, T_BIG_COMPLEX, p);
  mpc_init(n);
  mpc_set(n, big_complex(p), MPC_RNDNN);
  mpc_asinh(n, n, MPC_RNDNN);
  p = mpc_to_big_complex(sc, n);
  mpc_clear(n);
  return(p);
}

static s7_pointer big_acosh(s7_scheme *sc, s7_pointer args)
{
  #define H_acosh "(acosh z) returns acosh(z)"
  #define Q_acosh sc->pcl_n

  s7_pointer p;
  double x;
  mpc_t n;

  p = car(args);
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->acosh_symbol, args, a_number_string));
  p = promote_number(sc, T_BIG_COMPLEX, p);

  mpc_init(n);
  mpc_set(n, big_complex(p), MPC_RNDNN);
  mpc_acosh(n, n, MPC_RNDNN);

  x = mpfr_get_d(mpc_imagref(n), GMP_RNDN);
  if (x == 0.0)
    p = mpfr_to_big_real(sc, mpc_realref(n));
  else p = mpc_to_big_complex(sc, n);
  mpc_clear(n);
  return(p);
}

static s7_pointer big_atanh(s7_scheme *sc, s7_pointer args)
{
  #define H_atanh "(atanh z) returns atanh(z)"
  #define Q_atanh sc->pcl_n
  s7_pointer p;
  mpc_t n;

  p = car(args);
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->atanh_symbol, args, a_number_string));

  if (s7_is_real(p))
    {
      bool ok;
      mpfr_t temp;
      p = promote_number(sc, T_BIG_REAL, p);
      mpfr_init_set_ui(temp, 1, GMP_RNDN);
      ok = (mpfr_cmpabs(big_real(p), temp) < 0);
      mpfr_clear(temp);
      if (ok)
	{
	  mpfr_t n;
	  mpfr_init_set(n, big_real(p), GMP_RNDN);
	  mpfr_atanh(n, n, GMP_RNDN);
	  p = mpfr_to_big_real(sc, n);
	  mpfr_clear(n);
	  return(p);
	}
    }
  p = promote_number(sc, T_BIG_COMPLEX, p);
  mpc_init(n);
  mpc_set(n, big_complex(p), MPC_RNDNN);
  mpc_atanh(n, n, MPC_RNDNN);
  p = mpc_to_big_complex(sc, n);
  mpc_clear(n);
  return(p);
}

static s7_pointer big_atan(s7_scheme *sc, s7_pointer args)
{
  #define H_atan "(atan z) returns atan(z), (atan y x) returns atan(y/x)"
  #define Q_atan s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_number_symbol, sc->is_real_symbol)
  s7_pointer p0, p1 = NULL, p;
  mpc_t n;

  p0 = car(args);
  if (!s7_is_number(p0))
    return(method_or_bust_with_type_one_arg(sc, p0, sc->atan_symbol, args, a_number_string));

  if (is_not_null(cdr(args)))
    {
      p1 = cadr(args);
      if (!s7_is_real(p1))
	return(method_or_bust(sc, p1, sc->atan_symbol, args, T_REAL, 2));
      if (!s7_is_real(p0))
	return(wrong_type_argument(sc, sc->atan_symbol, 1, p0, T_REAL));
      p1 = promote_number(sc, T_BIG_REAL, p1);
    }

  if (s7_is_real(p0))
    {
      mpfr_t n;
      p0 = promote_number(sc, T_BIG_REAL, p0);
      mpfr_init_set(n, big_real(p0), GMP_RNDN);
      if (!p1)
	mpfr_atan(n, n, GMP_RNDN);
      else mpfr_atan2(n, n, big_real(p1), GMP_RNDN);
      p = mpfr_to_big_real(sc, n);
      mpfr_clear(n);
      return(p);
    }
  p0 = promote_number(sc, T_BIG_COMPLEX, p0);
  mpc_init_set(n, big_complex(p0), MPC_RNDNN);
  mpc_atan(n, n, MPC_RNDNN);
  p = mpc_to_big_complex(sc, n);
  mpc_clear(n);
  return(p);
}

static s7_pointer big_acos(s7_scheme *sc, s7_pointer args)
{
  #define H_acos "(acos z) returns acos(z); (cos (acos 1)) = 1"
  #define Q_acos sc->pcl_n
  s7_pointer p;
  mpc_t n;

  p = car(args);
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->acos_symbol, args, a_number_string));

  if (s7_is_real(p))
    {
      bool ok;
      mpfr_t temp;
      mpfr_t n;
      p = promote_number(sc, T_BIG_REAL, p);
      mpfr_init_set(n, big_real(p), GMP_RNDN);
      mpfr_init_set_ui(temp, 1, GMP_RNDN);
      ok = (mpfr_cmpabs(n, temp) <= 0);
      mpfr_clear(temp);
      if (ok)
	{
	  mpfr_acos(n, n, GMP_RNDN);
	  p = mpfr_to_big_real(sc, n);
	  mpfr_clear(n);
	  return(p);
	}
      mpfr_clear(n);
    }
  p = promote_number(sc, T_BIG_COMPLEX, p);
  mpc_init_set(n, big_complex(p), MPC_RNDNN);
  mpc_acos(n, n, MPC_RNDNN);
  p = mpc_to_big_complex(sc, n);
  mpc_clear(n);
  return(p);
}

static s7_pointer big_asin(s7_scheme *sc, s7_pointer args)
{
  #define H_asin "(asin z) returns asin(z); (sin (asin 1)) = 1"
  #define Q_asin sc->pcl_n
  s7_pointer p;
  mpc_t n;

  p = car(args);
  if (!s7_is_number(p))
    return(method_or_bust_with_type_one_arg(sc, p, sc->asin_symbol, args, a_number_string));

  if (s7_is_real(p))
    {
      bool ok;
      mpfr_t temp;
      mpfr_t n;
      p = promote_number(sc, T_BIG_REAL, p);
      mpfr_init_set(n, big_real(p), GMP_RNDN);
      mpfr_init_set_ui(temp, 1, GMP_RNDN);
      ok = (mpfr_cmpabs(n, temp) <= 0);
      mpfr_clear(temp);
      if (ok)
	{
	  mpfr_asin(n, n, GMP_RNDN);
	  p = mpfr_to_big_real(sc, n);
	  mpfr_clear(n);
	  return(p);
	}
      mpfr_clear(n);
    }
  p = promote_number(sc, T_BIG_COMPLEX, p);
  mpc_init_set(n, big_complex(p), MPC_RNDNN);
  mpc_asin(n, n, MPC_RNDNN);
  p = mpc_to_big_complex(sc, n);
  mpc_clear(n);
  return(p);
}

static s7_pointer big_lognot(s7_scheme *sc, s7_pointer args)
{
  if (is_t_big_integer(car(args)))
    {
      s7_pointer p;
      mpz_t n;
      mpz_init(n);
      mpz_com(n, big_integer(car(args)));
      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }
  return(g_lognot(sc, args));
}

#if (!WITH_PURE_S7)
static s7_pointer big_integer_length(s7_scheme *sc, s7_pointer args)
{
  if (is_t_big_integer(car(args)))
    {
      s7_pointer result;
      mpfr_t n;
      mpfr_init_set_z(n, big_integer(car(args)), GMP_RNDN);
      if (mpfr_cmp_ui(n, 0) < 0)
	mpfr_neg(n, n, GMP_RNDN);
      else mpfr_add_ui(n, n, 1, GMP_RNDN);
      mpfr_log2(n, n, GMP_RNDU);
      result = make_integer(sc, mpfr_get_si(n, GMP_RNDU));
      mpfr_clear(n);
      return(result);
    }
  return(g_integer_length(sc, args));
}
#endif

static s7_pointer big_ash(s7_scheme *sc, s7_pointer args)
{
  s7_pointer p0, p1;

  p0 = car(args);
  p1 = cadr(args);
  /* here, as in expt, there are cases like (ash 1 63) which need to be handled as bignums so there's no way to tell when it's safe to drop into g_ash instead. */
  if ((s7_is_integer(p0)) && /* this includes bignum ints... */
      (s7_is_integer(p1)))
    {
      mpz_t n;
      s7_int shift;
      s7_pointer p;
      bool p0_is_big;
      int32_t p0_compared_to_zero = 0;

      p0_is_big = is_big_number(p0);
      if (p0_is_big)
	p0_compared_to_zero = mpz_cmp_ui(big_integer(p0), 0);
      else
	{
	  if (s7_integer(p0) > 0)
	    p0_compared_to_zero = 1;
	  else
	    {
	      if (s7_integer(p0) < 0)
		p0_compared_to_zero = -1;
	      else p0_compared_to_zero = 0;
	    }
	}

      if (p0_compared_to_zero == 0)
	return(small_int(0));

      if (is_big_number(p1))
	{
	  if (!mpz_fits_sint_p(big_integer(p1)))
	    {
	      if (mpz_cmp_ui(big_integer(p1), 0) > 0)
		return(out_of_range(sc, sc->ash_symbol, small_int(2), p1, its_too_large_string));

	      /* here if p0 is negative, we need to return -1 */
	      if (p0_compared_to_zero == 1)
		return(small_int(0));
	      return(minus_one);
	    }
	  shift = mpz_get_si(big_integer(p1));
	}
      else
	{
	  shift = s7_integer(p1);
	  if (shift < s7_int32_min)
	    {
	      if (p0_compared_to_zero == 1)
		return(small_int(0));
	      return(minus_one);
	    }
	}

      mpz_init_set(n, big_integer(promote_number(sc, T_BIG_INTEGER, p0)));
      if (shift > 0)     /* left */
	mpz_mul_2exp(n, n, shift);
      else
	{
	  if (shift < 0) /* right */
	    mpz_fdiv_q_2exp(n, n, (uint32_t)(-shift));
	}
      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }
  return(g_ash(sc, args));
}

static bool is_integer_via_method(s7_scheme *sc, s7_pointer p)
{
  if (s7_is_integer(p))
    return(true);
  if (has_active_methods(sc, p))
    {
      s7_pointer f;
      f = find_method(sc, find_let(sc, p), sc->is_integer_symbol);
      if (f != sc->undefined)
	return(is_true(sc, s7_apply_function(sc, f, cons(sc, p, sc->nil))));
    }
  return(false);
}

static s7_pointer big_bits(s7_scheme *sc, s7_pointer args, s7_pointer sym, int32_t start, s7_function g_bits,
			   void (*mpz_bits)(mpz_ptr, mpz_srcptr, mpz_srcptr))
{
  s7_pointer x, lst;
  bool use_bigs = false;
  args = copy_args_if_needed(sc, args);
  for (x = args; is_not_null(x); x = cdr(x))
    {
      if (!is_integer_via_method(sc, car(x)))
	return(wrong_type_argument(sc, sym, position_of(x, args), car(x), T_INTEGER));
      if (!use_bigs) use_bigs = (type(car(x)) != T_INTEGER);
    }
  if (use_bigs)
    {
      mpz_t n;
      mpz_init_set_si(n, 0);
      if (start == -1)
	mpz_sub_ui(n, n, 1);
      for (x = args; is_not_null(x); x = cdr(x))
	{
	  s7_pointer i;
	  i = car(x);
	  switch (type(i))
	    {
	    case T_BIG_INTEGER:
	      mpz_bits(n, n, big_integer(i));
	      break;

	    case T_INTEGER:
	      mpz_bits(n, n, big_integer(s7_int_to_big_integer(sc, integer(i))));
	      break;

	    default:
	      /* we know it's an integer of some sort, but what about the method */
	      lst = cons(sc, mpz_to_big_integer(sc, n), x);
	      mpz_clear(n);
	      return(method_or_bust(sc, i, sym, lst, T_INTEGER, position_of(x, args)));
	    }
	}
      x = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(x);
    }
  return(g_bits(sc, args));
}

static s7_pointer big_logand(s7_scheme *sc, s7_pointer args)
{
  if (is_null(args))
    return(minus_one);
  return(big_bits(sc, args, sc->logand_symbol, -1, g_logand, mpz_and));
}

static s7_pointer big_logior(s7_scheme *sc, s7_pointer args)
{
  if (is_null(args))
    return(small_int(0));
  return(big_bits(sc, args, sc->logior_symbol, 0, g_logior, mpz_ior));
}

static s7_pointer big_logxor(s7_scheme *sc, s7_pointer args)
{
  if (is_null(args))
    return(small_int(0));
  return(big_bits(sc, args, sc->logxor_symbol, 0, g_logxor, mpz_xor));
}

static s7_pointer big_rationalize(s7_scheme *sc, s7_pointer args)
{
  #define H_rationalize "(rationalize x err) returns the ratio with lowest denominator within err of x"
  #define Q_rationalize s7_make_signature(sc, 3, sc->is_real_symbol, sc->is_real_symbol, sc->is_real_symbol)
  /* can return be non-rational? */

  /* currently (rationalize 1/0 1e18) -> 0
   * remember to pad with many trailing zeros:
   *    (rationalize 0.1 0)                -> 3602879701896397/36028797018963968
   *    (rationalize 0.1000000000000000 0) -> 1/10
   * perhaps gmp number reader used if gmp -- could this be the trailing zeros problem?  (why is the non-gmp case ok?)
   *         also the bignum function is faking it.
   *         (rationalize (real-part (bignum "0.1+i")) 0) -> 3602879701896397/36028797018963968
   * a confusing case:
   *   (rationalize 5925563891587147521650777143.74135805596e05) should be 148139097289678688041269428593533951399/250000
   * but that requires more than 128 bits of bignum-precision.
   */

  s7_pointer p0, p1 = NULL, p;
  mpfr_t error, ux, x0, x1;
  mpz_t i, i0, i1;
  double xx;

  p0 = car(args);
  if (!s7_is_real(p0))
    return(method_or_bust(sc, p0, sc->rationalize_symbol, args, T_REAL, 1));

  /* p0 can be exact, but we still have to check it for simplification */
  if (is_not_null(cdr(args)))
    {
      double err_x;
      p1 = cadr(args);
      if (!s7_is_real(p1))              /* (rationalize (expt 2 60) -) */
	return(method_or_bust(sc, p1, sc->rationalize_symbol, args, T_REAL, 2));

      if (is_big_number(p1))
	mpfr_init_set(error, big_real(promote_number(sc, T_BIG_REAL, p1)), GMP_RNDN);
      else mpfr_init_set_d(error, s7_real(p1), GMP_RNDN);

      err_x = mpfr_get_d(error, GMP_RNDN);
      if (is_NaN(err_x))
	{
	  mpfr_clear(error);
	  return(out_of_range(sc, sc->rationalize_symbol, small_int(2), cadr(args), its_nan_string));
	}
      if (mpfr_inf_p(error) != 0)
	{
	  mpfr_clear(error);
	  return(small_int(0));
	}
      mpfr_abs(error, error, GMP_RNDN);
    }
  else mpfr_init_set_d(error, sc->default_rationalize_error, GMP_RNDN);

  if (is_big_number(p0))
    mpfr_init_set(ux, big_real(promote_number(sc, T_BIG_REAL, p0)), GMP_RNDN);
  else mpfr_init_set_d(ux, real_to_double(sc, p0, "rationalize"), GMP_RNDN);

  xx = mpfr_get_d(ux, GMP_RNDN);
  if (is_NaN(xx))
    {
      mpfr_clear(ux);
      mpfr_clear(error);
      return(out_of_range(sc, sc->rationalize_symbol, small_int(1), car(args), its_nan_string));
    }
  if (mpfr_inf_p(ux) != 0)
    {
      mpfr_clear(ux);
      mpfr_clear(error);
      return(out_of_range(sc, sc->rationalize_symbol, small_int(1), car(args), its_infinite_string));
    }

  mpfr_init_set(x0, ux, GMP_RNDN);           /* x0 = ux - error */
  mpfr_sub(x0, x0, error, GMP_RNDN);
  mpfr_init_set(x1, ux, GMP_RNDN);           /* x1 = ux + error */
  mpfr_add(x1, x1, error, GMP_RNDN);
  mpz_init(i);
  mpfr_get_z(i, x0, GMP_RNDU);               /* i = ceil(x0) */

  if (mpfr_cmp_ui(error, 1) >= 0)            /* if (error >= 1.0) */
    {
      mpz_t n;

      if (mpfr_cmp_ui(x0, 0) < 0)            /* if (x0 < 0) */
	{
	  if (mpfr_cmp_ui(x1, 0) < 0)        /*   if (x1 < 0) */
	    {
	      mpz_init(n);
	      mpfr_get_z(n, x1, GMP_RNDD);   /*     num = floor(x1) */
	    }
	  else mpz_init_set_ui(n, 0);        /*   else num = 0 */
	}
      else mpz_init_set(n, i);               /* else num = i */

      mpz_clear(i);
      mpfr_clear(ux);
      mpfr_clear(x0);
      mpfr_clear(x1);
      mpfr_clear(error);
      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }

  if (mpfr_cmp_z(x1, i) >= 0)                /* if (x1 >= i) */
    {
      mpz_t n;

      if (mpz_cmp_ui(i, 0) >= 0)             /* if (i >= 0) */
	mpz_init_set(n, i);                  /*   num = i */
      else
	{
	  mpz_init(n);
	  mpfr_get_z(n, x1, GMP_RNDD);       /* else num = floor(x1) */
	}

      mpz_clear(i);
      mpfr_clear(ux);
      mpfr_clear(x0);
      mpfr_clear(x1);
      mpfr_clear(error);
      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }

  {
    mpz_t p0, q0, r, r1, p1, q1, old_p1, old_q1;
    mpfr_t val, e0, e1, e0p, e1p, old_e0, old_e1, old_e0p;

    mpz_init(i0);
    mpz_init(i1);
    mpfr_get_z(i0, x0, GMP_RNDD);            /* i0 = floor(x0) */
    mpfr_get_z(i1, x1, GMP_RNDU);            /* i1 = ceil(x1) */

    mpz_init_set(p0, i0);                    /* p0 = i0 */
    mpz_init_set_ui(q0, 1);                  /* q0 = 1 */
    mpz_init_set(p1, i1);                    /* p1 = i1 */
    mpz_init_set_ui(q1, 1);                  /* q1 = 1 */
    mpfr_init(e0);
    mpfr_init(e1);
    mpfr_init(e0p);
    mpfr_init(e1p);
    mpfr_sub_z(e0, x0, i1, GMP_RNDN);        /* e0 = i1 - x0 */
    mpfr_neg(e0, e0, GMP_RNDN);
    mpfr_sub_z(e1, x0, i0, GMP_RNDN);        /* e1 = x0 - i0 */
    mpfr_sub_z(e0p, x1, i1, GMP_RNDN);       /* e0p = i1 - x1 */
    mpfr_neg(e0p, e0p, GMP_RNDN);
    mpfr_sub_z(e1p, x1, i0, GMP_RNDN);       /* e1p = x1 - i0 */

    mpfr_init(val);

    mpfr_init(old_e0);
    mpfr_init(old_e1);
    mpfr_init(old_e0p);

    mpz_init(r);
    mpz_init(r1);
    mpz_init(old_p1);
    mpz_init(old_q1);

    while (true)
      {
	mpfr_set_z(val, p0, GMP_RNDN);
	mpfr_div_z(val, val, q0, GMP_RNDN);  /* val = p0/q0 */

	if (((mpfr_cmp(x0, val) <= 0) &&      /* if ((x0 <= val) && (val <= x1)) */
	     (mpfr_cmp(val, x1) <= 0)) ||
	    (mpfr_cmp_ui(e1, 0) == 0) ||
	    (mpfr_cmp_ui(e1p, 0) == 0))
	  /* these last 2 are probably not needed -- they protect against running out of bits in the non-gmp case above */
	  {
	    mpq_t q;
	    mpq_init(q);
	    mpq_set_num(q, p0);            /* return(p0/q0) */
	    mpq_set_den(q, q0);

	    mpz_clear(i);
	    mpz_clear(i0);
	    mpz_clear(i1);
	    mpfr_clear(ux);
	    mpfr_clear(x0);
	    mpfr_clear(x1);
	    mpfr_clear(error);

	    mpz_clear(p0);
	    mpz_clear(q0);
	    mpz_clear(r);
	    mpz_clear(r1);
	    mpz_clear(p1);
	    mpz_clear(q1);
	    mpz_clear(old_p1);
	    mpz_clear(old_q1);

	    mpfr_clear(val);
	    mpfr_clear(e0);
	    mpfr_clear(e1);
	    mpfr_clear(e0p);
	    mpfr_clear(e1p);
	    mpfr_clear(old_e0);
	    mpfr_clear(old_e1);
	    mpfr_clear(old_e0p);

	    p = mpq_to_big_ratio(sc, q);
	    mpq_clear(q);
	    return(p);
	  }

	mpfr_div(val, e0, e1, GMP_RNDN);
	mpfr_get_z(r, val, GMP_RNDD);           /* r = floor(e0/e1) */
	mpfr_div(val, e0p, e1p, GMP_RNDN);
	mpfr_get_z(r1, val, GMP_RNDU);          /* r1 = ceil(e0p/e1p) */
	if (mpz_cmp(r1, r) < 0)                 /* if (r1 < r) */
	  mpz_set(r, r1);                       /*   r = r1 */

	mpz_set(old_p1, p1);                    /* old_p1 = p1 */
	mpz_set(p1, p0);                        /* p1 = p0 */
	mpz_set(old_q1, q1);                    /* old_q1 = q1 */
	mpz_set(q1, q0);                        /* q1 = q0 */

	mpfr_set(old_e0, e0, GMP_RNDN);         /* old_e0 = e0 */
	mpfr_set(e0, e1p, GMP_RNDN);            /* e0 = e1p */
	mpfr_set(old_e0p, e0p, GMP_RNDN);       /* old_e0p = e0p */
	mpfr_set(e0p, e1, GMP_RNDN);            /* e0p = e1 */
	mpfr_set(old_e1, e1, GMP_RNDN);         /* old_e1 = e1 */

	mpz_mul(p0, p0, r);                     /* p0 = old_p1 + r * p0 */
	mpz_add(p0, p0, old_p1);

	mpz_mul(q0, q0, r);                     /* q0 = old_q1 + r * q0 */
	mpz_add(q0, q0, old_q1);

	mpfr_mul_z(e1, e1p, r, GMP_RNDN);       /* e1 = old_e0p - r * e1p */
	mpfr_sub(e1, old_e0p, e1, GMP_RNDN);

	mpfr_mul_z(e1p, old_e1, r, GMP_RNDN);   /* e1p = old_e0 - r * old_e1 */
	mpfr_sub(e1p, old_e0, e1p, GMP_RNDN);
      }
  }
}

#if (!WITH_PURE_S7)
static s7_pointer big_exact_to_inexact(s7_scheme *sc, s7_pointer args)
{
  #define H_exact_to_inexact "(exact->inexact num) converts num to an inexact number; (exact->inexact 3/2) = 1.5"
  #define Q_exact_to_inexact s7_make_signature(sc, 2, sc->is_number_symbol, sc->is_number_symbol)
  s7_pointer p;

  p = car(args);
  if (!s7_is_number(p))   /* apparently (exact->inexact 1+i) is not an error */
    return(method_or_bust_with_type_one_arg(sc, p, sc->exact_to_inexact_symbol, args, a_number_string));
  if (!s7_is_rational(p))
    return(p);
  return(promote_number(sc, T_BIG_REAL, to_big(sc, p)));
}

static s7_pointer big_inexact_to_exact(s7_scheme *sc, s7_pointer args)
{
  #define H_inexact_to_exact "(inexact->exact num) converts num to an exact number; (inexact->exact 1.5) = 3/2"
  #define Q_inexact_to_exact s7_make_signature(sc, 2, sc->is_real_symbol, sc->is_real_symbol)
  s7_pointer p;
  p = car(args);
  if (s7_is_rational(p))
    return(p);
  if (!s7_is_real(p))
    return(method_or_bust_one_arg(sc, p, sc->inexact_to_exact_symbol, args, T_REAL));
  return(big_rationalize(sc, args));
}
#endif

static s7_pointer big_convert_to_int(s7_scheme *sc, s7_pointer args, s7_pointer sym,
				     void (*div_func)(mpz_ptr, mpz_srcptr, mpz_srcptr),
				     mp_rnd_t mode)
{
  /* we can't go to the normal (non-gmp) functions here */
  s7_pointer p;
  mpz_t n;

  p = car(args);
  if (!s7_is_real(p))
    return(method_or_bust_one_arg(sc, p, sym, args, T_REAL));
  if (s7_is_integer(p))
    return(p);

  p = to_big(sc, p);
  if (is_t_big_ratio(p))
    {
      /* apparently we have to do the divide by hand */
      mpz_t d;
      mpz_init_set(n, mpq_numref(big_ratio(p)));
      mpz_init_set(d, mpq_denref(big_ratio(p)));
      div_func(n, n, d);
      mpz_clear(d);
    }
  else
    {
      if ((g_is_nan(sc, args) == sc->T) ||
	  (g_is_infinite(sc, args)) == sc->T)
	return(simple_out_of_range(sc, sym, p, (g_is_nan(sc, args) == sc->T) ? its_nan_string : its_infinite_string));

      mpz_init(n);
      mpfr_get_z(n, big_real(p), mode);
    }
  p = mpz_to_big_integer(sc, n);
  mpz_clear(n);
  return(p);
}

static s7_pointer big_floor(s7_scheme *sc, s7_pointer args)
{
  #define H_floor "(floor x) returns the integer closest to x toward -inf"
  #define Q_floor s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)
  return(big_convert_to_int(sc, args, sc->floor_symbol, mpz_fdiv_q, GMP_RNDD));
}

static s7_pointer big_ceiling(s7_scheme *sc, s7_pointer args)
{
  #define H_ceiling "(ceiling x) returns the integer closest to x toward inf"
  #define Q_ceiling s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)
  return(big_convert_to_int(sc, args, sc->ceiling_symbol, mpz_cdiv_q, GMP_RNDU));
}

static s7_pointer big_truncate(s7_scheme *sc, s7_pointer args)
{
  #define H_truncate "(truncate x) returns the integer closest to x toward 0"
  #define Q_truncate s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)
  return(big_convert_to_int(sc, args, sc->truncate_symbol, mpz_tdiv_q, GMP_RNDZ));
}

static s7_pointer big_round(s7_scheme *sc, s7_pointer args)
{
  #define H_round "(round x) returns the integer closest to x"
  #define Q_round s7_make_signature(sc, 2, sc->is_integer_symbol, sc->is_real_symbol)

  s7_pointer p;
  mpz_t n;

  p = car(args);
  if (!s7_is_real(p))
    return(method_or_bust_one_arg(sc, p, sc->round_symbol, args, T_REAL));
  if (s7_is_integer(p))
    return(p);

  p = to_big(sc, p);
  if (is_t_big_integer(p))
    return(p);

  if (is_t_big_ratio(p))
    {
      int32_t rnd;
      mpz_t rm;
      mpz_init_set(n, mpq_numref(big_ratio(p)));
      mpz_init(rm);
      mpz_fdiv_qr(n, rm, n, mpq_denref(big_ratio(p)));
      mpz_mul_ui(rm, rm, 2);
      rnd = mpz_cmpabs(rm, mpq_denref(big_ratio(p)));
      mpz_fdiv_q(rm, rm, mpq_denref(big_ratio(p)));
      if (rnd > 0)
	mpz_add(n, n, rm);
      else
	{
	  if (rnd == 0)
	    {
	      if (mpz_odd_p(n))
		mpz_add_ui(n, n, 1);
	    }
	}
      mpz_clear(rm);
      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }

  if ((g_is_nan(sc, args) == sc->T) ||
      (g_is_infinite(sc, args)) == sc->T)
    return(simple_out_of_range(sc, sc->round_symbol, p, (g_is_nan(sc, args) == sc->T) ? its_nan_string : its_infinite_string));

  {
    int32_t cmp_res;
    mpz_t fl, ce;
    mpfr_t x, dfl, dce;
    mpfr_init_set(x, big_real(p), GMP_RNDN);
    mpz_init(fl);
    mpfr_get_z(fl, x, GMP_RNDD);           /* fl = floor(x) */
    mpz_init(ce);
    mpfr_get_z(ce, x, GMP_RNDU);           /* ce = ceil(x) */
    mpfr_init(dfl);
    mpfr_sub_z(dfl, x, fl, GMP_RNDN);      /* dfl = x - fl */
    mpfr_init(dce);
    mpfr_sub_z(dce, x, ce, GMP_RNDN);      /* dce = -(ce - x) */
    mpfr_neg(dce, dce, GMP_RNDN);          /*    and reversed */
    cmp_res = mpfr_cmp(dfl, dce);
    if (cmp_res > 0)                       /* if (dfl > dce) return(ce) */
      mpz_init_set(n, ce);
    else
      {
	if (cmp_res < 0)                   /* if (dfl < dce) return(fl) */
	  mpz_init_set(n, fl);
	else
	  {
	    if (mpz_even_p(fl))
	      mpz_init_set(n, fl);         /* if (mod(fl, 2) == 0) return(fl) */
	    else mpz_init_set(n, ce);
	  }
      }
    mpz_clear(fl);
    mpz_clear(ce);
    mpfr_clear(dfl);
    mpfr_clear(dce);
    mpfr_clear(x);
    p = mpz_to_big_integer(sc, n);
    mpz_clear(n);
    return(p);
  }
}

static s7_pointer big_quotient(s7_scheme *sc, s7_pointer args)
{
  #define H_quotient "(quotient x1 x2) returns the integer quotient of x1 and x2; (quotient 4 3) = 1"
  #define Q_quotient sc->pcl_r

  s7_pointer x, y, p;
  x = car(args);
  y = cadr(args);

  if (!s7_is_real(x))
    return(method_or_bust(sc, x, sc->quotient_symbol, args, T_REAL, 1));
  if (!s7_is_real(y))
    return(method_or_bust(sc, y, sc->quotient_symbol, args, T_REAL, 2));

  if ((s7_is_integer(x)) &&
      (s7_is_integer(y)))
    {
      mpz_t n;
      x = to_big(sc, x);
      y = to_big(sc, y);

      if (s7_is_zero(y))
	return(division_by_zero_error(sc, sc->quotient_symbol, args));

      mpz_init_set(n, big_integer(x));
      mpz_tdiv_q(n, n, big_integer(y));

      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }
  return(big_truncate(sc, set_plist_1(sc, big_divide(sc, args))));
}

static s7_pointer big_remainder(s7_scheme *sc, s7_pointer args)
{
  #define H_remainder "(remainder x1 x2) returns the integer remainder of x1 and x2; (remainder 10 3) = 1"
  #define Q_remainder sc->pcl_r

  s7_pointer x, y, p;
  x = car(args);
  y = cadr(args);

  if (!s7_is_real(x))
    return(method_or_bust(sc, x, sc->remainder_symbol, args, T_REAL, 1));
  if (!s7_is_real(y))
    return(method_or_bust(sc, y, sc->remainder_symbol, args, T_REAL, 2));

  if ((s7_is_integer(x)) &&
      (s7_is_integer(y)))
    {
      mpz_t n;
      x = to_big(sc, x);
      y = to_big(sc, y);

      if (s7_is_zero(y))
	return(division_by_zero_error(sc, sc->remainder_symbol, args));

      mpz_init_set(n, big_integer(x));
      mpz_tdiv_r(n, n, big_integer(y));

      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }
  return(big_subtract(sc,
          list_2(sc, x,
           big_multiply(sc,
            set_plist_2(sc, y,
             big_quotient(sc, args))))));
}

static s7_pointer big_modulo(s7_scheme *sc, s7_pointer args)
{
  #define H_modulo "(modulo x1 x2) returns x1 mod x2; (modulo 4 3) = 1.  The arguments can be real numbers."
  #define Q_modulo sc->pcl_r

  s7_pointer a, b, p;

  a = car(args);
  if (!s7_is_real(a))
    return(method_or_bust(sc, a, sc->modulo_symbol, args, T_REAL, 1));

  b = cadr(args);
  if (!s7_is_real(b))
    return(method_or_bust(sc, b, sc->modulo_symbol, args, T_REAL, 2));

  a = to_big(sc, a);
  b = to_big(sc, b);

  if ((s7_is_integer(a)) &&
      (s7_is_integer(b)))
    {
      s7_pointer x, y;
      int32_t cy, cz;
      mpz_t n;

      y = promote_number(sc, T_BIG_INTEGER, b);
      if (mpz_cmp_ui(big_integer(y), 0) == 0)
	return(a);

      x = promote_number(sc, T_BIG_INTEGER, a);
      /* mpz_mod is too tricky here */

      mpz_init_set(n, big_integer(x));
      mpz_fdiv_r(n, n, big_integer(y));
      cy = mpz_cmp_ui(big_integer(y), 0);
      cz = mpz_cmp_ui(n, 0);
      if (((cy < 0) && (cz > 0)) ||
	  ((cy > 0) && (cz < 0)))
	mpz_add(n, n, big_integer(y));

      p = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(p);
    }
  if (s7_is_zero(b)) return(a); /* see g_modulo */

  return(big_subtract(sc,
          list_2(sc, a,
           big_multiply(sc,
            list_2(sc, b,
    	     big_floor(sc,
              set_plist_1(sc,
               big_divide(sc,
	        set_plist_2(sc, a, b)))))))));
}

static int32_t big_real_scan_args(s7_scheme *sc, s7_pointer args)
{
  int32_t i, result_type = T_INTEGER;
  s7_pointer arg;

  for (i = 1, arg = args; is_not_null(arg); i++, arg = cdr(arg))
    {
      s7_pointer p;
      p = car(arg);
      if (!is_real_via_method(sc, p))
	return(-i);
      result_type = get_result_type(sc, result_type, p);
    }
  return(result_type);
}

static s7_pointer bigrat_to_bigint(s7_scheme *sc, s7_pointer result)
{
  mpz_t n;
  s7_pointer p;
  mpz_init_set(n, mpq_numref(big_ratio(result)));
  p = mpz_to_big_integer(sc, n);
  mpz_clear(n);
  return(p);
}

static s7_pointer big_max(s7_scheme *sc, s7_pointer args)
{
  int32_t result_type;
  s7_pointer x, result, arg;

  args = copy_args_if_needed(sc, args);
  result_type = big_real_scan_args(sc, args);
  if (result_type < 0)
    return(wrong_type_argument(sc, sc->max_symbol, -result_type, s7_list_ref(sc, args, -1 - result_type), T_REAL));
  if (result_type < T_BIG_INTEGER)
    return(g_max(sc, args));
  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->max_symbol, args);
  result = promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->max_symbol, cons(sc, result, x));

      arg = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: if (mpz_cmp(big_integer(result), big_integer(arg)) < 0) result = arg; break;
	case T_BIG_RATIO:   if (mpq_cmp(big_ratio(result), big_ratio(arg)) < 0)	    result = arg; break;
	case T_BIG_REAL:    if (mpfr_cmp(big_real(result), big_real(arg)) < 0)	    result = arg; break;
	}
    }
  if ((result_type == T_BIG_RATIO) && /* maybe actual result was an int32_t */
      (mpz_cmp_ui(mpq_denref(big_ratio(result)), 1) == 0))
    return(bigrat_to_bigint(sc, result));
  return(result);
}

static s7_pointer big_min(s7_scheme *sc, s7_pointer args)
{
  int32_t result_type;
  s7_pointer x, result, arg;

  args = copy_args_if_needed(sc, args);
  result_type = big_real_scan_args(sc, args);
  if (result_type < 0)
    return(wrong_type_argument(sc, sc->min_symbol, -result_type, s7_list_ref(sc, args, -1 - result_type), T_REAL));
  if (result_type < T_BIG_INTEGER)
    return(g_min(sc, args));
  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->min_symbol, args);
  result = promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->min_symbol, cons(sc, result, x));

      arg = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: if (mpz_cmp(big_integer(result), big_integer(arg)) > 0)  result = arg; break;
	case T_BIG_RATIO:   if (mpq_cmp(big_ratio(result), big_ratio(arg)) > 0)      result = arg; break;
	case T_BIG_REAL:    if (mpfr_cmp(big_real(result), big_real(arg)) > 0)       result = arg; break;
	}
    }
  if ((result_type == T_BIG_RATIO) &&
      (mpz_cmp_ui(mpq_denref(big_ratio(result)), 1) == 0))
    return(bigrat_to_bigint(sc, result));
  return(result);
}

static s7_pointer big_less(s7_scheme *sc, s7_pointer args)
{
  #define H_less "(< x1 ...) returns #t if its arguments are in increasing order"
  #define Q_less s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)

  int32_t result_type;
  s7_pointer x, previous, current;

  args = copy_args_if_needed(sc, args);
  result_type = big_real_scan_args(sc, args);
  if (result_type < 0)
    return(wrong_type_argument(sc, sc->lt_symbol, -result_type, s7_list_ref(sc, args, -1 - result_type), T_REAL));
  /* don't try to use g_less here */
  if (result_type < T_BIG_INTEGER)
    result_type += 4;
  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->lt_symbol, args);
  previous = promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->lt_symbol, cons(sc, previous, x));

      current = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: if (mpz_cmp(big_integer(previous), big_integer(current)) >= 0) return(sc->F); break;
	case T_BIG_RATIO:   if (mpq_cmp(big_ratio(previous),   big_ratio(current)) >= 0) return(sc->F);	  break;
	case T_BIG_REAL:    if (mpfr_cmp(big_real(previous),   big_real(current)) >= 0) return(sc->F);	  break;
	}
      previous = current;
    }
  return(sc->T);
}

static s7_pointer big_less_or_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_less_or_equal "(<= x1 ...) returns #t if its arguments are in increasing order"
  #define Q_less_or_equal s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)

  int32_t result_type;
  s7_pointer x, previous, current;

  args = copy_args_if_needed(sc, args);
  result_type = big_real_scan_args(sc, args);
  if (result_type < 0)
    return(wrong_type_argument(sc, sc->leq_symbol, -result_type, s7_list_ref(sc, args, -1 - result_type), T_REAL));
  if (result_type < T_BIG_INTEGER)
    result_type += 4;
  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->leq_symbol, args);
  previous = promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->leq_symbol, cons(sc, previous, x));

      current = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: if (mpz_cmp(big_integer(previous), big_integer(current)) > 0) return(sc->F);  break;
	case T_BIG_RATIO:   if (mpq_cmp(big_ratio(previous),   big_ratio(current)) > 0) return(sc->F);	  break;
	case T_BIG_REAL:    if (mpfr_cmp(big_real(previous),   big_real(current)) > 0) return(sc->F);	  break;
	}
      previous = current;
    }
  return(sc->T);
}

static s7_pointer big_greater(s7_scheme *sc, s7_pointer args)
{
  #define H_greater "(> x1 ...) returns #t if its arguments are in decreasing order"
  #define Q_greater s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)

  int32_t result_type;
  s7_pointer x, previous, current;

  args = copy_args_if_needed(sc, args);
  result_type = big_real_scan_args(sc, args);
  if (result_type < 0)
    return(wrong_type_argument(sc, sc->gt_symbol, -result_type, s7_list_ref(sc, args, -1 - result_type), T_REAL));
  if (result_type < T_BIG_INTEGER)
    result_type += 4;
  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->gt_symbol, args);
  previous = promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->gt_symbol, cons(sc, previous, x));
      current = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: if (mpz_cmp(big_integer(previous), big_integer(current)) <= 0) return(sc->F); break;
	case T_BIG_RATIO:   if (mpq_cmp(big_ratio(previous),   big_ratio(current)) <= 0) return(sc->F);	  break;
	case T_BIG_REAL:    if (mpfr_cmp(big_real(previous),   big_real(current)) <= 0) return(sc->F);	  break;
	}
      previous = current;
    }
  return(sc->T);
}

static s7_pointer big_greater_or_equal(s7_scheme *sc, s7_pointer args)
{
  #define H_greater_or_equal "(>= x1 ...) returns #t if its arguments are in decreasing order"
  #define Q_greater_or_equal s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_real_symbol)

  int32_t result_type;
  s7_pointer x, previous, current;

  args = copy_args_if_needed(sc, args);
  result_type = big_real_scan_args(sc, args);
  if (result_type < 0)
    return(wrong_type_argument(sc, sc->geq_symbol, -result_type, s7_list_ref(sc, args, -1 - result_type), T_REAL));
  if (result_type < T_BIG_INTEGER)
    result_type += 4;
  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->geq_symbol, args);
  previous = promote_number(sc, result_type, car(args));

  for (x = cdr(args); is_not_null(x); x = cdr(x))
    {
      if (!s7_is_number(car(x)))
	check_method_uncopied(sc, car(x), sc->geq_symbol, cons(sc, previous, x));
      current = promote_number(sc, result_type, car(x));
      switch (result_type)
	{
	case T_BIG_INTEGER: if (mpz_cmp(big_integer(previous), big_integer(current)) < 0) return(sc->F);  break;
	case T_BIG_RATIO:   if (mpq_cmp(big_ratio(previous),   big_ratio(current)) < 0) return(sc->F);	  break;
	case T_BIG_REAL:    if (mpfr_cmp(big_real(previous),   big_real(current)) < 0) return(sc->F);	  break;
	}
      previous = current;
    }
  return(sc->T);
}

static s7_pointer big_equal(s7_scheme *sc, s7_pointer args)
{
  #define Q_equal s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_number_symbol)

  /* this is equivalent? for bignums, the other case goes through big_numbers_are_eqv */
  int32_t i, result_type = T_INTEGER;
  s7_pointer arg, y, result;
  bool got_nan = false;

  args = copy_args_if_needed(sc, args);
  for (i = 1, arg = args; is_not_null(arg); i++, arg = cdr(arg))
    {
      s7_pointer p;
      p = car(arg);
      if (!is_number_via_method(sc, p))
	return(wrong_type_argument(sc, sc->eq_symbol, i, s7_list_ref(sc, args, i - 1), T_COMPLEX));
      result_type = get_result_type(sc, result_type, p);

      if (!got_nan)
	got_nan = (((is_t_real(p)) && (is_NaN(real(p)))) ||  /* (= (bignum "3") 1/0) */
		   ((is_t_complex(p)) && ((is_NaN(real_part(p))) || (is_NaN(imag_part(p))))));
    }
  if (got_nan) return(sc->F); /* put this off until here so that non-numbers anywhere in the arg list will raise an error */

  if (result_type < T_BIG_INTEGER)
    result_type += 4;

  if (!s7_is_number(car(args)))
    check_method(sc, car(args), sc->eq_symbol, args);
  result = promote_number(sc, result_type, car(args));

  for (y = cdr(args); is_not_null(y); y = cdr(y))
    {
      if (!s7_is_number(car(y)))
	check_method_uncopied(sc, car(y), sc->eq_symbol, cons(sc, result, y));

      arg = promote_number(sc, result_type, car(y));
      switch (result_type)
	{
	case T_BIG_INTEGER: if (mpz_cmp(big_integer(result), big_integer(arg)) != 0) return(sc->F); break;
	case T_BIG_RATIO:   if (mpq_cmp(big_ratio(result),   big_ratio(arg)) != 0)   return(sc->F); break;

	case T_BIG_REAL:
	  {
	    mpfr_t *a1;
	    bool res;
	    a1 = s7_double_to_mpfr(sc->equivalent_float_epsilon);
	    res = (mpfr_cmp(big_real(big_abs(sc, set_plist_1(sc, big_subtract(sc, set_plist_2(sc, result, arg))))), *a1) > 0);
	    mpfr_clear(*a1);
	    free(a1);
	    if (res) return(sc->F);
	  }
	  break;

	case T_BIG_COMPLEX:
	  {
	    mpfr_t *a1;
	    bool res;
	    a1 = s7_double_to_mpfr(sc->equivalent_float_epsilon);
	    res = (mpfr_cmp(big_real(big_magnitude(sc, set_plist_1(sc, big_subtract(sc, set_plist_2(sc, result, arg))))), *a1) > 0);
	    mpfr_clear(*a1);
	    free(a1);
	    if (res) return(sc->F);
	  }
	  break;
	}
    }
  return(sc->T);
}

static s7_pointer bigrat(s7_scheme *sc, mpz_t n, mpz_t d)
{
  s7_pointer x, rat;
  mpq_t q;
  if (mpz_cmp_ui(d, 1) == 0)
    {
      rat = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      mpz_clear(d);
      return(rat);
    }
  mpq_init(q);
  mpq_set_num(q, n);
  mpq_set_den(q, d);
  mpz_clear(n);
  mpz_clear(d);

  x = mpq_to_big_ratio(sc, q);
  mpq_clear(q);
  return(x);
}

static s7_pointer big_gcd(s7_scheme *sc, s7_pointer args)
{
  #define H_gcd "(gcd ...) returns the greatest common divisor of its rational arguments"
  #define Q_gcd sc->pcl_f

  bool rats = false;
  s7_pointer x, lst;

  if (is_null(args)) return(small_int(0));
  args = copy_args_if_needed(sc, args);
  for (x = args; is_pair(x); x = cdr(x))
    {
      if (!is_rational_via_method(sc, car(x)))
	return(wrong_type_argument_with_type(sc, sc->gcd_symbol, position_of(x, args), car(x), a_rational_string));
      if (!rats)
	rats = (!is_integer_via_method(sc, car(x)));
    }
  if (is_null(cdr(args)))    /* (gcd -2305843009213693951/4611686018427387903) */
    return(big_abs(sc, args));

  if (!rats)
    {
      mpz_t n;
      mpz_init(n);
      for (x = args; is_not_null(x); x = cdr(x))
	{
	  if (!s7_is_number(car(x)))
	    {
	      lst = cons(sc, mpz_to_big_integer(sc, n), x);
	      mpz_clear(n);
	      return(method_or_bust(sc, car(x), sc->gcd_symbol, lst, T_INTEGER, position_of(x, args)));
	    }
	  mpz_gcd(n, n, big_integer(promote_number(sc, T_BIG_INTEGER, car(x))));
	  if (mpz_cmp_ui(n, 1) == 0)
	    {
	      mpz_clear(n);
	      return(small_int(1));
	    }
	}
      x = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(x);
    }

  {
    s7_pointer rat;
    mpq_t q;
    mpz_t n, d;

    if (!s7_is_number(car(args)))
      check_method(sc, car(args), sc->gcd_symbol, args);
    rat = promote_number(sc, T_BIG_RATIO, car(args));
    mpz_init_set(n, mpq_numref(big_ratio(rat)));
    mpz_init_set(d, mpq_denref(big_ratio(rat)));
    for (x = cdr(args); is_not_null(x); x = cdr(x))
      {
	if (!s7_is_number(car(x)))
	  {
	    mpq_init(q);
	    mpq_set_num(q, n);
	    mpq_set_den(q, d);
	    lst = cons(sc, mpq_to_big_ratio(sc, q), x);
	    mpz_clear(n);
	    mpz_clear(d);
	    mpq_clear(q);
	    return(method_or_bust_with_type(sc, car(x), sc->gcd_symbol, lst, a_rational_string, position_of(x, args)));
	  }
	rat = promote_number(sc, T_BIG_RATIO, car(x));
	mpz_gcd(n, n, mpq_numref(big_ratio(rat)));
	mpz_lcm(d, d, mpq_denref(big_ratio(rat)));
      }
    return(bigrat(sc, n, d));
  }
}

static s7_pointer big_lcm(s7_scheme *sc, s7_pointer args)
{
  #define H_lcm "(lcm ...) returns the least common multiple of its rational arguments"
  #define Q_lcm sc->pcl_f

  s7_pointer x, lst;
  bool rats = false;

  if (is_null(args)) return(small_int(1));
  args = copy_args_if_needed(sc, args);
  for (x = args; is_pair(x); x = cdr(x))
    {
      if (!is_rational_via_method(sc, car(x)))
	return(wrong_type_argument_with_type(sc, sc->lcm_symbol, position_of(x, args), car(x), a_rational_string));
      if (!rats)
	rats = (!is_integer_via_method(sc, car(x)));
    }

   if (is_null(cdr(args)))    /* (lcm -2305843009213693951/4611686018427387903) */
      return(big_abs(sc, args));

   if (!rats)
    {
      mpz_t n;
      mpz_init(n);
      mpz_set_ui(n, 1);
      for (x = args; is_not_null(x); x = cdr(x))
	{
	  if (!s7_is_number(car(x)))
	    {
	      lst = cons(sc, mpz_to_big_integer(sc, n), x);
	      mpz_clear(n);
	      return(method_or_bust(sc, car(x), sc->lcm_symbol, lst, T_INTEGER, position_of(x, args)));
	    }
	  mpz_lcm(n, n, big_integer(promote_number(sc, T_BIG_INTEGER, car(x))));
	  if (mpz_cmp_ui(n, 0) == 0)
	    {
	      mpz_clear(n);
	      return(small_int(0));
	    }
	}
      x = mpz_to_big_integer(sc, n);
      mpz_clear(n);
      return(x);
    }

  {
    s7_pointer rat;
    mpq_t q;
    mpz_t n, d;

    if (!s7_is_number(car(args)))
      check_method(sc, car(args), sc->lcm_symbol, args);
    rat = promote_number(sc, T_BIG_RATIO, car(args));
    mpz_init_set(n, mpq_numref(big_ratio(rat)));
    if (mpz_cmp_ui(n, 0) == 0)
      {
	mpz_clear(n);
	return(small_int(0));
      }

    mpz_init_set(d, mpq_denref(big_ratio(rat)));
    for (x = cdr(args); is_not_null(x); x = cdr(x))
      {
	if (!s7_is_number(car(x)))
	  {
	    mpq_init(q);
	    mpq_set_num(q, n);
	    mpq_set_den(q, d);
	    lst = cons(sc, mpq_to_big_ratio(sc, q), x);
	    mpz_clear(n);
	    mpz_clear(d);
	    mpq_clear(q);
	    return(method_or_bust_with_type(sc, car(x), sc->lcm_symbol, lst, a_rational_string, position_of(x, args)));
	  }

	rat = promote_number(sc, T_BIG_RATIO, car(x));
	mpz_lcm(n, n, mpq_numref(big_ratio(rat)));
	if (mpz_cmp_ui(n, 0) == 0)
	  {
	    mpz_clear(n);
	    mpz_clear(d);
	    return(small_int(0));
	  }
	mpz_gcd(d, d, mpq_denref(big_ratio(rat)));
      }
    return(bigrat(sc, n, d));
  }
}

static s7_pointer set_bignum_precision(s7_scheme *sc, int32_t precision)
{
  mp_prec_t bits;
  if (precision <= 1)                   /* (set! (*s7* 'bignum-precision) 1) causes mpfr to segfault! (also 0 and -1) */
    return(s7_out_of_range_error(sc, "set! (*s7* 'bignum-precision)", 0, wrap_integer1(sc, precision), "has to be greater than 1"));

  bits = (mp_prec_t)precision;
  mpfr_set_default_prec(bits);
  mpc_set_default_precision(bits);
  s7_symbol_set_value(sc, sc->pi_symbol, big_pi(sc));
  return(sc->F);
}

static s7_pointer big_random_state(s7_scheme *sc, s7_pointer args)
{
  #define H_random_state "(random-state seed) returns a new random number state initialized with 'seed'. \
Pass this as the second argument to 'random' to get a repeatable random number sequence:\n\
    (let ((seed (random-state 1234))) (random 1.0 seed))"
  #define Q_random_state s7_make_circular_signature(sc, 1, 2, sc->is_random_state_symbol, sc->is_integer_symbol)

  s7_pointer r, seed;
  seed = car(args);
  if (!s7_is_integer(seed))
    return(method_or_bust_one_arg(sc, seed, sc->random_state_symbol, args, T_INTEGER));

  if (type(seed) != T_BIG_INTEGER)
    seed = promote_number(sc, T_BIG_INTEGER, seed);

  new_cell(sc, r, T_RANDOM_STATE);
  gmp_randinit_default(random_gmp_state(r));
  gmp_randseed(random_gmp_state(r), big_integer(seed));
  add_big_random_state(sc, r);
  return(r);
}

static s7_pointer big_random(s7_scheme *sc, s7_pointer args)
{
  #define H_random "(random num (state #f)) returns a random number between 0 and num (0 if num=0)."
  #define Q_random s7_make_signature(sc, 3, sc->is_number_symbol, sc->is_number_symbol, sc->is_random_state_symbol)
  s7_pointer num, state, x;

  num = car(args);
  if (!s7_is_number(num))
    return(method_or_bust_with_type(sc, num, sc->random_symbol, args, a_number_string, 1));

  state = sc->default_rng;
  if (is_not_null(cdr(args)))
    {
      state = cadr(args);
      if (!is_random_state(state))
	return(wrong_type_argument_with_type(sc, sc->random_symbol, 2, state, a_random_state_object_string));
    }

  if (s7_is_zero(num))
    return(num);

  if (!is_big_number(num))
    {
      switch (type(num))
	{
	case T_INTEGER: num = promote_number(sc, T_BIG_INTEGER, num);  break;
	case T_RATIO:   num = promote_number(sc, T_BIG_RATIO, num);    break;
	case T_REAL:    num = promote_number(sc, T_BIG_REAL, num);     break;
	default:        num = promote_number(sc, T_BIG_COMPLEX, num);  break;
	}
    }

  switch (type(num))
    {
    case T_BIG_INTEGER:
      {
	mpz_t n;
	mpz_init(n);
	mpz_urandomm(n, random_gmp_state(state), big_integer(num));

	/* this does not work if num is a negative number -- you get positive results. so check num for sign, and negate result if necessary. */
	if (mpz_cmp_ui(big_integer(num), 0) < 0)
	  mpz_neg(n, n);

	x = mpz_to_big_integer(sc, n);
	mpz_clear(n);
	return(x);
      }

    case T_BIG_RATIO:
      {
	mpfr_t n, e;
	mpfr_t rat;

	mpfr_init_set_ui(n, 1, GMP_RNDN);
	mpfr_urandomb(n, random_gmp_state(state));
	mpfr_init_set_q(rat, big_ratio(num), GMP_RNDN);
	mpfr_mul(n, n, rat, GMP_RNDN);

	mpfr_init_set_str(e, "0.0000001", 10, GMP_RNDN);
	mpfr_mul(e, e, rat, GMP_RNDN);
	mpfr_clear(rat);
	/* as in g_random, small ratios are a problem because the error term (sc->default_rationalize_error = 1e-12 here) clobbers everything to 0. */
	x = big_rationalize(sc, set_plist_2(sc, mpfr_to_big_real(sc, n), mpfr_to_big_real(sc, e)));
	mpfr_clear(n);
	mpfr_clear(e);
	return(x);
      }

    case T_BIG_REAL:
      {
	mpfr_t n;
	mpfr_init_set_ui(n, 1, GMP_RNDN);
	mpfr_urandomb(n, random_gmp_state(state));
	mpfr_mul(n, n, big_real(num), GMP_RNDN);
	x = mpfr_to_big_real(sc, n);
	mpfr_clear(n);
	return(x);
      }

    case T_BIG_COMPLEX:
      {
	mpc_t n;
	mpc_init(n);
	mpc_urandom(n, random_gmp_state(state));
	mpfr_mul(mpc_realref(n), mpc_realref(n), mpc_realref(big_complex(num)), GMP_RNDN);
	mpfr_mul(mpc_imagref(n), mpc_imagref(n), mpc_imagref(big_complex(num)), GMP_RNDN);
	x = mpc_to_big_complex(sc, n);
	mpc_clear(n);
	return(x);
      }
    }
  return(sc->F); /* make the compiler happy */
}

s7_double s7_random(s7_scheme *sc, s7_pointer state)
{
  s7_pointer p;
  p = big_random(sc, set_plist_1(sc, (state) ? state : sc->default_rng));
  return((s7_double)mpfr_get_d(big_real(p), GMP_RNDN));
}


static void s7_gmp_init(s7_scheme *sc)
{
  #define big_defun(Scheme_Name, C_Name, Req, Opt, Rst) s7_define_typed_function(sc, Scheme_Name, big_ ## C_Name, Req, Opt, Rst, H_ ## C_Name, Q_ ## C_Name)
  #define c_big_defun(Scheme_Name, C_Name, Req, Opt, Rst) s7_define_typed_function(sc, Scheme_Name, c_big_ ## C_Name, Req, Opt, Rst, H_ ## C_Name, Q_ ## C_Name)

  sc->add_symbol =              big_defun("+",                add,              0, 0, true);
  sc->subtract_symbol =         big_defun("-",                subtract,         1, 0, true);
  sc->multiply_symbol =         big_defun("*",                multiply,         0, 0, true);
  sc->divide_symbol =           big_defun("/",                divide,           1, 0, true);
  sc->max_symbol =              big_defun("max",              max,              1, 0, true);
  sc->min_symbol =              big_defun("min",              min,              1, 0, true);
  sc->lt_symbol =               big_defun("<",                less,             2, 0, true);
  sc->leq_symbol =              big_defun("<=",               less_or_equal,    2, 0, true);
  sc->gt_symbol =               big_defun(">",                greater,          2, 0, true);
  sc->geq_symbol =              big_defun(">=",               greater_or_equal, 2, 0, true);
  sc->eq_symbol =               big_defun("=",                equal,            2, 0, true);
  sc->rationalize_symbol =      big_defun("rationalize",      rationalize,      1, 1, false);
#if (!WITH_PURE_S7)
  sc->exact_to_inexact_symbol = big_defun("exact->inexact",   exact_to_inexact, 1, 0, false);
  sc->inexact_to_exact_symbol = big_defun("inexact->exact",   inexact_to_exact, 1, 0, false);
  sc->integer_length_symbol =   big_defun("integer-length",   integer_length,   1, 0, false);
  sc->make_rectangular_symbol = c_big_defun("make-rectangular", complex,        2, 0, false);
  sc->make_polar_symbol =       big_defun("make-polar",       make_polar,       2, 0, false);
#endif
  sc->floor_symbol =            big_defun("floor",            floor,            1, 0, false);
  sc->ceiling_symbol =          big_defun("ceiling",          ceiling,          1, 0, false);
  sc->truncate_symbol =         big_defun("truncate",         truncate,         1, 0, false);
  sc->round_symbol =            big_defun("round",            round,            1, 0, false);
  sc->quotient_symbol =         big_defun("quotient",         quotient,         2, 0, false);
  sc->remainder_symbol =        big_defun("remainder",        remainder,        2, 0, false);
  sc->modulo_symbol =           big_defun("modulo",           modulo,           2, 0, false);
  sc->gcd_symbol =              big_defun("gcd",              gcd,              0, 0, true);
  sc->lcm_symbol =              big_defun("lcm",              lcm,              0, 0, true);
  sc->complex_symbol =          c_big_defun("complex",        complex,          2, 0, false);
  sc->magnitude_symbol =        big_defun("magnitude",        magnitude,        1, 0, false);
  sc->angle_symbol =            big_defun("angle",            angle,            1, 0, false);
  sc->abs_symbol =              big_defun("abs",              abs,              1, 0, false);
  sc->lognot_symbol =           big_defun("lognot",           lognot,           1, 0, false);
  sc->logior_symbol =           big_defun("logior",           logior,           0, 0, true);
  sc->logxor_symbol =           big_defun("logxor",           logxor,           0, 0, true);
  sc->logand_symbol =           big_defun("logand",           logand,           0, 0, true);
  sc->ash_symbol =              big_defun("ash",              ash,              2, 0, false);
  sc->exp_symbol =              big_defun("exp",              exp,              1, 0, false);
  sc->expt_symbol =             big_defun("expt",             expt,             2, 0, false);
  sc->log_symbol =              big_defun("log",              log,              1, 1, false);
  sc->sqrt_symbol =             big_defun("sqrt",             sqrt,             1, 0, false);
  sc->sin_symbol =              big_defun("sin",              sin,              1, 0, false);
  sc->cos_symbol =              big_defun("cos",              cos,              1, 0, false);
  sc->tan_symbol =              big_defun("tan",              tan,              1, 0, false);
  sc->asin_symbol =             big_defun("asin",             asin,             1, 0, false);
  sc->acos_symbol =             big_defun("acos",             acos,             1, 0, false);
  sc->atan_symbol =             big_defun("atan",             atan,             1, 1, false);
  sc->sinh_symbol =             big_defun("sinh",             sinh,             1, 0, false);
  sc->cosh_symbol =             big_defun("cosh",             cosh,             1, 0, false);
  sc->tanh_symbol =             big_defun("tanh",             tanh,             1, 0, false);
  sc->asinh_symbol =            big_defun("asinh",            asinh,            1, 0, false);
  sc->acosh_symbol =            big_defun("acosh",            acosh,            1, 0, false);
  sc->atanh_symbol =            big_defun("atanh",            atanh,            1, 0, false);
  sc->random_symbol =           big_defun("random",           random,           1, 1, false);
  sc->random_state_symbol =     big_defun("random-state",     random_state,     1, 1, false);
  sc->is_bignum_symbol =        big_defun("bignum?",          is_bignum,        1, 0, false); /* needed by Q_bignum below */
  sc->bignum_symbol =           big_defun("bignum",           bignum,           1, 1, false);

  sc->bignum_precision = DEFAULT_BIGNUM_PRECISION;
  mpfr_set_default_prec((mp_prec_t)DEFAULT_BIGNUM_PRECISION);
  mpc_set_default_precision((mp_prec_t)DEFAULT_BIGNUM_PRECISION);

  s7_symbol_set_value(sc, sc->pi_symbol, big_pi(sc));

  /* if these fixnum limits were read as strings, they'd be bignums in the gmp case,
   *   so for consistency make the symbolic versions bignums as well.
   */
  s7_symbol_set_value(sc, make_symbol(sc, "most-positive-fixnum"), s7_int_to_big_integer(sc, s7_integer(s7_name_to_value(sc, "most-positive-fixnum"))));
  s7_symbol_set_value(sc, make_symbol(sc, "most-negative-fixnum"), s7_int_to_big_integer(sc, s7_integer(s7_name_to_value(sc, "most-negative-fixnum"))));

  s7_provide(sc, "gmp");
}

#endif
/* WITH_GMP */


/* -------------------------------- *s7* environment -------------------------------- */

s7_int s7_print_length(s7_scheme *sc) {return(sc->print_length);}
s7_int s7_set_print_length(s7_scheme *sc, s7_int new_len)
{
  s7_int old_len;
  old_len = sc->print_length;
  sc->print_length = new_len;
  return(old_len);
}

s7_int s7_float_format_precision(s7_scheme *sc) {return(sc->float_format_precision);}
s7_int s7_set_float_format_precision(s7_scheme *sc, s7_int new_len)
{
  s7_int old_len;
  old_len = sc->float_format_precision;
  sc->float_format_precision = new_len;
  return(old_len);
}

static s7_pointer s7_let_field(s7_scheme *sc, const char *name)
{
  s7_pointer sym;
  sym = make_symbol(sc, name);
  set_s7_let_field(sym);
  return(sym);
}

static void init_s7_let(s7_scheme *sc)
{
  sc->stack_top_symbol =                     s7_let_field(sc, "stack-top");
  sc->stack_size_symbol =                    s7_let_field(sc, "stack-size");
  sc->stacktrace_defaults_symbol =           s7_let_field(sc, "stacktrace-defaults");
  sc->heap_size_symbol =                     s7_let_field(sc, "heap-size");
  sc->free_heap_size_symbol =                s7_let_field(sc, "free-heap-size");
  sc->gc_freed_symbol =                      s7_let_field(sc, "gc-freed");
  sc->gc_protected_objects_symbol =          s7_let_field(sc, "gc-protected-objects");
  /* set_immutable(sc->gc_protected_objects_symbol); */ /* removed 30-Mar-19 */
  sc->file_names_symbol =                    s7_let_field(sc, "file-names");
  sc->rootlet_size_symbol =                  s7_let_field(sc, "rootlet-size");
  sc->c_types_symbol =                       s7_let_field(sc, "c-types");
  sc->safety_symbol =                        s7_let_field(sc, "safety");
  sc->undefined_identifier_warnings_symbol = s7_let_field(sc, "undefined-identifier-warnings");
  sc->undefined_constant_warnings_symbol =   s7_let_field(sc, "undefined-constant-warnings");
  sc->gc_stats_symbol =                      s7_let_field(sc, "gc-stats");
  sc->max_heap_size_symbol =                 s7_let_field(sc, "max-heap-size");
  sc->max_stack_size_symbol =                s7_let_field(sc, "max-stack-size");
  sc->cpu_time_symbol =                      s7_let_field(sc, "cpu-time");
  sc->catches_symbol =                       s7_let_field(sc, "catches");
  sc->stack_symbol =                         s7_let_field(sc, "stack");
  sc->max_string_length_symbol =             s7_let_field(sc, "max-string-length");
  sc->max_format_length_symbol =             s7_let_field(sc, "max-format-length");
  sc->max_list_length_symbol =               s7_let_field(sc, "max-list-length");
  sc->max_vector_length_symbol =             s7_let_field(sc, "max-vector-length");
  sc->max_vector_dimensions_symbol =         s7_let_field(sc, "max-vector-dimensions");
  sc->default_hash_table_length_symbol =     s7_let_field(sc, "default-hash-table-length");
  sc->initial_string_port_length_symbol =    s7_let_field(sc, "initial-string-port-length");
  sc->default_rationalize_error_symbol =     s7_let_field(sc, "default-rationalize-error");
  sc->default_random_state_symbol =          s7_let_field(sc, "default-random-state");
  sc->equivalent_float_epsilon_symbol =      s7_let_field(sc, "equivalent-float-epsilon");
  sc->hash_table_float_epsilon_symbol =      s7_let_field(sc, "hash-table-float-epsilon");
  sc->print_length_symbol =                  s7_let_field(sc, "print-length");
  sc->bignum_precision_symbol =              s7_let_field(sc, "bignum-precision");
  sc->memory_usage_symbol =                  s7_let_field(sc, "memory-usage");
  sc->float_format_precision_symbol =        s7_let_field(sc, "float-format-precision");
  sc->history_symbol =                       s7_let_field(sc, "history");
  sc->history_enabled_symbol =               s7_let_field(sc, "history-enabled");
  sc->history_size_symbol =                  s7_let_field(sc, "history-size");
  sc->profile_info_symbol =                  s7_let_field(sc, "profile-info");
  sc->autoloading_symbol =                   s7_let_field(sc, "autoloading?");
}

#ifdef __linux__
  #include <sys/resource.h>
#endif

static s7_pointer kmg(s7_scheme *sc, s7_int bytes)
{
  block_t *b;
  int len = 0;
  b = mallocate(sc, 128);
  if (bytes < 1000)
    len = snprintf((char *)block_data(b), 128, "%" print_s7_int, bytes);
  else
    {
      if (bytes < 1000000)
	len = snprintf((char *)block_data(b), 128, "%.1fk", bytes / 1000.0);
      else
	{
	  if (bytes < 1000000000)
	    len = snprintf((char *)block_data(b), 128, "%.1fM", bytes / 1000000.0);
	  else len = snprintf((char *)block_data(b), 128, "%.1fG", bytes / 1000000000.0);
	}
    }
  return(cons(sc, make_integer(sc, bytes), block_to_string(sc, b, len)));
}

static s7_pointer memory_usage(s7_scheme *sc)               /* (for-each (lambda (f) (format *stderr* "~S~%" f)) (*s7* 'memory-usage)) */
{
  s7_int i, k, len, gc_loc;
  s7_pointer x, mu_let;
  gc_list *gp;
  s7_int ts[NUM_TYPES];

#ifdef __linux__
  struct rusage info;
  struct timeval ut;
#endif

  mu_let = s7_inlet(sc, sc->nil);
  gc_loc = s7_gc_protect_1(sc, mu_let);

#ifdef __linux__
  getrusage(RUSAGE_SELF, &info);
  ut = info.ru_utime;
  make_slot_1(sc, mu_let, make_symbol(sc, "process-time"), make_real(sc, ut.tv_sec + (floor(ut.tv_usec / 1000.0) / 1000.0)));
  make_slot_1(sc, mu_let, make_symbol(sc, "process-size"), kmg(sc, info.ru_maxrss * 1024));
  make_slot_1(sc, mu_let, make_symbol(sc, "IO"), cons(sc, make_integer(sc, info.ru_inblock), make_integer(sc, info.ru_oublock)));
#endif
#if (!S7_DEBUGGING)
  make_slot_1(sc, mu_let,
	      make_symbol(sc, "permanent-cells"),
	      cons(sc, make_integer(sc, sc->permanent_cells), kmg(sc, sc->permanent_cells * sizeof(s7_cell))));
#else
  make_slot_1(sc, mu_let, make_symbol(sc, "permanent-cells"),
	      s7_list(sc, 14,
		      make_integer(sc, sc->permanent_cells), kmg(sc, sc->permanent_cells * sizeof(s7_cell)), /* big allocs here, so this is slightly inaccurate */
		      make_symbol(sc, "unheap"), make_integer(sc, petrified_pointers),
		      make_symbol(sc, "slot"),   make_integer(sc, permanent_slots),
		      make_symbol(sc, "port"),   make_integer(sc, permanent_ports),
		      make_symbol(sc, "string"), make_integer(sc, permanent_strings),
		      make_symbol(sc, "cons"),   make_integer(sc, permanent_conses),
		      make_symbol(sc, "func"),   make_integer(sc, permanent_functions)));
  make_slot_1(sc, mu_let, make_symbol(sc, "permanent-strings"), kmg(sc, permanent_string_len));
#endif

  make_slot_1(sc, mu_let, make_symbol(sc, "rootlet-size"), make_integer(sc, sc->rootlet_entries));
  make_slot_1(sc, mu_let, make_symbol(sc, "heap-size"), cons(sc, make_integer(sc, sc->heap_size), kmg(sc, sc->heap_size * sizeof(s7_cell))));
  make_slot_1(sc, mu_let, make_symbol(sc, "cell-size"), make_integer(sc, sizeof(s7_cell)));

  for (i = 0; i < NUM_TYPES; i++) ts[i] = 0;
  for (k = 0; k < sc->heap_size; k++)
    ts[unchecked_type(sc->heap[k])]++;
  sc->w = sc->nil;
  for (i = 0; i < NUM_TYPES; i++)
    {
      if (ts[i] > 50)
	sc->w = cons(sc, cons(sc, make_symbol(sc, (i == 0) ? "free" : type_name_from_type(i, NO_ARTICLE)), make_integer(sc, ts[i])), sc->w);
    }
  if (is_pair(sc->w))
    make_slot_1(sc, mu_let, make_symbol(sc, "types"), sc->w);
  sc->w = sc->nil;

  make_slot_1(sc, mu_let, make_symbol(sc, "gc-protected-objects"),
	      cons(sc, make_integer(sc, sc->protected_objects_size - sc->gpofl_loc),
		   make_integer(sc, sc->protected_objects_size)));
  make_slot_1(sc, mu_let, make_symbol(sc, "setters"), make_integer(sc, sc->protected_setters_loc));

  {
    s7_int syms = 0, gens = 0, keys = 0, mx_list = 0;
    for (i = 0; i < SYMBOL_TABLE_SIZE; i++)
      {
	for (k = 0, x = vector_element(sc->symbol_table, i); is_not_null(x); x = cdr(x), k++)
	  {
	    syms++;
	    if (is_gensym(car(x))) gens++;
	    if (is_keyword(car(x))) keys++;
	  }
	if (k > mx_list) mx_list = k;
      }
    make_slot_1(sc, mu_let, make_symbol(sc, "symbol-table"),
		s7_list(sc, 9,
			make_integer(sc, SYMBOL_TABLE_SIZE),
			make_symbol(sc, "max-bin"), make_integer(sc, mx_list),
			make_symbol(sc, "symbols"), cons(sc, make_integer(sc, syms), make_integer(sc, syms - gens - keys)),
			make_symbol(sc, "gensyms"), make_integer(sc, gens),
			make_symbol(sc, "keys"),    make_integer(sc, keys)));
  }
  make_slot_1(sc, mu_let, make_symbol(sc, "stack"), cons(sc, make_integer(sc, s7_stack_top(sc)), make_integer(sc, sc->stack_size)));

  gp = sc->strings;
  for (len = 0, i = 0; i < (int32_t)(gp->loc); i++)
    len += string_length(gp->list[i]);
  make_slot_1(sc, mu_let, make_symbol(sc, "strings"), cons(sc, make_integer(sc, gp->loc), make_integer(sc, len)));

  {
    s7_int vlen = 0, flen = 0, ilen = 0, blen = 0;
    for (k = 0, gp = sc->vectors; k < 2; k++)
      {
	for (i = 0; i < gp->loc; i++)
	  {
	    s7_pointer v;
	    v = gp->list[i];
	    if (is_float_vector(v))
	      flen += vector_length(v);
	    else
	      {
		if (is_int_vector(v))
		  ilen += vector_length(v);
		else
		  {
		    if (is_byte_vector(v))
		      blen += vector_length(v);
		    else vlen += vector_length(v);
		  }
	      }
	  }
	gp = sc->multivectors;
      }
    make_slot_1(sc, mu_let, make_symbol(sc, "vectors"),
		s7_list(sc, 9,
			make_integer(sc, sc->vectors->loc + sc->multivectors->loc),
			make_symbol(sc, "vlen"),  make_integer(sc, vlen),
			make_symbol(sc, "fvlen"), make_integer(sc, flen),
			make_symbol(sc, "ivlen"), make_integer(sc, ilen),
			make_symbol(sc, "bvlen"), make_integer(sc, blen)));
  }

  gp = sc->input_ports;
  for (i = 0, len = 0; i < gp->loc; i++)
    {
      s7_pointer v;
      v = gp->list[i];
      if (port_data(v)) len += port_data_size(v);
    }
  make_slot_1(sc, mu_let, make_symbol(sc, "input-ports"), cons(sc, make_integer(sc, sc->input_ports->loc), make_integer(sc, len)));

  gp = sc->output_ports;
  for (i = 0, len = 0; i < gp->loc; i++)
    {
      s7_pointer v;
      v = gp->list[i];
      if (port_data(v)) len += port_data_size(v);
    }
  make_slot_1(sc, mu_let, make_symbol(sc, "output-ports"), cons(sc, make_integer(sc, sc->output_ports->loc), make_integer(sc, len)));

  gp = sc->continuations;
  for (i = 0, len = 0; i < gp->loc; i++)
    if (is_continuation(gp->list[i]))
      len += continuation_stack_size(gp->list[i]);
  make_slot_1(sc, mu_let, make_symbol(sc, "continuations"), cons(sc, make_integer(sc, sc->continuations->loc), make_integer(sc, len)));

  make_slot_1(sc, mu_let, make_symbol(sc, "c-objects"), make_integer(sc, sc->c_objects->loc));
#if WITH_GMP
  make_slot_1(sc, mu_let, make_symbol(sc, "bignums"),
	      s7_list(sc, 5, make_integer(sc, sc->big_integers->loc), make_integer(sc, sc->big_ratios->loc),
		      make_integer(sc, sc->big_reals->loc), make_integer(sc, sc->big_complexes->loc),
		      make_integer(sc, sc->big_random_states->loc)));
#endif

  {
    block_t *b;
    for (i = 0, len = 0, sc->w = sc->nil; i < TOP_BLOCK_LIST; i++)
      {
	for (b = sc->block_lists[i], k = 0; b; b = block_next(b), k++);
	sc->w = cons(sc, make_integer(sc, k), sc->w);
	len += ((sizeof(block_t) + (1LL << i)) * k);
      }
    for (b = sc->block_lists[TOP_BLOCK_LIST], k = 0; b; b = block_next(b), k++)
      len += (sizeof(block_t) + block_size(b));
    sc->w = cons(sc, make_integer(sc, k), sc->w);
    make_slot_1(sc, mu_let, make_symbol(sc, "free-lists"),
		list_2(sc, cons(sc, make_symbol(sc, "bytes"), kmg(sc, len)),
		           cons(sc, make_symbol(sc, "bins"), safe_reverse_in_place(sc, sc->w))));
    sc->w = sc->nil;
  }

  s7_gc_unprotect_at(sc, gc_loc);
  return(mu_let);
}

static s7_pointer g_s7_let_ref_fallback(s7_scheme *sc, s7_pointer args)
{
  s7_pointer sym;

  sym = cadr(args);
  if (!is_symbol(sym))
    return(simple_wrong_type_argument(sc, sc->let_ref_symbol, sym, T_SYMBOL));
  if (!is_s7_let_field(sym))
    return(s7_error(sc, sc->error_symbol,
		    set_elist_2(sc, wrap_string(sc, "can't get (*s7* '~S); no such field in *s7*", 43), sym)));

  if (sym == sc->print_length_symbol)                                    /* print-length */
    return(s7_make_integer(sc, sc->print_length));

  if (sym == sc->stack_top_symbol)                                       /* stack-top = how many frames active (4 stack entries per frame) */
    return(s7_make_integer(sc, (sc->stack_end - sc->stack_start) / 4));
  if (sym == sc->stack_size_symbol)                                      /* stack-size (max so far) */
    return(s7_make_integer(sc, sc->stack_size));
  if (sym == sc->max_stack_size_symbol)                                  /* max-stack-size */
    return(s7_make_integer(sc, sc->max_stack_size));
  if (sym == sc->stacktrace_defaults_symbol)                             /* stacktrace-defaults */
    return(sc->stacktrace_defaults);

  if (sym == sc->rootlet_size_symbol)                                    /* rootlet-size */
    return(s7_make_integer(sc, sc->rootlet_entries));
  if (sym == sc->safety_symbol)                                          /* safety */
    return(s7_make_integer(sc, sc->safety));
  if (sym == sc->autoloading_symbol)                                     /* autoloading? */
    return(s7_make_boolean(sc, sc->is_autoloading));
  if (sym == sc->undefined_identifier_warnings_symbol)                   /* undefined-identifier-warnings */
    return(s7_make_boolean(sc, sc->undefined_identifier_warnings));
  if (sym == sc->undefined_constant_warnings_symbol)                     /* undefined-constant-warnings */
    return(s7_make_boolean(sc, sc->undefined_constant_warnings));
  if (sym == sc->cpu_time_symbol)                                        /* cpu-time */
    return(s7_make_real(sc, (double)clock() / (double)CLOCKS_PER_SEC));
  if (sym == sc->catches_symbol)                                         /* catches */
    return(active_catches(sc));
  if (sym == sc->stack_symbol)                                           /* stack */
    return(stack_entries(sc, sc->stack, s7_stack_top(sc)));

  if (sym == sc->max_heap_size_symbol)                                   /* max-heap-size */
    return(s7_make_integer(sc, sc->max_heap_size));
  if (sym == sc->heap_size_symbol)                                       /* heap-size */
    return(s7_make_integer(sc, sc->heap_size));
  if (sym == sc->free_heap_size_symbol)                                  /* free-heap-size (number of unused cells in the heap) */
    return(s7_make_integer(sc, sc->free_heap_top - sc->free_heap));
  if (sym == sc->gc_freed_symbol)                                        /* gc-freed = how many cells freed during last GC sweep */
    return(s7_make_integer(sc, sc->gc_freed));
  if (sym == sc->gc_protected_objects_symbol)                            /* gc-protected-objects */
    return(sc->protected_objects);
  if (sym == sc->gc_stats_symbol)                                        /* gc-stats */
    return(make_integer(sc, sc->gc_stats));

  if (sym == sc->default_rationalize_error_symbol)                       /* default-rationalize-error */
    return(make_real(sc, sc->default_rationalize_error));
  if (sym == sc->default_random_state_symbol)                            /* default-random-state */
    return(sc->default_rng);

  if (sym == sc->history_symbol)                                         /* history (eval history circular buffer) */
#if WITH_HISTORY
    {
      if (sc->cur_code == sc->history_sink) /* i.e. history is current disabled */
	return((sc->using_history1) ? sc->eval_history1 : sc->eval_history2);
      return(sc->cur_code);
    }
#else
    return(sc->F);
#endif
  if (sym == sc->history_size_symbol)                                    /* history-size (eval history circular buffer size) */
    return(s7_make_integer(sc, sc->history_size));
  if (sym == sc->history_enabled_symbol)                                 /* history-enabled (is history buffer receiving additions) */
    return(s7_make_boolean(sc, s7_history_enabled(sc)));
  if (sym == sc->profile_info_symbol)                                    /* profile-info -- profiling data hash-table */
    return(sc->profile_info);
  if (sym == sc->max_list_length_symbol)                                 /* max-list-length (as arg to make-list) */
    return(s7_make_integer(sc, sc->max_list_length));
  if (sym == sc->max_vector_length_symbol)                               /* max-vector-length (as arg to make-vector and make-hash-table) */
    return(s7_make_integer(sc, sc->max_vector_length));
  if (sym == sc->max_vector_dimensions_symbol)                           /* max-vector-dimensions (make-vector) */
    return(s7_make_integer(sc, sc->max_vector_dimensions));
  if (sym == sc->max_string_length_symbol)                               /* max-string-length (as arg to make-string and read-string) */
    return(s7_make_integer(sc, sc->max_string_length));
  if (sym == sc->max_format_length_symbol)                               /* max-format-length (~N and width/precision args for floats) */
    return(s7_make_integer(sc, sc->max_format_length));
  if (sym == sc->default_hash_table_length_symbol)                       /* default size for make-hash-table */
    return(s7_make_integer(sc, sc->default_hash_table_length));
  if (sym == sc->equivalent_float_epsilon_symbol)                        /* equivalent-float-epsilon */
    return(s7_make_real(sc, sc->equivalent_float_epsilon));
  if (sym == sc->hash_table_float_epsilon_symbol)                        /* hash-table-float-epsilon */
    return(s7_make_real(sc, sc->hash_table_float_epsilon));
  if (sym == sc->initial_string_port_length_symbol)                      /* initial-string-port-length */
    return(s7_make_integer(sc, sc->initial_string_port_length));

  if (sym == sc->file_names_symbol)                                      /* file-names (loaded files) */
    {
      int32_t i;
      s7_pointer p;
      sc->w = sc->nil;
      for (i = 0; i <= sc->file_names_top; i++)
	sc->w = cons(sc, sc->file_names[i], sc->w);
      p = sc->w;
      sc->w = sc->nil;
      return(p);
    }

  if (sym == sc->c_types_symbol)                                         /* c-types */
    {
      s7_pointer res;
      int32_t i;
      sc->w = sc->nil;
      for (i = 0; i < sc->num_c_object_types; i++)                       /*   c-object type (tag) is i */
	sc->w = cons(sc, sc->c_object_types[i]->scheme_name, sc->w);
      res = safe_reverse_in_place(sc, sc->w);                            /*   so car(types) has tag 0 */
      sc->w = sc->nil;
      return(res);
    }

  if (sym == sc->bignum_precision_symbol)                                /* bignum-precision */
    return(s7_make_integer(sc, sc->bignum_precision));
  if (sym == sc->float_format_precision_symbol)                          /* float-format-precision */
    return(s7_make_integer(sc, sc->float_format_precision));
  if (sym == sc->memory_usage_symbol)                                    /* memory-usage */
    return(memory_usage(sc));

  /* sc->unlet is a scheme vector of slots -- not very useful at the scheme level */
  return(sc->undefined);
}

static s7_pointer g_s7_let_set_fallback(s7_scheme *sc, s7_pointer args)
{
  s7_pointer sym, val;

  sym = cadr(args);
  if (!is_symbol(sym))
    return(simple_wrong_type_argument(sc, sc->let_set_symbol, sym, T_SYMBOL));
  if (!is_s7_let_field(sym))
    return(s7_error(sc, sc->error_symbol,
		    set_elist_2(sc, wrap_string(sc, "can't set (*s7* '~S); no such field in *s7*", 43), sym)));

  val = caddr(args);

  if ((sym == sc->print_length_symbol) ||
      (sym == sc->max_vector_length_symbol) ||
      (sym == sc->max_vector_dimensions_symbol) ||
      (sym == sc->max_list_length_symbol) ||
      (sym == sc->history_size_symbol) ||
      (sym == sc->max_string_length_symbol) ||
      (sym == sc->max_format_length_symbol) ||
      (sym == sc->default_hash_table_length_symbol) ||
      (sym == sc->float_format_precision_symbol) ||
      (sym == sc->bignum_precision_symbol) ||
      (sym == sc->initial_string_port_length_symbol))
    {
      s7_int iv;

      if (!s7_is_integer(val))
	return(simple_wrong_type_argument(sc, sym, val, T_INTEGER));

      iv = s7_integer(val);         /* might be bignum if gmp */

      if ((iv < 0) ||               /* only print-length and float-format-precision can be 0, none can be negative */
	  ((iv == 0) &&
	   ((sym != sc->print_length_symbol) &&
	    (sym != sc->float_format_precision_symbol))))
	return(simple_out_of_range(sc, sym, val, wrap_string(sc, "should be a positive integer", 28)));

      /* float-format-precision should not be huge => hangs in snprintf -- what's a reasonable limit here? */
      if (sym == sc->float_format_precision_symbol)
	{
	  sc->float_format_precision = (iv < MAX_FLOAT_FORMAT_PRECISION) ? iv : MAX_FLOAT_FORMAT_PRECISION;
	  return(val);
	}

      if (sym == sc->print_length_symbol)               {sc->print_length = iv;               return(val);}
      if (sym == sc->default_hash_table_length_symbol)  {sc->default_hash_table_length = iv;  return(val);}
      if (sym == sc->max_vector_length_symbol)          {sc->max_vector_length = iv;          return(val);}
      if (sym == sc->max_vector_dimensions_symbol)      {sc->max_vector_dimensions = iv;      return(val);}
      if (sym == sc->max_list_length_symbol)            {sc->max_list_length = iv;            return(val);}
      if (sym == sc->max_string_length_symbol)          {sc->max_string_length = iv;          return(val);}
      if (sym == sc->max_format_length_symbol)          {sc->max_format_length = iv;          return(val);}
      if (sym == sc->initial_string_port_length_symbol) {sc->initial_string_port_length = iv; return(val);}
      if (sym == sc->history_size_symbol)
	{
#if WITH_HISTORY
	  s7_pointer p1, p2, p3;
	  if (iv > MAX_HISTORY_SIZE) iv = MAX_HISTORY_SIZE;
	  if (iv > sc->true_history_size)
	    {
	      /* splice in the new cells, reattach the circles */
	      s7_pointer next1, next2, next3;
	      next1 = cdr(sc->eval_history1);
	      next2 = cdr(sc->eval_history2);
	      next3 = cdr(sc->history_pairs);
	      set_cdr(sc->eval_history1, permanent_list(sc, iv - sc->true_history_size));
	      set_cdr(sc->eval_history2, permanent_list(sc, iv - sc->true_history_size));
	      set_cdr(sc->history_pairs, permanent_list(sc, iv - sc->true_history_size));
	      for (p3 = cdr(sc->history_pairs); is_pair(cdr(p3)); p3 = cdr(p3)) set_car(p3, permanent_list(sc, 1));
	      set_car(p3, permanent_list(sc, 1));
	      set_cdr(p3, next3);
	      for (p1 = sc->eval_history1, p2 = sc->eval_history2; is_pair(cdr(p1)); p1 = cdr(p1), p2 = cdr(p2));
	      set_cdr(p1, next1);
	      set_cdr(p2, next2);
	      sc->true_history_size = iv;
	    }
	  sc->history_size = iv;
	  /* clear out both bufffers to avoid GC confusion */
	  for (p1 = sc->eval_history1, p2 = sc->eval_history2; ; p2 = cdr(p2))
	    {
	      set_car(p1, sc->nil);
	      set_car(p2, sc->nil);
	      p1 = cdr(p1);
	      if (p1 == sc->eval_history1) break;
	    }
#else
	  sc->history_size = iv;
#endif
	  return(val);
	}
      if (sym == sc->bignum_precision_symbol)
	{
	  sc->bignum_precision = s7_integer(val);
#if WITH_GMP
	  set_bignum_precision(sc, sc->bignum_precision);
#endif
	}
      return(val);
    }

  if (sym == sc->history_enabled_symbol)
    {
      if (s7_is_boolean(val))
	return(s7_make_boolean(sc, s7_set_history_enabled(sc, s7_boolean(sc, val))));
      return(simple_wrong_type_argument(sc, sym, val, T_BOOLEAN));
    }

  if (sym == sc->gc_stats_symbol)
    {
      if (s7_is_boolean(val)) {sc->gc_stats = ((val == sc->T) ? GC_STATS : 0); return(val);}
      if (s7_is_integer(val)) {sc->gc_stats = s7_integer(val); return(val);}
      return(simple_wrong_type_argument(sc, sym, val, T_BOOLEAN));
    }

  if (sym == sc->max_stack_size_symbol)
    {
      if (s7_is_integer(val))
	{
	  s7_int size;
	  size = s7_integer(val);
	  if (size >= INITIAL_STACK_SIZE)
	    {
	      sc->max_stack_size = (uint32_t)size;
	      return(val);
	    }
	  return(simple_out_of_range(sc, sym, val, wrap_string(sc, "should be greater than the initial stack size (512)", 51)));
	}
      return(simple_wrong_type_argument(sc, sym, val, T_INTEGER));
    }

  if (sym == sc->max_heap_size_symbol)
    {
      if (s7_is_integer(val))
	{
	  s7_int size;
	  size = s7_integer(val);
	  if (size > 0)
	    {
	      sc->max_heap_size = size;
	      return(val);
	    }
	  return(simple_out_of_range(sc, sym, val, wrap_string(sc, "should be greater than 0", 24)));
	}
      return(simple_wrong_type_argument(sc, sym, val, T_INTEGER));
    }

  if (sym == sc->safety_symbol)
    {
      if (s7_is_integer(val))
	{
	  if ((s7_integer(val) > 2) || (s7_integer(val) < -1))
	    return(simple_out_of_range(sc, sym, val, wrap_string(sc, "should be between -1 (no safety) and 2 (max safety)", 51)));
	  sc->safety = s7_integer(val);
	  return(val);
	}
      return(simple_wrong_type_argument(sc, sym, val, T_INTEGER));
    }

  if (sym == sc->heap_size_symbol)
    {
      if (s7_is_integer(val))
	{
	  s7_int size;
	  size = s7_integer(val);
	  if (size >= sc->heap_size * 2)
	    resize_heap_to(sc, size);
	  return(val);
	}
      return(simple_wrong_type_argument(sc, sym, val, T_INTEGER));
    }

  if (sym == sc->autoloading_symbol)
    {
      if (s7_is_boolean(val)) {sc->is_autoloading = s7_boolean(sc, val); return(val);}
      return(simple_wrong_type_argument(sc, sym, val, T_BOOLEAN));
    }

  if (sym == sc->undefined_identifier_warnings_symbol)
    {
      if (s7_is_boolean(val)) {sc->undefined_identifier_warnings = s7_boolean(sc, val); return(val);}
      return(simple_wrong_type_argument(sc, sym, val, T_BOOLEAN));
    }
  if (sym == sc->undefined_constant_warnings_symbol)
    {
      if (s7_is_boolean(val)) {sc->undefined_constant_warnings = s7_boolean(sc, val); return(val);}
      return(simple_wrong_type_argument(sc, sym, val, T_BOOLEAN));
    }

  if (sym == sc->equivalent_float_epsilon_symbol)
    {
      if (s7_is_real(val))
	{
	  if (s7_real(val) < 0.0)
	    return(simple_out_of_range(sc, sym, val, wrap_string(sc, "should be positive", 18)));
	  sc->equivalent_float_epsilon = s7_real(val);
	  return(val);
	}
      return(simple_wrong_type_argument(sc, sym, val, T_REAL));
    }

  if (sym == sc->hash_table_float_epsilon_symbol)
    {
      if (s7_is_real(val))
	{
	  if (s7_real(val) < 0.0)
	    return(simple_out_of_range(sc, sym, val, wrap_string(sc, "should be positive", 18)));
	  sc->hash_table_float_epsilon = s7_real(val);
	  return(val);
	}
      return(simple_wrong_type_argument(sc, sym, val, T_REAL));
    }

  if (sym == sc->default_rationalize_error_symbol)
    {
      if (s7_is_real(val))
	{
	  if (s7_real(val) < 0.0)
	    return(simple_out_of_range(sc, sym, val, wrap_string(sc, "should be positive", 18)));
	  sc->default_rationalize_error = s7_real(val);
	  return(val);
	}
      return(simple_wrong_type_argument(sc, sym, val, T_REAL));
    }

  if (sym == sc->default_random_state_symbol)
    {
      if (is_random_state(val))
	{
#if (!WITH_GMP)
	  random_seed(sc->default_rng) = random_seed(val);
	  random_carry(sc->default_rng) = random_carry(val);
#endif
	  return(val);
	}
      return(wrong_type_argument_with_type(sc, sym, 1, val, a_random_state_object_string));
    }

  if (sym == sc->stacktrace_defaults_symbol)
    {
      if (!is_pair(val))
	return(simple_wrong_type_argument(sc, sym, val, T_PAIR));
      if (s7_list_length(sc, val) != 5)
	return(simple_wrong_type_argument_with_type(sc, sym, val, wrap_string(sc, "a list with 5 entries", 21)));
      if (!is_t_integer(car(val)))
	return(wrong_type_argument_with_type(sc, sym, 1, car(val), wrap_string(sc, "an integer (stack frames)", 25)));
      if (!is_t_integer(cadr(val)))
	return(wrong_type_argument_with_type(sc, sym, 2, cadr(val), wrap_string(sc, "an integer (cols-for-data)", 26)));
      if (!is_t_integer(caddr(val)))
	return(wrong_type_argument_with_type(sc, sym, 3, caddr(val), wrap_string(sc, "an integer (line length)", 24)));
      if (!is_t_integer(cadddr(val)))
	return(wrong_type_argument_with_type(sc, sym, 4, cadddr(val), wrap_string(sc, "an integer (comment position)", 29)));
      if (!s7_is_boolean(s7_list_ref(sc, val, 4)))
	return(wrong_type_argument_with_type(sc, sym, 5, s7_list_ref(sc, val, 4), wrap_string(sc, "a boolean (treat-data-as-comment)", 33)));
      sc->stacktrace_defaults = copy_list(sc, val);
      return(val);
    }

  if ((sym == sc->cpu_time_symbol) || (sym == sc->profile_info_symbol) ||
      (sym == sc->free_heap_size_symbol) || (sym == sc->gc_freed_symbol) || (sym == sc->gc_protected_objects_symbol) ||
      (sym == sc->file_names_symbol) || (sym == sc->c_types_symbol) || (sym == sc->catches_symbol) ||
      (sym == sc->rootlet_size_symbol) || (sym == sc->stack_top_symbol) || (sym == sc->stack_size_symbol))
    return(s7_error(sc, sc->error_symbol,
		    set_elist_2(sc, wrap_string(sc, "can't set (*s7* '~S)", 20), sym)));

  return(sc->undefined);
}


#if (!MS_WINDOWS)
/* s7bt: gdb stacktrace decoding */

static const char *decoded_name(s7_scheme *sc, s7_pointer p)
{
  int32_t i;
  if (p == sc->value) return("value");
  if (p == sc->args) return("args");
  if (p == sc->code) return("code");
  if (p == sc->cur_code) return("cur_code");
  if (p == sc->envir) return("envir");
  if (p == sc->nil) return("nil");
  if (p == sc->T) return("T");
  if (p == sc->F) return("F");
  if (p == eof_object) return("eof_object");
  if (p == sc->undefined) return("undefined");
  if (p == sc->unspecified) return("unspecified");
  if (p == sc->no_value) return("no_value");
  if (p == sc->unused) return("#<unused>");
  if (p == sc->symbol_table) return("symbol_table");
  if (p == sc->rootlet) return("rootlet");
  if (p == sc->unlet) return("unlet");
  if (p == sc->input_port) return("input_port");
  if (p == sc->output_port) return("output_port");
  if (p == sc->error_port) return("error_port");
  if (p == sc->owlet) return("owlet");
  if (p == sc->error_type) return("error_type");
  if (p == sc->error_data) return("error_data");
  if (p == sc->error_code) return("error_code");
  if (p == sc->error_line) return("error_line");
  if (p == sc->error_file) return("error_file");
  if (p == sc->standard_input) return("standard_input");
  if (p == sc->standard_output) return("standard_output");
  if (p == sc->standard_error) return("standard_error");
  if (p == sc->else_symbol) return("else_symbol");
  if (p == sc->load_hook) return("load_hook");
  if (p == sc->unbound_variable_hook) return("unbound_variable_hook");
  if (p == sc->missing_close_paren_hook) return("missing_close_paren_hook");
  if (p == sc->rootlet_redefinition_hook) return("rootlet_redefinition_hook");
  if (p == sc->error_hook) return("error_hook");
  if (p == sc->read_error_hook) return("read_error_hook");
  if (p == sc->v) return("v");
  if (p == sc->w) return("w");
  if (p == sc->x) return("x");
  if (p == sc->y) return("y");
  if (p == sc->z) return("z");
  if (p == sc->temp1) return("temp1");
  if (p == sc->temp2) return("temp2");
  if (p == sc->temp3) return("temp3");
  if (p == sc->temp4) return("temp4");
  if (p == sc->temp6) return("temp6");
  if (p == sc->temp7) return("temp7");
  if (p == sc->temp8) return("temp8");
  if (p == sc->temp9) return("temp9");
  if (p == sc->temp10) return("temp10");
  if (p == sc->temp_cell) return("temp_cell");
  if (p == sc->temp_cell_1) return("temp_cell_1");
  if (p == sc->temp_cell_2) return("temp_cell_2");
  if (p == sc->t1_1) return("t1_1");
  if (p == sc->t2_1) return("t2_1");
  if (p == sc->t2_2) return("t2_2");
  if (p == sc->t3_1) return("t3_1");
  if (p == sc->t3_2) return("t3_2");
  if (p == sc->t3_3) return("t3_3");
  if (p == sc->z2_1) return("z2_1");
  if (p == sc->z2_2) return("z2_2");
  if (p == sc->a1_1) return("a1_1");
  if (p == sc->a2_1) return("a2_1");
  if (p == sc->a2_2) return("a2_2");
  if (p == sc->a3_1) return("a3_1");
  if (p == sc->a3_2) return("a3_2");
  if (p == sc->a3_3) return("a3_3");
  if (p == sc->a4_1) return("a4_1");
  if (p == sc->a4_2) return("a4_2");
  if (p == sc->a4_3) return("a4_3");
  if (p == sc->a4_4) return("a4_4");
  if (p == sc->elist_1) return("elist_1");
  if (p == sc->elist_2) return("elist_2");
  if (p == sc->elist_3) return("elist_3");
  if (p == sc->elist_4) return("elist_4");
  if (p == sc->elist_5) return("elist_5");
  if (p == sc->plist_1) return("plist_1");
  if (p == sc->plist_2) return("plist_2");
  if (p == sc->plist_3) return("plist_3");
  if (p == sc->qlist_2) return("qlist_2");
  if (p == sc->qlist_3) return("qlist_3");
  if (p == sc->clist_1) return("clist_1");
  if (p == sc->integer_wrapper1) return("integer_wrapper1");
  if (p == sc->integer_wrapper2) return("integer_wrapper2");
  if (p == sc->integer_wrapper3) return("integer_wrapper3");
  if (p == sc->real_wrapper1) return("real_wrapper1");
  if (p == sc->real_wrapper2) return("real_wrapper2");
  if (p == sc->real_wrapper3) return("real_wrapper3");
  if (p == sc->real_wrapper4) return("real_wrapper4");
  for (i = 0; i < NUM_STRING_WRAPPERS; i++)
    if (p == sc->string_wrappers[i])
      return("string_wrapper");
  if (p == sc->wrong_type_arg_info) return("wrong_type_arg_info");
  if (p == sc->out_of_range_info) return("out_of_range_info");
  if (p == sc->simple_wrong_type_arg_info) return("simple_wrong_type_arg_info");
  if (p == sc->simple_out_of_range_info) return("simple_out_of_range_info");
  if (p == too_many_arguments_string) return("too_many_arguments_string");
  if (p == not_enough_arguments_string) return("not_enough_arguments_string");
  if (p == missing_method_string) return("missing_method_string");
  if (p == sc->stack) return("stack");

  for (i = 0; i < T_TEMPS_SIZE; i++)
    if (p == sc->t_temps[i])
      return("t_temp");
  for (i = 0; i < NUM_SAFE_LISTS; i++)
    if (p == sc->safe_lists[i])
      return("safe_list");

  return(NULL);
}

static bool is_decodable(s7_scheme *sc, s7_pointer p)
{
  int32_t i;
  s7_pointer x;
  s7_pointer *tp, *heap_top;

  /* check symbol-table */
  for (i = 0; i < SYMBOL_TABLE_SIZE; i++)
    for (x = vector_element(sc->symbol_table, i); is_not_null(x); x = cdr(x))
      {
	s7_pointer sym;
	sym = car(x);
	if ((sym == p) ||
	    ((is_global(sym)) && (is_slot(global_slot(sym))) && (p == slot_value(global_slot(sym)))))
	  return(true);
      }

  for (i = 0; i < NUM_CHARS; i++) if (p == chars[i]) return(true);
  for (i = 0; i <= NUM_SMALL_INTS; i++) if (p == small_ints[i]) return(true);
  /* also real_one and friends, sc->safe_lists, p|elist? */

  /* check the heap */
  tp = sc->heap;
  heap_top = (s7_pointer *)(sc->heap + sc->heap_size);
  while (tp < heap_top)
    if (p == (*tp++))
      return(true);

  return(false);
}

char *s7_decode_bt(s7_scheme *sc)
{
  FILE *fp;
  fp = fopen("gdb.txt", "r");
  if (fp)
    {
      int64_t i, size;
      size_t bytes;
      bool in_quotes = false;
      uint8_t *bt;
      block_t *bt_block;

      fseek(fp, 0, SEEK_END);
      size = ftell(fp);
      rewind(fp);

      bt_block = mallocate(sc, (size + 1) * sizeof(uint8_t));
      bt = (uint8_t *)block_data(bt_block);
      bytes = fread(bt, sizeof(uint8_t), size, fp);
      if (bytes != (size_t)size)
	{
	  fclose(fp);
	  liberate(sc, bt_block);
	  return((char *)" oops ");
	}
      bt[size] = '\0';
      fclose(fp);

      for (i = 0; i < size; i++)
	{
	  fputc(bt[i], stdout);
	  if ((bt[i] == '"') && ((i == 0) || (bt[i - 1] != '\\')))
	    in_quotes = (!in_quotes);
	  else
	    {
	      if ((!in_quotes) && (i < size - 8))
		{
		  if ((bt[i] == '=') &&
		      (((bt[i + 1] == '0') && (bt[i + 2] == 'x')) ||
		       ((bt[i + 1] == ' ') && (bt[i + 2] == '0') && (bt[i + 3] == 'x'))))
		    {
		      void *vp;
		      int32_t vals;
		      vals = sscanf((const char *)(bt + i + 1), "%p", &vp);
		      if ((vp) && (vals == 1))
			{
			  int32_t k;
			  for (k = i + ((bt[i + 2] == 'x') ? 3 : 4); (k < size) && (IS_DIGIT(bt[k], 16)); k++);
			  if ((bt[k] != ' ') || (bt[k + 1] != '"'))
			    {
			      if (vp == (void *)sc)
				{
				  if (bt[i + 1] == ' ') fputc(' ', stdout);
				  fprintf(stdout, "%s[s7]%s", BOLD_TEXT, UNBOLD_TEXT);
				  i = k - 1;
				}
			      else
				{
				  s7_pointer p;
				  const char *dname;

				  p = (s7_pointer)vp;
				  dname = decoded_name(sc, p);
				  if (dname)
				    {
				      if (bt[i + 1] == ' ') fputc(' ', stdout);
				      fprintf(stdout, "%s[sc->%s]%s", BOLD_TEXT, dname, UNBOLD_TEXT);
				    }

				  if ((dname) || (is_decodable(sc, p)))
				    {
				      if (bt[i + 1] == ' ') fputc(' ', stdout);
				      i = k - 1;
				      if (s7_is_valid(sc, p))
					{
					  s7_pointer strp;
					  if (dname) fprintf(stdout, " ");
					  strp = object_to_truncated_string(sc, p, 80);
					  fprintf(stdout, "%s%s%s", BOLD_TEXT, string_value(strp), UNBOLD_TEXT);
					  if ((is_pair(p)) &&
					      (has_line_number(p)))
					    {
					      uint32_t line, file;
					      line = pair_line(p);
					      file = pair_file(p);
					      if (line > 0)
						fprintf(stdout, " %s(%s[%u])%s",
							BOLD_TEXT, string_value(sc->file_names[file]), line, UNBOLD_TEXT);
					    }
					  /* #<stack> etc */
					}}}}}}}}}
      liberate(sc, bt_block);
    }
  return((char *)"");
}
#endif


/* -------------------------------- initialization -------------------------------- */

static s7_pointer make_real_wrapper(void)
{
  s7_pointer p;
  p = (s7_pointer)calloc(1, sizeof(s7_cell));
  typeflag(p) = T_REAL | T_UNHEAP | T_MUTABLE | T_IMMUTABLE;
  return(p);
}

static s7_pointer make_integer_wrapper(void)
{
  s7_pointer p;
  p = (s7_pointer)calloc(1, sizeof(s7_cell));
  typeflag(p) = T_INTEGER | T_UNHEAP | T_MUTABLE | T_IMMUTABLE; /* mutable to turn off set_has_print_name */
  return(p);
}

static void init_wrappers(s7_scheme *sc)
{
  int32_t i;
  sc->integer_wrapper1 = make_integer_wrapper();
  sc->integer_wrapper2 = make_integer_wrapper();
  sc->integer_wrapper3 = make_integer_wrapper();
  sc->real_wrapper1 = make_real_wrapper();
  sc->real_wrapper2 = make_real_wrapper();
  sc->real_wrapper3 = make_real_wrapper();
  sc->real_wrapper4 = make_real_wrapper();

  sc->string_wrappers = (s7_pointer *)malloc(NUM_STRING_WRAPPERS * sizeof(s7_pointer));
  sc->string_wrapper_pos = 0;
  for (i = 0; i < NUM_STRING_WRAPPERS; i++)
    {
      s7_pointer p;
      p = (s7_pointer)calloc(1, sizeof(s7_cell));
      sc->string_wrappers[i] = p;
      typeflag(p) = T_STRING | T_IMMUTABLE | T_SAFE_PROCEDURE | T_UNHEAP;
      string_block(p) = NULL;
      string_value(p) = NULL;
      string_length(p) = 0;
      string_hash(p) = 0;
    }
}

static s7_pointer make_unique(s7_scheme *sc, const char* name, uint64_t typ)
{
  s7_pointer p;
  p = alloc_pointer(sc);
  set_type(p, typ | T_IMMUTABLE | T_UNHEAP);
  unique_name_length(p) = safe_strlen(name);
  unique_name(p) = copy_string_with_length(name, unique_name_length(p));
  return(p);
}

#if (!MS_WINDOWS)
static pthread_mutex_t init_lock = PTHREAD_MUTEX_INITIALIZER;
#endif

s7_scheme *s7_init(void)
{
  int32_t i;
  s7_scheme *sc;
  s7_pointer sym;
  static bool already_inited = false;

#if (!MS_WINDOWS)
  setlocale(LC_NUMERIC, "C"); /* use decimal point in floats */
  pthread_mutex_lock(&init_lock);
#endif

  if (!already_inited)
    {
      if (sizeof(void *) > sizeof(s7_int))
	fprintf(stderr, "s7_int is too small: it has %d bytes, but void* has %d\n", (int)sizeof(s7_int), (int)sizeof(void *));

      init_types();
      init_ctables();
      init_mark_functions();
      init_display_functions();
      init_length_functions();
      init_equals();
      init_hash_maps();
      init_pows();
      init_int_limits();
      init_small_ints();
      init_uppers();
      init_chars();
      init_strings();
      fx_function_init();
      init_catchers();
      already_inited = true;
    }
#if (!MS_WINDOWS)
  pthread_mutex_unlock(&init_lock);
#endif
  sc = (s7_scheme *)calloc(1, sizeof(s7_scheme)); /* malloc is not recommended here */
  cur_sc = sc;                                    /* for gdb/debugging and clm optimizer */
  sc->gc_off = true;                              /* sc->args and so on are not set yet, so a gc during init -> segfault */
  sc->gc_stats = 0;
  init_gc_caches(sc);
  sc->permanent_cells = 0;
  sc->alloc_pointer_k = ALLOC_POINTER_SIZE;
  sc->alloc_pointer_cells = NULL;
  sc->alloc_big_pointer_k = ALLOC_BIG_POINTER_SIZE;
  sc->alloc_big_pointer_cells = NULL;
  sc->alloc_function_k = ALLOC_FUNCTION_SIZE;
  sc->alloc_function_cells = NULL;
  sc->alloc_symbol_k = ALLOC_SYMBOL_SIZE;
  sc->alloc_symbol_cells = NULL;
  sc->num_to_str_size = -1;
  sc->num_to_str = NULL;
  init_block_lists(sc);
  sc->alloc_string_k = ALLOC_STRING_SIZE;
  sc->alloc_string_cells = NULL;

  sc->longjmp_ok = false;
  sc->setjmp_loc = NO_SET_JUMP;

  if (sizeof(s7_int) == 4)
    sc->max_vector_length = (1 << 24);
  else sc->max_vector_length = (1LL << 32);
  sc->max_string_length = 1073741824; /* 1 << 30 */
  sc->max_format_length = 10000;
  sc->max_list_length = 1073741824;
  sc->max_vector_dimensions = 512;

  sc->strbuf_size = INITIAL_STRBUF_SIZE;
  sc->strbuf = (char *)calloc(sc->strbuf_size, sizeof(char));
  sc->print_width = sc->max_string_length;
  sc->short_print = false;
  sc->in_with_let = false;
  sc->object_out_locked = false;
  sc->has_openlets = true;

  sc->initial_string_port_length = 128;
  sc->format_depth = -1;
  sc->singletons = (s7_pointer *)calloc(256, sizeof(s7_pointer));
  sc->read_line_buf = NULL;
  sc->read_line_buf_size = 0;
  sc->last_error_line = -1;

  sc->nil =         make_unique(sc, "()",             T_NIL);
  sc->unused =      make_unique(sc, "#<unused>",      T_UNUSED);
  sc->T =           make_unique(sc, "#t",             T_BOOLEAN);
  sc->F =           make_unique(sc, "#f",             T_BOOLEAN);
  sc->undefined =   make_unique(sc, "#<undefined>",   T_UNDEFINED);
  sc->unspecified = make_unique(sc, "#<unspecified>", T_UNSPECIFIED);
#if S7_DEBUGGING
  sc->no_value =    make_unique(sc, "#<values>",      T_UNSPECIFIED);
#else
  sc->no_value =    make_unique(sc, "#<unspecified>", T_UNSPECIFIED);
#endif

  unique_car(sc->nil) = sc->unspecified;
  unique_cdr(sc->nil) = sc->unspecified;
  /* this is mixing two different s7_cell structs, cons and envr, but luckily envr has two initial s7_pointer fields, equivalent to car and cdr, so
   *    let_id which is the same as opt1 is unaffected.  To get the names built-in, I'll append unique_name and unique_name_length fields to the envr struct.
   */
  let_id(sc->nil) = -1;
  unique_cdr(sc->unspecified) = sc->unspecified;
  unique_cdr(sc->undefined) = sc->undefined;
  /* this way find_symbol of an undefined symbol returns #<undefined> not #<unspecified> */

  sc->temp_cell_1 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);
  sc->temp_cell = permanent_cons(sc, sc->temp_cell_1, sc->nil, T_PAIR | T_IMMUTABLE);
  sc->temp_cell_2 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);

  sc->t1_1 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);

  sc->t2_2 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);
  sc->t2_1 = permanent_cons(sc, sc->nil, sc->t2_2, T_PAIR | T_IMMUTABLE);
  sc->z2_2 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);
  sc->z2_1 = permanent_cons(sc, sc->nil, sc->z2_2, T_PAIR | T_IMMUTABLE);

  sc->t3_3 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);
  sc->t3_2 = permanent_cons(sc, sc->nil, sc->t3_3, T_PAIR | T_IMMUTABLE);
  sc->t3_1 = permanent_cons(sc, sc->nil, sc->t3_2, T_PAIR | T_IMMUTABLE);

  sc->a4_4 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);
  sc->a4_3 = permanent_cons(sc, sc->nil, sc->a4_4, T_PAIR | T_IMMUTABLE);
  sc->a4_2 = permanent_cons(sc, sc->nil, sc->a4_3, T_PAIR | T_IMMUTABLE);
  sc->a4_1 = permanent_cons(sc, sc->nil, sc->a4_2, T_PAIR | T_IMMUTABLE);

  sc->a1_1 = sc->a4_4;
  sc->a2_1 = sc->a4_3; sc->a2_2 = sc->a4_4;
  sc->a3_1 = sc->a4_2; sc->a3_2 = sc->a4_3; sc->a3_3 = sc->a4_4;

  sc->u1_1 = permanent_cons(sc, sc->nil, sc->nil, T_PAIR | T_IMMUTABLE);

  sc->safe_lists[0] = sc->nil;
  for (i = 1; i < NUM_SAFE_PRELISTS; i++)
    sc->safe_lists[i] = permanent_list(sc, i);
  for (i = NUM_SAFE_PRELISTS; i < NUM_SAFE_LISTS; i++)
    sc->safe_lists[i] = sc->nil;
  sc->current_safe_list = 0;

  sc->input_port_stack = sc->nil;
  sc->code = sc->nil;
#if WITH_HISTORY
  sc->eval_history1 = permanent_list(sc, DEFAULT_HISTORY_SIZE);
  sc->eval_history2 = permanent_list(sc, DEFAULT_HISTORY_SIZE);
  sc->history_pairs = permanent_list(sc, DEFAULT_HISTORY_SIZE);
  sc->history_sink = permanent_list(sc, 1);
  cdr(sc->history_sink) = sc->history_sink;
  {
    s7_pointer p1, p2, p3;
    for (p3 = sc->history_pairs; is_pair(cdr(p3)); p3 = cdr(p3)) set_car(p3, permanent_list(sc, 1));
    set_car(p3, permanent_list(sc, 1));
    set_cdr(p3, sc->history_pairs);
    for (p1 = sc->eval_history1, p2 = sc->eval_history2; is_pair(cdr(p1)); p1 = cdr(p1), p2 = cdr(p2));
    set_cdr(p1, sc->eval_history1);
    set_cdr(p2, sc->eval_history2);
    sc->cur_code = sc->eval_history1;
    sc->using_history1 = true;
  }
#else
  sc->cur_code = sc->F;
#endif
  sc->args = sc->nil;
  sc->value = sc->nil;
  sc->u = sc->nil;
  sc->v = sc->nil;
  sc->w = sc->nil;
  sc->x = sc->nil;
  sc->y = sc->nil;
  sc->z = sc->nil;

  sc->temp1 = sc->nil;
  sc->temp2 = sc->nil;
  sc->temp3 = sc->nil;
  sc->temp4 = sc->nil;
  sc->temp5 = sc->nil;
  sc->temp6 = sc->nil;
  sc->temp7 = sc->nil;
  sc->temp8 = sc->nil;
  sc->temp9 = sc->nil;
  sc->temp10 = sc->nil;
  for (i = 0; i < T_TEMPS_SIZE; i++) sc->t_temps[i] = sc->nil;
  sc->t_temp_ctr = 0;

  sc->begin_hook = NULL;
  sc->autoload_table = sc->nil;
  sc->autoload_names = NULL;
  sc->autoload_names_sizes = NULL;
  sc->autoloaded_already = NULL;
  sc->autoload_names_loc = 0;
  sc->is_autoloading = true;

  sc->heap_size = INITIAL_HEAP_SIZE;
  if ((sc->heap_size % 32) != 0)
    sc->heap_size = 32 * (int64_t)ceil((double)(sc->heap_size) / 32.0);
  sc->heap = (s7_pointer *)malloc(sc->heap_size * sizeof(s7_pointer));
  sc->free_heap = (s7_cell **)malloc(sc->heap_size * sizeof(s7_cell *));
  sc->free_heap_top = (s7_cell **)(sc->free_heap + INITIAL_HEAP_SIZE);
  sc->free_heap_trigger = (s7_cell **)(sc->free_heap + GC_TRIGGER_SIZE);
  sc->previous_free_heap_top = sc->free_heap_top;
  {
    s7_cell *cells;
    cells = (s7_cell *)calloc(INITIAL_HEAP_SIZE, sizeof(s7_cell)); /* calloc to make sure type=0 at start? (for gc/valgrind) */
    for (i = 0; i < INITIAL_HEAP_SIZE; i++)
      {
	sc->heap[i] = &cells[i];
 	sc->free_heap[i] = sc->heap[i];
	i++;
	sc->heap[i] = &cells[i];
 	sc->free_heap[i] = sc->heap[i];
     }
    sc->heap_blocks = (heap_block_t *)malloc(sizeof(heap_block_t));
    sc->heap_blocks->start = (intptr_t)cells;
    sc->heap_blocks->end = (intptr_t)cells + (sc->heap_size * sizeof(s7_cell));
    sc->heap_blocks->offset = 0;
    sc->heap_blocks->next = NULL;
  }
  sc->max_heap_size = (1LL << 62);

  /* this has to precede s7_make_* allocations */
  sc->protected_setters_size = INITIAL_PROTECTED_OBJECTS_SIZE;
  sc->protected_setters_loc = 0;
  sc->protected_setters = s7_make_vector(sc, INITIAL_PROTECTED_OBJECTS_SIZE);
  sc->protected_setter_symbols = s7_make_vector(sc, INITIAL_PROTECTED_OBJECTS_SIZE);

  sc->protected_objects_size = INITIAL_PROTECTED_OBJECTS_SIZE;
  sc->gpofl = (s7_int *)malloc(INITIAL_PROTECTED_OBJECTS_SIZE * sizeof(s7_int));
  sc->gpofl_loc = INITIAL_PROTECTED_OBJECTS_SIZE - 1;
  sc->protected_objects = s7_make_vector(sc, INITIAL_PROTECTED_OBJECTS_SIZE);
  for (i = 0; i < INITIAL_PROTECTED_OBJECTS_SIZE; i++)
    {
      vector_element(sc->protected_objects, i) = sc->unused;
      vector_element(sc->protected_setters, i) = sc->unused;
      vector_element(sc->protected_setter_symbols, i) = sc->unused;
      sc->gpofl[i] = i;
    }

  sc->stack = s7_make_vector(sc, INITIAL_STACK_SIZE);
  sc->stack_start = vector_elements(sc->stack); /* stack type set below */
  sc->stack_end = sc->stack_start;
  sc->stack_size = INITIAL_STACK_SIZE;
  sc->stack_resize_trigger = (s7_pointer *)(sc->stack_start + sc->stack_size / 2);
  set_type(sc->stack, T_STACK);
  sc->max_stack_size = (1 << 30);
  initialize_op_stack(sc);

  /* keep the symbol table out of the heap */
  sc->symbol_table = (s7_pointer)calloc(1, sizeof(s7_cell));
  set_type(sc->symbol_table, T_VECTOR | T_UNHEAP);
  vector_length(sc->symbol_table) = SYMBOL_TABLE_SIZE;
  vector_elements(sc->symbol_table) = (s7_pointer *)malloc(SYMBOL_TABLE_SIZE * sizeof(s7_pointer));
  vector_getter(sc->symbol_table) = default_vector_getter;
  vector_setter(sc->symbol_table) = default_vector_setter;
  s7_vector_fill(sc, sc->symbol_table, sc->nil);
  make_optlist(sc);

  for (i = 0; i < NUM_TYPES; i++)
    prepackaged_type_names[i] = s7_make_permanent_string(sc, (const char *)type_name_from_type(i, INDEFINITE_ARTICLE));

#if WITH_MULTITHREAD_CHECKS
  sc->lock_count = 0;
  {
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    pthread_mutex_init(&sc->lock, &attr);
  }
#endif

  sc->c_object_types = NULL;
  sc->c_object_types_size = 0;
  sc->num_c_object_types = 0;
  sc->typnam = NULL;
  sc->typnam_len = 0;
  sc->default_rationalize_error = (s7_int_bits == 63) ? 1.0e-12 : 1.0e-6;
  sc->hash_table_float_epsilon = 1.0e-12;
  sc->equivalent_float_epsilon = 1.0e-15;
  sc->float_format_precision = WRITE_REAL_PRECISION;
  sc->default_hash_table_length = 8;
  sc->gensym_counter = 0;
  sc->capture_let_counter = 0;
  sc->f_class = 0;
  sc->add_class = 0;
  sc->equal_class = 0;
  sc->let_number = 0;
  sc->format_column = 0;
  sc->format_ports = NULL;
  sc->file_names = NULL;
  sc->file_names_size = 0;
  sc->file_names_top = -1;
  sc->s7_call_line = 0;
  sc->s7_call_file = NULL;
  sc->s7_call_name = NULL;
  sc->safety = NO_SAFETY;
  sc->print_length = DEFAULT_PRINT_LENGTH;
  sc->history_size = DEFAULT_HISTORY_SIZE;
  sc->true_history_size = DEFAULT_HISTORY_SIZE;
  sc->profile_info = sc->nil;
  sc->baffle_ctr = 0;
  sc->syms_tag = 0;
  sc->syms_tag2 = 0;
  sc->class_name_symbol = make_symbol(sc, "class-name");
  sc->circle_info = init_circle_info(sc);
  sc->fdats = (format_data **)calloc(8, sizeof(format_data *));
  sc->num_fdats = 8;
  sc->plist_1 = permanent_list(sc, 1);
  sc->plist_2 = permanent_list(sc, 2);
  sc->plist_2_2 = cdr(sc->plist_2);
  sc->plist_3 = permanent_list(sc, 3);
  sc->qlist_2 = permanent_list(sc, 2);
  sc->qlist_3 = permanent_list(sc, 3);
  sc->clist_1 = permanent_list(sc, 1);
  sc->elist_1 = permanent_list(sc, 1);
  sc->elist_2 = permanent_list(sc, 2);
  sc->elist_3 = permanent_list(sc, 3);
  sc->elist_4 = permanent_list(sc, 4);
  sc->elist_5 = permanent_list(sc, 5);
  sc->undefined_identifier_warnings = false;
  sc->undefined_constant_warnings = false;
  sc->wrap_only = make_wrap_only(sc);
  sc->dox_slot_symbol = make_symbol(sc, "(dox_slot)");
  sc->unentry = (hash_entry_t *)malloc(sizeof(hash_entry_t));
  hash_entry_set_value(sc->unentry, sc->F);
  sc->begin_op = OP_BEGIN1;
  sc->geq_2 = NULL;
#if (!WITH_GMP)
  sc->seed_symbol = NULL;
  sc->carry_symbol = NULL;
#endif
  sc->active_symbol = NULL;
  sc->goto_symbol = NULL;
  sc->data_symbol = NULL;
  sc->weak_symbol = NULL;
  sc->dimensions_symbol = NULL;
  sc->info_symbol = NULL;
  sc->c_type_symbol = NULL;
  sc->at_end_symbol = NULL;
  sc->sequence_symbol = NULL;
  sc->position_symbol = NULL;
  sc->entries_symbol = NULL;
  sc->locked_symbol = NULL;
  sc->function_symbol = NULL;
  sc->open_symbol = NULL;
  sc->alias_symbol = NULL;
  sc->current_value_symbol = NULL;
  sc->source_symbol = NULL;
  sc->file_symbol = NULL;
  sc->line_symbol = NULL;
  sc->c_object_let_symbol = NULL;
  sc->class_symbol = NULL;
  sc->c_object_length_symbol = NULL;
  sc->c_object_set_symbol = NULL;
  sc->c_object_ref_symbol = NULL;
  sc->c_object_copy_symbol = NULL;
  sc->c_object_fill_symbol = NULL;
  sc->c_object_reverse_symbol = NULL;
  sc->c_object_to_list_symbol = NULL;
  sc->c_object_to_string_symbol = NULL;
  sc->closed_symbol = NULL;
  sc->port_type_symbol = NULL;
  sc->permanent_objects = NULL;
  sc->permanent_lets = NULL;
  sc->tree_pointers = NULL;
  sc->tree_pointers_size = 0;
  sc->tree_pointers_top = 0;

  sc->rootlet = s7_make_vector(sc, ROOTLET_SIZE);
  set_type(sc->rootlet, T_LET | T_SAFE_PROCEDURE);
  sc->rootlet_entries = 0;
  for (i = 0; i < ROOTLET_SIZE; i++)
    rootlet_element(sc->rootlet, i) = sc->nil;
  sc->envir = sc->nil;
  sc->shadow_rootlet = sc->nil;

  init_wrappers(sc);
  make_standard_ports(sc);

  #define H_quote             "(quote obj) returns obj unevaluated.  'obj is an abbreviation for (quote obj)."
  #define H_if                "(if expr true-stuff optional-false-stuff) evaluates expr, then if it is true, evaluates true-stuff; otherwise, \
                                      if optional-false-stuff exists, it is evaluated."
  #define H_when              "(when expr ...) evaluates expr, and if it is true, evaluates each form in its body, returning the value of the last"
  #define H_unless            "(unless expr ...) evaluates expr, and if it is false, evaluates each form in its body, returning the value of the last"
  #define H_begin             "(begin ...) evaluates each form in its body, returning the value of the last one"
  #define H_set               "(set! variable value) sets the value of variable to value."
  #define H_let               "(let ((var val)...) ...) binds each variable to its initial value, then evaluates its body,\
                                      returning the value of the last form.  The let variables are local to it, and \
                                      are not available for use until all have been initialized."
  #define H_let_star          "(let* ((var val)...) ...) binds each variable to its initial value, then evaluates its body, \
                                      returning the value of the last form.  The let* variables are local to it, and are available immediately."
  #define H_letrec            "(letrec ((var (lambda ...)))...) is like let, but var can refer to itself in its value \
                                      (i.e. you can define local recursive functions)"
  #define H_letrec_star       "(letrec* ((var val))...) is like letrec, but successive bindings are handled as in let*"
  #define H_cond              "(cond (expr clause...)...) is like if..then.  Each expr is evaluated in order, and if one is not #f, \
                                      the associated clauses are evaluated, whereupon cond returns."
  #define H_and               "(and expr expr ...) evaluates each of its arguments in order, quitting (and returning #f) \
                                      as soon as one of them returns #f.  If all are non-#f, it returns the last value."
  #define H_or                "(or expr expr ...) evaluates each of its argments in order, quitting as soon as one of them is not #f.  \
                                      If all are #f, or returns #f."
  #define H_case              "(case val ((key...) clause...)...) looks for val in the various lists of keys, and if a \
                                      match is found (via eqv?), the associated clauses are evaluated, and case returns."
  #define H_do                "(do (vars...) (loop control and return value) ...) is a do-loop."
  #define H_lambda            "(lambda args ...) returns a function."
  #define H_lambda_star       "(lambda* args ...) returns a function; the args list can have default values, \
                                      the parameters themselves can be accessed via keywords."
  #define H_define            "(define var val) assigns val to the variable (symbol) var.  (define (func args) ...) is \
                                      shorthand for (define func (lambda args ...))"
  #define H_define_star       "(define* (func args) ...) defines a function with optional/keyword arguments."
  #define H_define_constant   "(define-constant var val) defines var to be a constant (it can't be set or bound), with the value val."
  #define H_define_macro      "(define-macro (mac args) ...) defines mac to be a macro."
  #define H_define_macro_star "(define-macro* (mac args) ...) defines mac to be a macro with optional/keyword arguments."
  #define H_define_expansion  "(define-expansion (mac args) ...) defines mac to be a read-time macro."
  #define H_define_bacro      "(define-bacro (mac args) ...) defines mac to be a bacro."
  #define H_define_bacro_star "(define-bacro* (mac args) ...) defines mac to be a bacro with optional/keyword arguments."
  #define H_with_baffle       "(with-baffle ...) evaluates its body in a context that is safe from outside interference."
  #define H_macroexpand       "(macroexpand macro-call) returns the result of the expansion phase of evaluating the macro call."
  #define H_with_let          "(with-let env ...) evaluates its body in the environment env."
  #define H_let_temporarily   "(let-temporarily ((var value)...) . body) sets each var to its new value, evals body, then returns each var to its original value."

  sc->quote_symbol =             syntax(sc, "quote",                   OP_QUOTE,             small_int(1), small_int(1), H_quote);
  sc->if_symbol =                syntax(sc, "if",                      OP_IF,                small_int(2), small_int(3), H_if);
  sc->when_symbol =              syntax(sc, "when",                    OP_WHEN,              small_int(2), max_arity,    H_when);
  sc->unless_symbol =            syntax(sc, "unless",                  OP_UNLESS,            small_int(2), max_arity,    H_unless);
  sc->begin_symbol =             syntax(sc, "begin",                   OP_BEGIN,             small_int(0), max_arity,    H_begin);      /* (begin) is () */
  sc->set_symbol =               syntax(sc, "set!",                    OP_SET,               small_int(2), small_int(2), H_set);
  sc->cond_symbol =              syntax(sc, "cond",                    OP_COND,              small_int(1), max_arity,    H_cond);
  sc->and_symbol =               syntax(sc, "and",                     OP_AND,               small_int(0), max_arity,    H_and);
  sc->or_symbol =                syntax(sc, "or",                      OP_OR,                small_int(0), max_arity,    H_or);
  sc->case_symbol =              syntax(sc, "case",                    OP_CASE,              small_int(2), max_arity,    H_case);
  sc->with_baffle_symbol =       syntax(sc, "with-baffle",             OP_WITH_BAFFLE,       small_int(0), max_arity,    H_with_baffle); /* (with-baffle) is () */
  sc->macroexpand_symbol =       syntax(sc, "macroexpand",             OP_MACROEXPAND,       small_int(1), small_int(1), H_macroexpand);
  sc->define_symbol =            definer_syntax(sc, "define",          OP_DEFINE,            small_int(2), max_arity,    H_define);
  sc->define_star_symbol =       definer_syntax(sc, "define*",         OP_DEFINE_STAR,       small_int(2), max_arity,    H_define_star);
  sc->define_constant_symbol =   definer_syntax(sc, "define-constant", OP_DEFINE_CONSTANT,   small_int(2), max_arity,    H_define_constant);
  sc->define_macro_symbol =      definer_syntax(sc, "define-macro",    OP_DEFINE_MACRO,      small_int(2), max_arity,    H_define_macro);
  sc->define_macro_star_symbol = definer_syntax(sc, "define-macro*",   OP_DEFINE_MACRO_STAR, small_int(2), max_arity,    H_define_macro_star);
  sc->define_expansion_symbol =  definer_syntax(sc, "define-expansion",OP_DEFINE_EXPANSION,  small_int(2), max_arity,    H_define_expansion);
  sc->define_bacro_symbol =      definer_syntax(sc, "define-bacro",    OP_DEFINE_BACRO,      small_int(2), max_arity,    H_define_bacro);
  sc->define_bacro_star_symbol = definer_syntax(sc, "define-bacro*",   OP_DEFINE_BACRO_STAR, small_int(2), max_arity,    H_define_bacro_star);
  sc->let_symbol =               binder_syntax(sc, "let",              OP_LET,               small_int(2), max_arity,    H_let);
  sc->let_star_symbol =          binder_syntax(sc, "let*",             OP_LET_STAR,          small_int(2), max_arity,    H_let_star);
  sc->letrec_symbol =            binder_syntax(sc, "letrec",           OP_LETREC,            small_int(2), max_arity,    H_letrec);
  sc->letrec_star_symbol =       binder_syntax(sc, "letrec*",          OP_LETREC_STAR,       small_int(2), max_arity,    H_letrec_star);
  sc->do_symbol =                binder_syntax(sc, "do",               OP_DO,                small_int(2), max_arity,    H_do); /* 2 because body can be null */
  sc->lambda_symbol =            binder_syntax(sc, "lambda",           OP_LAMBDA,            small_int(2), max_arity,    H_lambda);
  sc->lambda_star_symbol =       binder_syntax(sc, "lambda*",          OP_LAMBDA_STAR,       small_int(2), max_arity,    H_lambda_star);
  sc->let_temporarily_symbol =   binder_syntax(sc, "let-temporarily",  OP_LET_TEMPORARILY,   small_int(2), max_arity,    H_let_temporarily);
  sc->with_let_symbol =          binder_syntax(sc, "with-let",         OP_WITH_LET,          small_int(1), max_arity,    H_with_let);
  set_local_slot(sc->with_let_symbol, global_slot(sc->with_let_symbol)); /* for set_locals */
  set_immutable(sc->with_let_symbol);
  sc->setter_symbol = make_symbol(sc, "setter");

#if WITH_IMMUTABLE_UNQUOTE
  /* this code solves the various unquote redefinition troubles
   * if "," -> "(unquote...)" in the reader, (let (, (lambda (x) (+ x 1))) ,,,,1) -> 5
   *   in s7, this requires a quote: (let (, (lambda (x) (+ x 1))) ,,,,'1)
   */
  sc->unquote_symbol =              make_symbol(sc, ",");
  set_immutable(sc->unquote_symbol);
#else
  sc->unquote_symbol =              make_symbol(sc, "unquote");
#endif

  sc->feed_to_symbol =              make_symbol(sc, "=>");
  sc->baffle_symbol =               make_symbol(sc, "(baffle)");
  sc->body_symbol =                 make_symbol(sc, "body");
  sc->error_symbol =                make_symbol(sc, "error");
  sc->read_error_symbol =           make_symbol(sc, "read-error");
  sc->string_read_error_symbol =    make_symbol(sc, "string-read-error");
  sc->syntax_error_symbol =         make_symbol(sc, "syntax-error");
  sc->unbound_variable_symbol =     make_symbol(sc, "unbound-variable");
  sc->wrong_type_arg_symbol =       make_symbol(sc, "wrong-type-arg");
  sc->wrong_number_of_args_symbol = make_symbol(sc, "wrong-number-of-args");
  sc->format_error_symbol =         make_symbol(sc, "format-error");
  sc->autoload_error_symbol =       make_symbol(sc, "autoload-error");
  sc->out_of_range_symbol =         make_symbol(sc, "out-of-range");
  sc->no_catch_symbol =             make_symbol(sc, "no-catch");
  sc->io_error_symbol =             make_symbol(sc, "io-error");
  sc->missing_method_symbol =       make_symbol(sc, "missing-method");
  sc->invalid_escape_function_symbol = make_symbol(sc, "invalid-escape-function");
  sc->division_by_zero_symbol =     make_symbol(sc, "division-by-zero");

  sc->baffled_symbol =              make_symbol(sc, "baffled!");
  sc->value_symbol =                make_symbol(sc, "value");
  sc->type_symbol =                 make_symbol(sc, "type");
  sc->else_symbol =                 make_symbol(sc, "else");
  s7_make_slot(sc, sc->nil, sc->else_symbol, sc->else_symbol);
  sc->__func___symbol =             make_symbol(sc, "__func__");

  sc->key_allow_other_keys_symbol = s7_make_keyword(sc, "allow-other-keys");
  sc->key_rest_symbol =             s7_make_keyword(sc, "rest");
  sc->key_if_symbol =               s7_make_keyword(sc, "if");
  sc->key_readable_symbol =         s7_make_keyword(sc, "readable");
  sc->key_display_symbol =          s7_make_keyword(sc, "display");
  sc->key_write_symbol =            s7_make_keyword(sc, "write");

  sc->owlet = init_owlet(sc);

  sc->wrong_type_arg_info = permanent_list(sc, 6);
  set_car(sc->wrong_type_arg_info, s7_make_permanent_string(sc, "~A argument ~D, ~S, is ~A but should be ~A"));

  sc->simple_wrong_type_arg_info = permanent_list(sc, 5);
  set_car(sc->simple_wrong_type_arg_info, s7_make_permanent_string(sc, "~A argument, ~S, is ~A but should be ~A"));

  sc->out_of_range_info = permanent_list(sc, 5);
  set_car(sc->out_of_range_info, s7_make_permanent_string(sc, "~A argument ~D, ~S, is out of range (~A)"));

  sc->simple_out_of_range_info = permanent_list(sc, 4);
  set_car(sc->simple_out_of_range_info, s7_make_permanent_string(sc, "~A argument, ~S, is out of range (~A)"));

  sc->gc_off = false;

  #define defun(Scheme_Name, C_Name, Req, Opt, Rst) \
    s7_define_typed_function(sc, Scheme_Name, g_ ## C_Name, Req, Opt, Rst, H_ ## C_Name, Q_ ## C_Name)

  #define unsafe_defun(Scheme_Name, C_Name, Req, Opt, Rst) \
    s7_define_unsafe_typed_function(sc, Scheme_Name, g_ ## C_Name, Req, Opt, Rst, H_ ## C_Name, Q_ ## C_Name)

  #define b_defun(Scheme_Name, C_Name, Opt, SymId, Marker, Simple) \
    define_bool_function(sc, Scheme_Name, g_ ## C_Name, Opt, H_ ## C_Name, Q_ ## C_Name, SymId, Marker, Simple, b_ ## C_Name ## _setter)

  /* we need the sc->is_* symbols first for the procedure signature lists */
  sc->is_boolean_symbol = make_symbol(sc, "boolean?");
  sc->pl_bt = s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->T);

  sc->is_symbol_symbol =          b_defun("symbol?",	      is_symbol,	  0, T_SYMBOL,       mark_symbol_vector, true);
  sc->is_syntax_symbol =          b_defun("syntax?",	      is_syntax,	  0, T_SYNTAX,       just_mark_vector,   true);
  sc->is_gensym_symbol =          b_defun("gensym?",	      is_gensym,	  0, T_FREE,         mark_symbol_vector, true);
  sc->is_keyword_symbol =         b_defun("keyword?",	      is_keyword,	  0, T_FREE,         just_mark_vector,   true);
  sc->is_let_symbol =             b_defun("let?",	      is_let,		  0, T_LET,          mark_vector_1,      false);
  sc->is_openlet_symbol =         b_defun("openlet?",	      is_openlet,	  0, T_FREE,         mark_vector_1,      false);
  sc->is_iterator_symbol =        b_defun("iterator?",	      is_iterator,	  0, T_ITERATOR,     mark_vector_1,      false);
  sc->is_macro_symbol =           b_defun("macro?",	      is_macro,		  0, T_FREE,         mark_vector_1,      false);
  sc->is_c_pointer_symbol =       b_defun("c-pointer?",	      is_c_pointer,	  1, T_C_POINTER,    mark_vector_1,      false);
  sc->is_input_port_symbol =      b_defun("input-port?",      is_input_port,	  0, T_INPUT_PORT,   mark_vector_1,      true);
  sc->is_output_port_symbol =     b_defun("output-port?",     is_output_port,	  0, T_OUTPUT_PORT,  mark_simple_vector, true);
  sc->is_eof_object_symbol =      b_defun("eof-object?",      is_eof_object,	  0, T_EOF_OBJECT,   just_mark_vector,   true);
  sc->is_integer_symbol =         b_defun("integer?",	      is_integer,	  0, (WITH_GMP) ? T_FREE : T_INTEGER, mark_simple_vector, true);
  sc->is_byte_symbol =            b_defun("byte?",	      is_byte,		  0, T_FREE,         mark_simple_vector, true);
  sc->is_number_symbol =          b_defun("number?",	      is_number,	  0, T_FREE,         mark_simple_vector, true);
  sc->is_real_symbol =            b_defun("real?",	      is_real,		  0, T_FREE,         mark_simple_vector, true);
  sc->is_float_symbol =           b_defun("float?",           is_float,           0, T_FREE,         mark_simple_vector, true);
  sc->is_complex_symbol =         b_defun("complex?",	      is_complex,	  0, T_FREE,         mark_simple_vector, true);
  sc->is_rational_symbol =        b_defun("rational?",	      is_rational,	  0, T_FREE,         mark_simple_vector, true);
  sc->is_random_state_symbol =    b_defun("random-state?",    is_random_state,	  0, T_RANDOM_STATE, mark_simple_vector, true);
  sc->is_char_symbol =            b_defun("char?",	      is_char,		  0, T_CHARACTER,    just_mark_vector,   true);
  sc->is_string_symbol =          b_defun("string?",	      is_string,	  0, T_STRING,       mark_simple_vector, true);
  sc->is_list_symbol =            b_defun("list?",	      is_list,		  0, T_FREE,         mark_vector_1,      false);
  sc->is_pair_symbol =            b_defun("pair?",	      is_pair,		  0, T_PAIR,         mark_vector_1,      false);
  sc->is_vector_symbol =          b_defun("vector?",	      is_vector,	  0, T_FREE,         mark_vector_1,      false);
  sc->is_float_vector_symbol =    b_defun("float-vector?",    is_float_vector,	  0, T_FLOAT_VECTOR, mark_simple_vector, true);
  sc->is_int_vector_symbol =      b_defun("int-vector?",      is_int_vector,	  0, T_INT_VECTOR,   mark_simple_vector, true);
  sc->is_byte_vector_symbol =     b_defun("byte-vector?",     is_byte_vector,	  0, T_BYTE_VECTOR,  mark_simple_vector, true);
  sc->is_hash_table_symbol =      b_defun("hash-table?",      is_hash_table,      0, T_HASH_TABLE,   mark_vector_1,      false);
  sc->is_continuation_symbol =    b_defun("continuation?",    is_continuation,	  0, T_CONTINUATION, mark_vector_1,      false);
  sc->is_procedure_symbol =       b_defun("procedure?",	      is_procedure,	  0, T_FREE,         mark_vector_1,      false);
  sc->is_dilambda_symbol =        b_defun("dilambda?",	      is_dilambda,	  0, T_FREE,         mark_vector_1,      false);
  /* set above */                 b_defun("boolean?",	      is_boolean,	  0, T_BOOLEAN,      just_mark_vector,   true);
  sc->is_proper_list_symbol =     b_defun("proper-list?",     is_proper_list,     0, T_FREE,         mark_vector_1,      false);
  sc->is_sequence_symbol =        b_defun("sequence?",	      is_sequence,	  0, T_FREE,         mark_vector_1,      false);
  sc->is_null_symbol =            b_defun("null?",	      is_null,		  0, T_NIL,          just_mark_vector,   true);
  sc->is_undefined_symbol =       b_defun("undefined?",       is_undefined,       0, T_UNDEFINED,    just_mark_vector,   true);
  sc->is_unspecified_symbol =     b_defun("unspecified?",     is_unspecified,     0, T_UNSPECIFIED,  just_mark_vector,   true);
  sc->is_c_object_symbol =        b_defun("c-object?",	      is_c_object,	  0, T_C_OBJECT,     mark_vector_1,      false);
  sc->is_subvector_symbol =       b_defun("subvector?",	      is_subvector,	  0, T_FREE,         mark_vector_1,      false);
  sc->is_weak_hash_table_symbol = b_defun("weak-hash-table?", is_weak_hash_table, 0, T_FREE,         mark_vector_1,      false);

  /* these are for signatures */
  sc->not_symbol = defun("not",	not, 1, 0, false);
  sc->is_integer_or_real_at_end_symbol = make_symbol(sc, "integer:real?");
  sc->is_integer_or_any_at_end_symbol =  make_symbol(sc, "integer:any?");

  sc->pl_p =   s7_make_signature(sc, 2, sc->T, sc->is_pair_symbol);
  sc->pl_tl =  s7_make_signature(sc, 3, s7_make_signature(sc, 2, sc->is_pair_symbol, sc->not_symbol), sc->T, sc->is_list_symbol); /* memq and memv signature */
  sc->pl_bc =  s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_char_symbol);
  sc->pl_bn =  s7_make_signature(sc, 2, sc->is_boolean_symbol, sc->is_number_symbol);
  sc->pl_sf =  s7_make_signature(sc, 3, sc->T, sc->is_string_symbol, s7_make_signature(sc, 2, sc->is_procedure_symbol, sc->is_macro_symbol));
  sc->pcl_bt = s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->T);
  sc->pcl_bc = s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_char_symbol);
  sc->pcl_bs = s7_make_circular_signature(sc, 1, 2, sc->is_boolean_symbol, sc->is_string_symbol);
  sc->pcl_i =  s7_make_circular_signature(sc, 0, 1, sc->is_integer_symbol);
  sc->pcl_r =  s7_make_circular_signature(sc, 0, 1, sc->is_real_symbol);
  sc->pcl_f =  s7_make_circular_signature(sc, 0, 1, sc->is_rational_symbol);
  sc->pcl_n =  s7_make_circular_signature(sc, 0, 1, sc->is_number_symbol);
  sc->pcl_s =  s7_make_circular_signature(sc, 0, 1, sc->is_string_symbol);
  sc->pcl_v =  s7_make_circular_signature(sc, 0, 1, sc->is_vector_symbol);
  sc->pcl_c =  s7_make_circular_signature(sc, 0, 1, sc->is_char_symbol);
  sc->pcl_e =  s7_make_circular_signature(sc, 0, 1, s7_make_signature(sc, 4, sc->is_let_symbol, sc->is_procedure_symbol, sc->is_macro_symbol, sc->is_c_object_symbol));

  sc->values_symbol = make_symbol(sc, "values");

  sc->gensym_symbol =                defun("gensym",		gensym,			0, 1, false);
  sc->symbol_table_symbol =          defun("symbol-table",	symbol_table,		0, 0, false);
  sc->symbol_to_string_symbol =      defun("symbol->string",	symbol_to_string,	1, 0, false);
  sc->string_to_symbol_symbol =      defun("string->symbol",	string_to_symbol,	1, 0, false);
  sc->symbol_symbol =                defun("symbol",		symbol,			1, 0, true);
  sc->symbol_to_value_symbol =       defun("symbol->value",	symbol_to_value,	1, 1, false);
  sc->symbol_to_dynamic_value_symbol = defun("symbol->dynamic-value", symbol_to_dynamic_value, 1, 0, false);
  sc->immutable_symbol =             unsafe_defun("immutable!",	immutable,		1, 0, false);
  sc->is_immutable_symbol =          defun("immutable?",	is_immutable,		1, 0, false);
  sc->is_constant_symbol =           defun("constant?",	        is_constant,		1, 0, false);

  sc->string_to_keyword_symbol =     defun("string->keyword",	string_to_keyword,      1, 0, false);
  sc->symbol_to_keyword_symbol =     defun("symbol->keyword",	symbol_to_keyword,	1, 0, false);
  sc->keyword_to_symbol_symbol =     defun("keyword->symbol",	keyword_to_symbol,	1, 0, false);

  sc->outlet_symbol =                defun("outlet",		outlet,			1, 0, false);
  sc->rootlet_symbol =               defun("rootlet",		rootlet,		0, 0, false);
  sc->curlet_symbol =                defun("curlet",		curlet,			0, 0, false);
  set_type_bit(sc->curlet_symbol, T_FULL_DEFINER);
  sc->unlet_symbol =                 defun("unlet",		unlet,			0, 0, false);
  set_local_slot(sc->unlet_symbol, global_slot(sc->unlet_symbol)); /* for set_locals */
  set_immutable(sc->unlet_symbol);
  /* unlet (and with-let) don't actually need to be immutable, but s7.html says they are... */
  sc->sublet_symbol =                defun("sublet",		sublet,			1, 0, true);
  sc->varlet_symbol =                unsafe_defun("varlet",	varlet,			1, 0, true);
  set_type_bit(sc->varlet_symbol, T_FULL_DEFINER);
  sc->cutlet_symbol =                unsafe_defun("cutlet",	cutlet,			1, 0, true);
  sc->inlet_symbol =                 defun("inlet",		inlet,			0, 0, true);
  sc->owlet_symbol =                 defun("owlet",		owlet,			0, 0, false);
  sc->coverlet_symbol =              defun("coverlet",		coverlet,		1, 0, false);
  sc->openlet_symbol =               defun("openlet",		openlet,		1, 0, false);
                                     defun("coverlets",		coverlets,		0, 0, false);
                                     defun("openlets",		openlets,		0, 0, false);
  sc->let_ref_symbol =               defun("let-ref",		let_ref,		2, 0, false);
  sc->let_set_symbol =               defun("let-set!",		let_set,		3, 0, false);
  sc->let_ref_fallback_symbol = make_symbol(sc, "let-ref-fallback");
  sc->let_set_fallback_symbol = make_symbol(sc, "let-set-fallback"); /* was let-set!-fallback until 9-Oct-17 */

  sc->make_iterator_symbol =         defun("make-iterator",	make_iterator,		1, 1, false);
  sc->iterate_symbol =               defun("iterate",		iterate,		1, 0, false);
  sc->iterator_sequence_symbol =     defun("iterator-sequence", iterator_sequence,	1, 0, false);
  sc->iterator_is_at_end_symbol =    defun("iterator-at-end?",  iterator_is_at_end,	1, 0, false);

  sc->is_provided_symbol =           defun("provided?",	        is_provided,		1, 0, false);
  sc->provide_symbol =               unsafe_defun("provide",	provide,		1, 0, false); /* can add *features* to curlet */
  set_type_bit(sc->provide_symbol, T_FULL_DEFINER);
  sc->is_defined_symbol =            defun("defined?",		is_defined,		1, 2, false);

  sc->c_object_type_symbol =         defun("c-object-type",     c_object_type,		1, 0, false);
  sc->c_pointer_symbol =             defun("c-pointer",	        c_pointer,		1, 4, false);
  sc->c_pointer_info_symbol =        defun("c-pointer-info",    c_pointer_info,		1, 0, false);
  sc->c_pointer_type_symbol =        defun("c-pointer-type",    c_pointer_type,		1, 0, false);
  sc->c_pointer_weak1_symbol =       defun("c-pointer-weak1",   c_pointer_weak1,	1, 0, false);
  sc->c_pointer_weak2_symbol =       defun("c-pointer-weak2",   c_pointer_weak2,	1, 0, false);
  sc->c_pointer_to_list_symbol =     defun("c-pointer->list",   c_pointer_to_list,      1, 0, false);

  sc->port_file_symbol =             defun("port-file",	        port_file,		1, 0, false);
  sc->port_position_symbol =         defun("port-position",	port_position,		1, 0, false);
  sc->port_line_number_symbol =      defun("port-line-number",  port_line_number,	0, 1, false);
  sc->port_filename_symbol =         defun("port-filename",	port_filename,		0, 1, false);
  sc->pair_line_number_symbol =      defun("pair-line-number",  pair_line_number,	1, 0, false);
  sc->pair_filename_symbol =         defun("pair-filename",     pair_filename,	        1, 0, false);
#if WITH_PROFILE
                                     defun("profile-line-number", profile_line_number,	1, 0, false);
                                     defun("profile-filename",    profile_filename,     1, 0, false);
#endif
  sc->is_port_closed_symbol =        defun("port-closed?",	is_port_closed,		1, 0, false);

  sc->current_input_port_symbol =    defun("current-input-port",  current_input_port,  0, 0, false);
  sc->current_output_port_symbol =   defun("current-output-port", current_output_port, 0, 0, false);
  sc->current_error_port_symbol =    defun("current-error-port", current_error_port,    0, 0, false);
  sc->set_current_error_port_symbol = defun("set-current-error-port", set_current_error_port, 1, 0, false);
#if (!WITH_PURE_S7)
  sc->let_to_list_symbol =           defun("let->list",	         let_to_list,		1, 0, false);
  sc->set_current_input_port_symbol = defun("set-current-input-port", set_current_input_port, 1, 0, false);
  sc->set_current_output_port_symbol = defun("set-current-output-port", set_current_output_port, 1, 0, false);
  sc->is_char_ready_symbol =         defun("char-ready?",	is_char_ready,		0, 1, false); /* the least-used scheme function */
#endif

  sc->close_input_port_symbol =      defun("close-input-port",   close_input_port,	1, 0, false);
  sc->close_output_port_symbol =     defun("close-output-port",  close_output_port,	1, 0, false);
  sc->flush_output_port_symbol =     defun("flush-output-port",  flush_output_port,	0, 1, false);
  sc->open_input_file_symbol =       defun("open-input-file",    open_input_file,	1, 1, false);
  sc->open_output_file_symbol =      defun("open-output-file",   open_output_file,	1, 1, false);
  sc->open_input_string_symbol =     defun("open-input-string",  open_input_string,	1, 0, false);
  sc->open_output_string_symbol =    defun("open-output-string", open_output_string,	0, 0, false);
  sc->get_output_string_symbol =     defun("get-output-string",  get_output_string,	1, 1, false);

  sc->newline_symbol =               defun("newline",		newline,		0, 1, false);
  sc->write_symbol =                 defun("write",		write,			1, 1, false);
  sc->display_symbol =               defun("display",		display,		1, 1, false);
  sc->read_char_symbol =             defun("read-char",	        read_char,		0, 1, false);
  sc->peek_char_symbol =             defun("peek-char",	        peek_char,		0, 1, false);
  sc->write_char_symbol =            defun("write-char",	write_char,		1, 1, false);
  sc->write_string_symbol =          defun("write-string",	write_string,		1, 3, false);
  sc->read_byte_symbol =             defun("read-byte",	        read_byte,		0, 1, false);
  sc->write_byte_symbol =            defun("write-byte",	write_byte,		1, 1, false);
  sc->read_line_symbol =             defun("read-line",	        read_line,		0, 2, false);
  sc->read_string_symbol =           defun("read-string",	read_string,		1, 1, false);
  sc->read_symbol =                  unsafe_defun("read",	read,			0, 1, false);
  /* read can't be safe because it messes with the stack, expecting to be all by itself in the call sequence
   *   (not embedded in OP_SAFE_C_opSq for example) -- that is, it pushes OP_READ_INTERNAL, then returns
   *   expecting goto START, which would be nonsense if arg=c_callee(read) -> c_callee(arg).
   *   a safe procedure leaves its argument list alone, does not push anything on the stack,
   *   and leaves sc->code|args unscathed (c_call assumes that is the case).  The stack part can
   *   be hidden: if a c_function calls s7_apply_function (lambda passed as arg as in some clm gens)
   *   then is called with args that use fx*, and the lambda func does the same, the two calls
   *   can step on each other.
   */

  sc->call_with_input_string_symbol = unsafe_defun("call-with-input-string", call_with_input_string, 2, 0, false);
  sc->call_with_input_file_symbol =   unsafe_defun("call-with-input-file",   call_with_input_file,   2, 0, false);
  sc->with_input_from_string_symbol = unsafe_defun("with-input-from-string", with_input_from_string, 2, 0, false);
  sc->with_input_from_file_symbol =   unsafe_defun("with-input-from-file",   with_input_from_file,   2, 0, false);

  sc->call_with_output_string_symbol = unsafe_defun("call-with-output-string", call_with_output_string, 1, 0, false);
  sc->call_with_output_file_symbol =   unsafe_defun("call-with-output-file",   call_with_output_file,   2, 0, false);
  sc->with_output_to_string_symbol =   unsafe_defun("with-output-to-string",   with_output_to_string,   1, 0, false);
  sc->with_output_to_file_symbol =     unsafe_defun("with-output-to-file",     with_output_to_file,     2, 0, false);

#if WITH_SYSTEM_EXTRAS
  sc->is_directory_symbol =          defun("directory?",	is_directory,		1, 0, false);
  sc->file_exists_symbol =           defun("file-exists?",	file_exists,		1, 0, false);
  sc->delete_file_symbol =           defun("delete-file",	delete_file,		1, 0, false);
  sc->getenv_symbol =                defun("getenv",		getenv,			1, 0, false);
  sc->system_symbol =                defun("system",		system,			1, 1, false);
#if (!MS_WINDOWS)
  sc->directory_to_list_symbol =     defun("directory->list",   directory_to_list,	1, 0, false);
  sc->file_mtime_symbol =            defun("file-mtime",	file_mtime,		1, 0, false);
#endif
#endif

  sc->real_part_symbol =             defun("real-part",	        real_part,		1, 0, false);
  sc->imag_part_symbol =             defun("imag-part",	        imag_part,		1, 0, false);
  sc->numerator_symbol =             defun("numerator",	        numerator,		1, 0, false);
  sc->denominator_symbol =           defun("denominator",	denominator,		1, 0, false);
  sc->is_even_symbol =               defun("even?",		is_even,		1, 0, false);
  sc->is_odd_symbol =                defun("odd?",		is_odd,			1, 0, false);
  sc->is_zero_symbol =               defun("zero?",		is_zero,		1, 0, false);
  sc->is_positive_symbol =           defun("positive?",	        is_positive,		1, 0, false);
  sc->is_negative_symbol =           defun("negative?",	        is_negative,		1, 0, false);
  sc->is_infinite_symbol =           defun("infinite?",	        is_infinite,		1, 0, false);
  sc->is_nan_symbol =                defun("nan?",		is_nan,			1, 0, false);

#if (!WITH_GMP)
  sc->complex_symbol =               defun("complex",	        complex,	        2, 0, false);
  sc->magnitude_symbol =             defun("magnitude",	        magnitude,		1, 0, false);
  sc->angle_symbol =                 defun("angle",		angle,			1, 0, false);
  sc->rationalize_symbol =           defun("rationalize",	rationalize,		1, 1, false);
  sc->abs_symbol =                   defun("abs",		abs,			1, 0, false);
  sc->exp_symbol =                   defun("exp",		exp,			1, 0, false);
  sc->log_symbol =                   defun("log",		log,			1, 1, false);
  sc->sin_symbol =                   defun("sin",		sin,			1, 0, false);
  sc->cos_symbol =                   defun("cos",		cos,			1, 0, false);
  sc->tan_symbol =                   defun("tan",		tan,			1, 0, false);
  sc->asin_symbol =                  defun("asin",		asin,			1, 0, false);
  sc->acos_symbol =                  defun("acos",		acos,			1, 0, false);
  sc->atan_symbol =                  defun("atan",		atan,			1, 1, false);
  sc->sinh_symbol =                  defun("sinh",		sinh,			1, 0, false);
  sc->cosh_symbol =                  defun("cosh",		cosh,			1, 0, false);
  sc->tanh_symbol =                  defun("tanh",		tanh,			1, 0, false);
  sc->asinh_symbol =                 defun("asinh",		asinh,			1, 0, false);
  sc->acosh_symbol =                 defun("acosh",		acosh,			1, 0, false);
  sc->atanh_symbol =                 defun("atanh",		atanh,			1, 0, false);
  sc->sqrt_symbol =                  defun("sqrt",		sqrt,			1, 0, false);
  sc->expt_symbol =                  defun("expt",		expt,			2, 0, false);
  sc->floor_symbol =                 defun("floor",		floor,			1, 0, false);
  sc->ceiling_symbol =               defun("ceiling",		ceiling,		1, 0, false);
  sc->truncate_symbol =              defun("truncate",		truncate,		1, 0, false);
  sc->round_symbol =                 defun("round",		round,			1, 0, false);
  sc->lcm_symbol =                   defun("lcm",		lcm,			0, 0, true);
  sc->gcd_symbol =                   defun("gcd",		gcd,			0, 0, true);
  sc->add_symbol =                   defun("+",		        add,			0, 0, true);
  sc->subtract_symbol =              defun("-",		        subtract,		1, 0, true);
  sc->multiply_symbol =              defun("*",		        multiply,		0, 0, true);
  sc->divide_symbol =                defun("/",		        divide,			1, 0, true);
  sc->max_symbol =                   defun("max",		max,			1, 0, true);
  sc->min_symbol =                   defun("min",		min,			1, 0, true);
  sc->quotient_symbol =              defun("quotient",		quotient,		2, 0, false);
  sc->remainder_symbol =             defun("remainder",	        remainder,		2, 0, false);
  sc->modulo_symbol =                defun("modulo",		modulo,			2, 0, false);
  sc->eq_symbol =                    defun("=",		        equal,			2, 0, true);
  sc->lt_symbol =                    defun("<",		        less,			2, 0, true);
  sc->gt_symbol =                    defun(">",		        greater,		2, 0, true);
  sc->leq_symbol =                   defun("<=",		less_or_equal,		2, 0, true);
  sc->geq_symbol =                   defun(">=",		greater_or_equal,	2, 0, true);
  sc->logior_symbol =                defun("logior",		logior,			0, 0, true);
  sc->logxor_symbol =                defun("logxor",		logxor,			0, 0, true);
  sc->logand_symbol =                defun("logand",		logand,			0, 0, true);
  sc->lognot_symbol =                defun("lognot",		lognot,			1, 0, false);
  sc->ash_symbol =                   defun("ash",		ash,			2, 0, false);
  sc->random_state_symbol =          defun("random-state",      random_state,	        1, 1, false);
  sc->random_symbol =                defun("random",		random,			1, 1, false);
#if (!WITH_PURE_S7)
  sc->inexact_to_exact_symbol =      defun("inexact->exact",	inexact_to_exact,	1, 0, false);
  sc->exact_to_inexact_symbol =      defun("exact->inexact",	exact_to_inexact,	1, 0, false);
  sc->integer_length_symbol =        defun("integer-length",	integer_length,		1, 0, false);
  sc->make_polar_symbol =            defun("make-polar",	make_polar,		2, 0, false);
  sc->make_rectangular_symbol =      defun("make-rectangular",  complex,	        2, 0, false);
#endif
#endif /* !gmp */

  sc->logbit_symbol =                defun("logbit?",		logbit,			2, 0, false);
  sc->integer_decode_float_symbol =  defun("integer-decode-float", integer_decode_float, 1, 0, false);
#if (!WITH_PURE_S7)
  sc->is_exact_symbol =              defun("exact?",		is_exact,		1, 0, false);
  sc->is_inexact_symbol =            defun("inexact?",		is_inexact,		1, 0, false);
#endif
  sc->random_state_to_list_symbol =  defun("random-state->list", random_state_to_list, 0, 1, false);

  sc->number_to_string_symbol =      defun("number->string",	number_to_string,	1, 1, false);
  sc->string_to_number_symbol =      defun("string->number",	string_to_number,	1, 1, false);

  sc->char_upcase_symbol =           defun("char-upcase",	char_upcase,		1, 0, false);
  sc->char_downcase_symbol =         defun("char-downcase",	char_downcase,		1, 0, false);
  sc->char_to_integer_symbol =       defun("char->integer",	char_to_integer,	1, 0, false);
  sc->integer_to_char_symbol =       defun("integer->char",	integer_to_char,	1, 0, false);

  sc->is_char_upper_case_symbol =    defun("char-upper-case?",  is_char_upper_case,	1, 0, false);
  sc->is_char_lower_case_symbol =    defun("char-lower-case?",  is_char_lower_case,	1, 0, false);
  sc->is_char_alphabetic_symbol =    defun("char-alphabetic?",  is_char_alphabetic,	1, 0, false);
  sc->is_char_numeric_symbol =       defun("char-numeric?",	is_char_numeric,	1, 0, false);
  sc->is_char_whitespace_symbol =    defun("char-whitespace?",  is_char_whitespace,	1, 0, false);

  sc->char_eq_symbol =               defun("char=?",		chars_are_equal,	2, 0, true);
  sc->char_lt_symbol =               defun("char<?",		chars_are_less,		2, 0, true);
  sc->char_gt_symbol =               defun("char>?",		chars_are_greater,	2, 0, true);
  sc->char_leq_symbol =              defun("char<=?",		chars_are_leq,		2, 0, true);
  sc->char_geq_symbol =              defun("char>=?",		chars_are_geq,		2, 0, true);
  sc->char_position_symbol =         defun("char-position",	char_position,		2, 1, false);
  sc->string_position_symbol =       defun("string-position",	string_position,	2, 1, false);

  sc->make_string_symbol =           defun("make-string",	make_string,		1, 1, false);
  sc->string_ref_symbol =            defun("string-ref",	string_ref,		2, 0, false);
  sc->string_set_symbol =            defun("string-set!",	string_set,		3, 0, false);

  sc->string_eq_symbol =             defun("string=?",		strings_are_equal,	2, 0, true);
  sc->string_lt_symbol =             defun("string<?",		strings_are_less,	2, 0, true);
  sc->string_gt_symbol =             defun("string>?",		strings_are_greater,	2, 0, true);
  sc->string_leq_symbol =            defun("string<=?",	        strings_are_leq,	2, 0, true);
  sc->string_geq_symbol =            defun("string>=?",	        strings_are_geq,	2, 0, true);

#if (!WITH_PURE_S7)
  sc->char_ci_eq_symbol =            defun("char-ci=?",	        chars_are_ci_equal,	2, 0, true);
  sc->char_ci_lt_symbol =            defun("char-ci<?",	        chars_are_ci_less,	2, 0, true);
  sc->char_ci_gt_symbol =            defun("char-ci>?",	        chars_are_ci_greater,	2, 0, true);
  sc->char_ci_leq_symbol =           defun("char-ci<=?",	chars_are_ci_leq,	2, 0, true);
  sc->char_ci_geq_symbol =           defun("char-ci>=?",	chars_are_ci_geq,	2, 0, true);
  sc->string_ci_eq_symbol =          defun("string-ci=?",	strings_are_ci_equal,	2, 0, true);
  sc->string_ci_lt_symbol =          defun("string-ci<?",	strings_are_ci_less,	2, 0, true);
  sc->string_ci_gt_symbol =          defun("string-ci>?",	strings_are_ci_greater, 2, 0, true);
  sc->string_ci_leq_symbol =         defun("string-ci<=?",	strings_are_ci_leq,	2, 0, true);
  sc->string_ci_geq_symbol =         defun("string-ci>=?",	strings_are_ci_geq,	2, 0, true);
  sc->string_copy_symbol =           defun("string-copy",	string_copy,		1, 0, false);
  sc->string_fill_symbol =           defun("string-fill!",	string_fill,		2, 2, false);
  sc->list_to_string_symbol =        defun("list->string",	list_to_string,		1, 0, false);
  sc->string_length_symbol =         defun("string-length",	string_length,		1, 0, false);
  sc->string_to_list_symbol =        defun("string->list",	string_to_list,		1, 2, false);
#endif

  sc->string_downcase_symbol =       defun("string-downcase",	string_downcase,	1, 0, false);
  sc->string_upcase_symbol =         defun("string-upcase",	string_upcase,		1, 0, false);
  sc->string_append_symbol =         defun("string-append",	string_append,		0, 0, true);
  sc->substring_symbol =             defun("substring",	        substring,		2, 1, false);
  sc->string_symbol =                defun("string",		string,			0, 0, true);
  sc->object_to_string_symbol =      defun("object->string",	object_to_string,	1, 2, false);
  sc->format_symbol =                defun("format",		format,			2, 0, true); /* was 1, 5-Feb-19 */
  /* this was unsafe, but was that due to the (ill-advised) use of temp_call_2 in the arg lists? */
  sc->object_to_let_symbol =         defun("object->let",	object_to_let,	        1, 0, false);

  sc->cons_symbol =                  defun("cons",		cons,			2, 0, false);
  sc->car_symbol =                   defun("car",		car,			1, 0, false);
  sc->cdr_symbol =                   defun("cdr",		cdr,			1, 0, false);
  sc->set_car_symbol =               defun("set-car!",		set_car,		2, 0, false);
  sc->set_cdr_symbol =               defun("set-cdr!",	        set_cdr,		2, 0, false); /* was unsafe 27-Sep-17 */
  sc->caar_symbol =                  defun("caar",		caar,			1, 0, false);
  sc->cadr_symbol =                  defun("cadr",		cadr,			1, 0, false);
  sc->cdar_symbol =                  defun("cdar",		cdar,			1, 0, false);
  sc->cddr_symbol =                  defun("cddr",		cddr,			1, 0, false);
  sc->caaar_symbol =                 defun("caaar",		caaar,			1, 0, false);
  sc->caadr_symbol =                 defun("caadr",		caadr,			1, 0, false);
  sc->cadar_symbol =                 defun("cadar",		cadar,			1, 0, false);
  sc->cdaar_symbol =                 defun("cdaar",		cdaar,			1, 0, false);
  sc->caddr_symbol =                 defun("caddr",		caddr,			1, 0, false);
  sc->cdddr_symbol =                 defun("cdddr",		cdddr,			1, 0, false);
  sc->cdadr_symbol =                 defun("cdadr",		cdadr,			1, 0, false);
  sc->cddar_symbol =                 defun("cddar",		cddar,			1, 0, false);
  sc->caaaar_symbol =                defun("caaaar",		caaaar,			1, 0, false);
  sc->caaadr_symbol =                defun("caaadr",		caaadr,			1, 0, false);
  sc->caadar_symbol =                defun("caadar",		caadar,			1, 0, false);
  sc->cadaar_symbol =                defun("cadaar",		cadaar,			1, 0, false);
  sc->caaddr_symbol =                defun("caaddr",		caaddr,			1, 0, false);
  sc->cadddr_symbol =                defun("cadddr",		cadddr,			1, 0, false);
  sc->cadadr_symbol =                defun("cadadr",		cadadr,			1, 0, false);
  sc->caddar_symbol =                defun("caddar",		caddar,			1, 0, false);
  sc->cdaaar_symbol =                defun("cdaaar",		cdaaar,			1, 0, false);
  sc->cdaadr_symbol =                defun("cdaadr",		cdaadr,			1, 0, false);
  sc->cdadar_symbol =                defun("cdadar",		cdadar,			1, 0, false);
  sc->cddaar_symbol =                defun("cddaar",		cddaar,			1, 0, false);
  sc->cdaddr_symbol =                defun("cdaddr",		cdaddr,			1, 0, false);
  sc->cddddr_symbol =                defun("cddddr",		cddddr,			1, 0, false);
  sc->cddadr_symbol =                defun("cddadr",		cddadr,			1, 0, false);
  sc->cdddar_symbol =                defun("cdddar",		cdddar,			1, 0, false);

  sc->assq_symbol =                  defun("assq",		assq,			2, 0, false);
  sc->assv_symbol =                  defun("assv",		assv,			2, 0, false);
  sc->assoc_symbol =                 unsafe_defun("assoc",	assoc,			2, 1, false);
  sc->memq_symbol =                  defun("memq",		memq,			2, 0, false);
  sc->memv_symbol =                  defun("memv",		memv,			2, 0, false);
  sc->member_symbol =                unsafe_defun("member",	member,			2, 1, false);

  sc->list_symbol =                  defun("list",		list,			0, 0, true);
  sc->list_ref_symbol =              defun("list-ref",		list_ref,		2, 0, true);
  sc->list_set_symbol =              defun("list-set!",	        list_set,		3, 0, true);
  sc->list_tail_symbol =             defun("list-tail",	        list_tail,		2, 0, false);
  sc->make_list_symbol =             defun("make-list",  	make_list,		1, 1, false);

  sc->length_symbol =                defun("length",		length,			1, 0, false);
  sc->copy_symbol =                  defun("copy",		copy,			1, 3, false);
  /* set_type_bit(sc->copy_symbol, T_FULL_DEFINER); */ /* (copy (inlet 'a 1) (curlet)), but this check needs to be smarter */
  sc->fill_symbol =                  defun("fill!",		fill,			2, 2, false);
  sc->reverse_symbol =               defun("reverse",		reverse,		1, 0, false);
  sc->reverseb_symbol =              defun("reverse!",		reverse_in_place,	1, 0, false);
  sc->sort_symbol =                  unsafe_defun("sort!",	sort,			2, 0, false);
  sc->append_symbol =                defun("append",		append,			0, 0, true);

#if (!WITH_PURE_S7)
  sc->vector_append_symbol =         defun("vector-append",	vector_append,		0, 0, true);
  sc->list_to_vector_symbol =        defun("list->vector",	list_to_vector,		1, 0, false);
  sc->vector_fill_symbol =           defun("vector-fill!",	vector_fill,		2, 2, false);
  sc->vector_length_symbol =         defun("vector-length",	vector_length,		1, 0, false);
  sc->vector_to_list_symbol =        defun("vector->list",	vector_to_list,		1, 2, false);
#else
  sc->vector_append_symbol = sc->append_symbol;
  sc->vector_fill_symbol = sc->fill_symbol;
  sc->string_fill_symbol = sc->fill_symbol;
#endif
  sc->vector_ref_symbol =            defun("vector-ref",	vector_ref,		2, 0, true);
  sc->vector_set_symbol =            defun("vector-set!",	vector_set,		3, 0, true);
  sc->vector_dimensions_symbol =     defun("vector-dimensions", vector_dimensions,	1, 0, false);
  sc->make_vector_symbol =           defun("make-vector",	make_vector,		1, 2, false);
  sc->vector_symbol =                defun("vector",		vector,			0, 0, true);
  set_setter(sc->vector_symbol); /* like cons, I guess */

  sc->subvector_symbol =             defun("subvector",         subvector,	        2, 1, false);
  sc->subvector_position_symbol =    defun("subvector-position", subvector_position,    1, 0, false);
  sc->subvector_vector_symbol =      defun("subvector-vector",  subvector_vector,       1, 0, false);

  sc->float_vector_symbol =          defun("float-vector",	float_vector,		0, 0, true);
  sc->make_float_vector_symbol =     defun("make-float-vector", make_float_vector,	1, 1, false);
  sc->float_vector_set_symbol =      defun("float-vector-set!", float_vector_set,	3, 0, true);
  sc->float_vector_ref_symbol =      defun("float-vector-ref",  float_vector_ref,	2, 0, true);

  sc->int_vector_symbol =            defun("int-vector",	int_vector,		0, 0, true);
  sc->make_int_vector_symbol =       defun("make-int-vector",	make_int_vector,	1, 1, false);
  sc->int_vector_set_symbol =        defun("int-vector-set!",	int_vector_set,		3, 0, true);
  sc->int_vector_ref_symbol =        defun("int-vector-ref",	int_vector_ref,		2, 0, true);

  sc->byte_vector_symbol =           defun("byte-vector",	byte_vector,		0, 0, true);
  sc->make_byte_vector_symbol =      defun("make-byte-vector",  make_byte_vector,	1, 1, false);
  sc->byte_vector_ref_symbol =       defun("byte-vector-ref",	byte_vector_ref,        2, 0, true);
  sc->byte_vector_set_symbol =       defun("byte-vector-set!",	byte_vector_set,	3, 0, true);
  sc->string_to_byte_vector_symbol = defun("string->byte-vector", string_to_byte_vector, 1, 0, false);
  sc->byte_vector_to_string_symbol = defun("byte-vector->string", byte_vector_to_string, 1, 0, false);

  sc->hash_table_symbol =            defun("hash-table",	hash_table,		0, 0, true);
  sc->make_hash_table_symbol =       defun("make-hash-table",	make_hash_table,	0, 3, false);
  sc->make_weak_hash_table_symbol =  defun("make-weak-hash-table", make_weak_hash_table,0, 3, false);
  sc->weak_hash_table_symbol =       defun("weak-hash-table",   weak_hash_table,        0, 0, true);
  sc->hash_table_ref_symbol =        defun("hash-table-ref",	hash_table_ref,		2, 0, true);
  sc->hash_table_set_symbol =        defun("hash-table-set!",	hash_table_set,		3, 0, false);
  sc->hash_table_entries_symbol =    defun("hash-table-entries", hash_table_entries,	1, 0, false);

  sc->cyclic_sequences_symbol =      defun("cyclic-sequences",  cyclic_sequences,	1, 0, false);
  sc->call_cc_symbol =               unsafe_defun("call/cc",	call_cc,		1, 0, false);
  sc->call_with_current_continuation_symbol = unsafe_defun("call-with-current-continuation", call_cc, 1, 0, false);
  sc->call_with_exit_symbol =        unsafe_defun("call-with-exit", call_with_exit,	1, 0, false);

  sc->load_symbol =                  unsafe_defun("load",	load,			1, 1, false);
  sc->autoload_symbol =              defun("autoload",	        autoload,		2, 0, false);
  sc->eval_symbol =                  unsafe_defun("eval",	eval,			1, 1, false);
  set_type_bit(sc->eval_symbol, T_FULL_DEFINER);
  sc->eval_string_symbol =           unsafe_defun("eval-string", eval_string,		1, 1, false);
  set_type_bit(sc->eval_string_symbol, T_FULL_DEFINER);
  sc->apply_symbol =                 unsafe_defun("apply",	apply,			1, 0, true);
  {
    s7_pointer p;
    set_is_definer(sc->apply_symbol);  
    /* yow... (apply (inlet) (f)) in do body where (f) returns '(define...) -- see s7test.scm under apply
     *   perhaps better: if closure returns a definer in some way set its name as a definer? even this is not fool-proof
     */
    p = slot_value(global_slot(sc->apply_symbol));
    set_type(p, type(p) | T_COPY_ARGS | T_UNHEAP);
    /* (let ((x '((1 2) 3 4))) (catch #t (lambda () (apply apply apply x)) (lambda args 'error)) x) should not mess up x! */
  }
  sc->for_each_symbol =              unsafe_defun("for-each",	for_each,		2, 0, true);
  sc->map_symbol =                   unsafe_defun("map",	map,			2, 0, true);
  sc->dynamic_wind_symbol =          unsafe_defun("dynamic-wind", dynamic_wind,	        3, 0, false);
  /* sc->values_symbol = */          unsafe_defun("values",	values,			0, 0, true);
  sc->catch_symbol =                 unsafe_defun("catch",	catch,			3, 0, false);
  sc->throw_symbol =                 unsafe_defun("throw",	throw,			1, 0, true);
  sc->error_symbol =                 unsafe_defun("error",	error,			0, 0, true);
  /* it's faster to leave error/throw unsafe than to set needs_copied_args and use s7_define_safe_function because copy_list overwhelms any other savings */
  sc->stacktrace_symbol =            defun("stacktrace",	stacktrace,		0, 5, false);

  sc->apply_values_symbol =          unsafe_defun("apply-values", apply_values,         0, 1, false);
  set_immutable(sc->apply_values_symbol);
  sc->list_values_symbol =           unsafe_defun("list-values", list_values,           0, 0, true);
  set_immutable(sc->list_values_symbol);

  sc->documentation_symbol =         defun("documentation",     documentation,          1, 0, false);
  sc->signature_symbol =             defun("signature",         signature,	        1, 0, false);
  sc->help_symbol =                  defun("help",		help,			1, 0, false);
  sc->procedure_source_symbol =      defun("procedure-source",  procedure_source,	1, 0, false);
  sc->funclet_symbol =               defun("funclet",		funclet,		1, 0, false);
  sc->dilambda_symbol =              defun("dilambda",          dilambda,               2, 0, false);
  s7_typed_dilambda(sc, "setter", g_setter, 1, 1, g_set_setter, 2, 1, H_setter, Q_setter, NULL);
  sc->arity_symbol =                 defun("arity",		arity,			1, 0, false);
  sc->is_aritable_symbol =           defun("aritable?",	        is_aritable,		2, 0, false);

  sc->is_eq_symbol =                 defun("eq?",		is_eq,			2, 0, false);
  sc->is_eqv_symbol =                defun("eqv?",		is_eqv,			2, 0, false);
  sc->is_equal_symbol =              defun("equal?",		is_equal,		2, 0, false);
  sc->is_equivalent_symbol =         defun("equivalent?",	is_equivalent,	2, 0, false);
  sc->type_of_symbol =               defun("type-of",		type_of,		1, 0, false);

  sc->gc_symbol =                    unsafe_defun("gc",		gc,			0, 1, false);
  sc->s7_version_symbol =            defun("s7-version",	s7_version,		0, 0, false);
                                     defun("emergency-exit",	emergency_exit,		0, 1, false);
  sc->exit_symbol =                  defun("exit",		exit,			0, 1, false);

#if WITH_GCC
  s7_define_function(sc, "abort", g_abort, 0, 0, true, "drop into gdb I hope");
#endif
  s7_define_function(sc, "s7-optimize", g_optimize, 1, 0, false, "short-term debugging aid");

  sc->c_object_set_function = s7_make_function(sc, "#<c-object-setter>", g_c_object_set, 1, 0, true, "c-object setter");
  /* c_function_signature(sc->c_object_set_function) = s7_make_circular_signature(sc, 2, 3, sc->T, sc->is_c_object_symbol, sc->T); */

  set_scope_safe(slot_value(global_slot(sc->call_with_input_string_symbol)));
  set_scope_safe(slot_value(global_slot(sc->call_with_input_file_symbol)));
  set_scope_safe(slot_value(global_slot(sc->call_with_output_string_symbol)));
  set_scope_safe(slot_value(global_slot(sc->call_with_output_file_symbol)));
  set_scope_safe(slot_value(global_slot(sc->with_input_from_string_symbol)));
  set_scope_safe(slot_value(global_slot(sc->with_input_from_file_symbol)));
  set_scope_safe(slot_value(global_slot(sc->with_output_to_string_symbol)));
  set_scope_safe(slot_value(global_slot(sc->with_output_to_file_symbol)));
  set_scope_safe(slot_value(global_slot(sc->set_cdr_symbol)));
  set_maybe_safe(slot_value(global_slot(sc->assoc_symbol)));
  set_scope_safe(slot_value(global_slot(sc->assoc_symbol)));
  set_maybe_safe(slot_value(global_slot(sc->member_symbol)));
  set_scope_safe(slot_value(global_slot(sc->member_symbol)));
  set_scope_safe(slot_value(global_slot(sc->sort_symbol)));
  set_scope_safe(slot_value(global_slot(sc->call_with_exit_symbol)));
  set_scope_safe(slot_value(global_slot(sc->for_each_symbol)));
  set_maybe_safe(slot_value(global_slot(sc->for_each_symbol)));
  set_scope_safe(slot_value(global_slot(sc->map_symbol)));
  set_maybe_safe(slot_value(global_slot(sc->map_symbol)));
  set_scope_safe(slot_value(global_slot(sc->dynamic_wind_symbol)));
  set_scope_safe(slot_value(global_slot(sc->catch_symbol)));
  set_scope_safe(slot_value(global_slot(sc->throw_symbol)));
  set_scope_safe(slot_value(global_slot(sc->error_symbol)));
  set_scope_safe(slot_value(global_slot(sc->apply_values_symbol)));
  set_scope_safe(slot_value(global_slot(sc->list_values_symbol)));

  sc->tree_leaves_symbol =    defun("tree-leaves",   tree_leaves,    1, 0, false);
  sc->tree_memq_symbol =      defun("tree-memq",     tree_memq,      2, 0, false);
  sc->tree_set_memq_symbol =  defun("tree-set-memq", tree_set_memq,  2, 0, false);
  sc->tree_count_symbol =     defun("tree-count",    tree_count,     2, 1, false);
  sc->tree_is_cyclic_symbol = defun("tree-cyclic?",  tree_is_cyclic, 1, 0, false);

  /* -------- *features* -------- */
  sc->features_symbol = s7_define_variable_with_documentation(sc, "*features*", sc->nil, "list of currently available features ('complex-numbers, etc)");
  s7_set_setter(sc, sc->features_symbol, s7_make_function(sc, "#<set-*features*>", g_features_set, 2, 0, false, "*features* setter"));

  /* -------- *load-path* -------- */
  sc->load_path_symbol = s7_define_variable_with_documentation(sc, "*load-path*", sc->nil,
			   "*load-path* is a list of directories (strings) that the load function searches if it is passed an incomplete file name");
  s7_set_setter(sc, sc->load_path_symbol, s7_make_function(sc, "#<set-*load-path*>", g_load_path_set, 2, 0, false, "*load-path* setter"));

#ifdef CLOAD_DIR
  sc->cload_directory_symbol = s7_define_variable(sc, "*cload-directory*", s7_make_string(sc, (char *)CLOAD_DIR));
  s7_add_to_load_path(sc, (const char *)CLOAD_DIR);
#else
  sc->cload_directory_symbol = s7_define_variable(sc, "*cload-directory*", make_empty_string(sc, 0, 0));
#endif
  s7_set_setter(sc, sc->cload_directory_symbol, s7_make_function(sc, "#<set-*cload-directory*>", g_cload_directory_set, 2, 0, false, "*cload-directory* setter"));

  /* -------- *autoload* --------
   * this pretends to be a hash-table or environment, but it's actually a function
   */
  sc->autoloader_symbol = s7_define_typed_function(sc, "*autoload*", g_autoloader, 1, 0, false, H_autoloader, Q_autoloader);
  c_function_set_setter(slot_value(global_slot(sc->autoloader_symbol)), slot_value(global_slot(sc->autoload_symbol))); /* (set! (*autoload* x) y) */

  sc->libraries_symbol = s7_define_variable_with_documentation(sc, "*libraries*", sc->nil, "list of currently loaded libraries (libc.scm, etc)");
  s7_set_setter(sc, sc->libraries_symbol, s7_make_function(sc, "#<set-*libraries*>", g_libraries_set, 2, 0, false, "*libraries* setter"));

  s7_autoload(sc, make_symbol(sc, "cload.scm"),       s7_make_permanent_string(sc, "cload.scm"));
  s7_autoload(sc, make_symbol(sc, "lint.scm"),        s7_make_permanent_string(sc, "lint.scm"));
  s7_autoload(sc, make_symbol(sc, "stuff.scm"),       s7_make_permanent_string(sc, "stuff.scm"));
  s7_autoload(sc, make_symbol(sc, "mockery.scm"),     s7_make_permanent_string(sc, "mockery.scm"));
  s7_autoload(sc, make_symbol(sc, "write.scm"),       s7_make_permanent_string(sc, "write.scm"));
  s7_autoload(sc, make_symbol(sc, "reactive.scm"),    s7_make_permanent_string(sc, "reactive.scm"));
  s7_autoload(sc, make_symbol(sc, "repl.scm"),        s7_make_permanent_string(sc, "repl.scm"));
  s7_autoload(sc, make_symbol(sc, "r7rs.scm"),        s7_make_permanent_string(sc, "r7rs.scm"));
  s7_autoload(sc, make_symbol(sc, "profile.scm"),     s7_make_permanent_string(sc, "profile.scm"));

  s7_autoload(sc, make_symbol(sc, "libc.scm"),        s7_make_permanent_string(sc, "libc.scm"));
  s7_autoload(sc, make_symbol(sc, "libm.scm"),        s7_make_permanent_string(sc, "libm.scm"));
  s7_autoload(sc, make_symbol(sc, "libdl.scm"),       s7_make_permanent_string(sc, "libdl.scm"));
  s7_autoload(sc, make_symbol(sc, "libgsl.scm"),      s7_make_permanent_string(sc, "libgsl.scm"));
  s7_autoload(sc, make_symbol(sc, "libgdbm.scm"),     s7_make_permanent_string(sc, "libgdbm.scm"));
  s7_autoload(sc, make_symbol(sc, "libutf8proc.scm"), s7_make_permanent_string(sc, "libutf8proc.scm"));

  sc->require_symbol = s7_define_macro(sc, "require", g_require, 1, 0, true, H_require);
  sc->stacktrace_defaults = s7_list(sc, 5, small_int(3), small_int(45), small_int(80), small_int(45), sc->T);

  /* -------- *#readers* -------- */
  sym = s7_define_variable_with_documentation(sc, "*#readers*", sc->nil, "list of current reader macros");
  sc->sharp_readers = global_slot(sym);
  s7_set_setter(sc, sym, s7_make_function(sc, "#<set-*#readers*>", g_sharp_readers_set, 2, 0, false, "*#readers* setter"));

  /* *features* */
  s7_provide(sc, "s7");
  s7_provide(sc, "s7-" S7_VERSION);
  s7_provide(sc, "ratio");

  sc->local_documentation_symbol = make_symbol(sc, "+documentation+");
  sc->local_signature_symbol =     make_symbol(sc, "+signature+");
  sc->local_setter_symbol =        make_symbol(sc, "+setter+");
  sc->local_iterator_symbol =      make_symbol(sc, "+iterator+");

  /* for backwards compatibility */
  s7_define_constant(sc, "nan.0", real_NaN);
  s7_define_constant(sc, "inf.0", real_infinity);

#if WITH_PURE_S7
  s7_provide(sc, "pure-s7");
#endif
#if WITH_EXTRA_EXPONENT_MARKERS
  s7_provide(sc, "dfls-exponents");
#endif
#if HAVE_OVERFLOW_CHECKS
  s7_provide(sc, "overflow-checks");
#endif
#if WITH_SYSTEM_EXTRAS
  s7_provide(sc, "system-extras");
#endif
#if WITH_IMMUTABLE_UNQUOTE
  s7_provide(sc, "immutable-unquote");
#endif
#if S7_DEBUGGING
  s7_provide(sc, "debugging");
#endif
#if WITH_PROFILE
  s7_provide(sc, "profiling");
#endif
#if HAVE_COMPLEX_NUMBERS
  s7_provide(sc, "complex-numbers");
#endif
#if WITH_HISTORY
  s7_provide(sc, "history");
#endif
#if WITH_C_LOADER
  s7_provide(sc, "dlopen");
#endif
#if (!DISABLE_AUTOLOAD)
  s7_provide(sc, "autoload");
#endif

#ifdef __APPLE__
  s7_provide(sc, "osx");
#endif
#ifdef __linux__
  s7_provide(sc, "linux");
#endif
#ifdef __OpenBSD__
  s7_provide(sc, "openbsd");
#endif
#ifdef __NetBSD__
  s7_provide(sc, "netbsd");
#endif
#ifdef __FreeBSD__
  s7_provide(sc, "freebsd");
#endif
#if MS_WINDOWS
  s7_provide(sc, "windows");
#endif
#ifdef __bfin__
  s7_provide(sc, "blackfin");
#endif
#ifdef __ANDROID__
  s7_provide(sc, "android");
#endif
#ifdef __CYGWIN__
  s7_provide(sc, "cygwin");
#endif
#ifdef __hpux
  s7_provide(sc, "hpux");
#endif
#if defined(__sun) && defined(__SVR4)
  s7_provide(sc, "solaris");
#endif
#ifdef __MINGW32__
  s7_provide(sc, "mingw");
#endif

#ifdef __SUNPRO_C
  s7_provide(sc, "sunpro_c");
#endif
#if (defined(__clang__))
  s7_provide(sc, "clang");
#endif
#if (defined(__GNUC__))
  s7_provide(sc, "gcc");
#endif

  sc->vector_set_function = slot_value(global_slot(sc->vector_set_symbol));
  set_setter(sc->vector_set_symbol);
  /* not float-vector-set! here */

  sc->list_set_function = slot_value(global_slot(sc->list_set_symbol));
  set_setter(sc->list_set_symbol);

  sc->hash_table_set_function = slot_value(global_slot(sc->hash_table_set_symbol));
  set_setter(sc->hash_table_set_symbol);

  sc->let_set_function = slot_value(global_slot(sc->let_set_symbol));
  set_setter(sc->let_set_symbol);

  set_setter(sc->cons_symbol); /* (this blocks an over-eager do loop optimization -- see do-test-15 in s7test) */

  sc->string_set_function = slot_value(global_slot(sc->string_set_symbol));
  set_setter(sc->string_set_symbol);

  set_setter(sc->byte_vector_set_symbol);
  set_setter(sc->set_car_symbol);
  set_setter(sc->set_cdr_symbol);

#if (WITH_PURE_S7)
  /* we need to be able at least to set (current-output-port) to #f */
  c_function_set_setter(slot_value(global_slot(sc->current_input_port_symbol)),
			s7_make_function(sc, "#<set-*stdin*>", g_set_current_input_port, 1, 0, false, "*stdin* setter"));
  c_function_set_setter(slot_value(global_slot(sc->current_output_port_symbol)),
			s7_make_function(sc, "#<set-*stdout*>", g_set_current_output_port, 1, 0, false, "*stdout* setter"));
#else
  set_setter(sc->set_current_input_port_symbol);
  set_setter(sc->set_current_output_port_symbol);
  s7_function_set_setter(sc, "current-input-port",  "set-current-input-port");
  s7_function_set_setter(sc, "current-output-port", "set-current-output-port");
#endif

  set_setter(sc->set_current_error_port_symbol);
  s7_function_set_setter(sc, "current-error-port",  "set-current-error-port");
  /* despite the similar names, current-error-port is different from the other two, and a setter is needed
   *    in scheme because error and warn send output to it by default.  It is not a "dynamic variable" unlike
   *    the other two.  In the input/output cases, setting the port can only cause confusion.
   *    current-error-port should simply be an s7 variable with a name like *error-port* and an setter to
   *    ensure its new value, if any, is an output port.
   */

  s7_function_set_setter(sc, "car",              "set-car!");
  s7_function_set_setter(sc, "cdr",              "set-cdr!");
  s7_function_set_setter(sc, "hash-table-ref",   "hash-table-set!");
  s7_function_set_setter(sc, "vector-ref",       "vector-set!");
  s7_function_set_setter(sc, "float-vector-ref", "float-vector-set!");
  s7_function_set_setter(sc, "int-vector-ref",   "int-vector-set!");
  s7_function_set_setter(sc, "byte-vector-ref",  "byte-vector-set!");
  s7_function_set_setter(sc, "list-ref",         "list-set!");
  s7_function_set_setter(sc, "let-ref",          "let-set!");
  s7_function_set_setter(sc, "string-ref",       "string-set!");
  c_function_set_setter(slot_value(global_slot(sc->outlet_symbol)),
			s7_make_function(sc, "#<set-outlet>", g_set_outlet, 2, 0, false, "outlet setter"));
  c_function_set_setter(slot_value(global_slot(sc->port_line_number_symbol)),
			s7_make_function(sc, "#<set-port-line-number>", g_set_port_line_number, 1, 1, false, "port line setter"));
  c_function_set_setter(slot_value(global_slot(sc->port_position_symbol)),
			s7_make_function(sc, "#<set-port-position>", g_set_port_position, 2, 0, false, "port position setter"));

  s7_define_constant(sc, "most-positive-fixnum", mostfix);
  s7_define_constant(sc, "most-negative-fixnum", leastfix);
  sc->pi_symbol = s7_define_constant(sc, "pi", real_pi);
  sc->objstr_max_len = s7_int_max;

  {
    s7_pointer p;
    new_cell(sc, p, T_RANDOM_STATE);
#if WITH_GMP
    {
      mpz_t seed;
      mpz_init_set_ui(seed, (uint32_t)time(NULL));
      gmp_randinit_default(random_gmp_state(p));
      gmp_randseed(random_gmp_state(p), seed);
      mpz_clear(seed);
    }
#else
    sc->bignum_precision = DEFAULT_BIGNUM_PRECISION;
    random_seed(p) = (uint64_t)time(NULL);
    random_carry(p) = 1675393560;
#endif
    sc->default_rng = p;
  }

  for (i = 0; i < 10; i++) sc->singletons[(uint8_t)'0' + i] = small_int(i);
  sc->singletons[(uint8_t)'+'] = sc->add_symbol;
  sc->singletons[(uint8_t)'-'] = sc->subtract_symbol;
  sc->singletons[(uint8_t)'*'] = sc->multiply_symbol;
  sc->singletons[(uint8_t)'/'] = sc->divide_symbol;
  sc->singletons[(uint8_t)'<'] = sc->lt_symbol;
  sc->singletons[(uint8_t)'>'] = sc->gt_symbol;
  sc->singletons[(uint8_t)'='] = sc->eq_symbol;

#if WITH_GMP
  s7_gmp_init(sc);
#endif

  init_choosers(sc);
  init_typers(sc);

  /* -------------------------------------------------------------------------------- */
  s7_set_p_pp_function(slot_value(global_slot(sc->float_vector_ref_symbol)), float_vector_ref_p_pp);
  s7_set_d_7pi_function(slot_value(global_slot(sc->float_vector_ref_symbol)), float_vector_ref_d_7pi);
  s7_set_d_7pii_function(slot_value(global_slot(sc->float_vector_ref_symbol)), float_vector_ref_d_7pii);
  s7_set_d_7pid_function(slot_value(global_slot(sc->float_vector_set_symbol)), float_vector_set_d_7pid);
  s7_set_d_7piid_function(slot_value(global_slot(sc->float_vector_set_symbol)), float_vector_set_d_7piid);

  s7_set_p_pp_function(slot_value(global_slot(sc->int_vector_ref_symbol)), int_vector_ref_p_pp);
  s7_set_i_7pi_function(slot_value(global_slot(sc->int_vector_ref_symbol)), int_vector_ref_i_7pi);
  s7_set_i_7pii_function(slot_value(global_slot(sc->int_vector_ref_symbol)), int_vector_ref_i_7pii);
  s7_set_i_7piii_function(slot_value(global_slot(sc->int_vector_ref_symbol)), int_vector_ref_i_7piii);
  s7_set_i_7pii_function(slot_value(global_slot(sc->int_vector_set_symbol)), int_vector_set_i_7pii);
  s7_set_i_7piii_function(slot_value(global_slot(sc->int_vector_set_symbol)), int_vector_set_i_7piii);

  s7_set_i_7pi_function(slot_value(global_slot(sc->byte_vector_ref_symbol)), byte_vector_ref_i_7pi);
  s7_set_i_7pii_function(slot_value(global_slot(sc->byte_vector_ref_symbol)), byte_vector_ref_i_7pii);
  s7_set_i_7pii_function(slot_value(global_slot(sc->byte_vector_set_symbol)), byte_vector_set_i_7pii);
  s7_set_i_7piii_function(slot_value(global_slot(sc->byte_vector_set_symbol)), byte_vector_set_i_7piii);

  s7_set_p_pp_function(slot_value(global_slot(sc->vector_ref_symbol)), vector_ref_p_pp);
  s7_set_p_pi_function(slot_value(global_slot(sc->vector_ref_symbol)), vector_ref_p_pi);
  s7_set_p_pii_function(slot_value(global_slot(sc->vector_ref_symbol)), vector_ref_p_pii);
  s7_set_p_pip_function(slot_value(global_slot(sc->vector_set_symbol)), vector_set_p_pip);
  s7_set_p_piip_function(slot_value(global_slot(sc->vector_set_symbol)), vector_set_p_piip);
  s7_set_p_pi_direct_function(slot_value(global_slot(sc->vector_ref_symbol)), vector_ref_p_pi_direct);
  s7_set_p_pip_direct_function(slot_value(global_slot(sc->vector_set_symbol)), vector_set_p_pip_direct);

  s7_set_p_pi_function(slot_value(global_slot(sc->list_ref_symbol)), list_ref_p_pi);
  s7_set_p_pip_function(slot_value(global_slot(sc->list_set_symbol)), list_set_p_pip);
  s7_set_p_pi_direct_function(slot_value(global_slot(sc->list_ref_symbol)), list_ref_p_pi_direct);
  s7_set_p_pip_direct_function(slot_value(global_slot(sc->list_set_symbol)), list_set_p_pip_direct);

  s7_set_p_pp_function(slot_value(global_slot(sc->let_ref_symbol)), let_ref_p_pp);
  s7_set_p_ppp_function(slot_value(global_slot(sc->let_set_symbol)), let_set_p_ppp);

  s7_set_p_pi_function(slot_value(global_slot(sc->string_ref_symbol)), string_ref_p_pi);
  s7_set_p_pp_function(slot_value(global_slot(sc->string_ref_symbol)), string_ref_p_pp);
  s7_set_p_pip_function(slot_value(global_slot(sc->string_set_symbol)), string_set_p_pip);
  s7_set_p_pi_direct_function(slot_value(global_slot(sc->string_ref_symbol)), string_ref_p_pi_direct);
  s7_set_p_pip_direct_function(slot_value(global_slot(sc->string_set_symbol)), string_set_p_pip_direct);

  s7_set_p_pp_function(slot_value(global_slot(sc->hash_table_ref_symbol)), hash_table_ref_p_pp);
  s7_set_p_ppp_function(slot_value(global_slot(sc->hash_table_set_symbol)), hash_table_set_p_ppp);
  s7_set_p_pp_direct_function(slot_value(global_slot(sc->hash_table_ref_symbol)), s7_hash_table_ref);
  s7_set_p_ppp_direct_function(slot_value(global_slot(sc->hash_table_set_symbol)), s7_hash_table_set);

#if (!WITH_GMP)
  s7_set_p_ii_function(slot_value(global_slot(sc->complex_symbol)), complex_p_ii);
  s7_set_p_dd_function(slot_value(global_slot(sc->complex_symbol)), complex_p_dd);
  s7_set_p_p_function(slot_value(global_slot(sc->random_symbol)), random_p_p);

  s7_set_p_i_function(slot_value(global_slot(sc->number_to_string_symbol)), number_to_string_p_i);
  s7_set_p_d_function(slot_value(global_slot(sc->number_to_string_symbol)), number_to_string_p_d); /* this is probably ok in gmp case -- uses is_float */
  s7_set_p_p_function(slot_value(global_slot(sc->number_to_string_symbol)), number_to_string_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->number_to_string_symbol)), number_to_string_p_pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->string_to_number_symbol)), string_to_number_p_pp);
#endif

  s7_set_p_p_function(slot_value(global_slot(sc->car_symbol)), car_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->set_car_symbol)), set_car_p_pp);
  s7_set_p_p_function(slot_value(global_slot(sc->cdr_symbol)), cdr_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->set_cdr_symbol)), set_cdr_p_pp);
  s7_set_p_p_function(slot_value(global_slot(sc->caar_symbol)), caar_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->cadr_symbol)), cadr_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->cdar_symbol)), cdar_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->cddr_symbol)), cddr_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->caddr_symbol)), caddr_p_p);

  s7_set_p_p_function(slot_value(global_slot(sc->string_to_symbol_symbol)), string_to_symbol_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->symbol_to_string_symbol)), symbol_to_string_p);
  s7_set_p_function(slot_value(global_slot(sc->newline_symbol)), newline_p);
  s7_set_p_p_function(slot_value(global_slot(sc->newline_symbol)), newline_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->display_symbol)), display_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->display_symbol)), display_p_pp);
  s7_set_p_p_function(slot_value(global_slot(sc->write_symbol)), write_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->write_symbol)), write_p_pp);
  s7_set_p_p_function(slot_value(global_slot(sc->write_char_symbol)), write_char_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->write_char_symbol)), write_char_p_pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->read_line_symbol)), read_line_p_pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->inlet_symbol)), inlet_p_pp);
  s7_set_i_7p_function(slot_value(global_slot(sc->port_line_number_symbol)), port_line_number_i_7p);
  s7_set_p_pp_function(slot_value(global_slot(sc->cons_symbol)), cons_p_pp);
  s7_set_p_function(slot_value(global_slot(sc->s7_version_symbol)), s7_version_p);
  s7_set_p_function(slot_value(global_slot(sc->open_output_string_symbol)), open_output_string_p);
  s7_set_p_ppi_function(slot_value(global_slot(sc->char_position_symbol)), char_position_p_ppi);
  s7_set_p_pp_function(slot_value(global_slot(sc->append_symbol)), append_p_pp);
  s7_set_p_ppp_function(slot_value(global_slot(sc->append_symbol)), append_p_ppp);
  s7_set_p_function(slot_value(global_slot(sc->values_symbol)), values_p);
  s7_set_p_p_function(slot_value(global_slot(sc->values_symbol)), values_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->member_symbol)), member_p_pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->assoc_symbol)), assoc_p_pp);

#if (!WITH_GMP)
  s7_set_i_i_function(slot_value(global_slot(sc->abs_symbol)), abs_i_i);
  s7_set_d_d_function(slot_value(global_slot(sc->abs_symbol)), abs_d_d);
  s7_set_d_d_function(slot_value(global_slot(sc->exp_symbol)), exp_d_d);
  s7_set_d_d_function(slot_value(global_slot(sc->sin_symbol)), sin_d_d);
  s7_set_p_d_function(slot_value(global_slot(sc->sin_symbol)), sin_p_d);
  s7_set_d_d_function(slot_value(global_slot(sc->cos_symbol)), cos_d_d);
  s7_set_p_d_function(slot_value(global_slot(sc->cos_symbol)), cos_p_d);
  s7_set_d_d_function(slot_value(global_slot(sc->tan_symbol)), tan_d_d);
  s7_set_d_d_function(slot_value(global_slot(sc->sinh_symbol)), sinh_d_d);
  s7_set_d_d_function(slot_value(global_slot(sc->cosh_symbol)), cosh_d_d);
  s7_set_d_d_function(slot_value(global_slot(sc->tanh_symbol)), tanh_d_d);
  s7_set_d_7d_function(slot_value(global_slot(sc->random_symbol)), random_d_7d);
  s7_set_i_i_function(slot_value(global_slot(sc->round_symbol)), round_i_i);
  s7_set_i_i_function(slot_value(global_slot(sc->floor_symbol)), floor_i_i);
  s7_set_i_i_function(slot_value(global_slot(sc->truncate_symbol)), truncate_i_i);
  s7_set_i_i_function(slot_value(global_slot(sc->ceiling_symbol)), ceiling_i_i);
  s7_set_d_dd_function(slot_value(global_slot(sc->atan_symbol)), atan_d_dd);
  s7_set_d_7dd_function(slot_value(global_slot(sc->quotient_symbol)), quotient_d_7dd);
  s7_set_d_7dd_function(slot_value(global_slot(sc->remainder_symbol)), remainder_d_7dd);
  s7_set_d_dd_function(slot_value(global_slot(sc->modulo_symbol)), modulo_d_dd);
  s7_set_p_pp_function(slot_value(global_slot(sc->multiply_symbol)), multiply_p_pp);
  s7_set_p_dd_function(slot_value(global_slot(sc->multiply_symbol)), mul_p_dd);
  s7_set_p_dd_function(slot_value(global_slot(sc->add_symbol)), add_p_dd);
  s7_set_p_dd_function(slot_value(global_slot(sc->subtract_symbol)), sub_p_dd);
  s7_set_i_7d_function(slot_value(global_slot(sc->round_symbol)), round_i_7d);
  s7_set_i_7d_function(slot_value(global_slot(sc->floor_symbol)), floor_i_7d);
  s7_set_i_7p_function(slot_value(global_slot(sc->floor_symbol)), floor_i_7p);
  s7_set_i_7p_function(slot_value(global_slot(sc->ceiling_symbol)), ceiling_i_7p);
  s7_set_i_7d_function(slot_value(global_slot(sc->truncate_symbol)), truncate_i_7d);
  s7_set_i_7d_function(slot_value(global_slot(sc->ceiling_symbol)), ceiling_i_7d);
  s7_set_i_7i_function(slot_value(global_slot(sc->random_symbol)), random_i_7i);
  s7_set_i_7ii_function(slot_value(global_slot(sc->quotient_symbol)), quotient_i_7ii);
  s7_set_i_7ii_function(slot_value(global_slot(sc->remainder_symbol)), remainder_i_7ii);
  s7_set_i_ii_function(slot_value(global_slot(sc->modulo_symbol)), modulo_i_ii);
  s7_set_p_d_function(slot_value(global_slot(sc->rationalize_symbol)), rationalize_p_d);
#endif
  s7_set_p_d_function(slot_value(global_slot(sc->float_vector_symbol)), float_vector_p_d);
  s7_set_p_i_function(slot_value(global_slot(sc->int_vector_symbol)), int_vector_p_i);

  s7_set_d_d_function(slot_value(global_slot(sc->add_symbol)), add_d_d);
  s7_set_d_d_function(slot_value(global_slot(sc->subtract_symbol)), subtract_d_d);
  s7_set_d_d_function(slot_value(global_slot(sc->multiply_symbol)), multiply_d_d);
  s7_set_d_7d_function(slot_value(global_slot(sc->divide_symbol)), divide_d_7d);
  s7_set_d_dd_function(slot_value(global_slot(sc->add_symbol)), add_d_dd);
  s7_set_d_dd_function(slot_value(global_slot(sc->subtract_symbol)), subtract_d_dd);
  s7_set_d_dd_function(slot_value(global_slot(sc->multiply_symbol)), multiply_d_dd);
  s7_set_d_7dd_function(slot_value(global_slot(sc->divide_symbol)), divide_d_7dd);
  s7_set_d_ddd_function(slot_value(global_slot(sc->add_symbol)), add_d_ddd);
  s7_set_d_ddd_function(slot_value(global_slot(sc->subtract_symbol)), subtract_d_ddd);
  s7_set_d_ddd_function(slot_value(global_slot(sc->multiply_symbol)), multiply_d_ddd);
  s7_set_d_dddd_function(slot_value(global_slot(sc->add_symbol)), add_d_dddd);
  s7_set_d_dddd_function(slot_value(global_slot(sc->subtract_symbol)), subtract_d_dddd);
  s7_set_d_dddd_function(slot_value(global_slot(sc->multiply_symbol)), multiply_d_dddd);
  s7_set_p_i_function(slot_value(global_slot(sc->divide_symbol)), divide_p_i);
  s7_set_p_ii_function(slot_value(global_slot(sc->divide_symbol)), divide_p_ii);
#if (!WITH_GMP)
  s7_set_p_pp_function(slot_value(global_slot(sc->add_symbol)), add_p_pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->subtract_symbol)), subtract_p_pp);
#endif
  s7_set_d_dd_function(slot_value(global_slot(sc->max_symbol)), max_d_dd);
  s7_set_d_dd_function(slot_value(global_slot(sc->min_symbol)), min_d_dd);
  s7_set_d_ddd_function(slot_value(global_slot(sc->max_symbol)), max_d_ddd);
  s7_set_d_ddd_function(slot_value(global_slot(sc->min_symbol)), min_d_ddd);
  s7_set_d_dddd_function(slot_value(global_slot(sc->max_symbol)), max_d_dddd);
  s7_set_d_dddd_function(slot_value(global_slot(sc->min_symbol)), min_d_dddd);
  s7_set_i_ii_function(slot_value(global_slot(sc->max_symbol)), max_i_ii);
  s7_set_i_ii_function(slot_value(global_slot(sc->min_symbol)), min_i_ii);
  s7_set_i_iii_function(slot_value(global_slot(sc->max_symbol)), max_i_iii);
  s7_set_i_iii_function(slot_value(global_slot(sc->min_symbol)), min_i_iii);
  s7_set_i_i_function(slot_value(global_slot(sc->subtract_symbol)), subtract_i_i);
  s7_set_i_i_function(slot_value(global_slot(sc->lognot_symbol)), lognot_i_i);
  s7_set_i_ii_function(slot_value(global_slot(sc->add_symbol)), add_i_ii);
  s7_set_i_iii_function(slot_value(global_slot(sc->add_symbol)), add_i_iii);
  s7_set_i_ii_function(slot_value(global_slot(sc->subtract_symbol)), subtract_i_ii);
  s7_set_i_iii_function(slot_value(global_slot(sc->subtract_symbol)), subtract_i_iii);
  s7_set_i_ii_function(slot_value(global_slot(sc->multiply_symbol)), multiply_i_ii);
  s7_set_i_iii_function(slot_value(global_slot(sc->multiply_symbol)), multiply_i_iii);
  s7_set_i_7ii_function(slot_value(global_slot(sc->ash_symbol)), ash_i_7ii);
  s7_set_i_ii_function(slot_value(global_slot(sc->logior_symbol)), logior_i_ii);
  s7_set_i_ii_function(slot_value(global_slot(sc->logxor_symbol)), logxor_i_ii);
  s7_set_i_ii_function(slot_value(global_slot(sc->logand_symbol)), logand_i_ii);
  s7_set_i_iii_function(slot_value(global_slot(sc->logior_symbol)), logior_i_iii);
  s7_set_i_iii_function(slot_value(global_slot(sc->logxor_symbol)), logxor_i_iii);
  s7_set_i_iii_function(slot_value(global_slot(sc->logand_symbol)), logand_i_iii);

#if (!WITH_PURE_S7)
  s7_set_p_pp_function(slot_value(global_slot(sc->vector_append_symbol)), vector_append_p_pp);
  s7_set_p_ppp_function(slot_value(global_slot(sc->vector_append_symbol)), vector_append_p_ppp);
  s7_set_i_i_function(slot_value(global_slot(sc->integer_length_symbol)), integer_length_i_i);
  s7_set_i_7p_function(slot_value(global_slot(sc->string_length_symbol)), string_length_i_7p);
  s7_set_i_7p_function(slot_value(global_slot(sc->vector_length_symbol)), vector_length_i_7p);
  s7_set_p_p_function(slot_value(global_slot(sc->vector_to_list_symbol)), vector_to_list_p_p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_exact_symbol)), is_exact_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_inexact_symbol)), is_inexact_b_7p);
#endif
#if (!WITH_GMP)
  s7_set_i_7p_function(slot_value(global_slot(sc->numerator_symbol)), numerator_i_7p);
  s7_set_i_7p_function(slot_value(global_slot(sc->denominator_symbol)), denominator_i_7p);
#endif
  s7_set_i_7p_function(slot_value(global_slot(sc->char_to_integer_symbol)), char_to_integer_i_7p);
  s7_set_i_7p_function(slot_value(global_slot(sc->hash_table_entries_symbol)), hash_table_entries_i_7p);
  s7_set_i_7p_function(slot_value(global_slot(sc->tree_leaves_symbol)), tree_leaves_i_7p);

  s7_set_b_p_function(slot_value(global_slot(sc->is_boolean_symbol)), s7_is_boolean);
  s7_set_b_p_function(slot_value(global_slot(sc->is_byte_vector_symbol)), s7_is_byte_vector);
  s7_set_b_p_function(slot_value(global_slot(sc->is_c_object_symbol)), s7_is_c_object);
  s7_set_b_p_function(slot_value(global_slot(sc->is_char_symbol)), s7_is_character);
  s7_set_b_p_function(slot_value(global_slot(sc->is_complex_symbol)), s7_is_complex);
  s7_set_b_p_function(slot_value(global_slot(sc->is_continuation_symbol)), s7_is_continuation);
  s7_set_b_p_function(slot_value(global_slot(sc->is_c_pointer_symbol)), s7_is_c_pointer);
  s7_set_b_p_function(slot_value(global_slot(sc->is_dilambda_symbol)), s7_is_dilambda);
  s7_set_b_p_function(slot_value(global_slot(sc->is_eof_object_symbol)), s7_is_eof_object);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_even_symbol)), is_even_b_7p);
  s7_set_b_p_function(slot_value(global_slot(sc->is_float_symbol)), is_float_b);
  s7_set_b_p_function(slot_value(global_slot(sc->is_float_vector_symbol)), s7_is_float_vector);
  s7_set_b_p_function(slot_value(global_slot(sc->is_gensym_symbol)), s7_is_gensym);
  s7_set_b_p_function(slot_value(global_slot(sc->is_hash_table_symbol)), s7_is_hash_table);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_infinite_symbol)), is_infinite_b_7p);
  s7_set_b_p_function(slot_value(global_slot(sc->is_input_port_symbol)), is_input_port_b);
  s7_set_b_p_function(slot_value(global_slot(sc->is_integer_symbol)), s7_is_integer);
  s7_set_b_p_function(slot_value(global_slot(sc->is_int_vector_symbol)), s7_is_int_vector);
  s7_set_b_p_function(slot_value(global_slot(sc->is_keyword_symbol)), s7_is_keyword);
  s7_set_b_p_function(slot_value(global_slot(sc->is_let_symbol)), s7_is_let);
  s7_set_b_p_function(slot_value(global_slot(sc->is_list_symbol)), is_list_b);
  s7_set_b_p_function(slot_value(global_slot(sc->is_macro_symbol)), is_macro_b);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_nan_symbol)), is_nan_b_7p);
  s7_set_b_p_function(slot_value(global_slot(sc->is_null_symbol)), is_null_b);
  s7_set_b_p_function(slot_value(global_slot(sc->is_number_symbol)), s7_is_number);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_odd_symbol)), is_odd_b_7p);
  s7_set_b_p_function(slot_value(global_slot(sc->is_output_port_symbol)), is_output_port_b);
  s7_set_b_p_function(slot_value(global_slot(sc->is_pair_symbol)), s7_is_pair);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_port_closed_symbol)), is_port_closed_b_7p);
  s7_set_b_p_function(slot_value(global_slot(sc->is_procedure_symbol)), s7_is_procedure);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_proper_list_symbol)), is_proper_list_b_7p);
  s7_set_b_p_function(slot_value(global_slot(sc->is_random_state_symbol)), is_random_state_b);
  s7_set_b_p_function(slot_value(global_slot(sc->is_rational_symbol)), s7_is_rational);
  s7_set_b_p_function(slot_value(global_slot(sc->is_real_symbol)), s7_is_real);
  s7_set_b_p_function(slot_value(global_slot(sc->is_sequence_symbol)), is_sequence_b);
  s7_set_b_p_function(slot_value(global_slot(sc->is_string_symbol)), s7_is_string);
  s7_set_b_p_function(slot_value(global_slot(sc->is_symbol_symbol)), s7_is_symbol);
  s7_set_b_p_function(slot_value(global_slot(sc->is_syntax_symbol)), s7_is_syntax);
  s7_set_b_p_function(slot_value(global_slot(sc->is_vector_symbol)), s7_is_vector);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_iterator_symbol)), is_iterator_b_7p);

  s7_set_b_7p_function(slot_value(global_slot(sc->is_char_alphabetic_symbol)), is_char_alphabetic_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_char_lower_case_symbol)), is_char_lower_case_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_char_numeric_symbol)), is_char_numeric_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_char_upper_case_symbol)), is_char_upper_case_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_char_whitespace_symbol)), is_char_whitespace_b_7p);
  s7_set_b_p_direct_function(slot_value(global_slot(sc->is_char_alphabetic_symbol)), is_char_alphabetic_c);
  s7_set_b_p_direct_function(slot_value(global_slot(sc->is_char_lower_case_symbol)), is_char_lower_case_c);
  s7_set_b_p_direct_function(slot_value(global_slot(sc->is_char_numeric_symbol)), is_char_numeric_c);
  s7_set_b_p_direct_function(slot_value(global_slot(sc->is_char_upper_case_symbol)), is_char_upper_case_c);
  s7_set_b_p_direct_function(slot_value(global_slot(sc->is_char_whitespace_symbol)), is_char_whitespace_c);

  s7_set_b_p_function(slot_value(global_slot(sc->is_openlet_symbol)), s7_is_openlet);
  s7_set_b_7p_function(slot_value(global_slot(sc->iterator_is_at_end_symbol)), iterator_is_at_end_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_zero_symbol)), is_zero_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_negative_symbol)), is_negative_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_positive_symbol)), is_positive_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->not_symbol)), not_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_provided_symbol)), is_provided_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->is_defined_symbol)), is_defined_b_7p);
  s7_set_b_7pp_function(slot_value(global_slot(sc->is_defined_symbol)), is_defined_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->tree_memq_symbol)), s7_tree_memq);
  s7_set_b_7pp_function(slot_value(global_slot(sc->tree_set_memq_symbol)), tree_set_memq_b_7pp);
  s7_set_b_p_function(slot_value(global_slot(sc->is_immutable_symbol)), s7_is_immutable);

  s7_set_p_p_function(slot_value(global_slot(sc->is_pair_symbol)), is_pair_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->is_constant_symbol)), is_constant_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->type_of_symbol)), s7_type_of);
  /* s7_set_p_p_function(slot_value(global_slot(sc->openlet_symbol)), s7_openlet); -- needs error check */
  s7_set_p_i_function(slot_value(global_slot(sc->integer_to_char_symbol)), integer_to_char_p_i);
  s7_set_p_p_function(slot_value(global_slot(sc->integer_to_char_symbol)), integer_to_char_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->iterate_symbol)), iterate_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->list_symbol)), list_p_p);
  s7_set_p_pp_function(slot_value(global_slot(sc->list_symbol)), list_p_pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->assq_symbol)), assq_p_pp);
  s7_set_p_p_function(slot_value(global_slot(sc->tree_leaves_symbol)), tree_leaves_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->length_symbol)), length_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->pair_line_number_symbol)), pair_line_number_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->c_pointer_info_symbol)), c_pointer_info_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->c_pointer_type_symbol)), c_pointer_type_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->c_pointer_weak1_symbol)), c_pointer_weak1_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->c_pointer_weak2_symbol)), c_pointer_weak2_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->is_negative_symbol)), is_negative_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->is_char_alphabetic_symbol)), is_char_alphabetic_p_p);
  s7_set_p_p_function(slot_value(global_slot(sc->is_char_whitespace_symbol)), is_char_whitespace_p_p);
  s7_set_p_i_function(slot_value(global_slot(sc->make_string_symbol)), make_string_p_i);
  s7_set_p_ii_function(slot_value(global_slot(sc->make_int_vector_symbol)), make_int_vector_p_ii);
  s7_set_p_ii_function(slot_value(global_slot(sc->make_byte_vector_symbol)), make_byte_vector_p_ii);

#if WITH_SYSTEM_EXTRAS
  s7_set_b_7p_function(slot_value(global_slot(sc->is_directory_symbol)), is_directory_b_7p);
  s7_set_b_7p_function(slot_value(global_slot(sc->file_exists_symbol)), file_exists_b_7p);
#endif

  s7_set_b_i_function(slot_value(global_slot(sc->is_even_symbol)), is_even_i);
  s7_set_b_i_function(slot_value(global_slot(sc->is_odd_symbol)), is_odd_i);
  s7_set_b_i_function(slot_value(global_slot(sc->is_zero_symbol)), is_zero_i);
  s7_set_b_d_function(slot_value(global_slot(sc->is_zero_symbol)), is_zero_d);
  s7_set_b_i_function(slot_value(global_slot(sc->is_positive_symbol)), is_positive_i);
  s7_set_b_d_function(slot_value(global_slot(sc->is_positive_symbol)), is_positive_d);
  s7_set_b_i_function(slot_value(global_slot(sc->is_negative_symbol)), is_negative_i);
  s7_set_b_d_function(slot_value(global_slot(sc->is_negative_symbol)), is_negative_d);

  s7_set_b_ii_function(slot_value(global_slot(sc->logbit_symbol)), logbit_b_ii);
  s7_set_b_ii_function(slot_value(global_slot(sc->eq_symbol)), req_b_ii);
  s7_set_b_ii_function(slot_value(global_slot(sc->lt_symbol)), lt_b_ii);
  s7_set_b_ii_function(slot_value(global_slot(sc->leq_symbol)), leq_b_ii);
  s7_set_b_ii_function(slot_value(global_slot(sc->gt_symbol)), gt_b_ii);
  s7_set_b_ii_function(slot_value(global_slot(sc->geq_symbol)), geq_b_ii);
  s7_set_b_dd_function(slot_value(global_slot(sc->eq_symbol)), req_b_dd);
  s7_set_b_dd_function(slot_value(global_slot(sc->lt_symbol)), lt_b_dd);
  s7_set_b_dd_function(slot_value(global_slot(sc->leq_symbol)), leq_b_dd);
  s7_set_b_dd_function(slot_value(global_slot(sc->gt_symbol)), gt_b_dd);
  s7_set_b_dd_function(slot_value(global_slot(sc->geq_symbol)), geq_b_dd);

#if (!WITH_GMP)
  s7_set_b_7pp_function(slot_value(global_slot(sc->logbit_symbol)), logbit_b_7pp);
  s7_set_p_pi_function(slot_value(global_slot(sc->eq_symbol)), equal_p_pi);
  s7_set_p_pp_function(slot_value(global_slot(sc->eq_symbol)), equal_p_pp);
  s7_set_p_ii_function(slot_value(global_slot(sc->eq_symbol)), equal_p_ii);
  s7_set_p_dd_function(slot_value(global_slot(sc->eq_symbol)), equal_p_dd);

  s7_set_p_pp_function(slot_value(global_slot(sc->lt_symbol)), lt_p_pp);
  s7_set_p_pi_function(slot_value(global_slot(sc->lt_symbol)), lt_p_pi);
  s7_set_p_ii_function(slot_value(global_slot(sc->lt_symbol)), lt_p_ii);
  s7_set_p_dd_function(slot_value(global_slot(sc->lt_symbol)), lt_p_dd);

  s7_set_p_pp_function(slot_value(global_slot(sc->leq_symbol)), leq_p_pp);
  s7_set_p_pi_function(slot_value(global_slot(sc->leq_symbol)), leq_p_pi);
  s7_set_p_dd_function(slot_value(global_slot(sc->leq_symbol)), leq_p_dd);
  s7_set_p_ii_function(slot_value(global_slot(sc->leq_symbol)), leq_p_ii);

  s7_set_p_pp_function(slot_value(global_slot(sc->gt_symbol)), gt_p_pp);
  s7_set_p_pi_function(slot_value(global_slot(sc->gt_symbol)), gt_p_pi);
  s7_set_p_dd_function(slot_value(global_slot(sc->gt_symbol)), gt_p_dd);
  s7_set_p_ii_function(slot_value(global_slot(sc->gt_symbol)), gt_p_ii);

  s7_set_p_pp_function(slot_value(global_slot(sc->geq_symbol)), geq_p_pp);
  s7_set_p_pi_function(slot_value(global_slot(sc->geq_symbol)), geq_p_pi);
  s7_set_p_ii_function(slot_value(global_slot(sc->geq_symbol)), geq_p_ii);
  s7_set_p_dd_function(slot_value(global_slot(sc->geq_symbol)), geq_p_dd);

  s7_set_b_7pp_function(slot_value(global_slot(sc->eq_symbol)), req_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->lt_symbol)), lt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->leq_symbol)), leq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->gt_symbol)), gt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->geq_symbol)), geq_b_7pp);

  s7_set_b_pi_function(slot_value(global_slot(sc->eq_symbol)), equal_b_pi);
  s7_set_b_pi_function(slot_value(global_slot(sc->lt_symbol)), lt_b_pi);
  s7_set_b_pi_function(slot_value(global_slot(sc->leq_symbol)), leq_b_pi);
  s7_set_b_pi_function(slot_value(global_slot(sc->gt_symbol)), gt_b_pi);
  s7_set_b_pi_function(slot_value(global_slot(sc->geq_symbol)), geq_b_pi);
#endif

  s7_set_b_pp_function(slot_value(global_slot(sc->is_eq_symbol)), s7_is_eq);
  s7_set_b_pp_function(slot_value(global_slot(sc->is_eqv_symbol)), s7_is_eqv);
  s7_set_b_7pp_function(slot_value(global_slot(sc->is_equal_symbol)), is_equal_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->is_equivalent_symbol)), is_equivalent_b_7pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->is_equal_symbol)), is_equal_p_pp);
  s7_set_p_pp_function(slot_value(global_slot(sc->is_equivalent_symbol)), is_equivalent_p_pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_lt_symbol)), char_lt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_leq_symbol)), char_leq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_gt_symbol)), char_gt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_geq_symbol)), char_geq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_eq_symbol)), char_eq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_lt_symbol)), string_lt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_leq_symbol)), string_leq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_gt_symbol)), string_gt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_geq_symbol)), string_geq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_eq_symbol)), string_eq_b_7pp);

  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_lt_symbol)), char_lt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_leq_symbol)), char_leq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_gt_symbol)), char_gt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_geq_symbol)), char_geq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_eq_symbol)), char_eq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_lt_symbol)), string_lt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_leq_symbol)), string_leq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_gt_symbol)), string_gt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_geq_symbol)), string_geq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_eq_symbol)), string_eq_b_direct);

  s7_set_b_7pp_function(slot_value(global_slot(sc->is_aritable_symbol)), is_aritable_b_7pp);
#if (!WITH_PURE_S7)
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_ci_lt_symbol)), char_ci_lt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_ci_leq_symbol)), char_ci_leq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_ci_gt_symbol)), char_ci_gt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_ci_geq_symbol)), char_ci_geq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->char_ci_eq_symbol)), char_ci_eq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_ci_lt_symbol)), string_ci_lt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_ci_leq_symbol)), string_ci_leq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_ci_gt_symbol)), string_ci_gt_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_ci_geq_symbol)), string_ci_geq_b_7pp);
  s7_set_b_7pp_function(slot_value(global_slot(sc->string_ci_eq_symbol)), string_ci_eq_b_7pp);

  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_ci_lt_symbol)), char_ci_lt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_ci_leq_symbol)), char_ci_leq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_ci_gt_symbol)), char_ci_gt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_ci_geq_symbol)), char_ci_geq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->char_ci_eq_symbol)), char_ci_eq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_ci_lt_symbol)), string_ci_lt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_ci_leq_symbol)), string_ci_leq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_ci_gt_symbol)), string_ci_gt_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_ci_geq_symbol)), string_ci_geq_b_direct);
  s7_set_b_pp_direct_function(slot_value(global_slot(sc->string_ci_eq_symbol)), string_ci_eq_b_direct);
#endif

  /* -------------------------------------------------------------------------------- */
  s7_define_macro(sc, "quasiquote", g_quasiquote, 1, 0, false, H_quasiquote);

#if (!WITH_PURE_S7)
  s7_eval_c_string(sc, "(define-macro (call-with-values producer consumer) (list consumer (list producer)))");
  /* (call-with-values (lambda () (values 1 2 3)) +) */

  s7_eval_c_string(sc, "(define-macro (multiple-value-bind vars expression . body)                        \n\
                          (list (cons 'lambda (cons vars body)) expression))");

  s7_eval_c_string(sc, "(define-macro (cond-expand . clauses)                                             \n\
                          (letrec ((traverse (lambda (tree)                                               \n\
		                               (if (pair? tree)                                           \n\
			                           (cons (traverse (car tree))                            \n\
				                         (case (cdr tree) ((())) (else => traverse)))     \n\
			                           (if (memq tree '(and or not else)) tree                \n\
			                               (and (symbol? tree) (provided? tree)))))))         \n\
                            (cons 'cond (map (lambda (clause)                                             \n\
		                               (if (pair? clause)                                         \n\
                                                   (cons (traverse (car clause))                          \n\
			                                 (case (cdr clause) ((()) '(#f)) (else)))         \n\
                                                   (error 'read-error \"cond-expand: bad clause\")))      \n\
		                             clauses))))");
#endif

  s7_eval_c_string(sc, "(define-expansion (reader-cond . clauses)                                         \n\
                          (call-with-exit                                                                 \n\
                            (lambda (return)                                                              \n\
                              (for-each                                                                   \n\
                                (lambda (clause)                                                          \n\
	                          (let ((val (eval (car clause))))                                        \n\
                                    (when val                                                             \n\
                                      (return (cond ((null? (cdr clause)) val)                            \n\
                                                    ((eq? (cadr clause) '=>) ((eval (caddr clause)) val)) \n\
                                                    ((null? (cddr clause)) (cadr clause))                 \n\
                                                    (else (apply values (map quote (cdr clause)))))))))   \n\
                                clauses)                                                                  \n\
                              (values))))"); /* this is not redundant */  /* map above ignores trailing cdr if improper */

  s7_eval_c_string(sc, "(define make-hook                                                                 \n\
                          (let ((+signature+ '(procedure?))                                               \n\
                                (+documentation+ \"(make-hook . pars) returns a new hook (a function) that passes the parameters to its function list.\")) \n\
                            (lambda hook-args                                                             \n\
                              (let ((body ()))                                                            \n\
                                (apply lambda* hook-args                                                  \n\
                                  (copy '(let ((result #<unspecified>))                                   \n\
                                           (let ((hook (curlet)))                                         \n\
                                             (for-each (lambda (hook-function) (hook-function hook)) body)\n\
                                             result))                                                     \n\
                                        :readable)                                                        \n\
                                  ())))))");

  s7_eval_c_string(sc, "(define hook-functions                                                            \n\
                          (let ((+signature+ '(#t procedure?))                                            \n\
                                (+documentation+ \"(hook-functions hook) gets or sets the list of functions associated with the hook\")) \n\
                            (dilambda                                                                     \n\
                              (lambda (hook)                                                              \n\
                                ((funclet hook) 'body))                                                   \n\
                              (lambda (hook lst)                                                          \n\
                                (if (do ((p lst (cdr p)))                                                 \n\
                                        ((not (and (pair? p)                                              \n\
                                                   (procedure? (car p))                                   \n\
                                                   (aritable? (car p) 1)))                                \n\
                                         (null? p)))                                                      \n\
                                    (set! ((funclet hook) 'body) lst)                                     \n\
                                    (error 'wrong-type-arg \"hook-functions must be a list of functions, each accepting one argument: ~S\" lst))))))");


  /* -------- *unbound-variable-hook* -------- */
  sc->unbound_variable_hook = s7_eval_c_string(sc, "(make-hook 'variable)");
  s7_define_constant_with_documentation(sc, "*unbound-variable-hook*", sc->unbound_variable_hook,
					"*unbound-variable-hook* functions are called when an unbound variable is encountered, passed (hook 'variable).");

  /* -------- *missing-close-paren-hook* -------- */
  sc->missing_close_paren_hook = s7_eval_c_string(sc, "(make-hook)");
  s7_define_constant_with_documentation(sc, "*missing-close-paren-hook*", sc->missing_close_paren_hook,
					"*missing-close-paren-hook* functions are called when the reader thinks a close paren is missing");

  /* -------- *load-hook* -------- */
  sc->load_hook = s7_eval_c_string(sc, "(make-hook 'name)");
  s7_define_constant_with_documentation(sc, "*load-hook*", sc->load_hook,
					"*load-hook* functions are invoked by load, passing the to-be-loaded filename as (hook 'name)");

  /* -------- *error-hook* -------- */
  sc->error_hook = s7_eval_c_string(sc, "(make-hook 'type 'data)");
  s7_define_constant_with_documentation(sc, "*error-hook*", sc->error_hook,
					"*error-hook* functions are called in the error handler, passed (hook 'type) and (hook 'data).");

  /* -------- *read-error-hook* -------- */
  sc->read_error_hook = s7_eval_c_string(sc, "(make-hook 'type 'data)");
  s7_define_constant_with_documentation(sc, "*read-error-hook*", sc->read_error_hook,
					"*read-error-hook* functions are called by the reader if it is unhappy, passing the current program string as (hook 'data).");

  /* -------- *rootlet-redefinition-hook* -------- */
  sc->rootlet_redefinition_hook = s7_eval_c_string(sc, "(make-hook 'name 'value)");
  s7_define_constant_with_documentation(sc, "*rootlet-redefinition-hook*", sc->rootlet_redefinition_hook,
					"*rootlet-redefinition-hook* functions are called when a top-level variable's value is changed, (hook 'name 'value).");

  sc->s7_let = s7_inlet(sc, /* have to use s7_inlet here because we're setting let fallbacks */
		 s7_list(sc, 4,
			 sc->let_ref_fallback_symbol, s7_make_function(sc, "s7-let-ref", g_s7_let_ref_fallback, 2, 0, false, "*s7* reader"),
			 sc->let_set_fallback_symbol, s7_make_function(sc, "s7-let-set", g_s7_let_set_fallback, 3, 0, false, "*s7* writer")));
  s7_define_constant(sc, "*s7*", s7_openlet(sc, sc->s7_let));

  { /* make the two *s7* accessor fields immutable */
    s7_pointer slot;
    slot = let_slots(sc->s7_let);
    set_immutable(slot);
    set_immutable(next_slot(slot));
  }

#if (!DISABLE_DEPRECATED)
  s7_eval_c_string(sc, "(begin                                         \n\
                          (define global-environment  rootlet)         \n\
                          (define current-environment curlet)          \n\
                          (define morally-equal?      equivalent?)     \n\
                          (define make-keyword        string->keyword))");  /* make-keyword is used in CM's scm/s7.scm */
#endif

#if S7_DEBUGGING
  if (!s7_type_names[0]) fprintf(stderr, "no type_names\n"); /* squelch a very stupid warning! */
  if (strcmp(op_names[HOP_SAFE_C_PP], "h_safe_c_pp") != 0) fprintf(stderr, "op_name: %s\n", op_names[HOP_SAFE_C_PP]);
  if (strcmp(op_names[OP_SET_WITH_LET_2], "set_with_let_2") != 0) fprintf(stderr, "op_name: %s\n", op_names[OP_SET_WITH_LET_2]);
  if (strcmp(op_names[OP_SAFE_CLOSURE_A_A], "safe_closure_a_a") != 0) fprintf(stderr, "op_name: %s\n", op_names[OP_SAFE_CLOSURE_A_A]);
  if ((OP_MAX_DEFINED != 807) || (OPT_MAX_DEFINED != 409))
    fprintf(stderr, "size: cell: %d, block: %d, max op: %d, opt: %d\n", (int)sizeof(s7_cell), (int)sizeof(block_t), OP_MAX_DEFINED, OPT_MAX_DEFINED);
  /* 64 bit machine: cell size: 48, 80 if gmp, 104 if debugging, block size: 40 */
#endif

  save_unlet(sc);
  init_s7_let(sc);          /* set up *s7* */
  init_signatures(sc);      /* depends on procedure symbols */

  return(sc);
}


/* -------------------------------- repl -------------------------------- */

#ifndef USE_SND
  #define USE_SND 0
#endif
#ifndef WITH_MAIN
  #define WITH_MAIN 0
#endif

#if (WITH_MAIN && (!USE_SND))

int main(int argc, char **argv)
{
  s7_scheme *sc;

  sc = s7_init();
  if (argc == 2)
    {
      fprintf(stderr, "load %s\n", argv[1]);
      s7_load(sc, argv[1]);
    }
  else
    {
#if (!MS_WINDOWS)
      s7_load(sc, "repl.scm");              /* this is libc dependent */
      s7_eval_c_string(sc, "((*repl* 'run))");
#else
      while (1)                             /* a minimal repl -- taken from s7.html */
	{
	  char buffer[512];
	  char response[1024];
	  fprintf(stdout, "\n> ");
	  fgets(buffer, 512, stdin);
	  if ((buffer[0] != '\n') || (strlen(buffer) > 1))
	    {
	      snprintf(response, 1024, "(write %s)", buffer);
	      s7_eval_c_string(sc, response);
	    }
	}
#endif
    }
  return(0);
}

/* in Linux:  gcc s7.c -o repl -DWITH_MAIN -DUSE_SND=0 -I. -O2 -g -ldl -lm -Wl,-export-dynamic
 * in *BSD:   gcc s7.c -o repl -DWITH_MAIN -DUSE_SND=0 -I. -O2 -g -lm -Wl,-export-dynamic
 * in OSX:    gcc s7.c -o repl -DWITH_MAIN -DUSE_SND=0 -I. -O2 -g -lm
 *   (clang also needs LDFLAGS="-Wl,-export-dynamic" in Linux and "-fPIC")
 */
#endif

/* ------------------------------------------------------------------------------------------
 *
 * new snd version: snd.h configure.ac HISTORY.Snd NEWS barchive diffs, /usr/ccrma/web/html/software/snd/index.html
 *
 * ------------------------------------------------------------------------------------------
 *           12  |  13  |  14  |  15  |  16  |  17  |  18  | 19.0  19.1  19.3  19.4
 * ------------------------------------------------------------------------------------------
 * tpeak         |      |      |      |  391 |  377 |  199 |  199   160   161   161
 * tmac          |      |      |      | 9052 |  264 |  236 |  236   236   236   236
 * tshoot        |      |      |      |      |      |  710 |              636   559
 * tauto         |      |      | 1752 | 1689 | 1700 |  835 |  594   594   595   595
 * tref          |      |      | 2372 | 2125 | 1036 |  983 |  971   966   954   954
 * index    44.3 | 3291 | 1725 | 1276 | 1255 | 1168 | 1022 | 1018   993   974   972
 * teq           |      |      | 6612 | 2777 | 1931 | 1539 | 1540  1518  1513  1530
 * s7test   1721 | 1358 |  995 | 1194 | 2926 | 2110 | 1726 | 1719  1715  1692  1696
 * lint          |      |      |      | 4041 | 2702 | 2120 | 2092  2087  2099  2088 2089
 * tcopy         |      |      | 13.6 | 3183 | 2974 | 2320 | 2264  2249  2260  2261
 * tread         |      |      |      |      | 2357 | 2336 | 2338  2335  2332  2282
 * tform         |      |      | 6816 | 3714 | 2762 | 2362 | 2358  2268  2320  2299
 * tvect         |      |      |      |      |      | 5616 | 2650  2520  2471  2463
 * tfft          |      | 15.5 | 16.4 | 17.3 | 3966 | 2493 | 2502  2467  2467  2467
 * tlet          |      |      |      |      | 4717 | 2959 | 2946  2678  2685  2673
 * dup           |      |      |      |      | 20.8 | 5711 | 4137  3469  2993  2754 2773
 * tclo          |      | 4391 | 4666 | 4651 | 4682 | 3084 | 3061  2832  2855  2871
 * tmap          |      |      |  9.3 | 5279 | 3445 | 3015 | 3009  3085  3085  3084
 * tsort         |      |      |      | 8584 | 4111 | 3327 | 3317  3318  3318  3318
 * tset          |      |      |      |      | 10.0 | 6432 | 6317  6390  3464  3443 3453
 * titer         |      |      |      | 5971 | 4646 | 3587 | 3564  3559  3551  3520
 * thash         |      |      | 50.7 | 8778 | 7697 | 5309 | 5254  5181  5150  4994
 * trec     25.0 | 19.2 | 15.8 | 16.4 | 16.4 | 16.4 | 11.0 | 11.0  10.9  10.9  10.9
 * tgen          | 71.0 | 70.6 | 38.0 | 12.6 | 11.9 | 11.2 | 11.1  11.1  11.2  11.2
 * tall     90.0 | 43.0 | 14.5 | 12.7 | 17.9 | 18.8 | 17.1 | 17.1  17.2  16.9  16.9
 * calls   359.0 |275.0 | 54.0 | 34.7 | 43.7 | 40.4 | 38.4 | 38.4  38.4  38.4  38.3
 * sg            |      |      |      |139.0 | 85.9 | 78.0 | 78.0  72.9  73.0  72.8
 * lg            |      |      |      |211.0 |133.0 |112.7 |110.6 110.2 110.1 109.4
 * tbig          |      |      |      |      |246.9 |230.6 |213.3 187.3 185.1 184.9
 * ------------------------------------------------------------------------------------------
 *
 * mutable cells in opt for set [where?][currently 75403 has_safe_steppers] and in CLM [where are the allocs?]
 *
 * do definer is ok if in let etc, fxify step/end and treat step ops like and_p
 *
 * more s->t cases [fx_tree in any body [with 1 var? let*_fx_a reverses but others don't] without definers (let etc) = arg fxs] fxcounts
 *   70696 let_one_*
 *
 * saved let in assoc member [if bool_optimize]
 *   perhaps: op_let_a et al if body is very safe (no recursion/definers/macros)? is this info saved? [save it!] let_*_aa|fx? [got let*_fx_a]
 *   can't any unheaped let be permanent? -- need to make sure no [uncovered] definers [remove_from heap?]
 *   what about do frame?
 *   true let*, letrec(*) (timing?)
 *   all lets start in decl order -- remove reverse_slots and change print slot_list (how to handle shadows)
 *     if no definers add op_safe_c_t etc
 *
 * chained rec calls from top funclet: when top changes, update all, then skip the internal checks
 *   if tc, these could be just set vals and goto top
 *   or could all such refs be hardwired to see the top? funclet field? __func__? permanent let with pointer to owning closure + outlet path
 *   safe_rclo_a, opt_lambda call -> top=code, its opt1_lambda is the func
 *     get func from opt1_lambda(opt1_lambda(code)), set let_slots->fx_call(a), code->body, closure_push
 *
 * op-trans2 et al for combined ops [when_and_ap optimization order is pessimal]
 *   check* if used in this way can't push_stack (as does check_when)
 *   do steppers where not fxified can predetermine eval target like sc->begin_op and call via op*? need fx_choose-like table
 *   any goto eval could do this?? and goto begin could handle the first or all??
 *
 * new timing test for t984
 * opt support for complex, exp_d_d 
 * s7test or snd-test should run binary-io.scm: 
 *   (read-aif-header "4.aiff"): ("AIFF" 44 6758392 16 22050 4)
 *   (read-au-header "oboe.snd"): (".snd" 28 101656 3 22050 1 "")
 *
 * trouble: safe closure let reversal [decl order], optimize_func*(2), shared_info
 *   needs split: optimize_func*, do*, s7_copy_1[watch out for let->break], eval
 *   what if safe closure is fx_treed, then applied with unreversed let? [all lets should be in decl order as above]
 *   undo op_*D*+symbol cases
 */
